; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__08182E14_stralign@h DB 01H
__42976693_threads@h DB 01H
__817A88BE_threadqueue@c DB 01H
msvcjmc	ENDS
PUBLIC	kvz_threadqueue_init
PUBLIC	kvz_threadqueue_job_create
PUBLIC	kvz_threadqueue_submit
PUBLIC	kvz_threadqueue_job_dep_add
PUBLIC	kvz_threadqueue_copy_ref
PUBLIC	kvz_threadqueue_free_job
PUBLIC	kvz_threadqueue_waitfor
PUBLIC	kvz_threadqueue_stop
PUBLIC	kvz_threadqueue_free
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??threadqueue_push_job@@9@9	; `threadqueue_push_job'::`1'::__LINE__Var
PUBLIC	??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@ ; `string'
PUBLIC	??_C@_1CG@PECLADJO@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAn?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAs?$AA?5?$AA?$DN@ ; `string'
PUBLIC	?__LINE__Var@?0??threadqueue_pop_job@@9@9	; `threadqueue_pop_job'::`1'::__LINE__Var
PUBLIC	??_C@_1DG@NBKHGELB@?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?9?$AA?$DO?$AAf?$AAi@ ; `string'
PUBLIC	?__LINE__Var@?0??threadqueue_worker@@9@9	; `threadqueue_worker'::`1'::__LINE__Var
PUBLIC	??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@	; `string'
PUBLIC	??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0@				; `string'
PUBLIC	??_C@_0BM@GFDKEBKL@?$CGthreadqueue?9?$DOjob_available@ ; `string'
PUBLIC	??_C@_0CJ@IEPOFDPD@pthread_cond_wait?$CI?$CFs?$DN?$CFp?0?5?$CFs?$DN?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@		; `string'
PUBLIC	??_C@_1FE@IHCDHMCL@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@ ; `string'
PUBLIC	??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@ ; `string'
PUBLIC	??_C@_1FI@KLIDNBIO@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@ ; `string'
PUBLIC	??_C@_0BH@NPKCIKON@?$CGthreadqueue?9?$DOjob_done@ ; `string'
PUBLIC	??_C@_0CE@JJHPJKJK@pthread_cond_signal?$CI?$CFs?$DN?$CFp?$CJ?5fail@ ; `string'
PUBLIC	??_C@_0O@CPKPLFPC@?$CGdepjob?9?$DOlock@		; `string'
PUBLIC	??_C@_1MA@CILPAJDO@?$AAd?$AAe?$AAp?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN@ ; `string'
PUBLIC	??_C@_1CK@JMNOOCPM@?$AAd?$AAe?$AAp?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAn?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd@ ; `string'
PUBLIC	?__LINE__Var@?0??kvz_threadqueue_init@@9@9	; `kvz_threadqueue_init'::`1'::__LINE__Var
PUBLIC	??_C@_0BM@HIMFGFND@pthread_mutex_init?5failed?$CB?6@ ; `string'
PUBLIC	??_C@_0BL@OMHDKFFL@pthread_cond_init?5failed?$CB?6@ ; `string'
PUBLIC	??_C@_0CI@FOHADHPI@Could?5not?5malloc?5threadqueue?9?$DOt@ ; `string'
PUBLIC	??_C@_0BI@EKNPILFE@pthread_create?5failed?$CB?6@ ; `string'
PUBLIC	??_C@_0BG@LJHKKGBE@Could?5not?5alloc?5job?$CB?6@ ; `string'
PUBLIC	??_C@_0CB@OHFOAGLG@pthread_mutex_init?$CIjob?$CJ?5failed?$CB@ ; `string'
PUBLIC	?__LINE__Var@?0??kvz_threadqueue_submit@@9@9	; `kvz_threadqueue_submit'::`1'::__LINE__Var
PUBLIC	??_C@_1FG@PFPCKMKF@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@ ; `string'
PUBLIC	?__LINE__Var@?0??kvz_threadqueue_job_dep_add@@9@9 ; `kvz_threadqueue_job_dep_add'::`1'::__LINE__Var
PUBLIC	??_C@_0BC@CBBBDMI@?$CGdependency?9?$DOlock@	; `string'
PUBLIC	?__LINE__Var@?0??kvz_threadqueue_copy_ref@@9@9	; `kvz_threadqueue_copy_ref'::`1'::__LINE__Var
PUBLIC	??_C@_1CE@NMICBIH@?$AAn?$AAe?$AAw?$AA_?$AAr?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
PUBLIC	?__LINE__Var@?0??kvz_threadqueue_free_job@@9@9	; `kvz_threadqueue_free_job'::`1'::__LINE__Var
PUBLIC	??_C@_1CE@EMPGFCAP@?$AAn?$AAe?$AAw?$AA_?$AAr?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	?__LINE__Var@?0??kvz_threadqueue_waitfor@@9@9	; `kvz_threadqueue_waitfor'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??kvz_threadqueue_stop@@9@9	; `kvz_threadqueue_stop'::`1'::__LINE__Var
PUBLIC	??_C@_1EO@DJPPPMHK@?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?9?$AA?$DO?$AAt?$AAh@ ; `string'
PUBLIC	??_C@_0CH@CJMCPDDL@pthread_cond_broadcast?$CI?$CFs?$DN?$CFp?$CJ?5f@ ; `string'
PUBLIC	??_C@_0BG@DMJOJJP@pthread_join?5failed?$CB?6@	; `string'
PUBLIC	??_C@_0BP@DKJFEBPG@pthread_mutex_destroy?5failed?$CB?6@ ; `string'
PUBLIC	??_C@_0BO@DMELMKKN@pthread_cond_destroy?5failed?$CB?6@ ; `string'
EXTRN	__imp__wassert:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	pthread_cond_broadcast:PROC
EXTRN	pthread_cond_destroy:PROC
EXTRN	pthread_cond_init:PROC
EXTRN	pthread_cond_signal:PROC
EXTRN	pthread_cond_wait:PROC
EXTRN	pthread_create:PROC
EXTRN	pthread_join:PROC
EXTRN	pthread_mutex_destroy:PROC
EXTRN	pthread_mutex_init:PROC
EXTRN	pthread_mutex_lock:PROC
EXTRN	pthread_mutex_unlock:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_init DD imagerel $LN16
	DD	imagerel $LN16+708
	DD	imagerel $unwind$kvz_threadqueue_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_job_create DD imagerel $LN5
	DD	imagerel $LN5+273
	DD	imagerel $unwind$kvz_threadqueue_job_create
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_submit DD imagerel $LN16
	DD	imagerel $LN16+635
	DD	imagerel $unwind$kvz_threadqueue_submit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_job_dep_add DD imagerel $LN15
	DD	imagerel $LN15+767
	DD	imagerel $unwind$kvz_threadqueue_job_dep_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_copy_ref DD imagerel $LN4
	DD	imagerel $LN4+138
	DD	imagerel $unwind$kvz_threadqueue_copy_ref
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_free_job DD imagerel $LN9
	DD	imagerel $LN9+301
	DD	imagerel $unwind$kvz_threadqueue_free_job
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_waitfor DD imagerel $LN11
	DD	imagerel $LN11+467
	DD	imagerel $unwind$kvz_threadqueue_waitfor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_stop DD imagerel $LN17
	DD	imagerel $LN17+674
	DD	imagerel $unwind$kvz_threadqueue_stop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_threadqueue_free DD imagerel $LN9
	DD	imagerel $LN9+388
	DD	imagerel $unwind$kvz_threadqueue_free
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+59
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+126
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+150
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$threadqueue_push_job DD imagerel threadqueue_push_job
	DD	imagerel threadqueue_push_job+218
	DD	imagerel $unwind$threadqueue_push_job
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$threadqueue_pop_job DD imagerel threadqueue_pop_job
	DD	imagerel threadqueue_pop_job+190
	DD	imagerel $unwind$threadqueue_pop_job
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$threadqueue_worker DD imagerel threadqueue_worker
	DD	imagerel threadqueue_worker+1923
	DD	imagerel $unwind$threadqueue_worker
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BO@DMELMKKN@pthread_cond_destroy?5failed?$CB?6@
CONST	SEGMENT
??_C@_0BO@DMELMKKN@pthread_cond_destroy?5failed?$CB?6@ DB 'pthread_cond_d'
	DB	'estroy failed!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DKJFEBPG@pthread_mutex_destroy?5failed?$CB?6@
CONST	SEGMENT
??_C@_0BP@DKJFEBPG@pthread_mutex_destroy?5failed?$CB?6@ DB 'pthread_mutex'
	DB	'_destroy failed!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DMJOJJP@pthread_join?5failed?$CB?6@
CONST	SEGMENT
??_C@_0BG@DMJOJJP@pthread_join?5failed?$CB?6@ DB 'pthread_join failed!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CJMCPDDL@pthread_cond_broadcast?$CI?$CFs?$DN?$CFp?$CJ?5f@
CONST	SEGMENT
??_C@_0CH@CJMCPDDL@pthread_cond_broadcast?$CI?$CFs?$DN?$CFp?$CJ?5f@ DB 'p'
	DB	'thread_cond_broadcast(%s=%p) failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@DJPPPMHK@?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?9?$AA?$DO?$AAt?$AAh@
CONST	SEGMENT
??_C@_1EO@DJPPPMHK@?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?9?$AA?$DO?$AAt?$AAh@ DB 't'
	DB	00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'q', 00H
	DB	'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, '-', 00H, '>', 00H, 't'
	DB	00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, '_', 00H
	DB	'r', 00H, 'u', 00H, 'n', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, '_', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_threadqueue_stop@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_threadqueue_stop@@9@9 DD 0255H	; `kvz_threadqueue_stop'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_threadqueue_waitfor@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_threadqueue_waitfor@@9@9 DD 0242H	; `kvz_threadqueue_waitfor'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CE@EMPGFCAP@?$AAn?$AAe?$AAw?$AA_?$AAr?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@EMPGFCAP@?$AAn?$AAe?$AAw?$AA_?$AAr?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_threadqueue_free_job@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_threadqueue_free_job@@9@9 DD 0224H	; `kvz_threadqueue_free_job'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CE@NMICBIH@?$AAn?$AAe?$AAw?$AA_?$AAr?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@NMICBIH@?$AAn?$AAe?$AAw?$AA_?$AAr?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H
	DB	'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '>'
	DB	00H, '=', 00H, ' ', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_threadqueue_copy_ref@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_threadqueue_copy_ref@@9@9 DD 0212H	; `kvz_threadqueue_copy_ref'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@CBBBDMI@?$CGdependency?9?$DOlock@
CONST	SEGMENT
??_C@_0BC@CBBBDMI@?$CGdependency?9?$DOlock@ DB '&dependency->lock', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_threadqueue_job_dep_add@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_threadqueue_job_dep_add@@9@9 DD 01efH ; `kvz_threadqueue_job_dep_add'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FG@PFPCKMKF@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@
CONST	SEGMENT
??_C@_1FG@PFPCKMKF@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@ DB 'j'
	DB	00H, 'o', 00H, 'b', 00H, '-', 00H, '>', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'T', 00H, 'H', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'D', 00H
	DB	'Q', 00H, 'U', 00H, 'E', 00H, 'U', 00H, 'E', 00H, '_', 00H, 'J'
	DB	00H, 'O', 00H, 'B', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H
	DB	'T', 00H, 'E', 00H, '_', 00H, 'P', 00H, 'A', 00H, 'U', 00H, 'S'
	DB	00H, 'E', 00H, 'D', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_threadqueue_submit@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_threadqueue_submit@@9@9 DD 01caH	; `kvz_threadqueue_submit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@OHFOAGLG@pthread_mutex_init?$CIjob?$CJ?5failed?$CB@
CONST	SEGMENT
??_C@_0CB@OHFOAGLG@pthread_mutex_init?$CIjob?$CJ?5failed?$CB@ DB 'pthread'
	DB	'_mutex_init(job) failed!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LJHKKGBE@Could?5not?5alloc?5job?$CB?6@
CONST	SEGMENT
??_C@_0BG@LJHKKGBE@Could?5not?5alloc?5job?$CB?6@ DB 'Could not alloc job!'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EKNPILFE@pthread_create?5failed?$CB?6@
CONST	SEGMENT
??_C@_0BI@EKNPILFE@pthread_create?5failed?$CB?6@ DB 'pthread_create faile'
	DB	'd!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FOHADHPI@Could?5not?5malloc?5threadqueue?9?$DOt@
CONST	SEGMENT
??_C@_0CI@FOHADHPI@Could?5not?5malloc?5threadqueue?9?$DOt@ DB 'Could not '
	DB	'malloc threadqueue->threads!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OMHDKFFL@pthread_cond_init?5failed?$CB?6@
CONST	SEGMENT
??_C@_0BL@OMHDKFFL@pthread_cond_init?5failed?$CB?6@ DB 'pthread_cond_init'
	DB	' failed!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HIMFGFND@pthread_mutex_init?5failed?$CB?6@
CONST	SEGMENT
??_C@_0BM@HIMFGFND@pthread_mutex_init?5failed?$CB?6@ DB 'pthread_mutex_in'
	DB	'it failed!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_threadqueue_init@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_threadqueue_init@@9@9 DD 0171H	; `kvz_threadqueue_init'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CK@JMNOOCPM@?$AAd?$AAe?$AAp?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAn?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd@
CONST	SEGMENT
??_C@_1CK@JMNOOCPM@?$AAd?$AAe?$AAp?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAn?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd@ DB 'd'
	DB	00H, 'e', 00H, 'p', 00H, 'j', 00H, 'o', 00H, 'b', 00H, '-', 00H
	DB	'>', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n'
	DB	00H, 'd', 00H, 's', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@CILPAJDO@?$AAd?$AAe?$AAp?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1MA@CILPAJDO@?$AAd?$AAe?$AAp?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN@ DB 'd'
	DB	00H, 'e', 00H, 'p', 00H, 'j', 00H, 'o', 00H, 'b', 00H, '-', 00H
	DB	'>', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'T', 00H, 'H', 00H, 'R', 00H
	DB	'E', 00H, 'A', 00H, 'D', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'U'
	DB	00H, 'E', 00H, '_', 00H, 'J', 00H, 'O', 00H, 'B', 00H, '_', 00H
	DB	'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'E', 00H, '_', 00H, 'W'
	DB	00H, 'A', 00H, 'I', 00H, 'T', 00H, 'I', 00H, 'N', 00H, 'G', 00H
	DB	' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'p'
	DB	00H, 'j', 00H, 'o', 00H, 'b', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'T', 00H, 'H', 00H, 'R', 00H, 'E', 00H, 'A', 00H
	DB	'D', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'U', 00H, 'E', 00H, '_'
	DB	00H, 'J', 00H, 'O', 00H, 'B', 00H, '_', 00H, 'S', 00H, 'T', 00H
	DB	'A', 00H, 'T', 00H, 'E', 00H, '_', 00H, 'P', 00H, 'A', 00H, 'U'
	DB	00H, 'S', 00H, 'E', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CPKPLFPC@?$CGdepjob?9?$DOlock@
CONST	SEGMENT
??_C@_0O@CPKPLFPC@?$CGdepjob?9?$DOlock@ DB '&depjob->lock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JJHPJKJK@pthread_cond_signal?$CI?$CFs?$DN?$CFp?$CJ?5fail@
CONST	SEGMENT
??_C@_0CE@JJHPJKJK@pthread_cond_signal?$CI?$CFs?$DN?$CFp?$CJ?5fail@ DB 'p'
	DB	'thread_cond_signal(%s=%p) failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NPKCIKON@?$CGthreadqueue?9?$DOjob_done@
CONST	SEGMENT
??_C@_0BH@NPKCIKON@?$CGthreadqueue?9?$DOjob_done@ DB '&threadqueue->job_d'
	DB	'one', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@KLIDNBIO@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@
CONST	SEGMENT
??_C@_1FI@KLIDNBIO@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@ DB 'j'
	DB	00H, 'o', 00H, 'b', 00H, '-', 00H, '>', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'T', 00H, 'H', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'D', 00H
	DB	'Q', 00H, 'U', 00H, 'E', 00H, 'U', 00H, 'E', 00H, '_', 00H, 'J'
	DB	00H, 'O', 00H, 'B', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H
	DB	'T', 00H, 'E', 00H, '_', 00H, 'R', 00H, 'U', 00H, 'N', 00H, 'N'
	DB	00H, 'I', 00H, 'N', 00H, 'G', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
CONST	SEGMENT
??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@ DB 'pthread'
	DB	'_mutex_unlock(%s) failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@IHCDHMCL@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@
CONST	SEGMENT
??_C@_1FE@IHCDHMCL@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@ DB 'j'
	DB	00H, 'o', 00H, 'b', 00H, '-', 00H, '>', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'T', 00H, 'H', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'D', 00H
	DB	'Q', 00H, 'U', 00H, 'E', 00H, 'U', 00H, 'E', 00H, '_', 00H, 'J'
	DB	00H, 'O', 00H, 'B', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A', 00H
	DB	'T', 00H, 'E', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'D'
	DB	00H, 'Y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
CONST	SEGMENT
??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@ DB '&job->lock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IEPOFDPD@pthread_cond_wait?$CI?$CFs?$DN?$CFp?0?5?$CFs?$DN?$CFp?$CJ@
CONST	SEGMENT
??_C@_0CJ@IEPOFDPD@pthread_cond_wait?$CI?$CFs?$DN?$CFp?0?5?$CFs?$DN?$CFp?$CJ@ DB 'p'
	DB	'thread_cond_wait(%s=%p, %s=%p) failed!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GFDKEBKL@?$CGthreadqueue?9?$DOjob_available@
CONST	SEGMENT
??_C@_0BM@GFDKEBKL@?$CGthreadqueue?9?$DOjob_available@ DB '&threadqueue->'
	DB	'job_available', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0@ DB '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
CONST	SEGMENT
??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@ DB 'pth'
	DB	'read_mutex_lock(%s) failed!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
CONST	SEGMENT
??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@ DB '&threadqueue->lock', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??threadqueue_worker@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??threadqueue_worker@@9@9 DD 011cH	; `threadqueue_worker'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DG@NBKHGELB@?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?9?$AA?$DO?$AAf?$AAi@
CONST	SEGMENT
??_C@_1DG@NBKHGELB@?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?9?$AA?$DO?$AAf?$AAi@ DB 't'
	DB	00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'q', 00H
	DB	'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, '-', 00H, '>', 00H, 'f'
	DB	00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??threadqueue_pop_job@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??threadqueue_pop_job@@9@9 DD 0109H	; `threadqueue_pop_job'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CG@PECLADJO@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAn?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAs?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1CG@PECLADJO@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAn?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAs?$AA?5?$AA?$DN@ DB 'j'
	DB	00H, 'o', 00H, 'b', 00H, '-', 00H, '>', 00H, 'n', 00H, 'd', 00H
	DB	'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 's', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
CONST	SEGMENT
??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, '8', 00H, '4', 00H, '0', 00H, '3', 00H, '8'
	DB	00H, '\', 00H, 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H
	DB	'o', 00H, 'p', 00H, '\', 00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e'
	DB	00H, 'o', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'c', 00H, '_', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, '_', 00H, 't', 00H, 'e', 00H, 's', 00H, 't', 00H
	DB	'\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 't', 00H, 'h'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'q', 00H, 'u', 00H
	DB	'e', 00H, 'u', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??threadqueue_push_job@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??threadqueue_push_job@@9@9 DD 0f0H	; `threadqueue_push_job'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$threadqueue_worker DD 035052a01H
	DD	010e3313H
	DD	070070039H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
threadqueue_worker$rtcName$0 DB 06aH
	DB	06fH
	DB	062H
	DB	00H
	ORG $+12
threadqueue_worker$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:threadqueue_worker$rtcName$0
	ORG $+48
threadqueue_worker$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:threadqueue_worker$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$threadqueue_pop_job DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$threadqueue_push_job DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 025053901H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
fprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
fprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:fprintf$rtcName$0
	ORG $+48
fprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:fprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 035053901H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_free DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_stop DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_waitfor DD 035052f01H
	DD	01133318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_free_job DD 025052a01H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_copy_ref DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_job_dep_add DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_submit DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_job_create DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_threadqueue_init DD 025052801H
	DD	010d2312H
	DD	070060025H
	DD	05005H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT threadqueue_worker
_TEXT	SEGMENT
threadqueue$ = 8
job$4 = 40
num_new_jobs$5 = 68
i$6 = 100
depjob$7 = 136
i$8 = 164
tv242 = 376
tv91 = 376
tv94 = 384
threadqueue_opaque$ = 432
threadqueue_worker PROC					; COMDAT

; 284  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 456				; 000001c8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 114				; 00000072H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+488]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 285  :   threadqueue_queue_t * const threadqueue = (threadqueue_queue_t *) threadqueue_opaque;

	mov	rax, QWORD PTR threadqueue_opaque$[rbp]
	mov	QWORD PTR threadqueue$[rbp], rax

; 286  : 
; 287  :   PTHREAD_LOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN13@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN28@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 3
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN28@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN13@threadqueu:
$LN2@threadqueu:
$LN5@threadqueu:

; 288  : 
; 289  :   for (;;) {
; 290  : 
; 291  :     while (!threadqueue->stop && threadqueue->first == NULL) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	test	eax, eax
	jne	$LN6@threadqueu
	mov	rax, QWORD PTR threadqueue$[rbp]
	cmp	QWORD PTR [rax+48], 0
	jne	$LN6@threadqueu

; 292  :       // Wait until there is something to do in the queue.
; 293  :       PTHREAD_COND_WAIT(&threadqueue->job_available, &threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, QWORD PTR threadqueue$[rbp]
	add	rcx, 8
	mov	rdx, rax
	call	pthread_cond_wait
	test	eax, eax
	je	$LN14@threadqueu
	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	QWORD PTR tv91[rbp], rax
	mov	rcx, QWORD PTR threadqueue$[rbp]
	add	rcx, 8
	mov	QWORD PTR tv94[rbp], rcx
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR tv91[rbp]
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR tv94[rbp]
	mov	r9, rcx
	lea	r8, OFFSET FLAT:??_C@_0BM@GFDKEBKL@?$CGthreadqueue?9?$DOjob_available@
	lea	rdx, OFFSET FLAT:??_C@_0CJ@IEPOFDPD@pthread_cond_wait?$CI?$CFs?$DN?$CFp?0?5?$CFs?$DN?$CFp?$CJ@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN29@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 9
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN29@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN14@threadqueu:

; 294  :     }

	jmp	$LN5@threadqueu
$LN6@threadqueu:

; 295  : 
; 296  :     if (threadqueue->stop) 

	mov	rax, QWORD PTR threadqueue$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	test	eax, eax
	je	SHORT $LN15@threadqueu

; 297  :     {
; 298  :         //printf("threadqueue need stop !!!\n");
; 299  :         break;

	jmp	$LN3@threadqueu
$LN15@threadqueu:

; 300  :     }
; 301  : 
; 302  :     // Get a job and remove it from the queue.
; 303  :     threadqueue_job_t *job = threadqueue_pop_job(threadqueue);

	mov	rcx, QWORD PTR threadqueue$[rbp]
	call	threadqueue_pop_job
	mov	QWORD PTR job$4[rbp], rax

; 304  : 
; 305  :     PTHREAD_LOCK(&job->lock);

	mov	rax, QWORD PTR job$4[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN16@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN30@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 21
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN30@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN16@threadqueu:

; 306  :     assert(job->state == THREADQUEUE_JOB_STATE_READY);

	mov	rax, QWORD PTR job$4[rbp]
	cmp	DWORD PTR [rax+8], 2
	je	SHORT $LN31@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 22
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1FE@IHCDHMCL@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN31@threadqueu:

; 307  :     job->state = THREADQUEUE_JOB_STATE_RUNNING;

	mov	rax, QWORD PTR job$4[rbp]
	mov	DWORD PTR [rax+8], 3

; 308  :     PTHREAD_UNLOCK(&job->lock);

	mov	rax, QWORD PTR job$4[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN17@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN32@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 24
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN32@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN17@threadqueu:

; 309  :     PTHREAD_UNLOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN18@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN33@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 25
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN33@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN18@threadqueu:

; 310  : 
; 311  :     job->fptr(job->arg);

	mov	rax, QWORD PTR job$4[rbp]
	mov	rcx, QWORD PTR [rax+48]
	mov	rax, QWORD PTR job$4[rbp]
	call	QWORD PTR [rax+40]

; 312  : 
; 313  :     PTHREAD_LOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN19@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN34@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 29
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN34@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN19@threadqueu:

; 314  :     PTHREAD_LOCK(&job->lock);

	mov	rax, QWORD PTR job$4[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN20@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN35@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 30
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN35@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN20@threadqueu:

; 315  :     assert(job->state == THREADQUEUE_JOB_STATE_RUNNING);

	mov	rax, QWORD PTR job$4[rbp]
	cmp	DWORD PTR [rax+8], 3
	je	SHORT $LN36@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 31
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1FI@KLIDNBIO@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN36@threadqueu:

; 316  :     job->state = THREADQUEUE_JOB_STATE_DONE;

	mov	rax, QWORD PTR job$4[rbp]
	mov	DWORD PTR [rax+8], 4

; 317  : 
; 318  :     PTHREAD_COND_SIGNAL(&threadqueue->job_done);

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 16
	mov	rcx, rax
	call	pthread_cond_signal
	test	eax, eax
	je	SHORT $LN21@threadqueu
	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 16
	mov	QWORD PTR tv242[rbp], rax
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR tv242[rbp]
	mov	r9, rcx
	lea	r8, OFFSET FLAT:??_C@_0BH@NPKCIKON@?$CGthreadqueue?9?$DOjob_done@
	lea	rdx, OFFSET FLAT:??_C@_0CE@JJHPJKJK@pthread_cond_signal?$CI?$CFs?$DN?$CFp?$CJ?5fail@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN37@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 34					; 00000022H
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN37@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN21@threadqueu:

; 319  : 
; 320  :     // Go through all the jobs that depend on this one, decreasing their
; 321  :     // ndepends. Count how many jobs can now start executing so we know how
; 322  :     // many threads to wake up.
; 323  :     int num_new_jobs = 0;

	mov	DWORD PTR num_new_jobs$5[rbp], 0

; 324  :     for (int i = 0; i < job->rdepends_count; ++i) {

	mov	DWORD PTR i$6[rbp], 0
	jmp	SHORT $LN9@threadqueu
$LN7@threadqueu:
	mov	eax, DWORD PTR i$6[rbp]
	inc	eax
	mov	DWORD PTR i$6[rbp], eax
$LN9@threadqueu:
	mov	rax, QWORD PTR job$4[rbp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR i$6[rbp], eax
	jge	$LN8@threadqueu

; 325  :       threadqueue_job_t * const depjob = job->rdepends[i];

	movsxd	rax, DWORD PTR i$6[rbp]
	mov	rcx, QWORD PTR job$4[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR depjob$7[rbp], rax

; 326  :       // The dependency (job) is locked before the job depending on it.
; 327  :       // This must be the same order as in kvz_threadqueue_job_dep_add.
; 328  :       PTHREAD_LOCK(&depjob->lock);

	mov	rax, QWORD PTR depjob$7[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN22@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0O@CPKPLFPC@?$CGdepjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN38@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 44					; 0000002cH
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN38@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN22@threadqueu:

; 329  : 
; 330  :       assert(depjob->state == THREADQUEUE_JOB_STATE_WAITING ||

	mov	rax, QWORD PTR depjob$7[rbp]
	cmp	DWORD PTR [rax+8], 1
	je	SHORT $LN39@threadqueu
	mov	rax, QWORD PTR depjob$7[rbp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN39@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 47					; 0000002fH
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1MA@CILPAJDO@?$AAd?$AAe?$AAp?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN39@threadqueu:

; 331  :              depjob->state == THREADQUEUE_JOB_STATE_PAUSED);
; 332  :       assert(depjob->ndepends > 0);

	mov	rax, QWORD PTR depjob$7[rbp]
	cmp	DWORD PTR [rax+12], 0
	jg	SHORT $LN40@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 48					; 00000030H
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1CK@JMNOOCPM@?$AAd?$AAe?$AAp?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAn?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN40@threadqueu:

; 333  :       depjob->ndepends--;

	mov	rax, QWORD PTR depjob$7[rbp]
	mov	eax, DWORD PTR [rax+12]
	dec	eax
	mov	rcx, QWORD PTR depjob$7[rbp]
	mov	DWORD PTR [rcx+12], eax

; 334  : 
; 335  :       if (depjob->ndepends == 0 && depjob->state == THREADQUEUE_JOB_STATE_WAITING) {

	mov	rax, QWORD PTR depjob$7[rbp]
	cmp	DWORD PTR [rax+12], 0
	jne	SHORT $LN23@threadqueu
	mov	rax, QWORD PTR depjob$7[rbp]
	cmp	DWORD PTR [rax+8], 1
	jne	SHORT $LN23@threadqueu

; 336  :         // Move the job to ready jobs.
; 337  :         threadqueue_push_job(threadqueue, kvz_threadqueue_copy_ref(depjob));

	mov	rcx, QWORD PTR depjob$7[rbp]
	call	kvz_threadqueue_copy_ref
	mov	rdx, rax
	mov	rcx, QWORD PTR threadqueue$[rbp]
	call	threadqueue_push_job

; 338  :         num_new_jobs++;

	mov	eax, DWORD PTR num_new_jobs$5[rbp]
	inc	eax
	mov	DWORD PTR num_new_jobs$5[rbp], eax
$LN23@threadqueu:

; 339  :       }
; 340  : 
; 341  :       // Clear this reference to the job.
; 342  :       PTHREAD_UNLOCK(&depjob->lock);

	mov	rax, QWORD PTR depjob$7[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN24@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0O@CPKPLFPC@?$CGdepjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN41@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 58					; 0000003aH
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN41@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN24@threadqueu:

; 343  :       kvz_threadqueue_free_job(&job->rdepends[i]);

	movsxd	rax, DWORD PTR i$6[rbp]
	mov	rcx, QWORD PTR job$4[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, rax
	call	kvz_threadqueue_free_job

; 344  :     }

	jmp	$LN7@threadqueu
$LN8@threadqueu:

; 345  :     job->rdepends_count = 0;

	mov	rax, QWORD PTR job$4[rbp]
	mov	DWORD PTR [rax+24], 0

; 346  : 
; 347  :     PTHREAD_UNLOCK(&job->lock);

	mov	rax, QWORD PTR job$4[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN25@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN42@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 63					; 0000003fH
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN42@threadqueu:
	xor	eax, eax
	jmp	$LN1@threadqueu
$LN25@threadqueu:

; 348  :     kvz_threadqueue_free_job(&job);

	lea	rcx, QWORD PTR job$4[rbp]
	call	kvz_threadqueue_free_job

; 349  : 
; 350  :     // The current thread will process one of the new jobs so we wake up
; 351  :     // one threads less than the the number of new jobs.
; 352  :     for (int i = 0; i < num_new_jobs - 1; i++) {

	mov	DWORD PTR i$8[rbp], 0
	jmp	SHORT $LN12@threadqueu
$LN10@threadqueu:
	mov	eax, DWORD PTR i$8[rbp]
	inc	eax
	mov	DWORD PTR i$8[rbp], eax
$LN12@threadqueu:
	mov	eax, DWORD PTR num_new_jobs$5[rbp]
	dec	eax
	cmp	DWORD PTR i$8[rbp], eax
	jge	SHORT $LN11@threadqueu

; 353  :       pthread_cond_signal(&threadqueue->job_available);

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	pthread_cond_signal

; 354  :     }

	jmp	SHORT $LN10@threadqueu
$LN11@threadqueu:

; 355  :   }

	jmp	$LN2@threadqueu
$LN3@threadqueu:

; 356  : 
; 357  :   threadqueue->thread_running_count--;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	eax, DWORD PTR [rax+36]
	dec	eax
	mov	rcx, QWORD PTR threadqueue$[rbp]
	mov	DWORD PTR [rcx+36], eax

; 358  :   PTHREAD_UNLOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN26@threadqueu
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN43@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_worker@@9@9
	add	eax, 74					; 0000004aH
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN43@threadqueu:
	xor	eax, eax
	jmp	SHORT $LN1@threadqueu
$LN26@threadqueu:

; 359  :   return NULL;

	xor	eax, eax
$LN1@threadqueu:

; 360  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:threadqueue_worker$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+408]
	pop	rdi
	pop	rbp
	ret	0
threadqueue_worker ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT threadqueue_pop_job
_TEXT	SEGMENT
job$ = 8
threadqueue$ = 256
threadqueue_pop_job PROC				; COMDAT

; 265  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 266  :   assert(threadqueue->first != NULL);

	mov	rax, QWORD PTR threadqueue$[rbp]
	cmp	QWORD PTR [rax+48], 0
	jne	SHORT $LN4@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_pop_job@@9@9
	inc	eax
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1DG@NBKHGELB@?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?9?$AA?$DO?$AAf?$AAi@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN4@threadqueu:

; 267  : 
; 268  :   threadqueue_job_t *job = threadqueue->first;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR job$[rbp], rax

; 269  :   threadqueue->first = job->next;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, QWORD PTR job$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax+48], rcx

; 270  :   job->next = NULL;

	mov	rax, QWORD PTR job$[rbp]
	mov	QWORD PTR [rax+56], 0

; 271  : 
; 272  :   if (threadqueue->first == NULL) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	cmp	QWORD PTR [rax+48], 0
	jne	SHORT $LN2@threadqueu

; 273  :     threadqueue->last = NULL;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	QWORD PTR [rax+56], 0
$LN2@threadqueu:

; 274  :   }
; 275  : 
; 276  :   return job;

	mov	rax, QWORD PTR job$[rbp]

; 277  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
threadqueue_pop_job ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT threadqueue_push_job
_TEXT	SEGMENT
threadqueue$ = 224
job$ = 232
threadqueue_push_job PROC				; COMDAT

; 240  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 241  :   assert(job->ndepends == 0);

	mov	rax, QWORD PTR job$[rbp]
	cmp	DWORD PTR [rax+12], 0
	je	SHORT $LN5@threadqueu
	mov	eax, DWORD PTR ?__LINE__Var@?0??threadqueue_push_job@@9@9
	inc	eax
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1CG@PECLADJO@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAn?$AAd?$AAe?$AAp?$AAe?$AAn?$AAd?$AAs?$AA?5?$AA?$DN@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN5@threadqueu:

; 242  :   job->state = THREADQUEUE_JOB_STATE_READY;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+8], 2

; 243  : 
; 244  :   if (threadqueue->first == NULL) //如果没有job转备好

	mov	rax, QWORD PTR threadqueue$[rbp]
	cmp	QWORD PTR [rax+48], 0
	jne	SHORT $LN2@threadqueu

; 245  :   {
; 246  :     threadqueue->first = job;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, QWORD PTR job$[rbp]
	mov	QWORD PTR [rax+48], rcx

; 247  :   } 

	jmp	SHORT $LN3@threadqueu
$LN2@threadqueu:

; 248  :   else 
; 249  :   {
; 250  :     threadqueue->last->next = job;//尾插法

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR job$[rbp]
	mov	QWORD PTR [rax+56], rcx
$LN3@threadqueu:

; 251  :   }
; 252  : 
; 253  :   threadqueue->last = job;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, QWORD PTR job$[rbp]
	mov	QWORD PTR [rax+56], rcx

; 254  :   job->next = NULL;

	mov	rax, QWORD PTR job$[rbp]
	mov	QWORD PTR [rax+56], 0

; 255  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
threadqueue_push_job ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
_Stream$ = 288
_Format$ = 296
fprintf	PROC						; COMDAT

; 835  :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__9FF75F13_stdio@h
	call	__CheckForDebuggerJustMyCode

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rbp+8]
	mov	QWORD PTR _ArgList$[rbp], rax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rbp]
	mov	rcx, QWORD PTR _Stream$[rbp]
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rbp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rbp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR _Result$[rbp]

; 842  :     }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:fprintf$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__9FF75F13_stdio@h
	call	__CheckForDebuggerJustMyCode

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rbp]
	mov	r8, QWORD PTR _Format$[rbp]
	mov	rdx, QWORD PTR _Stream$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 644  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 86   :     {

$LN3:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__1850469A_corecrt_stdio_config@h
	call	__CheckForDebuggerJustMyCode

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_free
_TEXT	SEGMENT
next$1 = 8
threadqueue$ = 256
kvz_threadqueue_free PROC				; COMDAT

; 630  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 631  :   if (threadqueue == NULL) return;

	cmp	QWORD PTR threadqueue$[rbp], 0
	jne	SHORT $LN4@kvz_thread
	jmp	$LN1@kvz_thread
$LN4@kvz_thread:

; 632  : 
; 633  :   kvz_threadqueue_stop(threadqueue);

	mov	rcx, QWORD PTR threadqueue$[rbp]
	call	kvz_threadqueue_stop
$LN2@kvz_thread:

; 634  : 
; 635  :   // Free all jobs.
; 636  :   while (threadqueue->first) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	cmp	QWORD PTR [rax+48], 0
	je	SHORT $LN3@kvz_thread

; 637  :     threadqueue_job_t *next = threadqueue->first->next;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rax, QWORD PTR [rax+48]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR next$1[rbp], rax

; 638  :     kvz_threadqueue_free_job(&threadqueue->first);

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	kvz_threadqueue_free_job

; 639  :     threadqueue->first = next;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, QWORD PTR next$1[rbp]
	mov	QWORD PTR [rax+48], rcx

; 640  :   }

	jmp	SHORT $LN2@kvz_thread
$LN3@kvz_thread:

; 641  :   threadqueue->last = NULL;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	QWORD PTR [rax+56], 0

; 642  : 
; 643  :   FREE_POINTER(threadqueue->threads);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, QWORD PTR [rax+24]
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	QWORD PTR [rax+24], 0

; 644  :   threadqueue->thread_count = 0;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	DWORD PTR [rax+32], 0

; 645  : 
; 646  :   if (pthread_mutex_destroy(&threadqueue->lock) != 0) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_destroy
	test	eax, eax
	je	SHORT $LN5@kvz_thread

; 647  :     fprintf(stderr, "pthread_mutex_destroy failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BP@DKJFEBPG@pthread_mutex_destroy?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
$LN5@kvz_thread:

; 648  :   }
; 649  : 
; 650  :   if (pthread_cond_destroy(&threadqueue->job_available) != 0) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	pthread_cond_destroy
	test	eax, eax
	je	SHORT $LN6@kvz_thread

; 651  :     fprintf(stderr, "pthread_cond_destroy failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BO@DMELMKKN@pthread_cond_destroy?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
$LN6@kvz_thread:

; 652  :   }
; 653  : 
; 654  :   if (pthread_cond_destroy(&threadqueue->job_done) != 0) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 16
	mov	rcx, rax
	call	pthread_cond_destroy
	test	eax, eax
	je	SHORT $LN7@kvz_thread

; 655  :     fprintf(stderr, "pthread_cond_destroy failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BO@DMELMKKN@pthread_cond_destroy?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
$LN7@kvz_thread:

; 656  :   }
; 657  : 
; 658  :   FREE_POINTER(threadqueue);

	mov	rcx, QWORD PTR threadqueue$[rbp]
	call	QWORD PTR __imp_free
	mov	QWORD PTR threadqueue$[rbp], 0
$LN1@kvz_thread:

; 659  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_stop
_TEXT	SEGMENT
i$1 = 4
tv142 = 216
threadqueue$ = 256
kvz_threadqueue_stop PROC				; COMDAT

; 597  : {

$LN17:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 598  :   PTHREAD_LOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN5@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN12@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_stop@@9@9
	inc	eax
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN12@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN5@kvz_thread:

; 599  : 
; 600  :   if (threadqueue->stop) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	movzx	eax, BYTE PTR [rax+40]
	test	eax, eax
	je	$LN6@kvz_thread

; 601  :     // The threadqueue should have stopped already.
; 602  :     assert(threadqueue->thread_running_count == 0);

	mov	rax, QWORD PTR threadqueue$[rbp]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN13@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_stop@@9@9
	add	eax, 5
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1EO@DJPPPMHK@?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AAq?$AAu?$AAe?$AAu?$AAe?$AA?9?$AA?$DO?$AAt?$AAh@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN13@kvz_thread:

; 603  :     PTHREAD_UNLOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN7@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN14@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_stop@@9@9
	add	eax, 6
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN14@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN7@kvz_thread:

; 604  :     return 1;

	mov	eax, 1
	jmp	$LN1@kvz_thread
$LN6@kvz_thread:

; 605  :   }
; 606  : 
; 607  :   // Tell all threads to stop.
; 608  :   threadqueue->stop = true;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	BYTE PTR [rax+40], 1

; 609  :   PTHREAD_COND_BROADCAST(&threadqueue->job_available);

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	pthread_cond_broadcast
	test	eax, eax
	je	SHORT $LN8@kvz_thread
	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 8
	mov	QWORD PTR tv142[rbp], rax
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR tv142[rbp]
	mov	r9, rcx
	lea	r8, OFFSET FLAT:??_C@_0BM@GFDKEBKL@?$CGthreadqueue?9?$DOjob_available@
	lea	rdx, OFFSET FLAT:??_C@_0CH@CJMCPDDL@pthread_cond_broadcast?$CI?$CFs?$DN?$CFp?$CJ?5f@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN15@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_stop@@9@9
	add	eax, 12
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN15@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN8@kvz_thread:

; 610  :   PTHREAD_UNLOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN9@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN16@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_stop@@9@9
	add	eax, 13
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN16@kvz_thread:
	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN9@kvz_thread:

; 611  : 
; 612  :   // Wait for them to stop.
; 613  :   for (int i = 0; i < threadqueue->thread_count; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@kvz_thread
$LN2@kvz_thread:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@kvz_thread:
	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	eax, DWORD PTR [rax+32]
	cmp	DWORD PTR i$1[rbp], eax
	jge	SHORT $LN3@kvz_thread

; 614  :     if (pthread_join(threadqueue->threads[i], NULL) != 0) {

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR threadqueue$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	xor	edx, edx
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	pthread_join
	test	eax, eax
	je	SHORT $LN10@kvz_thread

; 615  :       fprintf(stderr, "pthread_join failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BG@DMJOJJP@pthread_join?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf

; 616  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN10@kvz_thread:

; 617  :     }
; 618  :   }

	jmp	SHORT $LN2@kvz_thread
$LN3@kvz_thread:

; 619  : 
; 620  :   return 1;

	mov	eax, 1
$LN1@kvz_thread:

; 621  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_stop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_waitfor
_TEXT	SEGMENT
tv88 = 192
tv91 = 200
threadqueue$ = 240
job$ = 248
kvz_threadqueue_waitfor PROC				; COMDAT

; 578  : {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 579  :   PTHREAD_LOCK(&job->lock);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN4@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN8@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_waitfor@@9@9
	inc	eax
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN8@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN4@kvz_thread:
$LN2@kvz_thread:

; 580  :   while (job->state != THREADQUEUE_JOB_STATE_DONE) {

	mov	rax, QWORD PTR job$[rbp]
	cmp	DWORD PTR [rax+8], 4
	je	$LN3@kvz_thread

; 581  :     PTHREAD_COND_WAIT(&threadqueue->job_done, &job->lock);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, QWORD PTR threadqueue$[rbp]
	add	rcx, 16
	mov	rdx, rax
	call	pthread_cond_wait
	test	eax, eax
	je	$LN5@kvz_thread
	mov	rax, QWORD PTR job$[rbp]
	mov	QWORD PTR tv88[rbp], rax
	mov	rcx, QWORD PTR threadqueue$[rbp]
	add	rcx, 16
	mov	QWORD PTR tv91[rbp], rcx
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, QWORD PTR tv88[rbp]
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR tv91[rbp]
	mov	r9, rcx
	lea	r8, OFFSET FLAT:??_C@_0BH@NPKCIKON@?$CGthreadqueue?9?$DOjob_done@
	lea	rdx, OFFSET FLAT:??_C@_0CJ@IEPOFDPD@pthread_cond_wait?$CI?$CFs?$DN?$CFp?0?5?$CFs?$DN?$CFp?$CJ@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN9@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_waitfor@@9@9
	add	eax, 3
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN9@kvz_thread:
	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN5@kvz_thread:

; 582  :   }

	jmp	$LN2@kvz_thread
$LN3@kvz_thread:

; 583  :   PTHREAD_UNLOCK(&job->lock);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN6@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_waitfor@@9@9
	add	eax, 5
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN10@kvz_thread:
	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN6@kvz_thread:

; 584  : 
; 585  :   return 1;

	mov	eax, 1
$LN1@kvz_thread:

; 586  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_waitfor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_free_job
_TEXT	SEGMENT
job$ = 8
new_refcount$ = 36
i$1 = 68
job_ptr$ = 320
kvz_threadqueue_free_job PROC				; COMDAT

; 548  : {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 549  :   threadqueue_job_t *job = *job_ptr;

	mov	rax, QWORD PTR job_ptr$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR job$[rbp], rax

; 550  :   if (job == NULL) return;

	cmp	QWORD PTR job$[rbp], 0
	jne	SHORT $LN5@kvz_thread
	jmp	$LN1@kvz_thread
$LN5@kvz_thread:

; 551  :   *job_ptr = NULL;

	mov	rax, QWORD PTR job_ptr$[rbp]
	mov	QWORD PTR [rax], 0

; 552  : 
; 553  :   int new_refcount = KVZ_ATOMIC_DEC(&job->refcount);

	mov	rax, QWORD PTR job$[rbp]
	add	rax, 32					; 00000020H
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	mov	DWORD PTR new_refcount$[rbp], eax

; 554  :   if (new_refcount > 0) {

	cmp	DWORD PTR new_refcount$[rbp], 0
	jle	SHORT $LN6@kvz_thread

; 555  :     // There are still references so we don't free the data yet.
; 556  :     return;

	jmp	$LN1@kvz_thread
$LN6@kvz_thread:

; 557  :   }
; 558  : 
; 559  :   assert(new_refcount == 0);

	cmp	DWORD PTR new_refcount$[rbp], 0
	je	SHORT $LN8@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_free_job@@9@9
	add	eax, 11
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1CE@EMPGFCAP@?$AAn?$AAe?$AAw?$AA_?$AAr?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN8@kvz_thread:

; 560  : 
; 561  :   for (int i = 0; i < job->rdepends_count; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@kvz_thread
$LN2@kvz_thread:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@kvz_thread:
	mov	rax, QWORD PTR job$[rbp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR i$1[rbp], eax
	jge	SHORT $LN3@kvz_thread

; 562  :     kvz_threadqueue_free_job(&job->rdepends[i]);

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR job$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	rcx, rax
	call	kvz_threadqueue_free_job

; 563  :   }

	jmp	SHORT $LN2@kvz_thread
$LN3@kvz_thread:

; 564  :   job->rdepends_count = 0;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+24], 0

; 565  : 
; 566  :   FREE_POINTER(job->rdepends);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR job$[rbp]
	mov	QWORD PTR [rax+16], 0

; 567  :   pthread_mutex_destroy(&job->lock);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, rax
	call	pthread_mutex_destroy

; 568  :   FREE_POINTER(job);

	mov	rcx, QWORD PTR job$[rbp]
	call	QWORD PTR __imp_free
	mov	QWORD PTR job$[rbp], 0
$LN1@kvz_thread:

; 569  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_free_job ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_copy_ref
_TEXT	SEGMENT
new_refcount$ = 4
job$ = 256
kvz_threadqueue_copy_ref PROC				; COMDAT

; 530  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 531  :   int32_t new_refcount = KVZ_ATOMIC_INC(&job->refcount);

	mov	rax, QWORD PTR job$[rbp]
	add	rax, 32					; 00000020H
	mov	ecx, 1
	lock xadd DWORD PTR [rax], ecx
	inc	ecx
	mov	eax, ecx
	mov	DWORD PTR new_refcount$[rbp], eax

; 532  :   // The caller should have had another reference and we added one
; 533  :   // reference so refcount should be at least 2.
; 534  :   assert(new_refcount >= 2);

	cmp	DWORD PTR new_refcount$[rbp], 2
	jge	SHORT $LN3@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_copy_ref@@9@9
	add	eax, 4
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1CE@NMICBIH@?$AAn?$AAe?$AAw?$AA_?$AAr?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?$DN@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN3@kvz_thread:

; 535  :   return job;

	mov	rax, QWORD PTR job$[rbp]

; 536  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_copy_ref ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_job_dep_add
_TEXT	SEGMENT
bytes$1 = 8
job$ = 256
dependency$ = 264
kvz_threadqueue_job_dep_add PROC			; COMDAT

; 495  : {

$LN15:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 496  :   // Lock the dependency first and then the job depending on it.
; 497  :   // This must be the same order as in threadqueue_worker.
; 498  :   PTHREAD_LOCK(&dependency->lock);

	mov	rax, QWORD PTR dependency$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN2@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BC@CBBBDMI@?$CGdependency?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_job_dep_add@@9@9
	add	eax, 3
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN10@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN2@kvz_thread:

; 499  : 
; 500  :   if (dependency->state == THREADQUEUE_JOB_STATE_DONE) {

	mov	rax, QWORD PTR dependency$[rbp]
	cmp	DWORD PTR [rax+8], 4
	jne	SHORT $LN3@kvz_thread

; 501  :     // The dependency has been completed already so there is nothing to do.
; 502  :     PTHREAD_UNLOCK(&dependency->lock);

	mov	rax, QWORD PTR dependency$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN4@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BC@CBBBDMI@?$CGdependency?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN11@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_job_dep_add@@9@9
	add	eax, 7
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN11@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN4@kvz_thread:

; 503  :     return 1;

	mov	eax, 1
	jmp	$LN1@kvz_thread
$LN3@kvz_thread:

; 504  :   }
; 505  : 
; 506  :   PTHREAD_LOCK(&job->lock);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN5@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN12@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_job_dep_add@@9@9
	add	eax, 11
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN12@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN5@kvz_thread:

; 507  :   job->ndepends++;

	mov	rax, QWORD PTR job$[rbp]
	mov	eax, DWORD PTR [rax+12]
	inc	eax
	mov	rcx, QWORD PTR job$[rbp]
	mov	DWORD PTR [rcx+12], eax

; 508  :   PTHREAD_UNLOCK(&job->lock);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN6@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN13@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_job_dep_add@@9@9
	add	eax, 13
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN13@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN6@kvz_thread:

; 509  : 
; 510  :   // Add the reverse dependency
; 511  :   if (dependency->rdepends_count >= dependency->rdepends_size) {

	mov	rax, QWORD PTR dependency$[rbp]
	mov	rcx, QWORD PTR dependency$[rbp]
	mov	ecx, DWORD PTR [rcx+28]
	cmp	DWORD PTR [rax+24], ecx
	jl	SHORT $LN7@kvz_thread

; 512  :     dependency->rdepends_size += THREADQUEUE_LIST_REALLOC_SIZE;

	mov	rax, QWORD PTR dependency$[rbp]
	mov	eax, DWORD PTR [rax+28]
	add	eax, 32					; 00000020H
	mov	rcx, QWORD PTR dependency$[rbp]
	mov	DWORD PTR [rcx+28], eax

; 513  :     size_t bytes = dependency->rdepends_size * sizeof(threadqueue_job_t*);

	mov	rax, QWORD PTR dependency$[rbp]
	movsxd	rax, DWORD PTR [rax+28]
	shl	rax, 3
	mov	QWORD PTR bytes$1[rbp], rax

; 514  :     dependency->rdepends = realloc(dependency->rdepends, bytes);

	mov	rdx, QWORD PTR bytes$1[rbp]
	mov	rax, QWORD PTR dependency$[rbp]
	mov	rcx, QWORD PTR [rax+16]
	call	QWORD PTR __imp_realloc
	mov	rcx, QWORD PTR dependency$[rbp]
	mov	QWORD PTR [rcx+16], rax
$LN7@kvz_thread:

; 515  :   }
; 516  :   dependency->rdepends[dependency->rdepends_count++] = kvz_threadqueue_copy_ref(job);

	mov	rcx, QWORD PTR job$[rbp]
	call	kvz_threadqueue_copy_ref
	mov	rcx, QWORD PTR dependency$[rbp]
	movsxd	rcx, DWORD PTR [rcx+24]
	mov	rdx, QWORD PTR dependency$[rbp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	QWORD PTR [rdx+rcx*8], rax
	mov	rax, QWORD PTR dependency$[rbp]
	mov	eax, DWORD PTR [rax+24]
	inc	eax
	mov	rcx, QWORD PTR dependency$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 517  : 
; 518  :   PTHREAD_UNLOCK(&dependency->lock);

	mov	rax, QWORD PTR dependency$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN8@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BC@CBBBDMI@?$CGdependency?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN14@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_job_dep_add@@9@9
	add	eax, 23
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN14@kvz_thread:
	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN8@kvz_thread:

; 519  : 
; 520  :   return 1;

	mov	eax, 1
$LN1@kvz_thread:

; 521  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_job_dep_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_submit
_TEXT	SEGMENT
threadqueue$ = 224
job$ = 232
kvz_threadqueue_submit PROC				; COMDAT

; 458  : {

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 459  :   PTHREAD_LOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN2@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN11@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_submit@@9@9
	inc	eax
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN11@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN2@kvz_thread:

; 460  :   PTHREAD_LOCK(&job->lock);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN3@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN12@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_submit@@9@9
	add	eax, 2
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN12@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN3@kvz_thread:

; 461  :   assert(job->state == THREADQUEUE_JOB_STATE_PAUSED);

	mov	rax, QWORD PTR job$[rbp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN13@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_submit@@9@9
	add	eax, 3
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1FG@PFPCKMKF@?$AAj?$AAo?$AAb?$AA?9?$AA?$DO?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAT@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN13@kvz_thread:

; 462  : 
; 463  :   if (threadqueue->thread_count == 0) 

	mov	rax, QWORD PTR threadqueue$[rbp]
	cmp	DWORD PTR [rax+32], 0
	jne	SHORT $LN4@kvz_thread

; 464  :   {
; 465  :     // When not using threads, run the job immediately.
; 466  :     job->fptr(job->arg);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	mov	rax, QWORD PTR job$[rbp]
	call	QWORD PTR [rax+40]

; 467  :     job->state = THREADQUEUE_JOB_STATE_DONE;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+8], 4

; 468  :   } 

	jmp	SHORT $LN5@kvz_thread
$LN4@kvz_thread:

; 469  :   else if (job->ndepends == 0) 

	mov	rax, QWORD PTR job$[rbp]
	cmp	DWORD PTR [rax+12], 0
	jne	SHORT $LN6@kvz_thread

; 470  :   {
; 471  :     threadqueue_push_job(threadqueue, kvz_threadqueue_copy_ref(job));

	mov	rcx, QWORD PTR job$[rbp]
	call	kvz_threadqueue_copy_ref
	mov	rdx, rax
	mov	rcx, QWORD PTR threadqueue$[rbp]
	call	threadqueue_push_job

; 472  :     pthread_cond_signal(&threadqueue->job_available);

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 8
	mov	rcx, rax
	call	pthread_cond_signal

; 473  :   } 

	jmp	SHORT $LN7@kvz_thread
$LN6@kvz_thread:

; 474  :   else 
; 475  :   {
; 476  :     job->state = THREADQUEUE_JOB_STATE_WAITING;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+8], 1
$LN7@kvz_thread:
$LN5@kvz_thread:

; 477  :   }
; 478  :   PTHREAD_UNLOCK(&job->lock);

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN8@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0L@EOIFPCAA@?$CGjob?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN14@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_submit@@9@9
	add	eax, 20
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN14@kvz_thread:
	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN8@kvz_thread:

; 479  :   PTHREAD_UNLOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN9@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN15@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_submit@@9@9
	add	eax, 21
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN15@kvz_thread:
	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN9@kvz_thread:

; 480  : 
; 481  :   return 1;

	mov	eax, 1
$LN1@kvz_thread:

; 482  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_submit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_job_create
_TEXT	SEGMENT
job$ = 8
fptr$ = 256
arg$ = 264
kvz_threadqueue_job_create PROC				; COMDAT

; 432  : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 433  :   threadqueue_job_t *job = MALLOC(threadqueue_job_t, 1);

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR job$[rbp], rax

; 434  :   if (!job) {

	cmp	QWORD PTR job$[rbp], 0
	jne	SHORT $LN2@kvz_thread

; 435  :     fprintf(stderr, "Could not alloc job!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BG@LJHKKGBE@Could?5not?5alloc?5job?$CB?6@
	mov	rcx, rax
	call	fprintf

; 436  :     return NULL;

	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN2@kvz_thread:

; 437  :   }
; 438  : 
; 439  :   if (pthread_mutex_init(&job->lock, NULL) != 0) {

	mov	rax, QWORD PTR job$[rbp]
	xor	edx, edx
	mov	rcx, rax
	call	pthread_mutex_init
	test	eax, eax
	je	SHORT $LN3@kvz_thread

; 440  :     fprintf(stderr, "pthread_mutex_init(job) failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0CB@OHFOAGLG@pthread_mutex_init?$CIjob?$CJ?5failed?$CB@
	mov	rcx, rax
	call	fprintf

; 441  :     return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN3@kvz_thread:

; 442  :   }
; 443  : 
; 444  :   job->state = THREADQUEUE_JOB_STATE_PAUSED;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+8], 0

; 445  :   job->ndepends       = 0;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+12], 0

; 446  :   job->rdepends       = NULL;

	mov	rax, QWORD PTR job$[rbp]
	mov	QWORD PTR [rax+16], 0

; 447  :   job->rdepends_count = 0;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+24], 0

; 448  :   job->rdepends_size  = 0;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+28], 0

; 449  :   job->refcount       = 1;

	mov	rax, QWORD PTR job$[rbp]
	mov	DWORD PTR [rax+32], 1

; 450  :   job->fptr           = fptr;

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, QWORD PTR fptr$[rbp]
	mov	QWORD PTR [rax+40], rcx

; 451  :   job->arg            = arg;

	mov	rax, QWORD PTR job$[rbp]
	mov	rcx, QWORD PTR arg$[rbp]
	mov	QWORD PTR [rax+48], rcx

; 452  : 
; 453  :   return job;

	mov	rax, QWORD PTR job$[rbp]
$LN1@kvz_thread:

; 454  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_job_create ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
;	COMDAT kvz_threadqueue_init
_TEXT	SEGMENT
threadqueue$ = 8
i$1 = 36
thread_count$ = 288
kvz_threadqueue_init PROC				; COMDAT

; 369  : {

$LN16:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__817A88BE_threadqueue@c
	call	__CheckForDebuggerJustMyCode

; 370  :   threadqueue_queue_t *threadqueue = MALLOC(threadqueue_queue_t, 1);

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR threadqueue$[rbp], rax

; 371  :   if (!threadqueue) {

	cmp	QWORD PTR threadqueue$[rbp], 0
	jne	SHORT $LN5@kvz_thread

; 372  :     goto failed;

	jmp	$failed$17
$LN5@kvz_thread:

; 373  :   }
; 374  : 
; 375  :   if (pthread_mutex_init(&threadqueue->lock, NULL) != 0) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	xor	edx, edx
	mov	rcx, rax
	call	pthread_mutex_init
	test	eax, eax
	je	SHORT $LN6@kvz_thread

; 376  :     fprintf(stderr, "pthread_mutex_init failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BM@HIMFGFND@pthread_mutex_init?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf

; 377  :     goto failed;

	jmp	$failed$17
$LN6@kvz_thread:

; 378  :   }
; 379  : 
; 380  :   if (pthread_cond_init(&threadqueue->job_available, NULL) != 0) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 8
	xor	edx, edx
	mov	rcx, rax
	call	pthread_cond_init
	test	eax, eax
	je	SHORT $LN7@kvz_thread

; 381  :     fprintf(stderr, "pthread_cond_init failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BL@OMHDKFFL@pthread_cond_init?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf

; 382  :     goto failed;

	jmp	$failed$17
$LN7@kvz_thread:

; 383  :   }
; 384  : 
; 385  :   if (pthread_cond_init(&threadqueue->job_done, NULL) != 0) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	add	rax, 16
	xor	edx, edx
	mov	rcx, rax
	call	pthread_cond_init
	test	eax, eax
	je	SHORT $LN8@kvz_thread

; 386  :     fprintf(stderr, "pthread_cond_init failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BL@OMHDKFFL@pthread_cond_init?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf

; 387  :     goto failed;

	jmp	$failed$17
$LN8@kvz_thread:

; 388  :   }
; 389  : 
; 390  :   threadqueue->threads = MALLOC(pthread_t, thread_count);

	movsxd	rax, DWORD PTR thread_count$[rbp]
	shl	rax, 3
	mov	rcx, rax
	call	QWORD PTR __imp_malloc
	mov	rcx, QWORD PTR threadqueue$[rbp]
	mov	QWORD PTR [rcx+24], rax

; 391  :   if (!threadqueue->threads) {

	mov	rax, QWORD PTR threadqueue$[rbp]
	cmp	QWORD PTR [rax+24], 0
	jne	SHORT $LN9@kvz_thread

; 392  :     fprintf(stderr, "Could not malloc threadqueue->threads!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0CI@FOHADHPI@Could?5not?5malloc?5threadqueue?9?$DOt@
	mov	rcx, rax
	call	fprintf

; 393  :     goto failed;

	jmp	$failed$17
$LN9@kvz_thread:

; 394  :   }
; 395  :   threadqueue->thread_count = 0;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	DWORD PTR [rax+32], 0

; 396  :   threadqueue->thread_running_count = 0;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	DWORD PTR [rax+36], 0

; 397  : 
; 398  :   threadqueue->stop = false;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	BYTE PTR [rax+40], 0

; 399  : 
; 400  :   threadqueue->first              = NULL;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	QWORD PTR [rax+48], 0

; 401  :   threadqueue->last               = NULL;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	QWORD PTR [rax+56], 0

; 402  : 
; 403  :   // Lock the queue before creating threads, to ensure they all have correct information.
; 404  :   PTHREAD_LOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_lock
	test	eax, eax
	je	SHORT $LN10@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CA@GKIKFONO@pthread_mutex_lock?$CI?$CFs?$CJ?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN14@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_init@@9@9
	add	eax, 35					; 00000023H
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN14@kvz_thread:
	xor	eax, eax
	jmp	$LN1@kvz_thread
$LN10@kvz_thread:

; 405  :   for (int i = 0; i < thread_count; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@kvz_thread
$LN2@kvz_thread:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@kvz_thread:
	mov	eax, DWORD PTR thread_count$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jge	SHORT $LN3@kvz_thread

; 406  :     if (pthread_create(&threadqueue->threads[i], NULL, threadqueue_worker, threadqueue) != 0) {

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR threadqueue$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	r9, QWORD PTR threadqueue$[rbp]
	lea	r8, OFFSET FLAT:threadqueue_worker
	xor	edx, edx
	mov	rcx, rax
	call	pthread_create
	test	eax, eax
	je	SHORT $LN11@kvz_thread

; 407  :         fprintf(stderr, "pthread_create failed!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:??_C@_0BI@EKNPILFE@pthread_create?5failed?$CB?6@
	mov	rcx, rax
	call	fprintf

; 408  :         goto failed;

	jmp	$failed$17
$LN11@kvz_thread:

; 409  :     }
; 410  :     threadqueue->thread_count++;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR threadqueue$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 411  :     threadqueue->thread_running_count++;

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	eax, DWORD PTR [rax+36]
	inc	eax
	mov	rcx, QWORD PTR threadqueue$[rbp]
	mov	DWORD PTR [rcx+36], eax

; 412  :   }

	jmp	SHORT $LN2@kvz_thread
$LN3@kvz_thread:

; 413  :   PTHREAD_UNLOCK(&threadqueue->lock);

	mov	rax, QWORD PTR threadqueue$[rbp]
	mov	rcx, rax
	call	pthread_mutex_unlock
	test	eax, eax
	je	SHORT $LN12@kvz_thread
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	r8, OFFSET FLAT:??_C@_0BD@HJBDPDBK@?$CGthreadqueue?9?$DOlock@
	lea	rdx, OFFSET FLAT:??_C@_0CC@NNKLMNLE@pthread_mutex_unlock?$CI?$CFs?$CJ?5failed@
	mov	rcx, rax
	call	fprintf
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN15@kvz_thread
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_threadqueue_init@@9@9
	add	eax, 44					; 0000002cH
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1IC@FJBDNIFD@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN15@kvz_thread:
	xor	eax, eax
	jmp	SHORT $LN1@kvz_thread
$LN12@kvz_thread:

; 414  : 
; 415  :   return threadqueue;

	mov	rax, QWORD PTR threadqueue$[rbp]
	jmp	SHORT $LN1@kvz_thread
$failed$17:

; 416  : 
; 417  : failed:
; 418  :   kvz_threadqueue_free(threadqueue);

	mov	rcx, QWORD PTR threadqueue$[rbp]
	call	kvz_threadqueue_free

; 419  :   return NULL;

	xor	eax, eax
$LN1@kvz_thread:

; 420  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
kvz_threadqueue_init ENDP
_TEXT	ENDS
END
