; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\semaphore.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__45AE7532_corecrt_wconio@h DB 01H
__F82F49DA_corecrt_wio@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__8DC84CAD_corecrt_wtime@h DB 01H
__1DD914C8_stat@h DB 01H
__61D1BCEE_wchar@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__F5601360_stdlib@h DB 01H
__180FC352_cstdlib DB 01H
__3932F226_limits DB 01H
__6750BE0F_type_traits DB 01H
__B2B7B48F_ratio DB 01H
__CF01F9AA_time@h DB 01H
__39C46D1D_vcruntime_new@h DB 01H
__5DDFF4AC_chrono DB 01H
__614D3496_malloc@h DB 01H
__41172C56_vcruntime_exception@h DB 01H
__8EEC81FD_exception DB 01H
__241EEA0C_corecrt_memory@h DB 01H
__731387C4_string@h DB 01H
__07599918_vcruntime_typeinfo@h DB 01H
__7A726CBB_typeinfo DB 01H
__0AAD9FA2_xutility DB 01H
__4597251A_xmemory DB 01H
__859CFEA8_memory DB 01H
__3144A386_xstring DB 01H
__07A2BBA0_stdexcept DB 01H
__78819C50_xcall_once@h DB 01H
__C7DC8E70_system_error DB 01H
__78273460_tuple DB 01H
__A7A88A06_xthreads@h DB 01H
__5ED1861E_thread DB 01H
__A01ABEDF_mutex DB 01H
__5DFCCD2F_condition_variable DB 01H
__E504FD59_semaphore@cpp DB 01H
__2F0246D9_utility DB 01H
__84E00D2B_xatomic@h DB 01H
__D81DD1CB_xstddef DB 01H
msvcjmc	ENDS
PUBLIC	_sem_destroy
PUBLIC	_sem_init
PUBLIC	_sem_post
PUBLIC	_sem_wait
PUBLIC	?_Check_C_return@std@@YAHH@Z			; std::_Check_C_return
PUBLIC	??0_Mutex_base@std@@QAE@H@Z			; std::_Mutex_base::_Mutex_base
PUBLIC	??1_Mutex_base@std@@QAE@XZ			; std::_Mutex_base::~_Mutex_base
PUBLIC	?lock@_Mutex_base@std@@QAEXXZ			; std::_Mutex_base::lock
PUBLIC	?unlock@_Mutex_base@std@@QAEXXZ			; std::_Mutex_base::unlock
PUBLIC	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
PUBLIC	??0mutex@std@@QAE@XZ				; std::mutex::mutex
PUBLIC	??1mutex@std@@QAE@XZ				; std::mutex::~mutex
PUBLIC	??0condition_variable@std@@QAE@XZ		; std::condition_variable::condition_variable
PUBLIC	??1condition_variable@std@@QAE@XZ		; std::condition_variable::~condition_variable
PUBLIC	?notify_one@condition_variable@std@@QAEXXZ	; std::condition_variable::notify_one
PUBLIC	?wait@condition_variable@std@@QAEXAAV?$unique_lock@Vmutex@std@@@2@@Z ; std::condition_variable::wait
PUBLIC	?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
PUBLIC	??0?$unique_lock@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ; std::unique_lock<std::mutex>::unique_lock<std::mutex>
PUBLIC	??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ	; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
PUBLIC	?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ ; std::unique_lock<std::mutex>::mutex
PUBLIC	??0Semaphore@@QAE@H@Z				; Semaphore::Semaphore
PUBLIC	?post@Semaphore@@QAEXXZ				; Semaphore::post
PUBLIC	?wait@Semaphore@@QAEXXZ				; Semaphore::wait
PUBLIC	??1Semaphore@@QAE@XZ				; Semaphore::~Semaphore
PUBLIC	??_GSemaphore@@QAEPAXI@Z			; Semaphore::`scalar deleting destructor'
PUBLIC	??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z ; std::addressof<std::mutex>
PUBLIC	__JustMyCode_Default
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__Mtx_init_in_situ:PROC
EXTRN	__Mtx_destroy_in_situ:PROC
EXTRN	__Mtx_lock:PROC
EXTRN	__Mtx_unlock:PROC
EXTRN	__Cnd_init_in_situ:PROC
EXTRN	__Cnd_destroy_in_situ:PROC
EXTRN	__Cnd_wait:PROC
EXTRN	__Cnd_signal:PROC
EXTRN	?_Throw_C_error@std@@YAXH@Z:PROC		; std::_Throw_C_error
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?wait@Semaphore@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?wait@Semaphore@@QAEXXZ$0
__ehfuncinfo$?wait@Semaphore@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?wait@Semaphore@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?notify_one@condition_variable@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1condition_variable@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0mutex@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Mutex_base@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Mutex_base@std@@QAE@H@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xstddef
;	COMDAT ??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z PROC ; std::addressof<std::mutex>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __D81DD1CB_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 276  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z ENDP ; std::addressof<std::mutex>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GSemaphore@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GSemaphore@@QAEPAXI@Z PROC				; Semaphore::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Semaphore@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	92					; 0000005cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSemaphore@@QAEPAXI@Z ENDP				; Semaphore::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1Semaphore@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Semaphore@@QAE@XZ PROC				; Semaphore::~Semaphore, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1mutex@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1condition_variable@std@@QAE@XZ	; std::condition_variable::~condition_variable
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Semaphore@@QAE@XZ ENDP				; Semaphore::~Semaphore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\semaphore.cpp
;	COMDAT ?wait@Semaphore@@QAEXXZ
_TEXT	SEGMENT
tv71 = -236						; size = 4
_lck$ = -36						; size = 8
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?wait@Semaphore@@QAEXXZ PROC				; Semaphore::wait, COMDAT
; _this$ = ecx

; 36   :     void wait() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?wait@Semaphore@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E504FD59_semaphore@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 37   :         std::unique_lock<std::mutex> lck(mtx_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	lea	ecx, DWORD PTR _lck$[ebp]
	call	??0?$unique_lock@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ; std::unique_lock<std::mutex>::unique_lock<std::mutex>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 38   :         if (--val_ < 0) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR tv71[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR [edx], eax
	cmp	DWORD PTR tv71[ebp], 0
	jge	SHORT $LN2@wait

; 39   :             cvar_.wait(lck);

	lea	eax, DWORD PTR _lck$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?wait@condition_variable@std@@QAEXAAV?$unique_lock@Vmutex@std@@@2@@Z ; std::condition_variable::wait
$LN2@wait:

; 40   :         }
; 41   :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lck$[ebp]
	call	??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@wait
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@wait:
	DD	1
	DD	$LN7@wait
$LN7@wait:
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN5@wait
$LN5@wait:
	DB	108					; 0000006cH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?wait@Semaphore@@QAEXXZ$0:
	lea	ecx, DWORD PTR _lck$[ebp]
	jmp	??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?wait@Semaphore@@QAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-240]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?wait@Semaphore@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?wait@Semaphore@@QAEXXZ ENDP				; Semaphore::wait
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\semaphore.cpp
;	COMDAT ?post@Semaphore@@QAEXXZ
_TEXT	SEGMENT
tv71 = -224						; size = 4
_lck$ = -24						; size = 8
_this$ = -8						; size = 4
?post@Semaphore@@QAEXXZ PROC				; Semaphore::post, COMDAT
; _this$ = ecx

; 29   :     void post() {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E504FD59_semaphore@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 30   :         std::unique_lock<std::mutex> lck(mtx_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	lea	ecx, DWORD PTR _lck$[ebp]
	call	??0?$unique_lock@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ; std::unique_lock<std::mutex>::unique_lock<std::mutex>

; 31   :         if (++val_ <= 0) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	DWORD PTR tv71[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR [edx], eax
	cmp	DWORD PTR tv71[ebp], 0
	jg	SHORT $LN2@post

; 32   :             cvar_.notify_one();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?notify_one@condition_variable@std@@QAEXXZ ; std::condition_variable::notify_one
$LN2@post:

; 33   :         }
; 34   :     }

	lea	ecx, DWORD PTR _lck$[ebp]
	call	??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ ; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@post
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@post:
	DD	1
	DD	$LN6@post
$LN6@post:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN5@post
$LN5@post:
	DB	108					; 0000006cH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?post@Semaphore@@QAEXXZ ENDP				; Semaphore::post
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\semaphore.cpp
;	COMDAT ??0Semaphore@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_value$ = 8						; size = 4
??0Semaphore@@QAE@H@Z PROC				; Semaphore::Semaphore, COMDAT
; _this$ = ecx

; 26   :         val_(value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __E504FD59_semaphore@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0condition_variable@std@@QAE@XZ	; std::condition_variable::condition_variable
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0mutex@std@@QAE@XZ			; std::mutex::mutex

; 27   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0Semaphore@@QAE@H@Z ENDP				; Semaphore::Semaphore
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ PROC	; std::unique_lock<std::mutex>::mutex, COMDAT
; _this$ = ecx

; 256  :     _NODISCARD _Mutex* mutex() const noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 257  :         return _Pmtx;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 258  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ ENDP	; std::unique_lock<std::mutex>::mutex
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ PROC		; std::unique_lock<std::mutex>::~unique_lock<std::mutex>, COMDAT
; _this$ = ecx

; 186  :     ~unique_lock() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 187  :         if (_Owns) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN3@unique_loc

; 188  :             _Pmtx->unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?unlock@_Mutex_base@std@@QAEXXZ		; std::_Mutex_base::unlock
$LN3@unique_loc:

; 189  :         }
; 190  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$unique_lock@Vmutex@std@@@std@@QAE@XZ ENDP		; std::unique_lock<std::mutex>::~unique_lock<std::mutex>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ??0?$unique_lock@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Mtx$ = 8						; size = 4
??0?$unique_lock@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z PROC ; std::unique_lock<std::mutex>::unique_lock<std::mutex>, COMDAT
; _this$ = ecx

; 135  :     explicit unique_lock(_Mutex& _Mtx) : _Pmtx(_STD addressof(_Mtx)), _Owns(false) { // construct and lock

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Mtx$[ebp]
	push	eax
	call	??$addressof@Vmutex@std@@@std@@YAPAVmutex@0@AAV10@@Z ; std::addressof<std::mutex>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 136  :         _Pmtx->lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?lock@_Mutex_base@std@@QAEXXZ		; std::_Mutex_base::lock

; 137  :         _Owns = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 138  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$unique_lock@Vmutex@std@@@std@@QAE@AAVmutex@1@@Z ENDP ; std::unique_lock<std::mutex>::unique_lock<std::mutex>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ PROC ; std::condition_variable::_Mycnd, COMDAT
; _this$ = ecx

; 697  :     _Cnd_t _Mycnd() noexcept { // get pointer to _Cnd_internal_imp_t inside _Cnd_storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 698  :         return reinterpret_cast<_Cnd_t>(&_Cnd_storage);

	mov	eax, DWORD PTR _this$[ebp]

; 699  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ ENDP ; std::condition_variable::_Mycnd
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ?wait@condition_variable@std@@QAEXAAV?$unique_lock@Vmutex@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Lck$ = 8						; size = 4
?wait@condition_variable@std@@QAEXAAV?$unique_lock@Vmutex@std@@@2@@Z PROC ; std::condition_variable::wait, COMDAT
; _this$ = ecx

; 596  :     void wait(unique_lock<mutex>& _Lck) { // wait for signal

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 597  :         // Nothing to do to comply with LWG-2135 because std::mutex lock/unlock are nothrow
; 598  :         _Check_C_return(_Cnd_wait(_Mycnd(), _Lck.mutex()->_Mymtx()));

	mov	ecx, DWORD PTR __Lck$[ebp]
	call	?mutex@?$unique_lock@Vmutex@std@@@std@@QBEPAV02@XZ ; std::unique_lock<std::mutex>::mutex
	mov	ecx, eax
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	push	eax
	call	__Cnd_wait
	add	esp, 8
	push	eax
	call	?_Check_C_return@std@@YAHH@Z		; std::_Check_C_return
	add	esp, 4

; 599  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?wait@condition_variable@std@@QAEXAAV?$unique_lock@Vmutex@std@@@2@@Z ENDP ; std::condition_variable::wait
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ?notify_one@condition_variable@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?notify_one@condition_variable@std@@QAEXXZ PROC		; std::condition_variable::notify_one, COMDAT
; _this$ = ecx

; 588  :     void notify_one() noexcept { // wake up one waiter

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?notify_one@condition_variable@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 589  :         _Check_C_return(_Cnd_signal(_Mycnd()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	push	eax
	call	__Cnd_signal
	add	esp, 4
	push	eax
	call	?_Check_C_return@std@@YAHH@Z		; std::_Check_C_return
	add	esp, 4

; 590  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?notify_one@condition_variable@std@@QAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?notify_one@condition_variable@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?notify_one@condition_variable@std@@QAEXXZ ENDP		; std::condition_variable::notify_one
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ??1condition_variable@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1condition_variable@std@@QAE@XZ PROC			; std::condition_variable::~condition_variable, COMDAT
; _this$ = ecx

; 581  :     ~condition_variable() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1condition_variable@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 582  :         _Cnd_destroy_in_situ(_Mycnd());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	push	eax
	call	__Cnd_destroy_in_situ
	add	esp, 4

; 583  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1condition_variable@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1condition_variable@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1condition_variable@std@@QAE@XZ ENDP			; std::condition_variable::~condition_variable
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ??0condition_variable@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0condition_variable@std@@QAE@XZ PROC			; std::condition_variable::condition_variable, COMDAT
; _this$ = ecx

; 577  :     condition_variable() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 578  :         _Cnd_init_in_situ(_Mycnd());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mycnd@condition_variable@std@@AAEPAU_Cnd_internal_imp_t@@XZ ; std::condition_variable::_Mycnd
	push	eax
	call	__Cnd_init_in_situ
	add	esp, 4

; 579  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0condition_variable@std@@QAE@XZ ENDP			; std::condition_variable::condition_variable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1mutex@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1mutex@std@@QAE@XZ PROC				; std::mutex::~mutex, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Mutex_base@std@@QAE@XZ		; std::_Mutex_base::~_Mutex_base
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1mutex@std@@QAE@XZ ENDP				; std::mutex::~mutex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ??0mutex@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0mutex@std@@QAE@XZ PROC				; std::mutex::mutex, COMDAT
; _this$ = ecx

; 89   :     /* constexpr */ mutex() noexcept // TRANSITION, ABI

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0mutex@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 90   :         : _Mutex_base() {}

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Mutex_base@std@@QAE@H@Z		; std::_Mutex_base::_Mutex_base
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0mutex@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0mutex@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0mutex@std@@QAE@XZ ENDP				; std::mutex::mutex
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ PROC ; std::_Mutex_base::_Mymtx, COMDAT
; _this$ = ecx

; 82   :     _Mtx_t _Mymtx() noexcept { // get pointer to _Mtx_internal_imp_t inside _Mtx_storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 83   :         return reinterpret_cast<_Mtx_t>(&_Mtx_storage);

	mov	eax, DWORD PTR _this$[ebp]

; 84   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ENDP ; std::_Mutex_base::_Mymtx
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ?unlock@_Mutex_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?unlock@_Mutex_base@std@@QAEXXZ PROC			; std::_Mutex_base::unlock, COMDAT
; _this$ = ecx

; 66   :     void unlock() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	call	__Mtx_unlock
	add	esp, 4
	push	eax
	call	?_Check_C_return@std@@YAHH@Z		; std::_Check_C_return
	add	esp, 4

; 68   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?unlock@_Mutex_base@std@@QAEXXZ ENDP			; std::_Mutex_base::unlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ?lock@_Mutex_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?lock@_Mutex_base@std@@QAEXXZ PROC			; std::_Mutex_base::lock, COMDAT
; _this$ = ecx

; 50   :     void lock() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	call	__Mtx_lock
	add	esp, 4
	push	eax
	call	?_Check_C_return@std@@YAHH@Z		; std::_Check_C_return
	add	esp, 4

; 52   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?lock@_Mutex_base@std@@QAEXXZ ENDP			; std::_Mutex_base::lock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ??1_Mutex_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Mutex_base@std@@QAE@XZ PROC				; std::_Mutex_base::~_Mutex_base, COMDAT
; _this$ = ecx

; 43   :     ~_Mutex_base() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Mutex_base@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 44   :         _Mtx_destroy_in_situ(_Mymtx());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	call	__Mtx_destroy_in_situ
	add	esp, 4

; 45   :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Mutex_base@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Mutex_base@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Mutex_base@std@@QAE@XZ ENDP				; std::_Mutex_base::~_Mutex_base
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
;	COMDAT ??0_Mutex_base@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Flags$ = 8						; size = 4
??0_Mutex_base@std@@QAE@H@Z PROC			; std::_Mutex_base::_Mutex_base, COMDAT
; _this$ = ecx

; 39   :     _Mutex_base(int _Flags = 0) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Mutex_base@std@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __A01ABEDF_mutex
	call	@__CheckForDebuggerJustMyCode@4

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	mov	eax, DWORD PTR __Flags$[ebp]
	or	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mymtx@_Mutex_base@std@@AAEPAU_Mtx_internal_imp_t@@XZ ; std::_Mutex_base::_Mymtx
	push	eax
	call	__Mtx_init_in_situ
	add	esp, 8

; 41   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0_Mutex_base@std@@QAE@H@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Mutex_base@std@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Mutex_base@std@@QAE@H@Z ENDP			; std::_Mutex_base::_Mutex_base
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
;	COMDAT ?_Check_C_return@std@@YAHH@Z
_TEXT	SEGMENT
__Res$ = 8						; size = 4
?_Check_C_return@std@@YAHH@Z PROC			; std::_Check_C_return, COMDAT

; 129  : inline int _Check_C_return(int _Res) { // throw exception on failure

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A7A88A06_xthreads@h
	call	@__CheckForDebuggerJustMyCode@4

; 130  :     if (_Res != _Thrd_success) {

	cmp	DWORD PTR __Res$[ebp], 0
	je	SHORT $LN2@Check_C_re

; 131  :         _Throw_C_error(_Res);

	mov	eax, DWORD PTR __Res$[ebp]
	push	eax
	call	?_Throw_C_error@std@@YAXH@Z		; std::_Throw_C_error
$LN2@Check_C_re:

; 132  :     }
; 133  : 
; 134  :     return _Res;

	mov	eax, DWORD PTR __Res$[ebp]
$LN3@Check_C_re:

; 135  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Check_C_return@std@@YAHH@Z ENDP			; std::_Check_C_return
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\semaphore.cpp
;	COMDAT _sem_wait
_TEXT	SEGMENT
_sem$ = 8						; size = 4
_sem_wait PROC						; COMDAT

; 69   : int sem_wait(sem_t* sem) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E504FD59_semaphore@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 70   :     static_cast<Semaphore*>(*sem)->wait();

	mov	eax, DWORD PTR _sem$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?wait@Semaphore@@QAEXXZ			; Semaphore::wait

; 71   :     return 0;

	xor	eax, eax

; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sem_wait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\semaphore.cpp
;	COMDAT _sem_post
_TEXT	SEGMENT
_sem$ = 8						; size = 4
_sem_post PROC						; COMDAT

; 64   : int sem_post(sem_t* sem) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E504FD59_semaphore@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 65   :     static_cast<Semaphore*>(*sem)->post();

	mov	eax, DWORD PTR _sem$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?post@Semaphore@@QAEXXZ			; Semaphore::post

; 66   :     return 0;

	xor	eax, eax

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sem_post ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\semaphore.cpp
;	COMDAT _sem_init
_TEXT	SEGMENT
tv76 = -220						; size = 4
$T1 = -212						; size = 4
$T2 = -200						; size = 4
_sem$ = 8						; size = 4
___formal$ = 12						; size = 4
_value$ = 16						; size = 4
_sem_init PROC						; COMDAT

; 59   : int sem_init(sem_t* sem, int, unsigned int value) {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E504FD59_semaphore@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 60   :     *sem = new Semaphore(value);

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@sem_init
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0Semaphore@@QAE@H@Z			; Semaphore::Semaphore
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@sem_init
$LN3@sem_init:
	mov	DWORD PTR tv76[ebp], 0
$LN4@sem_init:
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR _sem$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx], eax

; 61   :     return 0;

	xor	eax, eax

; 62   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sem_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\semaphore.cpp
;	COMDAT _sem_destroy
_TEXT	SEGMENT
tv68 = -208						; size = 4
$T1 = -200						; size = 4
_sem$ = 8						; size = 4
_sem_destroy PROC					; COMDAT

; 53   : int sem_destroy(sem_t* sem) {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E504FD59_semaphore@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 54   :     delete static_cast<Semaphore*>(*sem);

	mov	eax, DWORD PTR _sem$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@sem_destro
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GSemaphore@@QAEPAXI@Z
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@sem_destro
$LN3@sem_destro:
	mov	DWORD PTR tv68[ebp], 0
$LN4@sem_destro:

; 55   :     *sem = nullptr;

	mov	eax, DWORD PTR _sem$[ebp]
	mov	DWORD PTR [eax], 0

; 56   :     return 0;

	xor	eax, eax

; 57   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sem_destroy ENDP
_TEXT	ENDS
END
