; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_01HIHLOKLC@1@				; `string'
PUBLIC	??_C@_01GBGANLPD@0@				; `string'
PUBLIC	??_C@_05BKICJGFO@hexbs@				; `string'
PUBLIC	??_C@_02IGJGHHBN@tz@				; `string'
PUBLIC	??_C@_04PLMLMMEO@full@				; `string'
PUBLIC	??_C@_05IGAABLKA@full8@				; `string'
PUBLIC	??_C@_06FAJNAJAJ@full16@			; `string'
PUBLIC	??_C@_06DHHFBIGD@full32@			; `string'
PUBLIC	??_C@_06GHOEHNAO@full64@			; `string'
PUBLIC	??_C@_03FBBPOKPO@dia@				; `string'
PUBLIC	??_C@_0M@BECHMDJA@progressive@			; `string'
PUBLIC	??_C@_03EFBLGMJL@tff@				; `string'
PUBLIC	??_C@_03DAGJGENI@bff@				; `string'
PUBLIC	??_C@_05PKCPKOLM@undef@				; `string'
PUBLIC	??_C@_04FKMICODN@show@				; `string'
PUBLIC	??_C@_04EKMNJIID@crop@				; `string'
PUBLIC	??_C@_09NILLCKIE@component@			; `string'
PUBLIC	??_C@_03DFNJAFMD@pal@				; `string'
PUBLIC	??_C@_04ODOFBIGI@ntsc@				; `string'
PUBLIC	??_C@_05CCIMDFBO@secam@				; `string'
PUBLIC	??_C@_03BADCJGEO@mac@				; `string'
PUBLIC	??_C@_02CKCDDIBB@tv@				; `string'
PUBLIC	??_C@_02BKJPHGNJ@pc@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_05EAEABODA@bt709@				; `string'
PUBLIC	??_C@_06CDGMBMLO@bt470m@			; `string'
PUBLIC	??_C@_07NBKEIMK@bt470bg@			; `string'
PUBLIC	??_C@_09EFOMJFPE@smpte170m@			; `string'
PUBLIC	??_C@_09BAPJEAMK@smpte240m@			; `string'
PUBLIC	??_C@_04PIBPBFCI@film@				; `string'
PUBLIC	??_C@_06DNGKCGNA@bt2020@			; `string'
PUBLIC	??_C@_06HPJICMPM@linear@			; `string'
PUBLIC	??_C@_06EPIPFMGF@log100@			; `string'
PUBLIC	??_C@_06LCBOFJFP@log316@			; `string'
PUBLIC	??_C@_0N@DHFDGFFB@iec61966?92?94@		; `string'
PUBLIC	??_C@_07NBPANCAO@bt1361e@			; `string'
PUBLIC	??_C@_0N@EKCEJBBE@iec61966?92?91@		; `string'
PUBLIC	??_C@_09ELIHPANI@bt2020?910@			; `string'
PUBLIC	??_C@_09HJLBJCFK@bt2020?912@			; `string'
PUBLIC	??_C@_03CDOLCGBP@GBR@				; `string'
PUBLIC	??_C@_03MELHMFCB@fcc@				; `string'
PUBLIC	??_C@_05EMKHKOLB@YCgCo@				; `string'
PUBLIC	??_C@_08FPKMKDMG@bt2020nc@			; `string'
PUBLIC	??_C@_07MIDOIAJG@bt2020c@			; `string'
PUBLIC	??_C@_04CGFJFPFD@none@				; `string'
PUBLIC	??_C@_05MIJNFGED@frame@				; `string'
PUBLIC	??_C@_04CKOGFLMC@tile@				; `string'
PUBLIC	??_C@_09KDPLEICE@frametile@			; `string'
PUBLIC	??_C@_0BA@MOLFBNHO@frametilemargin@		; `string'
PUBLIC	??_C@_08DNPJAFPH@checksum@			; `string'
PUBLIC	??_C@_03PKBIKOHH@md5@				; `string'
PUBLIC	??_C@_04DDFHDMOL@zero@				; `string'
PUBLIC	??_C@_03MCADLMAF@off@				; `string'
PUBLIC	??_C@_02LIELOMNJ@on@				; `string'
PUBLIC	??_C@_03EDJJDBOK@mvs@				; `string'
PUBLIC	??_C@_08PCEGOFBN@mv_signs@			; `string'
PUBLIC	??_C@_0N@BNMAPFPH@trans_coeffs@			; `string'
PUBLIC	??_C@_0BC@NEEMKKJK@trans_coeff_signs@		; `string'
PUBLIC	??_C@_0BB@ONDPODCM@intra_pred_modes@		; `string'
PUBLIC	??_C@_09CCGPDONC@sensitive@			; `string'
PUBLIC	??_C@_04IJFJNCMM@edge@				; `string'
PUBLIC	??_C@_04BKGNPECA@band@				; `string'
PUBLIC	??_C@_06EKNFNOKI@custom@			; `string'
PUBLIC	??_C@_07DLHCIBDH@default@			; `string'
PUBLIC	??_C@_05CMFMCDFD@no?9rc@			; `string'
PUBLIC	??_C@_06COJIGPIB@lambda@			; `string'
PUBLIC	??_C@_03IKELICBO@oba@				; `string'
PUBLIC	??_C@_04HAPDLBFF@auto@				; `string'
PUBLIC	??_C@_03DLLNJHFD@y4m@				; `string'
PUBLIC	??_C@_03ODNDLLDO@yuv@				; `string'
PUBLIC	??_C@_09KOALFBAC@ultrafast@			; `string'
PUBLIC	??_C@_02FGFKDEHA@rd@				; `string'
PUBLIC	??_C@_0P@IOGMAPKE@pu?9depth?9intra@		; `string'
PUBLIC	??_C@_03EAGHKAEK@2?93@				; `string'
PUBLIC	??_C@_0P@PGOKPLMD@pu?9depth?9inter@		; `string'
PUBLIC	??_C@_03ELMJDOOF@1?92@				; `string'
PUBLIC	??_C@_02FIDLOBHM@me@				; `string'
PUBLIC	??_C@_03BEPOBKLC@gop@				; `string'
PUBLIC	??_C@_01KJLJFBPL@8@				; `string'
PUBLIC	??_C@_03GCDGINBO@ref@				; `string'
PUBLIC	??_C@_06CGCIAMGP@bipred@			; `string'
PUBLIC	??_C@_07KBNBPJMI@deblock@			; `string'
PUBLIC	??_C@_03NICKIOPH@0?30@				; `string'
PUBLIC	??_C@_08NLKLMLIL@signhide@			; `string'
PUBLIC	??_C@_05DLBDLGJF@subme@				; `string'
PUBLIC	??_C@_03MEBPJOO@sao@				; `string'
PUBLIC	??_C@_04HLCEBPLD@rdoq@				; `string'
PUBLIC	??_C@_09CNMMAOKA@rdoq?9skip@			; `string'
PUBLIC	??_C@_0P@KCEICG@transform?9skip@		; `string'
PUBLIC	??_C@_06FFHEEO@mv?9rdo@				; `string'
PUBLIC	??_C@_0BC@NIDONDCE@full?9intra?9search@		; `string'
PUBLIC	??_C@_03MIABAOBE@smp@				; `string'
PUBLIC	??_C@_03DCBBJBAA@amp@				; `string'
PUBLIC	??_C@_0BF@MFJMPGDP@cu?9split?9termination@	; `string'
PUBLIC	??_C@_0BF@EGFOFOM@me?9early?9termination@	; `string'
PUBLIC	??_C@_0N@IJEFOOGB@intra?9rdo?9et@		; `string'
PUBLIC	??_C@_0L@CKGBKFNE@early?9skip@			; `string'
PUBLIC	??_C@_0BD@NKHCCIBG@fast?9residual?9cost@	; `string'
PUBLIC	??_C@_02DAMOKLOI@28@				; `string'
PUBLIC	??_C@_09NDDHJBDO@max?9merge@			; `string'
PUBLIC	??_C@_01BMBHCPLG@5@				; `string'
PUBLIC	??_C@_09HAJOA@superfast@			; `string'
PUBLIC	??_C@_01FDFGLJHB@2@				; `string'
PUBLIC	??_C@_08NNJCBKKK@veryfast@			; `string'
PUBLIC	??_C@_03FCNCAPKE@1?93@				; `string'
PUBLIC	??_C@_06EAGHDKMK@faster@			; `string'
PUBLIC	??_C@_01FAMBOPH@4@				; `string'
PUBLIC	??_C@_04LBNBHAJC@fast@				; `string'
PUBLIC	??_C@_06HIDOEFBI@medium@			; `string'
PUBLIC	??_C@_03BNJDJJGD@1?94@				; `string'
PUBLIC	??_C@_03OKGOGIMB@0?93@				; `string'
PUBLIC	??_C@_02KMALDIDP@16@				; `string'
PUBLIC	??_C@_04NFKKLJGK@slow@				; `string'
PUBLIC	??_C@_06HOLKEPBA@slower@			; `string'
PUBLIC	??_C@_08LJOJNDFC@veryslow@			; `string'
PUBLIC	??_C@_07MCGPCJOC@placebo@			; `string'
PUBLIC	??_C@_04IFKKHLLM@P400@				; `string'
PUBLIC	??_C@_04IGCOKPNC@P420@				; `string'
msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__80A96665_cfg@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_04IGCOKPNC@P420@
CONST	SEGMENT
??_C@_04IGCOKPNC@P420@ DB 'P420', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IFKKHLLM@P400@
CONST	SEGMENT
??_C@_04IFKKHLLM@P400@ DB 'P400', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MCGPCJOC@placebo@
CONST	SEGMENT
??_C@_07MCGPCJOC@placebo@ DB 'placebo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LJOJNDFC@veryslow@
CONST	SEGMENT
??_C@_08LJOJNDFC@veryslow@ DB 'veryslow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOLKEPBA@slower@
CONST	SEGMENT
??_C@_06HOLKEPBA@slower@ DB 'slower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NFKKLJGK@slow@
CONST	SEGMENT
??_C@_04NFKKLJGK@slow@ DB 'slow', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16@
CONST	SEGMENT
??_C@_02KMALDIDP@16@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OKGOGIMB@0?93@
CONST	SEGMENT
??_C@_03OKGOGIMB@0?93@ DB '0-3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BNJDJJGD@1?94@
CONST	SEGMENT
??_C@_03BNJDJJGD@1?94@ DB '1-4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HIDOEFBI@medium@
CONST	SEGMENT
??_C@_06HIDOEFBI@medium@ DB 'medium', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBNBHAJC@fast@
CONST	SEGMENT
??_C@_04LBNBHAJC@fast@ DB 'fast', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4@
CONST	SEGMENT
??_C@_01FAMBOPH@4@ DB '4', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06EAGHDKMK@faster@
CONST	SEGMENT
??_C@_06EAGHDKMK@faster@ DB 'faster', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FCNCAPKE@1?93@
CONST	SEGMENT
??_C@_03FCNCAPKE@1?93@ DB '1-3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NNJCBKKK@veryfast@
CONST	SEGMENT
??_C@_08NNJCBKKK@veryfast@ DB 'veryfast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2@
CONST	SEGMENT
??_C@_01FDFGLJHB@2@ DB '2', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09HAJOA@superfast@
CONST	SEGMENT
??_C@_09HAJOA@superfast@ DB 'superfast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5@
CONST	SEGMENT
??_C@_01BMBHCPLG@5@ DB '5', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09NDDHJBDO@max?9merge@
CONST	SEGMENT
??_C@_09NDDHJBDO@max?9merge@ DB 'max-merge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAMOKLOI@28@
CONST	SEGMENT
??_C@_02DAMOKLOI@28@ DB '28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
CONST	SEGMENT
??_C@_0BD@NKHCCIBG@fast?9residual?9cost@ DB 'fast-residual-cost', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CKGBKFNE@early?9skip@
CONST	SEGMENT
??_C@_0L@CKGBKFNE@early?9skip@ DB 'early-skip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IJEFOOGB@intra?9rdo?9et@
CONST	SEGMENT
??_C@_0N@IJEFOOGB@intra?9rdo?9et@ DB 'intra-rdo-et', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EGFOFOM@me?9early?9termination@
CONST	SEGMENT
??_C@_0BF@EGFOFOM@me?9early?9termination@ DB 'me-early-termination', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MFJMPGDP@cu?9split?9termination@
CONST	SEGMENT
??_C@_0BF@MFJMPGDP@cu?9split?9termination@ DB 'cu-split-termination', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCBBJBAA@amp@
CONST	SEGMENT
??_C@_03DCBBJBAA@amp@ DB 'amp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MIABAOBE@smp@
CONST	SEGMENT
??_C@_03MIABAOBE@smp@ DB 'smp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NIDONDCE@full?9intra?9search@
CONST	SEGMENT
??_C@_0BC@NIDONDCE@full?9intra?9search@ DB 'full-intra-search', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFHEEO@mv?9rdo@
CONST	SEGMENT
??_C@_06FFHEEO@mv?9rdo@ DB 'mv-rdo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCEICG@transform?9skip@
CONST	SEGMENT
??_C@_0P@KCEICG@transform?9skip@ DB 'transform-skip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNMMAOKA@rdoq?9skip@
CONST	SEGMENT
??_C@_09CNMMAOKA@rdoq?9skip@ DB 'rdoq-skip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HLCEBPLD@rdoq@
CONST	SEGMENT
??_C@_04HLCEBPLD@rdoq@ DB 'rdoq', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MEBPJOO@sao@
CONST	SEGMENT
??_C@_03MEBPJOO@sao@ DB 'sao', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DLBDLGJF@subme@
CONST	SEGMENT
??_C@_05DLBDLGJF@subme@ DB 'subme', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLKLMLIL@signhide@
CONST	SEGMENT
??_C@_08NLKLMLIL@signhide@ DB 'signhide', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NICKIOPH@0?30@
CONST	SEGMENT
??_C@_03NICKIOPH@0?30@ DB '0:0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KBNBPJMI@deblock@
CONST	SEGMENT
??_C@_07KBNBPJMI@deblock@ DB 'deblock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGCIAMGP@bipred@
CONST	SEGMENT
??_C@_06CGCIAMGP@bipred@ DB 'bipred', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDGINBO@ref@
CONST	SEGMENT
??_C@_03GCDGINBO@ref@ DB 'ref', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8@
CONST	SEGMENT
??_C@_01KJLJFBPL@8@ DB '8', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03BEPOBKLC@gop@
CONST	SEGMENT
??_C@_03BEPOBKLC@gop@ DB 'gop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FIDLOBHM@me@
CONST	SEGMENT
??_C@_02FIDLOBHM@me@ DB 'me', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMJDOOF@1?92@
CONST	SEGMENT
??_C@_03ELMJDOOF@1?92@ DB '1-2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PGOKPLMD@pu?9depth?9inter@
CONST	SEGMENT
??_C@_0P@PGOKPLMD@pu?9depth?9inter@ DB 'pu-depth-inter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03EAGHKAEK@2?93@
CONST	SEGMENT
??_C@_03EAGHKAEK@2?93@ DB '2-3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOGMAPKE@pu?9depth?9intra@
CONST	SEGMENT
??_C@_0P@IOGMAPKE@pu?9depth?9intra@ DB 'pu-depth-intra', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGFKDEHA@rd@
CONST	SEGMENT
??_C@_02FGFKDEHA@rd@ DB 'rd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KOALFBAC@ultrafast@
CONST	SEGMENT
??_C@_09KOALFBAC@ultrafast@ DB 'ultrafast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ODNDLLDO@yuv@
CONST	SEGMENT
??_C@_03ODNDLLDO@yuv@ DB 'yuv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLLNJHFD@y4m@
CONST	SEGMENT
??_C@_03DLLNJHFD@y4m@ DB 'y4m', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HAPDLBFF@auto@
CONST	SEGMENT
??_C@_04HAPDLBFF@auto@ DB 'auto', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKELICBO@oba@
CONST	SEGMENT
??_C@_03IKELICBO@oba@ DB 'oba', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06COJIGPIB@lambda@
CONST	SEGMENT
??_C@_06COJIGPIB@lambda@ DB 'lambda', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMFMCDFD@no?9rc@
CONST	SEGMENT
??_C@_05CMFMCDFD@no?9rc@ DB 'no-rc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default@
CONST	SEGMENT
??_C@_07DLHCIBDH@default@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EKNFNOKI@custom@
CONST	SEGMENT
??_C@_06EKNFNOKI@custom@ DB 'custom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKGNPECA@band@
CONST	SEGMENT
??_C@_04BKGNPECA@band@ DB 'band', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJFJNCMM@edge@
CONST	SEGMENT
??_C@_04IJFJNCMM@edge@ DB 'edge', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CCGPDONC@sensitive@
CONST	SEGMENT
??_C@_09CCGPDONC@sensitive@ DB 'sensitive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ONDPODCM@intra_pred_modes@
CONST	SEGMENT
??_C@_0BB@ONDPODCM@intra_pred_modes@ DB 'intra_pred_modes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NEEMKKJK@trans_coeff_signs@
CONST	SEGMENT
??_C@_0BC@NEEMKKJK@trans_coeff_signs@ DB 'trans_coeff_signs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNMAPFPH@trans_coeffs@
CONST	SEGMENT
??_C@_0N@BNMAPFPH@trans_coeffs@ DB 'trans_coeffs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PCEGOFBN@mv_signs@
CONST	SEGMENT
??_C@_08PCEGOFBN@mv_signs@ DB 'mv_signs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EDJJDBOK@mvs@
CONST	SEGMENT
??_C@_03EDJJDBOK@mvs@ DB 'mvs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LIELOMNJ@on@
CONST	SEGMENT
??_C@_02LIELOMNJ@on@ DB 'on', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCADLMAF@off@
CONST	SEGMENT
??_C@_03MCADLMAF@off@ DB 'off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DDFHDMOL@zero@
CONST	SEGMENT
??_C@_04DDFHDMOL@zero@ DB 'zero', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKBIKOHH@md5@
CONST	SEGMENT
??_C@_03PKBIKOHH@md5@ DB 'md5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNPJAFPH@checksum@
CONST	SEGMENT
??_C@_08DNPJAFPH@checksum@ DB 'checksum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MOLFBNHO@frametilemargin@
CONST	SEGMENT
??_C@_0BA@MOLFBNHO@frametilemargin@ DB 'frametilemargin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDPLEICE@frametile@
CONST	SEGMENT
??_C@_09KDPLEICE@frametile@ DB 'frametile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKOGFLMC@tile@
CONST	SEGMENT
??_C@_04CKOGFLMC@tile@ DB 'tile', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIJNFGED@frame@
CONST	SEGMENT
??_C@_05MIJNFGED@frame@ DB 'frame', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGFJFPFD@none@
CONST	SEGMENT
??_C@_04CGFJFPFD@none@ DB 'none', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIDOIAJG@bt2020c@
CONST	SEGMENT
??_C@_07MIDOIAJG@bt2020c@ DB 'bt2020c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FPKMKDMG@bt2020nc@
CONST	SEGMENT
??_C@_08FPKMKDMG@bt2020nc@ DB 'bt2020nc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EMKHKOLB@YCgCo@
CONST	SEGMENT
??_C@_05EMKHKOLB@YCgCo@ DB 'YCgCo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MELHMFCB@fcc@
CONST	SEGMENT
??_C@_03MELHMFCB@fcc@ DB 'fcc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CDOLCGBP@GBR@
CONST	SEGMENT
??_C@_03CDOLCGBP@GBR@ DB 'GBR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJLBJCFK@bt2020?912@
CONST	SEGMENT
??_C@_09HJLBJCFK@bt2020?912@ DB 'bt2020-12', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELIHPANI@bt2020?910@
CONST	SEGMENT
??_C@_09ELIHPANI@bt2020?910@ DB 'bt2020-10', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKCEJBBE@iec61966?92?91@
CONST	SEGMENT
??_C@_0N@EKCEJBBE@iec61966?92?91@ DB 'iec61966-2-1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBPANCAO@bt1361e@
CONST	SEGMENT
??_C@_07NBPANCAO@bt1361e@ DB 'bt1361e', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DHFDGFFB@iec61966?92?94@
CONST	SEGMENT
??_C@_0N@DHFDGFFB@iec61966?92?94@ DB 'iec61966-2-4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LCBOFJFP@log316@
CONST	SEGMENT
??_C@_06LCBOFJFP@log316@ DB 'log316', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EPIPFMGF@log100@
CONST	SEGMENT
??_C@_06EPIPFMGF@log100@ DB 'log100', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HPJICMPM@linear@
CONST	SEGMENT
??_C@_06HPJICMPM@linear@ DB 'linear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNGKCGNA@bt2020@
CONST	SEGMENT
??_C@_06DNGKCGNA@bt2020@ DB 'bt2020', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PIBPBFCI@film@
CONST	SEGMENT
??_C@_04PIBPBFCI@film@ DB 'film', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BAPJEAMK@smpte240m@
CONST	SEGMENT
??_C@_09BAPJEAMK@smpte240m@ DB 'smpte240m', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFOMJFPE@smpte170m@
CONST	SEGMENT
??_C@_09EFOMJFPE@smpte170m@ DB 'smpte170m', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBKEIMK@bt470bg@
CONST	SEGMENT
??_C@_07NBKEIMK@bt470bg@ DB 'bt470bg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CDGMBMLO@bt470m@
CONST	SEGMENT
??_C@_06CDGMBMLO@bt470m@ DB 'bt470m', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EAEABODA@bt709@
CONST	SEGMENT
??_C@_05EAEABODA@bt709@ DB 'bt709', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02BKJPHGNJ@pc@
CONST	SEGMENT
??_C@_02BKJPHGNJ@pc@ DB 'pc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CKCDDIBB@tv@
CONST	SEGMENT
??_C@_02CKCDDIBB@tv@ DB 'tv', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BADCJGEO@mac@
CONST	SEGMENT
??_C@_03BADCJGEO@mac@ DB 'mac', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCIMDFBO@secam@
CONST	SEGMENT
??_C@_05CCIMDFBO@secam@ DB 'secam', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODOFBIGI@ntsc@
CONST	SEGMENT
??_C@_04ODOFBIGI@ntsc@ DB 'ntsc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DFNJAFMD@pal@
CONST	SEGMENT
??_C@_03DFNJAFMD@pal@ DB 'pal', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NILLCKIE@component@
CONST	SEGMENT
??_C@_09NILLCKIE@component@ DB 'component', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKMNJIID@crop@
CONST	SEGMENT
??_C@_04EKMNJIID@crop@ DB 'crop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FKMICODN@show@
CONST	SEGMENT
??_C@_04FKMICODN@show@ DB 'show', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKCPKOLM@undef@
CONST	SEGMENT
??_C@_05PKCPKOLM@undef@ DB 'undef', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAGJGENI@bff@
CONST	SEGMENT
??_C@_03DAGJGENI@bff@ DB 'bff', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03EFBLGMJL@tff@
CONST	SEGMENT
??_C@_03EFBLGMJL@tff@ DB 'tff', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BECHMDJA@progressive@
CONST	SEGMENT
??_C@_0M@BECHMDJA@progressive@ DB 'progressive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FBBPOKPO@dia@
CONST	SEGMENT
??_C@_03FBBPOKPO@dia@ DB 'dia', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06GHOEHNAO@full64@
CONST	SEGMENT
??_C@_06GHOEHNAO@full64@ DB 'full64', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DHHFBIGD@full32@
CONST	SEGMENT
??_C@_06DHHFBIGD@full32@ DB 'full32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FAJNAJAJ@full16@
CONST	SEGMENT
??_C@_06FAJNAJAJ@full16@ DB 'full16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGAABLKA@full8@
CONST	SEGMENT
??_C@_05IGAABLKA@full8@ DB 'full8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLMLMMEO@full@
CONST	SEGMENT
??_C@_04PLMLMMEO@full@ DB 'full', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IGJGHHBN@tz@
CONST	SEGMENT
??_C@_02IGJGHHBN@tz@ DB 'tz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BKICJGFO@hexbs@
CONST	SEGMENT
??_C@_05BKICJGFO@hexbs@ DB 'hexbs', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0@
CONST	SEGMENT
??_C@_01GBGANLPD@0@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1@
CONST	SEGMENT
??_C@_01HIHLOKLC@1@ DB '1', 00H				; `string'
CONST	ENDS
CONST	SEGMENT
_kvz_gop_lowdelay4 DQ 03ff0000000000000r	; 1
	DB	05H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	04H
	DB	01H
	DB	05H
	DB	09H
	DB	0dH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	02H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	02H
	DB	06H
	DB	0aH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	03H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	DB	0bH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	01H
	DB	04H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	04H
	DB	08H
	DB	0cH
	ORG $+2
	ORG $+12
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
_kvz_gop_ra8 DQ	03ff0000000000000r		; 1
	DB	00H
	DB	08H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	08H
	DB	0cH
	DB	010H
	ORG $+2
	ORG $+13
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DB	03H
	DB	04H
	DB	02H
	DB	01H
	DB	01H
	DB	04H
	ORG $+15
	DB	02H
	DB	04H
	DB	08H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	02H
	DB	03H
	DB	01H
	DB	02H
	DB	02H
	DB	06H
	ORG $+14
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	01H
	DB	04H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+13
	DB	01H
	DB	01H
	ORG $+2
	ORG $+15
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	03H
	DB	04H
	DB	00H
	DB	02H
	DB	01H
	DB	05H
	ORG $+14
	DB	02H
	DB	01H
	DB	03H
	ORG $+2
	ORG $+14
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	06H
	DB	03H
	DB	01H
	DB	01H
	DB	02H
	ORG $+15
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	05H
	DB	04H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	ORG $+14
	DB	02H
	DB	01H
	DB	05H
	ORG $+2
	ORG $+14
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	07H
	DB	04H
	DB	00H
	DB	01H
	DB	01H
	ORG $+15
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+2
	ORG $+13
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
_kvz_gop_ra16 DQ 03ff0000000000000r		; 1
	DB	01H
	DB	010H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	010H
	DB	018H
	DB	020H
	ORG $+2
	ORG $+13
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DB	01H
	DB	08H
	DB	02H
	DB	01H
	DB	01H
	DB	08H
	ORG $+15
	DB	02H
	DB	08H
	DB	010H
	ORG $+2
	ORG $+14
	DQ	0c0138a0902de00d2r		; -4.8848
	DQ	03fca617c1bda511ar		; 0.2061
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	04H
	DB	03H
	DB	01H
	DB	02H
	DB	04H
	DB	0cH
	ORG $+14
	DB	02H
	DB	04H
	DB	0cH
	ORG $+2
	ORG $+14
	DQ	0c016fd8adab9f55ar		; -5.7476
	DQ	03fcd42c3c9eecbfbr		; 0.2286
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	02H
	DB	04H
	DB	01H
	DB	03H
	DB	02H
	DB	06H
	DB	0eH
	ORG $+13
	DB	02H
	DB	02H
	DB	0aH
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	01H
	DB	05H
	DB	00H
	DB	04H
	DB	01H
	DB	03H
	DB	07H
	DB	0fH
	ORG $+12
	DB	01H
	DB	01H
	ORG $+2
	ORG $+15
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	03H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	05H
	DB	0dH
	ORG $+13
	DB	02H
	DB	01H
	DB	03H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	06H
	DB	04H
	DB	01H
	DB	02H
	DB	02H
	DB	0aH
	ORG $+14
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	05H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	0bH
	ORG $+13
	DB	02H
	DB	01H
	DB	05H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	07H
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	09H
	ORG $+14
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	0cH
	DB	03H
	DB	01H
	DB	01H
	DB	04H
	ORG $+15
	DB	02H
	DB	04H
	DB	0cH
	ORG $+2
	ORG $+14
	DQ	0c016fd8adab9f55ar		; -5.7476
	DQ	03fcd42c3c9eecbfbr		; 0.2286
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	0aH
	DB	04H
	DB	01H
	DB	02H
	DB	02H
	DB	06H
	ORG $+14
	DB	02H
	DB	02H
	DB	0aH
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	09H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+13
	DB	02H
	DB	01H
	DB	09H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0bH
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	05H
	ORG $+14
	DB	03H
	DB	01H
	DB	03H
	DB	0bH
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	0eH
	DB	04H
	DB	01H
	DB	01H
	DB	02H
	ORG $+15
	DB	03H
	DB	02H
	DB	06H
	DB	0eH
	ORG $+2
	ORG $+13
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0dH
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	ORG $+14
	DB	03H
	DB	01H
	DB	05H
	DB	0dH
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0fH
	DB	05H
	DB	00H
	DB	01H
	DB	01H
	ORG $+15
	DB	04H
	DB	01H
	DB	03H
	DB	07H
	DB	0fH
	ORG $+2
	ORG $+12
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
?me_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_05BKICJGFO@hexbs@ ; `kvz_config_parse'::`2'::me_names
	DD	FLAT:??_C@_02IGJGHHBN@tz@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_05IGAABLKA@full8@
	DD	FLAT:??_C@_06FAJNAJAJ@full16@
	DD	FLAT:??_C@_06DHHFBIGD@full32@
	DD	FLAT:??_C@_06GHOEHNAO@full64@
	DD	FLAT:??_C@_03FBBPOKPO@dia@
	DD	00H
?source_scan_type_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_0M@BECHMDJA@progressive@ ; `kvz_config_parse'::`2'::source_scan_type_names
	DD	FLAT:??_C@_03EFBLGMJL@tff@
	DD	FLAT:??_C@_03DAGJGENI@bff@
	DD	00H
?overscan_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_05PKCPKOLM@undef@ ; `kvz_config_parse'::`2'::overscan_names
	DD	FLAT:??_C@_04FKMICODN@show@
	DD	FLAT:??_C@_04EKMNJIID@crop@
	DD	00H
?videoformat_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_09NILLCKIE@component@ ; `kvz_config_parse'::`2'::videoformat_names
	DD	FLAT:??_C@_03DFNJAFMD@pal@
	DD	FLAT:??_C@_04ODOFBIGI@ntsc@
	DD	FLAT:??_C@_05CCIMDFBO@secam@
	DD	FLAT:??_C@_03BADCJGEO@mac@
	DD	FLAT:??_C@_05PKCPKOLM@undef@
	DD	00H
?range_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_02CKCDDIBB@tv@ ; `kvz_config_parse'::`2'::range_names
	DD	FLAT:??_C@_02BKJPHGNJ@pc@
	DD	00H
?colorprim_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_00CNPNBAHC@@ ; `kvz_config_parse'::`2'::colorprim_names
	DD	FLAT:??_C@_05EAEABODA@bt709@
	DD	FLAT:??_C@_05PKCPKOLM@undef@
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_06CDGMBMLO@bt470m@
	DD	FLAT:??_C@_07NBKEIMK@bt470bg@
	DD	FLAT:??_C@_09EFOMJFPE@smpte170m@
	DD	FLAT:??_C@_09BAPJEAMK@smpte240m@
	DD	FLAT:??_C@_04PIBPBFCI@film@
	DD	FLAT:??_C@_06DNGKCGNA@bt2020@
	DD	00H
?transfer_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_00CNPNBAHC@@ ; `kvz_config_parse'::`2'::transfer_names
	DD	FLAT:??_C@_05EAEABODA@bt709@
	DD	FLAT:??_C@_05PKCPKOLM@undef@
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_06CDGMBMLO@bt470m@
	DD	FLAT:??_C@_07NBKEIMK@bt470bg@
	DD	FLAT:??_C@_09EFOMJFPE@smpte170m@
	DD	FLAT:??_C@_09BAPJEAMK@smpte240m@
	DD	FLAT:??_C@_06HPJICMPM@linear@
	DD	FLAT:??_C@_06EPIPFMGF@log100@
	DD	FLAT:??_C@_06LCBOFJFP@log316@
	DD	FLAT:??_C@_0N@DHFDGFFB@iec61966?92?94@
	DD	FLAT:??_C@_07NBPANCAO@bt1361e@
	DD	FLAT:??_C@_0N@EKCEJBBE@iec61966?92?91@
	DD	FLAT:??_C@_09ELIHPANI@bt2020?910@
	DD	FLAT:??_C@_09HJLBJCFK@bt2020?912@
	DD	00H
?colormatrix_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_03CDOLCGBP@GBR@ ; `kvz_config_parse'::`2'::colormatrix_names
	DD	FLAT:??_C@_05EAEABODA@bt709@
	DD	FLAT:??_C@_05PKCPKOLM@undef@
	DD	FLAT:??_C@_00CNPNBAHC@@
	DD	FLAT:??_C@_03MELHMFCB@fcc@
	DD	FLAT:??_C@_07NBKEIMK@bt470bg@
	DD	FLAT:??_C@_09EFOMJFPE@smpte170m@
	DD	FLAT:??_C@_09BAPJEAMK@smpte240m@
	DD	FLAT:??_C@_05EMKHKOLB@YCgCo@
	DD	FLAT:??_C@_08FPKMKDMG@bt2020nc@
	DD	FLAT:??_C@_07MIDOIAJG@bt2020c@
	DD	00H
?mv_constraint_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_04CGFJFPFD@none@ ; `kvz_config_parse'::`2'::mv_constraint_names
	DD	FLAT:??_C@_05MIJNFGED@frame@
	DD	FLAT:??_C@_04CKOGFLMC@tile@
	DD	FLAT:??_C@_09KDPLEICE@frametile@
	DD	FLAT:??_C@_0BA@MOLFBNHO@frametilemargin@
	DD	00H
?hash_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_04CGFJFPFD@none@ ; `kvz_config_parse'::`2'::hash_names
	DD	FLAT:??_C@_08DNPJAFPH@checksum@
	DD	FLAT:??_C@_03PKBIKOHH@md5@
	DD	00H
?cu_split_termination_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_04DDFHDMOL@zero@ ; `kvz_config_parse'::`2'::cu_split_termination_names
	DD	FLAT:??_C@_03MCADLMAF@off@
	DD	00H
?crypto_toggle_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_03MCADLMAF@off@ ; `kvz_config_parse'::`2'::crypto_toggle_names
	DD	FLAT:??_C@_02LIELOMNJ@on@
	DD	00H
?crypto_feature_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_03EDJJDBOK@mvs@ ; `kvz_config_parse'::`2'::crypto_feature_names
	DD	FLAT:??_C@_08PCEGOFBN@mv_signs@
	DD	FLAT:??_C@_0N@BNMAPFPH@trans_coeffs@
	DD	FLAT:??_C@_0BC@NEEMKKJK@trans_coeff_signs@
	DD	FLAT:??_C@_0BB@ONDPODCM@intra_pred_modes@
	DD	00H
?me_early_termination_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_03MCADLMAF@off@ ; `kvz_config_parse'::`2'::me_early_termination_names
	DD	FLAT:??_C@_02LIELOMNJ@on@
	DD	FLAT:??_C@_09CCGPDONC@sensitive@
	DD	00H
?sao_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_03MCADLMAF@off@ ; `kvz_config_parse'::`2'::sao_names
	DD	FLAT:??_C@_04IJFJNCMM@edge@
	DD	FLAT:??_C@_04BKGNPECA@band@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	00H
?scaling_list_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_03MCADLMAF@off@ ; `kvz_config_parse'::`2'::scaling_list_names
	DD	FLAT:??_C@_06EKNFNOKI@custom@
	DD	FLAT:??_C@_07DLHCIBDH@default@
	DD	00H
?rc_algorithm_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_05CMFMCDFD@no?9rc@ ; `kvz_config_parse'::`2'::rc_algorithm_names
	DD	FLAT:??_C@_06COJIGPIB@lambda@
	DD	FLAT:??_C@_03IKELICBO@oba@
	DD	00H
?file_format_names@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_04HAPDLBFF@auto@ ; `kvz_config_parse'::`2'::file_format_names
	DD	FLAT:??_C@_03DLLNJHFD@y4m@
	DD	FLAT:??_C@_03ODNDLLDO@yuv@
	DD	00H
?preset_values@?1??kvz_config_parse@@9@9 DD FLAT:??_C@_09KOALFBAC@ultrafast@ ; `kvz_config_parse'::`2'::preset_values
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03EAGHKAEK@2?93@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03ELMJDOOF@1?92@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_05BKICJGFO@hexbs@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_01KJLJFBPL@8@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_03MCADLMAF@off@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_09CCGPDONC@sensitive@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_02DAMOKLOI@28@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_09HAJOA@superfast@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03EAGHKAEK@2?93@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03ELMJDOOF@1?92@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_05BKICJGFO@hexbs@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_01KJLJFBPL@8@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FDFGLJHB@2@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_09CCGPDONC@sensitive@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_02DAMOKLOI@28@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_08NNJCBKKK@veryfast@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03EAGHKAEK@2?93@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03FCNCAPKE@1?93@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_05BKICJGFO@hexbs@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_01KJLJFBPL@8@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FDFGLJHB@2@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_09CCGPDONC@sensitive@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_02DAMOKLOI@28@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_06EAGHDKMK@faster@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03EAGHKAEK@2?93@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03FCNCAPKE@1?93@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_05BKICJGFO@hexbs@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_01KJLJFBPL@8@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_09CCGPDONC@sensitive@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_04LBNBHAJC@fast@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03FCNCAPKE@1?93@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03FCNCAPKE@1?93@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_05BKICJGFO@hexbs@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_01KJLJFBPL@8@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01FDFGLJHB@2@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_09CCGPDONC@sensitive@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_06HIDOEFBI@medium@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03BNJDJJGD@1?94@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03OKGOGIMB@0?93@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_05BKICJGFO@hexbs@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_02KMALDIDP@16@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_02LIELOMNJ@on@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_04NFKKLJGK@slow@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03BNJDJJGD@1?94@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03OKGOGIMB@0?93@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_05BKICJGFO@hexbs@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_02KMALDIDP@16@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_02LIELOMNJ@on@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_06HOLKEPBA@slower@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01FDFGLJHB@2@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03BNJDJJGD@1?94@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03OKGOGIMB@0?93@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_05BKICJGFO@hexbs@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_02KMALDIDP@16@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_03MCADLMAF@off@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_08LJOJNDFC@veryslow@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01FDFGLJHB@2@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03BNJDJJGD@1?94@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03OKGOGIMB@0?93@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_02IGJGHHBN@tz@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_02KMALDIDP@16@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_04DDFHDMOL@zero@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_03MCADLMAF@off@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	FLAT:??_C@_07MCGPCJOC@placebo@
	DD	FLAT:??_C@_02FGFKDEHA@rd@
	DD	FLAT:??_C@_01FDFGLJHB@2@
	DD	FLAT:??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	DD	FLAT:??_C@_03BNJDJJGD@1?94@
	DD	FLAT:??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	DD	FLAT:??_C@_03OKGOGIMB@0?93@
	DD	FLAT:??_C@_02FIDLOBHM@me@
	DD	FLAT:??_C@_02IGJGHHBN@tz@
	DD	FLAT:??_C@_03BEPOBKLC@gop@
	DD	FLAT:??_C@_02KMALDIDP@16@
	DD	FLAT:??_C@_03GCDGINBO@ref@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_06CGCIAMGP@bipred@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_07KBNBPJMI@deblock@
	DD	FLAT:??_C@_03NICKIOPH@0?30@
	DD	FLAT:??_C@_08NLKLMLIL@signhide@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_05DLBDLGJF@subme@
	DD	FLAT:??_C@_01FAMBOPH@4@
	DD	FLAT:??_C@_03MEBPJOO@sao@
	DD	FLAT:??_C@_04PLMLMMEO@full@
	DD	FLAT:??_C@_04HLCEBPLD@rdoq@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_09CNMMAOKA@rdoq?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0P@KCEICG@transform?9skip@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_06FFHEEO@mv?9rdo@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BC@NIDONDCE@full?9intra?9search@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_03MIABAOBE@smp@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_03DCBBJBAA@amp@
	DD	FLAT:??_C@_01HIHLOKLC@1@
	DD	FLAT:??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	DD	FLAT:??_C@_03MCADLMAF@off@
	DD	FLAT:??_C@_0BF@EGFOFOM@me?9early?9termination@
	DD	FLAT:??_C@_03MCADLMAF@off@
	DD	FLAT:??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0L@CKGBKFNE@early?9skip@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	DD	FLAT:??_C@_01GBGANLPD@0@
	DD	FLAT:??_C@_09NDDHJBDO@max?9merge@
	DD	FLAT:??_C@_01BMBHCPLG@5@
	DD	00H
	DD	00H
	ORG $+196
?formats@?GA@??kvz_config_parse@@9@9 DD 00H		; `kvz_config_parse'::`96'::formats
	DD	01H
?format_names@?GA@??kvz_config_parse@@9@9 DD FLAT:??_C@_04IFKKHLLM@P400@ ; `kvz_config_parse'::`96'::format_names
	DD	FLAT:??_C@_04IGCOKPNC@P420@
	DD	00H
	ORG $+4
?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9 DD 087000H ; `validate_hevc_level'::`2'::LEVEL_CONSTRAINTS
	DD	09000H
	DD	080H
	DD	0384000H
	DD	01e000H
	DD	05dcH
	DD	0708000H
	DD	03c000H
	DD	0bb8H
	DD	0fd2000H
	DD	087000H
	DD	01770H
	DD	01fa4000H
	DD	0f0000H
	DD	02710H
	DD	03fc0000H
	DD	0220000H
	DD	02ee0H
	DD	07f80000H
	DD	0220000H
	DD	04e20H
	DD	0ff00000H
	DD	0880000H
	DD	061a8H
	DD	01fe00000H
	DD	0880000H
	DD	09c40H
	DD	03fc00000H
	DD	0880000H
	DD	0ea60H
	DD	03fc00000H
	DD	02200000H
	DD	0ea60H
	DD	07f800000H
	DD	02200000H
	DD	01d4c0H
	DD	0ff000000H
	DD	02200000H
	DD	03a980H
?HIGH_TIER_BITRATES@?1??validate_hevc_level@@9@9 DD 07530H ; `validate_hevc_level'::`2'::HIGH_TIER_BITRATES
	DD	0c350H
	DD	0186a0H
	DD	027100H
	DD	03a980H
	DD	03a980H
	DD	075300H
	DD	0c3500H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	___local_stdio_scanf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	__vfscanf_l
PUBLIC	_fscanf
PUBLIC	__vsscanf_l
PUBLIC	_sscanf
PUBLIC	_kvz_config_alloc
PUBLIC	_kvz_config_init
PUBLIC	_kvz_config_destroy
PUBLIC	_kvz_config_parse
PUBLIC	_kvz_config_process_lp_gop
PUBLIC	_kvz_config_validate
PUBLIC	_sqrtf
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_03ICICOMAL@yes@				; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_02KAJCLHKP@no@				; `string'
PUBLIC	??_C@_0DO@DGIKDOFG@Invalid?5number?5of?5tiles?5?$CI1?5?$DM?$DN?5?$CF@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0BP@MANPHOLJ@Could?5not?5parse?5integer?5?$CC?$CFs?$CC?$CB?6@ ; `string'
PUBLIC	??_C@_0CE@GJGGGHOC@Could?5not?5allocate?5array?5for?5ti@ ; `string'
PUBLIC	??_C@_0CD@LGDHHOIJ@Expected?5number?5between?5?$CFd?5and?5@ ; `string'
PUBLIC	??_C@_03DJMIOEGN@?0?$DL?3@			; `string'
PUBLIC	??_C@_0CE@EEGEPHM@parsing?5failed?5?3?5too?5many?5membe@ ; `string'
PUBLIC	??_C@_0CD@HHLLOAHB@parsing?5failed?5?3?5too?5few?5member@ ; `string'
PUBLIC	??_C@_01IHBHIGKO@?0@				; `string'
PUBLIC	??_C@_05BIKBEGBP@?$CFd?9?$CFd@			; `string'
PUBLIC	??_C@_0CD@ECPHFAHJ@parsing?5failed?5?3?5too?5many?5value@ ; `string'
PUBLIC	??_C@_0DG@FHPHAOPI@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@ ; `string'
PUBLIC	??_C@_0DH@HFPBGNIO@Invalid?5number?5of?5slices?5?$CI0?5?$DM?5?$CF@ ; `string'
PUBLIC	??_C@_0CF@BNKABEII@Could?5not?5allocate?5array?5for?5sl@ ; `string'
PUBLIC	??_C@_03GGODHGCB@no?9@				; `string'
PUBLIC	??_C@_05IGKADHGO@width@				; `string'
PUBLIC	??_C@_06LNLHEAAG@height@			; `string'
PUBLIC	??_C@_09JFPMGDJC@input?9res@			; `string'
PUBLIC	??_C@_05OEHCLJIP@?$CFdx?$CFd@			; `string'
PUBLIC	??_C@_09FAGKMCMB@input?9fps@			; `string'
PUBLIC	??_C@_05LCKIIOJE@?$CFd?1?$CFd@			; `string'
PUBLIC	??_C@_02HKLCFNHM@qp@				; `string'
PUBLIC	??_C@_06FBOEEHNL@period@			; `string'
PUBLIC	??_C@_0L@OMIMLMPG@vps?9period@			; `string'
PUBLIC	??_C@_05NFGPCJDJ@?$CFd?3?$CFd@			; `string'
PUBLIC	??_C@_0P@GBNNMAAH@tr?9depth?9intra@		; `string'
PUBLIC	??_C@_0BB@JEPLFBLL@source?9scan?9type@		; `string'
PUBLIC	??_C@_0O@GDODIHNK@mv?9constraint@		; `string'
PUBLIC	??_C@_03PDCNJFPC@sar@				; `string'
PUBLIC	??_C@_08EKPNNHHH@overscan@			; `string'
PUBLIC	??_C@_0M@PKCLCCAL@videoformat@			; `string'
PUBLIC	??_C@_05CCGOGOBM@range@				; `string'
PUBLIC	??_C@_09LGJOCOCA@colorprim@			; `string'
PUBLIC	??_C@_08LGNJOGGB@transfer@			; `string'
PUBLIC	??_C@_0M@PKPDAFGD@colormatrix@			; `string'
PUBLIC	??_C@_09DOAGBPBM@chromaloc@			; `string'
PUBLIC	??_C@_03OIKLEJN@aud@				; `string'
PUBLIC	??_C@_07DDNHNHBH@cqmfile@			; `string'
PUBLIC	??_C@_0CO@OPJDAEPM@Failed?5to?5allocate?5memory?5for?5C@ ; `string'
PUBLIC	??_C@_0BB@KFGIMMCK@fast?9coeff?9table@		; `string'
PUBLIC	??_C@_0DL@DIBNFNDF@Failed?5to?5allocate?5memory?5for?5f@ ; `string'
PUBLIC	??_C@_0BA@LKPIHKKB@fastrd?9sampling@		; `string'
PUBLIC	??_C@_0BG@LLPHFMAP@fastrd?9accuracy?9check@	; `string'
PUBLIC	??_C@_0O@MBFJKMHN@fastrd?9outdir@		; `string'
PUBLIC	??_C@_0DO@KIOOILIB@Failed?5to?5allocate?5memory?5for?5f@ ; `string'
PUBLIC	??_C@_0N@DFHCBDAC@scaling?9list@		; `string'
PUBLIC	??_C@_0BC@GPFMDGBM@tiles?9width?9split@		; `string'
PUBLIC	??_C@_0CI@IIMCKGEE@Disabling?5TMVP?5because?5tiles?5ar@ ; `string'
PUBLIC	??_C@_0CL@MLFEDNBO@Disabling?5WPP?5because?5tiles?5wer@ ; `string'
PUBLIC	??_C@_0BD@PHGKEHDC@tiles?9height?9split@	; `string'
PUBLIC	??_C@_05HBFCGPPC@tiles@				; `string'
PUBLIC	??_C@_05OKCLCEKN@?$CFux?$CFu@			; `string'
PUBLIC	??_C@_0DK@GJMLLIF@Wrong?5format?5for?5tiles?4?5Expecte@ ; `string'
PUBLIC	??_C@_0DN@HPPGLGNJ@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@ ; `string'
PUBLIC	??_C@_03FDJNKJGA@wpp@				; `string'
PUBLIC	??_C@_03NPOHHFEC@owf@				; `string'
PUBLIC	??_C@_06DHJKELDJ@slices@			; `string'
PUBLIC	??_C@_09PLFMLLNL@tiles?$CLwpp@			; `string'
PUBLIC	??_C@_07NFPADACG@threads@			; `string'
PUBLIC	??_C@_05CDPJMNMF@cpuid@				; `string'
PUBLIC	??_C@_04NIDJFNBE@info@				; `string'
PUBLIC	??_C@_03NLJAFKOH@lp?9@				; `string'
PUBLIC	??_C@_0N@IDFEHDFC@lp?9g?$CFud?$CFut?$CFu@	; `string'
PUBLIC	??_C@_0CJ@JBECBFMC@Error?5in?5GOP?5syntax?4?5Example?3?5l@ ; `string'
PUBLIC	??_C@_0CB@CPLBNIGG@gop?4g?5must?5be?5between?51?5and?532?4@ ; `string'
PUBLIC	??_C@_0CA@PHKDDLG@gop?4d?5must?5be?5between?51?5and?58?4?6@ ; `string'
PUBLIC	??_C@_0CB@OLGGFFNG@gop?4t?5must?5be?5between?51?5and?515?4@ ; `string'
PUBLIC	??_C@_0DF@OLEAANOI@Input?5error?3?5unsupported?5gop?5le@ ; `string'
PUBLIC	??_C@_0BA@MNBIMPFK@intra?9qp?9offset@		; `string'
PUBLIC	??_C@_08COBIOIDI@open?9gop@			; `string'
PUBLIC	??_C@_07MNHELNBG@bitrate@			; `string'
PUBLIC	??_C@_06OFAGBOBG@preset@			; `string'
PUBLIC	??_C@_0BC@PJLALGNI@Using?5preset?5?$CFs?3?5@	; `string'
PUBLIC	??_C@_08BFGGEBOG@?9?9?$CFs?$DN?$CFs?5@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0CC@GGPECPGC@Input?5error?3?5unknown?5preset?5?$CC?$CFs@ ; `string'
PUBLIC	??_C@_04OGMFBKAB@psnr@				; `string'
PUBLIC	??_C@_04OIJGJDKO@hash@				; `string'
PUBLIC	??_C@_06LAEHEPPF@crypto@			; `string'
PUBLIC	??_C@_0DK@PJFMFHIP@?9?9crypto?5cannot?5be?5enabled?5beca@ ; `string'
PUBLIC	??_C@_03ICHNJLJF@key@				; `string'
PUBLIC	??_C@_08PIMDPPGO@lossless@			; `string'
PUBLIC	??_C@_04IDIAAMCH@tmvp@				; `string'
PUBLIC	??_C@_0CM@PFAEIPPG@Cannot?5enable?5TMVP?5because?5tile@ ; `string'
PUBLIC	??_C@_0N@MACMGKGI@input?9format@		; `string'
PUBLIC	??_C@_0BO@CJEIIFDP@input?9format?5not?5recognized?4?6@ ; `string'
PUBLIC	??_C@_0P@FLCBIFAI@input?9bitdepth@		; `string'
PUBLIC	??_C@_0CG@FHKGEIAH@input?9bitdepth?5not?5between?58?5an@ ; `string'
PUBLIC	??_C@_0GA@LAOEBOAK@input?9bitdepth?5can?8t?5be?5set?5to?5@ ; `string'
PUBLIC	??_C@_0P@MLHFGKE@implicit?9rdpcm@		; `string'
PUBLIC	??_C@_03OIDJBEAH@roi@				; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BK@HCGIMNIK@Could?5not?5open?5ROI?5file?4?6@ ; `string'
PUBLIC	??_C@_0BK@OKJNPDNA@Failed?5to?5read?5ROI?5size?4?6@ ; `string'
PUBLIC	??_C@_0BK@PIHOEAGH@Invalid?5ROI?5size?3?5?$CFdx?$CFd?4?6@ ; `string'
PUBLIC	??_C@_0DB@NFHNEBEH@ROI?5dimensions?5exceed?5arbitrary@ ; `string'
PUBLIC	??_C@_0CK@CFIEFPOB@Failed?5to?5allocate?5memory?5for?5R@ ; `string'
PUBLIC	??_C@_0BK@CEKLAFEC@Reading?5ROI?5file?5failed?4?6@ ; `string'
PUBLIC	??_C@_0N@BFIGBNPD@set?9qp?9in?9cu@		; `string'
PUBLIC	??_C@_07LCMEECMI@erp?9aqp@			; `string'
PUBLIC	??_C@_05KJNJLLGA@level@				; `string'
PUBLIC	??_C@_0M@MGLOGJPN@force?9level@			; `string'
PUBLIC	??_C@_05EENHEND@?$CFu?4?$CFu@			; `string'
PUBLIC	??_C@_0BL@DMMKLPHB@Invalid?5level?5value?3?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0CE@KCLEDEOI@Level?5value?5of?5?$CFs?5is?5out?5of?5bou@ ; `string'
PUBLIC	??_C@_09OOKJLFAD@high?9tier@			; `string'
PUBLIC	??_C@_08FPEEAHBF@me?9steps@			; `string'
PUBLIC	??_C@_0BN@HLDNCNIO@Invalid?5me?9steps?5value?3?5?$CC?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0CG@BLDCDBOL@me?9steps?5value?5is?5out?5of?5bounds@ ; `string'
PUBLIC	??_C@_03OPNODGAD@vaq@				; `string'
PUBLIC	??_C@_0CH@LLCDBEMB@max?9merge?5needs?5to?5be?5between?51@ ; `string'
PUBLIC	??_C@_0BC@NCEMMCMO@ml?9pu?9depth?9intra@	; `string'
PUBLIC	??_C@_0P@OELGANC@partial?9coding@		; `string'
PUBLIC	??_C@_0M@HMFNFDMO@?$CFu?$CB?$CFu?$CB?$CFu?$CB?$CFu@ ; `string'
PUBLIC	??_C@_0EK@CAEPCCID@invalid?5partial?9coding?5options?4@ ; `string'
PUBLIC	??_C@_0P@MOHBBPPH@zero?9coeff?9rdo@		; `string'
PUBLIC	??_C@_0N@LLEHIFIF@rc?9algorithm@		; `string'
PUBLIC	??_C@_0EI@KNFFFLOD@Invalid?5rate?5control?5algorithm?5@ ; `string'
PUBLIC	??_C@_0L@FHDAPBPN@intra?9bits@			; `string'
PUBLIC	??_C@_0P@EOCPJIEH@clip?9neighbour@		; `string'
PUBLIC	??_C@_0BC@FCLHPMHP@input?9file?9format@		; `string'
PUBLIC	??_C@_0ED@OHMCJCOI@Invalid?5input?5file?5format?5?$CFs?4?5V@ ; `string'
PUBLIC	??_C@_0BC@MDLEJHHN@stats?9file?9prefix@		; `string'
PUBLIC	??_C@_0BP@JEBBPBKL@vaq?5strength?5must?5be?5positive?6@ ; `string'
PUBLIC	??_C@_0CF@OMEIPLBB@Input?5error?3?5width?5must?5be?5posi@ ; `string'
PUBLIC	??_C@_0CG@DKOBNDGB@Input?5error?3?5height?5must?5be?5pos@ ; `string'
PUBLIC	??_C@_0CO@GFBEMOHN@Input?5error?3?5width?5must?5be?5a?5mu@ ; `string'
PUBLIC	??_C@_0CP@KJHABNME@Input?5error?3?5height?5must?5be?5a?5m@ ; `string'
PUBLIC	??_C@_0DH@KHFKCHDG@Input?5error?3?5resolution?5?$CFdx?$CFd?5t@ ; `string'
PUBLIC	??_C@_0CL@MFFDCLEO@Input?5error?3?5?9?9input?9fps?5must?5b@ ; `string'
PUBLIC	??_C@_0CD@JGPJBDLD@Input?5error?3?5?9?9input?9fps?5must?5?$DO@ ; `string'
PUBLIC	??_C@_0DB@OHGHIGBP@Input?5error?3?5?9?9input?9fps?5denomi@ ; `string'
PUBLIC	??_C@_0EE@OGJFAANK@Input?5error?3?5intra?5period?5?$CI?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0CJ@NGKFCDI@Input?5error?3?5?9?9ref?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0DK@DNPIANBN@Input?5error?3?5deblock?5beta?5param@ ; `string'
PUBLIC	??_C@_0DI@JGCJLIIK@Input?5error?3?5deblock?5tc?5paramet@ ; `string'
PUBLIC	??_C@_0DB@HNDIADEB@Input?5error?3?5?9?9rd?5parameter?5out@ ; `string'
PUBLIC	??_C@_0DG@GLNCMIMA@Input?5error?3?5?9?9tr?9depth?9intra?5i@ ; `string'
PUBLIC	??_C@_0DP@IKGAFMJE@Input?5error?3?5invalid?5?9?9subme?5pa@ ; `string'
PUBLIC	??_C@_0DI@LFNPHAFJ@Input?5error?3?5?9?9chromaloc?5parame@ ; `string'
PUBLIC	??_C@_0CO@KAPDACLP@Input?5error?3?5?9?9owf?5must?5be?5nonn@ ; `string'
PUBLIC	??_C@_0DC@FAGGEHMD@Input?5error?3?5?9?9qp?5parameter?5out@ ; `string'
PUBLIC	??_C@_0DH@KOCLFKPI@Input?5error?3?5?9?9intra?9qp?9offset?5@ ; `string'
PUBLIC	??_C@_0CM@CKIEFPCC@Input?5error?3?5?9?9bitrate?5must?5be?5@ ; `string'
PUBLIC	??_C@_0DJ@PFNAMAHF@Input?5error?3?5illegal?5value?5for?5@ ; `string'
PUBLIC	??_C@_0DB@NKPLDKGC@Input?5error?3?5Inter?5PU?5depth?5min@ ; `string'
PUBLIC	??_C@_0DJ@LKEEGGMM@Input?5error?3?5illegal?5value?5for?5@ ; `string'
PUBLIC	??_C@_0DB@FHKLKNFP@Input?5error?3?5Intra?5PU?5depth?5min@ ; `string'
PUBLIC	??_C@_0FA@LCOPIJJ@Input?5error?3?5tile?5separations?5i@ ; `string'
PUBLIC	??_C@_0FJ@MPOEBHAH@Input?5error?3?5tile?5separation?5in@ ; `string'
PUBLIC	??_C@_0FI@JACDALLH@Input?5error?3?5last?5x?5tile?5separa@ ; `string'
PUBLIC	??_C@_0FB@HNBMALLF@Input?5error?3?5tile?5separations?5i@ ; `string'
PUBLIC	??_C@_0FK@OICNJKMA@Input?5error?3?5tile?5separation?5in@ ; `string'
PUBLIC	??_C@_0FI@DKIHBBFK@Input?5error?3?5last?5tile?5separati@ ; `string'
PUBLIC	??_C@_0EC@FFAECHHG@Input?5error?3?5?9?9implicit?9rdpcm?5i@ ; `string'
PUBLIC	??_C@_0DI@CDMPKDBM@Input?5error?3?5?9?9slices?$DNwpp?5does?5@ ; `string'
PUBLIC	??_C@_0EM@GGPOIEDD@Input?5error?3?5?9?9scaling?9list?$DNcus@ ; `string'
PUBLIC	??_C@_0CN@OHMNFLAG@Bitrate?5set?5but?5rc?9algorithm?5is@ ; `string'
PUBLIC	??_C@_0DB@KOOPKHAF@Rate?5control?5algorithm?5set?5but?5@ ; `string'
PUBLIC	??_C@_0O@DAGNOIGH@Level?5warning@		; `string'
PUBLIC	??_C@_0M@HBAFJGPP@Level?5error@			; `string'
PUBLIC	??_C@_0CL@EKMHGODE@Input?5error?3?5?$CFg?5is?5an?5invalid?5l@ ; `string'
PUBLIC	??_C@_0DC@JBLKDAIN@Input?5error?3?5high?5tier?5requires@ ; `string'
PUBLIC	??_C@_04DGANLAON@high@				; `string'
PUBLIC	??_C@_04GHJNJNPO@main@				; `string'
PUBLIC	??_C@_0EO@PCCBAODD@?$CFs?3?5target?5bitrate?5exceeds?5?$CFi?0?5@ ; `string'
PUBLIC	??_C@_0FD@NEFLHEJP@?$CFs?3?5picture?5width?5of?5?$CFi?5is?5too?5@ ; `string'
PUBLIC	??_C@_0FE@PIOPPNDJ@?$CFs?3?5picture?5height?5of?5?$CFi?5is?5too@ ; `string'
PUBLIC	??_C@_0GP@PNEOCGC@?$CFs?3?5picture?5resolution?5of?5?$CFix?$CFi@ ; `string'
PUBLIC	??_C@_0HK@GAEEDBGA@?$CFs?3?5framerate?5of?5?$CFg?5is?5too?5big?5@ ; `string'
PUBLIC	__real@3fdd97f62b6ae7d5
PUBLIC	__real@3fdf5c28f5c28f5c
PUBLIC	__real@3fe27ef9db22d0e5
PUBLIC	__real@3fec816f0068db8d
PUBLIC	__real@4039000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@41200000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_abs:PROC
EXTRN	__imp__atof:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp__strtol:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strchr:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__strtok:PROC
EXTRN	__imp__strdup:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vfscanf:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	_sqrt:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
EXTRN	__dtoul3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT __real@3fec816f0068db8d
CONST	SEGMENT
__real@3fec816f0068db8d DQ 03fec816f0068db8dr	; 0.8908
CONST	ENDS
;	COMDAT __real@3fe27ef9db22d0e5
CONST	SEGMENT
__real@3fe27ef9db22d0e5 DQ 03fe27ef9db22d0e5r	; 0.578
CONST	ENDS
;	COMDAT __real@3fdf5c28f5c28f5c
CONST	SEGMENT
__real@3fdf5c28f5c28f5c DQ 03fdf5c28f5c28f5cr	; 0.49
CONST	ENDS
;	COMDAT __real@3fdd97f62b6ae7d5
CONST	SEGMENT
__real@3fdd97f62b6ae7d5 DQ 03fdd97f62b6ae7d5r	; 0.4624
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0HK@GAEEDBGA@?$CFs?3?5framerate?5of?5?$CFg?5is?5too?5big?5@
CONST	SEGMENT
??_C@_0HK@GAEEDBGA@?$CFs?3?5framerate?5of?5?$CFg?5is?5too?5big?5@ DB '%s:'
	DB	' framerate of %g is too big for this level (%g) and picture r'
	DB	'esolution (it has the sample rate of %llu, maximum is %u', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@PNEOCGC@?$CFs?3?5picture?5resolution?5of?5?$CFix?$CFi@
CONST	SEGMENT
??_C@_0GP@PNEOCGC@?$CFs?3?5picture?5resolution?5of?5?$CFix?$CFi@ DB '%s: '
	DB	'picture resolution of %ix%i is too large for this level (%g) '
	DB	'(it has %llu samples, maximum is %u samples)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@PIOPPNDJ@?$CFs?3?5picture?5height?5of?5?$CFi?5is?5too@
CONST	SEGMENT
??_C@_0FE@PIOPPNDJ@?$CFs?3?5picture?5height?5of?5?$CFi?5is?5too@ DB '%s: '
	DB	'picture height of %i is too large for this level (%g), maximu'
	DB	'm dimension is %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@NEFLHEJP@?$CFs?3?5picture?5width?5of?5?$CFi?5is?5too?5@
CONST	SEGMENT
??_C@_0FD@NEFLHEJP@?$CFs?3?5picture?5width?5of?5?$CFi?5is?5too?5@ DB '%s:'
	DB	' picture width of %i is too large for this level (%g), maximu'
	DB	'm dimension is %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@PCCBAODD@?$CFs?3?5target?5bitrate?5exceeds?5?$CFi?0?5@
CONST	SEGMENT
??_C@_0EO@PCCBAODD@?$CFs?3?5target?5bitrate?5exceeds?5?$CFi?0?5@ DB '%s: '
	DB	'target bitrate exceeds %i, which is the maximum %s tier level'
	DB	' %g bitrate', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHJNJNPO@main@
CONST	SEGMENT
??_C@_04GHJNJNPO@main@ DB 'main', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGANLAON@high@
CONST	SEGMENT
??_C@_04DGANLAON@high@ DB 'high', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JBLKDAIN@Input?5error?3?5high?5tier?5requires@
CONST	SEGMENT
??_C@_0DC@JBLKDAIN@Input?5error?3?5high?5tier?5requires@ DB 'Input error:'
	DB	' high tier requires at least level 4', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EKMHGODE@Input?5error?3?5?$CFg?5is?5an?5invalid?5l@
CONST	SEGMENT
??_C@_0CL@EKMHGODE@Input?5error?3?5?$CFg?5is?5an?5invalid?5l@ DB 'Input e'
	DB	'rror: %g is an invalid level value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBAFJGPP@Level?5error@
CONST	SEGMENT
??_C@_0M@HBAFJGPP@Level?5error@ DB 'Level error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DAGNOIGH@Level?5warning@
CONST	SEGMENT
??_C@_0O@DAGNOIGH@Level?5warning@ DB 'Level warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KOOPKHAF@Rate?5control?5algorithm?5set?5but?5@
CONST	SEGMENT
??_C@_0DB@KOOPKHAF@Rate?5control?5algorithm?5set?5but?5@ DB 'Rate control'
	DB	' algorithm set but bitrate not set.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OHMNFLAG@Bitrate?5set?5but?5rc?9algorithm?5is@
CONST	SEGMENT
??_C@_0CN@OHMNFLAG@Bitrate?5set?5but?5rc?9algorithm?5is@ DB 'Bitrate set '
	DB	'but rc-algorithm is turned off.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@GGPOIEDD@Input?5error?3?5?9?9scaling?9list?$DNcus@
CONST	SEGMENT
??_C@_0EM@GGPOIEDD@Input?5error?3?5?9?9scaling?9list?$DNcus@ DB 'Input er'
	DB	'ror: --scaling-list=custom does not work without --cqmfile=<F'
	DB	'ILE>.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CDMPKDBM@Input?5error?3?5?9?9slices?$DNwpp?5does?5@
CONST	SEGMENT
??_C@_0DI@CDMPKDBM@Input?5error?3?5?9?9slices?$DNwpp?5does?5@ DB 'Input e'
	DB	'rror: --slices=wpp does not work without --wpp.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@FFAECHHG@Input?5error?3?5?9?9implicit?9rdpcm?5i@
CONST	SEGMENT
??_C@_0EC@FFAECHHG@Input?5error?3?5?9?9implicit?9rdpcm?5i@ DB 'Input erro'
	DB	'r: --implicit-rdpcm is not suppoted without --lossless', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@DKIHBBFK@Input?5error?3?5last?5tile?5separati@
CONST	SEGMENT
??_C@_0FI@DKIHBBFK@Input?5error?3?5last?5tile?5separati@ DB 'Input error:'
	DB	' last tile separation in height (%d) should smaller than imag'
	DB	'e height (%d)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@OICNJKMA@Input?5error?3?5tile?5separation?5in@
CONST	SEGMENT
??_C@_0FK@OICNJKMA@Input?5error?3?5tile?5separation?5in@ DB 'Input error:'
	DB	' tile separation in height %d (at %d) is not at a multiple of'
	DB	' LCU_WIDTH (%d)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@HNBMALLF@Input?5error?3?5tile?5separations?5i@
CONST	SEGMENT
??_C@_0FB@HNBMALLF@Input?5error?3?5tile?5separations?5i@ DB 'Input error:'
	DB	' tile separations in height should be strictly monotonic (%d '
	DB	'<= %d)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@JACDALLH@Input?5error?3?5last?5x?5tile?5separa@
CONST	SEGMENT
??_C@_0FI@JACDALLH@Input?5error?3?5last?5x?5tile?5separa@ DB 'Input error'
	DB	': last x tile separation in width (%d) should smaller than im'
	DB	'age width (%d)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@MPOEBHAH@Input?5error?3?5tile?5separation?5in@
CONST	SEGMENT
??_C@_0FJ@MPOEBHAH@Input?5error?3?5tile?5separation?5in@ DB 'Input error:'
	DB	' tile separation in width %d (at %d) is not at a multiple of '
	DB	'LCU_WIDTH (%d)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@LCOPIJJ@Input?5error?3?5tile?5separations?5i@
CONST	SEGMENT
??_C@_0FA@LCOPIJJ@Input?5error?3?5tile?5separations?5i@ DB 'Input error: '
	DB	'tile separations in width should be strictly monotonic (%d <='
	DB	' %d)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FHKLKNFP@Input?5error?3?5Intra?5PU?5depth?5min@
CONST	SEGMENT
??_C@_0DB@FHKLKNFP@Input?5error?3?5Intra?5PU?5depth?5min@ DB 'Input error'
	DB	': Intra PU depth min (%d) > max (%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LKEEGGMM@Input?5error?3?5illegal?5value?5for?5@
CONST	SEGMENT
??_C@_0DJ@LKEEGGMM@Input?5error?3?5illegal?5value?5for?5@ DB 'Input error'
	DB	': illegal value for --pu-depth-intra (%d-%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NKPLDKGC@Input?5error?3?5Inter?5PU?5depth?5min@
CONST	SEGMENT
??_C@_0DB@NKPLDKGC@Input?5error?3?5Inter?5PU?5depth?5min@ DB 'Input error'
	DB	': Inter PU depth min (%d) > max (%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@PFNAMAHF@Input?5error?3?5illegal?5value?5for?5@
CONST	SEGMENT
??_C@_0DJ@PFNAMAHF@Input?5error?3?5illegal?5value?5for?5@ DB 'Input error'
	DB	': illegal value for --pu-depth-inter (%d-%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CKIEFPCC@Input?5error?3?5?9?9bitrate?5must?5be?5@
CONST	SEGMENT
??_C@_0CM@CKIEFPCC@Input?5error?3?5?9?9bitrate?5must?5be?5@ DB 'Input err'
	DB	'or: --bitrate must be nonnegative', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KOCLFKPI@Input?5error?3?5?9?9intra?9qp?9offset?5@
CONST	SEGMENT
??_C@_0DH@KOCLFKPI@Input?5error?3?5?9?9intra?9qp?9offset?5@ DB 'Input err'
	DB	'or: --intra-qp-offset out of range [-51..51]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FAGGEHMD@Input?5error?3?5?9?9qp?5parameter?5out@
CONST	SEGMENT
??_C@_0DC@FAGGEHMD@Input?5error?3?5?9?9qp?5parameter?5out@ DB 'Input erro'
	DB	'r: --qp parameter out of range [0..51]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KAPDACLP@Input?5error?3?5?9?9owf?5must?5be?5nonn@
CONST	SEGMENT
??_C@_0CO@KAPDACLP@Input?5error?3?5?9?9owf?5must?5be?5nonn@ DB 'Input err'
	DB	'or: --owf must be nonnegative or -1', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@LFNPHAFJ@Input?5error?3?5?9?9chromaloc?5parame@
CONST	SEGMENT
??_C@_0DI@LFNPHAFJ@Input?5error?3?5?9?9chromaloc?5parame@ DB 'Input error'
	DB	': --chromaloc parameter out of range [0..5]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@IKGAFMJE@Input?5error?3?5invalid?5?9?9subme?5pa@
CONST	SEGMENT
??_C@_0DP@IKGAFMJE@Input?5error?3?5invalid?5?9?9subme?5pa@ DB 'Input erro'
	DB	'r: invalid --subme parameter (must be in range 0-4)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GLNCMIMA@Input?5error?3?5?9?9tr?9depth?9intra?5i@
CONST	SEGMENT
??_C@_0DG@GLNCMIMA@Input?5error?3?5?9?9tr?9depth?9intra?5i@ DB 'Input err'
	DB	'or: --tr-depth-intra is out of range [0..4]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HNDIADEB@Input?5error?3?5?9?9rd?5parameter?5out@
CONST	SEGMENT
??_C@_0DB@HNDIADEB@Input?5error?3?5?9?9rd?5parameter?5out@ DB 'Input erro'
	DB	'r: --rd parameter out of range [0..3]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JGCJLIIK@Input?5error?3?5deblock?5tc?5paramet@
CONST	SEGMENT
??_C@_0DI@JGCJLIIK@Input?5error?3?5deblock?5tc?5paramet@ DB 'Input error:'
	DB	' deblock tc parameter out of range [-6..6]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DNPIANBN@Input?5error?3?5deblock?5beta?5param@
CONST	SEGMENT
??_C@_0DK@DNPIANBN@Input?5error?3?5deblock?5beta?5param@ DB 'Input error:'
	DB	' deblock beta parameter out of range [-6..6]', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKFCDI@Input?5error?3?5?9?9ref?5out?5of?5range@
CONST	SEGMENT
??_C@_0CJ@NGKFCDI@Input?5error?3?5?9?9ref?5out?5of?5range@ DB 'Input erro'
	DB	'r: --ref out of range [1..%d]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@OGJFAANK@Input?5error?3?5intra?5period?5?$CI?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0EE@OGJFAANK@Input?5error?3?5intra?5period?5?$CI?$CFd?$CJ?5@ DB 'In'
	DB	'put error: intra period (%d) not a multiple of B-gop length ('
	DB	'%d)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OHGHIGBP@Input?5error?3?5?9?9input?9fps?5denomi@
CONST	SEGMENT
??_C@_0DB@OHGHIGBP@Input?5error?3?5?9?9input?9fps?5denomi@ DB 'Input erro'
	DB	'r: --input-fps denominator must be >0', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JGPJBDLD@Input?5error?3?5?9?9input?9fps?5must?5?$DO@
CONST	SEGMENT
??_C@_0CD@JGPJBDLD@Input?5error?3?5?9?9input?9fps?5must?5?$DO@ DB 'Input '
	DB	'error: --input-fps must >=0', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MFFDCLEO@Input?5error?3?5?9?9input?9fps?5must?5b@
CONST	SEGMENT
??_C@_0CL@MFFDCLEO@Input?5error?3?5?9?9input?9fps?5must?5b@ DB 'Input err'
	DB	'or: --input-fps must be positive', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KHFKCHDG@Input?5error?3?5resolution?5?$CFdx?$CFd?5t@
CONST	SEGMENT
??_C@_0DH@KHFKCHDG@Input?5error?3?5resolution?5?$CFdx?$CFd?5t@ DB 'Input '
	DB	'error: resolution %dx%d too large (max %u CTUs)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KJHABNME@Input?5error?3?5height?5must?5be?5a?5m@
CONST	SEGMENT
??_C@_0CP@KJHABNME@Input?5error?3?5height?5must?5be?5a?5m@ DB 'Input erro'
	DB	'r: height must be a multiple of two', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GFBEMOHN@Input?5error?3?5width?5must?5be?5a?5mu@
CONST	SEGMENT
??_C@_0CO@GFBEMOHN@Input?5error?3?5width?5must?5be?5a?5mu@ DB 'Input erro'
	DB	'r: width must be a multiple of two', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DKOBNDGB@Input?5error?3?5height?5must?5be?5pos@
CONST	SEGMENT
??_C@_0CG@DKOBNDGB@Input?5error?3?5height?5must?5be?5pos@ DB 'Input error'
	DB	': height must be positive', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OMEIPLBB@Input?5error?3?5width?5must?5be?5posi@
CONST	SEGMENT
??_C@_0CF@OMEIPLBB@Input?5error?3?5width?5must?5be?5posi@ DB 'Input error'
	DB	': width must be positive', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JEBBPBKL@vaq?5strength?5must?5be?5positive?6@
CONST	SEGMENT
??_C@_0BP@JEBBPBKL@vaq?5strength?5must?5be?5positive?6@ DB 'vaq strength '
	DB	'must be positive', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MDLEJHHN@stats?9file?9prefix@
CONST	SEGMENT
??_C@_0BC@MDLEJHHN@stats?9file?9prefix@ DB 'stats-file-prefix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@OHMCJCOI@Invalid?5input?5file?5format?5?$CFs?4?5V@
CONST	SEGMENT
??_C@_0ED@OHMCJCOI@Invalid?5input?5file?5format?5?$CFs?4?5V@ DB 'Invalid '
	DB	'input file format %s. Valid values include %s, %s, and %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FCLHPMHP@input?9file?9format@
CONST	SEGMENT
??_C@_0BC@FCLHPMHP@input?9file?9format@ DB 'input-file-format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EOCPJIEH@clip?9neighbour@
CONST	SEGMENT
??_C@_0P@EOCPJIEH@clip?9neighbour@ DB 'clip-neighbour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHDAPBPN@intra?9bits@
CONST	SEGMENT
??_C@_0L@FHDAPBPN@intra?9bits@ DB 'intra-bits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@KNFFFLOD@Invalid?5rate?5control?5algorithm?5@
CONST	SEGMENT
??_C@_0EI@KNFFFLOD@Invalid?5rate?5control?5algorithm?5@ DB 'Invalid rate '
	DB	'control algorithm %s. Valid values include %s, %s, and %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LLEHIFIF@rc?9algorithm@
CONST	SEGMENT
??_C@_0N@LLEHIFIF@rc?9algorithm@ DB 'rc-algorithm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOHBBPPH@zero?9coeff?9rdo@
CONST	SEGMENT
??_C@_0P@MOHBBPPH@zero?9coeff?9rdo@ DB 'zero-coeff-rdo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@CAEPCCID@invalid?5partial?9coding?5options?4@
CONST	SEGMENT
??_C@_0EK@CAEPCCID@invalid?5partial?9coding?5options?4@ DB 'invalid parti'
	DB	'al-coding options. Expected "%%u!%%u!%%u!%%u", but got "%s"', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HMFNFDMO@?$CFu?$CB?$CFu?$CB?$CFu?$CB?$CFu@
CONST	SEGMENT
??_C@_0M@HMFNFDMO@?$CFu?$CB?$CFu?$CB?$CFu?$CB?$CFu@ DB '%u!%u!%u!%u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OELGANC@partial?9coding@
CONST	SEGMENT
??_C@_0P@OELGANC@partial?9coding@ DB 'partial-coding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NCEMMCMO@ml?9pu?9depth?9intra@
CONST	SEGMENT
??_C@_0BC@NCEMMCMO@ml?9pu?9depth?9intra@ DB 'ml-pu-depth-intra', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LLCDBEMB@max?9merge?5needs?5to?5be?5between?51@
CONST	SEGMENT
??_C@_0CH@LLCDBEMB@max?9merge?5needs?5to?5be?5between?51@ DB 'max-merge n'
	DB	'eeds to be between 1 and 5', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OPNODGAD@vaq@
CONST	SEGMENT
??_C@_03OPNODGAD@vaq@ DB 'vaq', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BLDCDBOL@me?9steps?5value?5is?5out?5of?5bounds@
CONST	SEGMENT
??_C@_0CG@BLDCDBOL@me?9steps?5value?5is?5out?5of?5bounds@ DB 'me-steps va'
	DB	'lue is out of bounds: "%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HLDNCNIO@Invalid?5me?9steps?5value?3?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0BN@HLDNCNIO@Invalid?5me?9steps?5value?3?5?$CC?$CFs?$CC@ DB 'Invali'
	DB	'd me-steps value: "%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FPEEAHBF@me?9steps@
CONST	SEGMENT
??_C@_08FPEEAHBF@me?9steps@ DB 'me-steps', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OOKJLFAD@high?9tier@
CONST	SEGMENT
??_C@_09OOKJLFAD@high?9tier@ DB 'high-tier', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KCLEDEOI@Level?5value?5of?5?$CFs?5is?5out?5of?5bou@
CONST	SEGMENT
??_C@_0CE@KCLEDEOI@Level?5value?5of?5?$CFs?5is?5out?5of?5bou@ DB 'Level v'
	DB	'alue of %s is out of bounds', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DMMKLPHB@Invalid?5level?5value?3?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BL@DMMKLPHB@Invalid?5level?5value?3?5?$CC?$CFs?$CC?6@ DB 'Invalid '
	DB	'level value: "%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EENHEND@?$CFu?4?$CFu@
CONST	SEGMENT
??_C@_05EENHEND@?$CFu?4?$CFu@ DB '%u.%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MGLOGJPN@force?9level@
CONST	SEGMENT
??_C@_0M@MGLOGJPN@force?9level@ DB 'force-level', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJNJLLGA@level@
CONST	SEGMENT
??_C@_05KJNJLLGA@level@ DB 'level', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCMEECMI@erp?9aqp@
CONST	SEGMENT
??_C@_07LCMEECMI@erp?9aqp@ DB 'erp-aqp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BFIGBNPD@set?9qp?9in?9cu@
CONST	SEGMENT
??_C@_0N@BFIGBNPD@set?9qp?9in?9cu@ DB 'set-qp-in-cu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CEKLAFEC@Reading?5ROI?5file?5failed?4?6@
CONST	SEGMENT
??_C@_0BK@CEKLAFEC@Reading?5ROI?5file?5failed?4?6@ DB 'Reading ROI file f'
	DB	'ailed.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CFIEFPOB@Failed?5to?5allocate?5memory?5for?5R@
CONST	SEGMENT
??_C@_0CK@CFIEFPOB@Failed?5to?5allocate?5memory?5for?5R@ DB 'Failed to al'
	DB	'locate memory for ROI table.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NFHNEBEH@ROI?5dimensions?5exceed?5arbitrary@
CONST	SEGMENT
??_C@_0DB@NFHNEBEH@ROI?5dimensions?5exceed?5arbitrary@ DB 'ROI dimensions'
	DB	' exceed arbitrary value of 10000.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PIHOEAGH@Invalid?5ROI?5size?3?5?$CFdx?$CFd?4?6@
CONST	SEGMENT
??_C@_0BK@PIHOEAGH@Invalid?5ROI?5size?3?5?$CFdx?$CFd?4?6@ DB 'Invalid ROI'
	DB	' size: %dx%d.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OKJNPDNA@Failed?5to?5read?5ROI?5size?4?6@
CONST	SEGMENT
??_C@_0BK@OKJNPDNA@Failed?5to?5read?5ROI?5size?4?6@ DB 'Failed to read RO'
	DB	'I size.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HCGIMNIK@Could?5not?5open?5ROI?5file?4?6@
CONST	SEGMENT
??_C@_0BK@HCGIMNIK@Could?5not?5open?5ROI?5file?4?6@ DB 'Could not open RO'
	DB	'I file.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03OIDJBEAH@roi@
CONST	SEGMENT
??_C@_03OIDJBEAH@roi@ DB 'roi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MLHFGKE@implicit?9rdpcm@
CONST	SEGMENT
??_C@_0P@MLHFGKE@implicit?9rdpcm@ DB 'implicit-rdpcm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@LAOEBOAK@input?9bitdepth?5can?8t?5be?5set?5to?5@
CONST	SEGMENT
??_C@_0GA@LAOEBOAK@input?9bitdepth?5can?8t?5be?5set?5to?5@ DB 'input-bitd'
	DB	'epth can''t be set to larger than 8 because Kvazaar is compil'
	DB	'ed with KVZ_BIT_DEPTH=8.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FHKGEIAH@input?9bitdepth?5not?5between?58?5an@
CONST	SEGMENT
??_C@_0CG@FHKGEIAH@input?9bitdepth?5not?5between?58?5an@ DB 'input-bitdep'
	DB	'th not between 8 and 16.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FLCBIFAI@input?9bitdepth@
CONST	SEGMENT
??_C@_0P@FLCBIFAI@input?9bitdepth@ DB 'input-bitdepth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CJEIIFDP@input?9format?5not?5recognized?4?6@
CONST	SEGMENT
??_C@_0BO@CJEIIFDP@input?9format?5not?5recognized?4?6@ DB 'input-format n'
	DB	'ot recognized.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MACMGKGI@input?9format@
CONST	SEGMENT
??_C@_0N@MACMGKGI@input?9format@ DB 'input-format', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PFAEIPPG@Cannot?5enable?5TMVP?5because?5tile@
CONST	SEGMENT
??_C@_0CM@PFAEIPPG@Cannot?5enable?5TMVP?5because?5tile@ DB 'Cannot enable'
	DB	' TMVP because tiles are used.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IDIAAMCH@tmvp@
CONST	SEGMENT
??_C@_04IDIAAMCH@tmvp@ DB 'tmvp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PIMDPPGO@lossless@
CONST	SEGMENT
??_C@_08PIMDPPGO@lossless@ DB 'lossless', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICHNJLJF@key@
CONST	SEGMENT
??_C@_03ICHNJLJF@key@ DB 'key', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PJFMFHIP@?9?9crypto?5cannot?5be?5enabled?5beca@
CONST	SEGMENT
??_C@_0DK@PJFMFHIP@?9?9crypto?5cannot?5be?5enabled?5beca@ DB '--crypto ca'
	DB	'nnot be enabled because it''s not compiled in.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LAEHEPPF@crypto@
CONST	SEGMENT
??_C@_06LAEHEPPF@crypto@ DB 'crypto', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OIJGJDKO@hash@
CONST	SEGMENT
??_C@_04OIJGJDKO@hash@ DB 'hash', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OGMFBKAB@psnr@
CONST	SEGMENT
??_C@_04OGMFBKAB@psnr@ DB 'psnr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GGPECPGC@Input?5error?3?5unknown?5preset?5?$CC?$CFs@
CONST	SEGMENT
??_C@_0CC@GGPECPGC@Input?5error?3?5unknown?5preset?5?$CC?$CFs@ DB 'Input '
	DB	'error: unknown preset "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BFGGEBOG@?9?9?$CFs?$DN?$CFs?5@
CONST	SEGMENT
??_C@_08BFGGEBOG@?9?9?$CFs?$DN?$CFs?5@ DB '--%s=%s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PJLALGNI@Using?5preset?5?$CFs?3?5@
CONST	SEGMENT
??_C@_0BC@PJLALGNI@Using?5preset?5?$CFs?3?5@ DB 'Using preset %s: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OFAGBOBG@preset@
CONST	SEGMENT
??_C@_06OFAGBOBG@preset@ DB 'preset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNHELNBG@bitrate@
CONST	SEGMENT
??_C@_07MNHELNBG@bitrate@ DB 'bitrate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08COBIOIDI@open?9gop@
CONST	SEGMENT
??_C@_08COBIOIDI@open?9gop@ DB 'open-gop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MNBIMPFK@intra?9qp?9offset@
CONST	SEGMENT
??_C@_0BA@MNBIMPFK@intra?9qp?9offset@ DB 'intra-qp-offset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OLEAANOI@Input?5error?3?5unsupported?5gop?5le@
CONST	SEGMENT
??_C@_0DF@OLEAANOI@Input?5error?3?5unsupported?5gop?5le@ DB 'Input error:'
	DB	' unsupported gop length, must be 0 or 8', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OLGGFFNG@gop?4t?5must?5be?5between?51?5and?515?4@
CONST	SEGMENT
??_C@_0CB@OLGGFFNG@gop?4t?5must?5be?5between?51?5and?515?4@ DB 'gop.t mus'
	DB	't be between 1 and 15.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PHKDDLG@gop?4d?5must?5be?5between?51?5and?58?4?6@
CONST	SEGMENT
??_C@_0CA@PHKDDLG@gop?4d?5must?5be?5between?51?5and?58?4?6@ DB 'gop.d mus'
	DB	't be between 1 and 8.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CPLBNIGG@gop?4g?5must?5be?5between?51?5and?532?4@
CONST	SEGMENT
??_C@_0CB@CPLBNIGG@gop?4g?5must?5be?5between?51?5and?532?4@ DB 'gop.g mus'
	DB	't be between 1 and 32.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JBECBFMC@Error?5in?5GOP?5syntax?4?5Example?3?5l@
CONST	SEGMENT
??_C@_0CJ@JBECBFMC@Error?5in?5GOP?5syntax?4?5Example?3?5l@ DB 'Error in G'
	DB	'OP syntax. Example: lp-g8d4t2', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDFEHDFC@lp?9g?$CFud?$CFut?$CFu@
CONST	SEGMENT
??_C@_0N@IDFEHDFC@lp?9g?$CFud?$CFut?$CFu@ DB 'lp-g%ud%ut%u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLJAFKOH@lp?9@
CONST	SEGMENT
??_C@_03NLJAFKOH@lp?9@ DB 'lp-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIDJFNBE@info@
CONST	SEGMENT
??_C@_04NIDJFNBE@info@ DB 'info', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CDPJMNMF@cpuid@
CONST	SEGMENT
??_C@_05CDPJMNMF@cpuid@ DB 'cpuid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NFPADACG@threads@
CONST	SEGMENT
??_C@_07NFPADACG@threads@ DB 'threads', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PLFMLLNL@tiles?$CLwpp@
CONST	SEGMENT
??_C@_09PLFMLLNL@tiles?$CLwpp@ DB 'tiles+wpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DHJKELDJ@slices@
CONST	SEGMENT
??_C@_06DHJKELDJ@slices@ DB 'slices', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NPOHHFEC@owf@
CONST	SEGMENT
??_C@_03NPOHHFEC@owf@ DB 'owf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FDJNKJGA@wpp@
CONST	SEGMENT
??_C@_03FDJNKJGA@wpp@ DB 'wpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HPPGLGNJ@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@
CONST	SEGMENT
??_C@_0DN@HPPGLGNJ@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@ DB 'In'
	DB	'valid number of tiles (0 < %d <= %d = MAX_TILES_PER_DIM)!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@GJMLLIF@Wrong?5format?5for?5tiles?4?5Expecte@
CONST	SEGMENT
??_C@_0DK@GJMLLIF@Wrong?5format?5for?5tiles?4?5Expecte@ DB 'Wrong format '
	DB	'for tiles. Expected "%%ux%%u", but got "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKCLCEKN@?$CFux?$CFu@
CONST	SEGMENT
??_C@_05OKCLCEKN@?$CFux?$CFu@ DB '%ux%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HBFCGPPC@tiles@
CONST	SEGMENT
??_C@_05HBFCGPPC@tiles@ DB 'tiles', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PHGKEHDC@tiles?9height?9split@
CONST	SEGMENT
??_C@_0BD@PHGKEHDC@tiles?9height?9split@ DB 'tiles-height-split', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MLFEDNBO@Disabling?5WPP?5because?5tiles?5wer@
CONST	SEGMENT
??_C@_0CL@MLFEDNBO@Disabling?5WPP?5because?5tiles?5wer@ DB 'Disabling WPP'
	DB	' because tiles were enabled.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IIMCKGEE@Disabling?5TMVP?5because?5tiles?5ar@
CONST	SEGMENT
??_C@_0CI@IIMCKGEE@Disabling?5TMVP?5because?5tiles?5ar@ DB 'Disabling TMV'
	DB	'P because tiles are used.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GPFMDGBM@tiles?9width?9split@
CONST	SEGMENT
??_C@_0BC@GPFMDGBM@tiles?9width?9split@ DB 'tiles-width-split', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DFHCBDAC@scaling?9list@
CONST	SEGMENT
??_C@_0N@DFHCBDAC@scaling?9list@ DB 'scaling-list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@KIOOILIB@Failed?5to?5allocate?5memory?5for?5f@
CONST	SEGMENT
??_C@_0DO@KIOOILIB@Failed?5to?5allocate?5memory?5for?5f@ DB 'Failed to al'
	DB	'locate memory for fast RD learning outfile name.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBFJKMHN@fastrd?9outdir@
CONST	SEGMENT
??_C@_0O@MBFJKMHN@fastrd?9outdir@ DB 'fastrd-outdir', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LLPHFMAP@fastrd?9accuracy?9check@
CONST	SEGMENT
??_C@_0BG@LLPHFMAP@fastrd?9accuracy?9check@ DB 'fastrd-accuracy-check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LKPIHKKB@fastrd?9sampling@
CONST	SEGMENT
??_C@_0BA@LKPIHKKB@fastrd?9sampling@ DB 'fastrd-sampling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@DIBNFNDF@Failed?5to?5allocate?5memory?5for?5f@
CONST	SEGMENT
??_C@_0DL@DIBNFNDF@Failed?5to?5allocate?5memory?5for?5f@ DB 'Failed to al'
	DB	'locate memory for fast coeff table file name.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFGIMMCK@fast?9coeff?9table@
CONST	SEGMENT
??_C@_0BB@KFGIMMCK@fast?9coeff?9table@ DB 'fast-coeff-table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OPJDAEPM@Failed?5to?5allocate?5memory?5for?5C@
CONST	SEGMENT
??_C@_0CO@OPJDAEPM@Failed?5to?5allocate?5memory?5for?5C@ DB 'Failed to al'
	DB	'locate memory for CQM file name.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDNHNHBH@cqmfile@
CONST	SEGMENT
??_C@_07DDNHNHBH@cqmfile@ DB 'cqmfile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03OIKLEJN@aud@
CONST	SEGMENT
??_C@_03OIKLEJN@aud@ DB 'aud', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DOAGBPBM@chromaloc@
CONST	SEGMENT
??_C@_09DOAGBPBM@chromaloc@ DB 'chromaloc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKPDAFGD@colormatrix@
CONST	SEGMENT
??_C@_0M@PKPDAFGD@colormatrix@ DB 'colormatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGNJOGGB@transfer@
CONST	SEGMENT
??_C@_08LGNJOGGB@transfer@ DB 'transfer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGJOCOCA@colorprim@
CONST	SEGMENT
??_C@_09LGJOCOCA@colorprim@ DB 'colorprim', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCGOGOBM@range@
CONST	SEGMENT
??_C@_05CCGOGOBM@range@ DB 'range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKCLCCAL@videoformat@
CONST	SEGMENT
??_C@_0M@PKCLCCAL@videoformat@ DB 'videoformat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EKPNNHHH@overscan@
CONST	SEGMENT
??_C@_08EKPNNHHH@overscan@ DB 'overscan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PDCNJFPC@sar@
CONST	SEGMENT
??_C@_03PDCNJFPC@sar@ DB 'sar', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GDODIHNK@mv?9constraint@
CONST	SEGMENT
??_C@_0O@GDODIHNK@mv?9constraint@ DB 'mv-constraint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JEPLFBLL@source?9scan?9type@
CONST	SEGMENT
??_C@_0BB@JEPLFBLL@source?9scan?9type@ DB 'source-scan-type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GBNNMAAH@tr?9depth?9intra@
CONST	SEGMENT
??_C@_0P@GBNNMAAH@tr?9depth?9intra@ DB 'tr-depth-intra', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NFGPCJDJ@?$CFd?3?$CFd@
CONST	SEGMENT
??_C@_05NFGPCJDJ@?$CFd?3?$CFd@ DB '%d:%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OMIMLMPG@vps?9period@
CONST	SEGMENT
??_C@_0L@OMIMLMPG@vps?9period@ DB 'vps-period', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FBOEEHNL@period@
CONST	SEGMENT
??_C@_06FBOEEHNL@period@ DB 'period', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HKLCFNHM@qp@
CONST	SEGMENT
??_C@_02HKLCFNHM@qp@ DB 'qp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LCKIIOJE@?$CFd?1?$CFd@
CONST	SEGMENT
??_C@_05LCKIIOJE@?$CFd?1?$CFd@ DB '%d/%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAGKMCMB@input?9fps@
CONST	SEGMENT
??_C@_09FAGKMCMB@input?9fps@ DB 'input-fps', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OEHCLJIP@?$CFdx?$CFd@
CONST	SEGMENT
??_C@_05OEHCLJIP@?$CFdx?$CFd@ DB '%dx%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFPMGDJC@input?9res@
CONST	SEGMENT
??_C@_09JFPMGDJC@input?9res@ DB 'input-res', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNLHEAAG@height@
CONST	SEGMENT
??_C@_06LNLHEAAG@height@ DB 'height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGKADHGO@width@
CONST	SEGMENT
??_C@_05IGKADHGO@width@ DB 'width', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GGODHGCB@no?9@
CONST	SEGMENT
??_C@_03GGODHGCB@no?9@ DB 'no-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BNKABEII@Could?5not?5allocate?5array?5for?5sl@
CONST	SEGMENT
??_C@_0CF@BNKABEII@Could?5not?5allocate?5array?5for?5sl@ DB 'Could not al'
	DB	'locate array for slices', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@HFPBGNIO@Invalid?5number?5of?5slices?5?$CI0?5?$DM?5?$CF@
CONST	SEGMENT
??_C@_0DH@HFPBGNIO@Invalid?5number?5of?5slices?5?$CI0?5?$DM?5?$CF@ DB 'In'
	DB	'valid number of slices (0 < %d <= %d = MAX_SLICES)!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FHPHAOPI@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@
CONST	SEGMENT
??_C@_0DG@FHPHAOPI@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@ DB 'In'
	DB	'valid number of tiles (0 < %d <= %d = MAX_SLICES)!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ECPHFAHJ@parsing?5failed?5?3?5too?5many?5value@
CONST	SEGMENT
??_C@_0CD@ECPHFAHJ@parsing?5failed?5?3?5too?5many?5value@ DB 'parsing fai'
	DB	'led : too many values.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BIKBEGBP@?$CFd?9?$CFd@
CONST	SEGMENT
??_C@_05BIKBEGBP@?$CFd?9?$CFd@ DB '%d-%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HHLLOAHB@parsing?5failed?5?3?5too?5few?5member@
CONST	SEGMENT
??_C@_0CD@HHLLOAHB@parsing?5failed?5?3?5too?5few?5member@ DB 'parsing fai'
	DB	'led : too few members.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EEGEPHM@parsing?5failed?5?3?5too?5many?5membe@
CONST	SEGMENT
??_C@_0CE@EEGEPHM@parsing?5failed?5?3?5too?5many?5membe@ DB 'parsing fail'
	DB	'ed : too many members.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DJMIOEGN@?0?$DL?3@
CONST	SEGMENT
??_C@_03DJMIOEGN@?0?$DL?3@ DB ',;:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LGDHHOIJ@Expected?5number?5between?5?$CFd?5and?5@
CONST	SEGMENT
??_C@_0CD@LGDHHOIJ@Expected?5number?5between?5?$CFd?5and?5@ DB 'Expected '
	DB	'number between %d and %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GJGGGHOC@Could?5not?5allocate?5array?5for?5ti@
CONST	SEGMENT
??_C@_0CE@GJGGGHOC@Could?5not?5allocate?5array?5for?5ti@ DB 'Could not al'
	DB	'locate array for tiles', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MANPHOLJ@Could?5not?5parse?5integer?5?$CC?$CFs?$CC?$CB?6@
CONST	SEGMENT
??_C@_0BP@MANPHOLJ@Could?5not?5parse?5integer?5?$CC?$CFs?$CC?$CB?6@ DB 'C'
	DB	'ould not parse integer "%s"!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@DGIKDOFG@Invalid?5number?5of?5tiles?5?$CI1?5?$DM?$DN?5?$CF@
CONST	SEGMENT
??_C@_0DO@DGIKDOFG@Invalid?5number?5of?5tiles?5?$CI1?5?$DM?$DN?5?$CF@ DB 'I'
	DB	'nvalid number of tiles (1 <= %d <= %d = MAX_TILES_PER_DIM)!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAJCLHKP@no@
CONST	SEGMENT
??_C@_02KAJCLHKP@no@ DB 'no', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICICOMAL@yes@
CONST	SEGMENT
??_C@_03ICICOMAL@yes@ DB 'yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _validate_hevc_level
_TEXT	SEGMENT
tv363 = -376						; size = 8
tv332 = -376						; size = 8
tv361 = -368						; size = 4
tv330 = -368						; size = 4
tv358 = -362						; size = 2
tv327 = -362						; size = 2
tv350 = -360						; size = 8
tv319 = -360						; size = 8
tv399 = -356						; size = 8
tv376 = -356						; size = 8
tv346 = -352						; size = 4
tv315 = -352						; size = 4
tv157 = -352						; size = 4
tv74 = -352						; size = 4
_max_dim$1 = -152					; size = 4
_max_dim$2 = -140					; size = 4
_max_dimension_squared$ = -128				; size = 4
_cfg_sample_rate$ = -116				; size = 8
_framerate$ = -100					; size = 8
_cfg_samples$ = -84					; size = 8
_max_lps$ = -68						; size = 4
_max_lsr$ = -56						; size = 4
_lvl$ = -44						; size = 4
_lvl_idx$ = -29						; size = 1
_level_err_prefix$ = -20				; size = 4
_level_error$ = -8					; size = 4
_cfg$ = 8						; size = 4
_validate_hevc_level PROC				; COMDAT

; 1770 : static int validate_hevc_level(kvz_config *const cfg) {

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-376]
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 1771 :   static const struct { uint32_t lsr; uint32_t lps; uint32_t main_bitrate; } LEVEL_CONSTRAINTS[13] = {
; 1772 :     { 552960, 36864, 128 }, // 1
; 1773 : 
; 1774 :     { 3686400, 122880, 1500 }, // 2
; 1775 :     { 7372800, 245760, 3000 }, // 2.1
; 1776 : 
; 1777 :     { 16588800, 552960, 6000 },  // 3
; 1778 :     { 33177600, 983040, 10000 }, // 3.1
; 1779 : 
; 1780 :     { 66846720, 2228224, 12000 },  // 4
; 1781 :     { 133693440, 2228224, 20000 }, // 4.1
; 1782 : 
; 1783 :     { 267386880, 8912896, 25000 },  // 5
; 1784 :     { 534773760, 8912896, 40000 },  // 5.1
; 1785 :     { 1069547520, 8912896, 60000 }, // 5.2
; 1786 : 
; 1787 :     { 1069547520, 35651584, 60000 },  // 6
; 1788 :     { 2139095040, 35651584, 120000 }, // 6.1
; 1789 :     { 4278190080, 35651584, 240000 }, // 6.2
; 1790 :   };
; 1791 : 
; 1792 :   // bit rates for the high-tiers of the levels from 4 to 6.2
; 1793 :   static const uint32_t HIGH_TIER_BITRATES[8] = {
; 1794 :     30000, 50000, 100000, 160000, 240000, 240000, 480000, 800000
; 1795 :   };
; 1796 : 
; 1797 :   int level_error = 0;

	mov	DWORD PTR _level_error$[ebp], 0

; 1798 : 
; 1799 :   const char* level_err_prefix;
; 1800 :   if (cfg->force_level) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2417]
	test	ecx, ecx
	je	SHORT $LN4@validate_h

; 1801 :     level_err_prefix = "Level warning";

	mov	DWORD PTR _level_err_prefix$[ebp], OFFSET ??_C@_0O@DAGNOIGH@Level?5warning@

; 1802 :   } else {

	jmp	SHORT $LN5@validate_h
$LN4@validate_h:

; 1803 :     level_err_prefix = "Level error";

	mov	DWORD PTR _level_err_prefix$[ebp], OFFSET ??_C@_0M@HBAFJGPP@Level?5error@
$LN5@validate_h:

; 1804 :   }
; 1805 : 
; 1806 :   uint8_t lvl_idx;
; 1807 : 
; 1808 :   // for nicer error print
; 1809 :   float lvl = ((float)cfg->level) / 10.0f;

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2416]
	cvtsi2ss xmm0, ecx
	divss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _lvl$[ebp], xmm0

; 1810 : 
; 1811 :   // check if the level is valid and get it's lsr and lps values
; 1812 :   switch (cfg->level) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2416]
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR tv74[ebp]
	sub	edx, 10					; 0000000aH
	mov	DWORD PTR tv74[ebp], edx
	cmp	DWORD PTR tv74[ebp], 52			; 00000034H
	ja	SHORT $LN19@validate_h
	mov	eax, DWORD PTR tv74[ebp]
	movzx	ecx, BYTE PTR $LN33@validate_h[eax]
	jmp	DWORD PTR $LN34@validate_h[ecx*4]
$LN6@validate_h:

; 1813 :   case 10:
; 1814 :     lvl_idx = 0;

	mov	BYTE PTR _lvl_idx$[ebp], 0

; 1815 :     break;

	jmp	$LN2@validate_h
$LN7@validate_h:

; 1816 :   case 20:
; 1817 :     lvl_idx = 1;

	mov	BYTE PTR _lvl_idx$[ebp], 1

; 1818 :     break;

	jmp	SHORT $LN2@validate_h
$LN8@validate_h:

; 1819 :   case 21:
; 1820 :     lvl_idx = 2;

	mov	BYTE PTR _lvl_idx$[ebp], 2

; 1821 :     break;

	jmp	SHORT $LN2@validate_h
$LN9@validate_h:

; 1822 :   case 30:
; 1823 :     lvl_idx = 3;

	mov	BYTE PTR _lvl_idx$[ebp], 3

; 1824 :     break;

	jmp	SHORT $LN2@validate_h
$LN10@validate_h:

; 1825 :   case 31:
; 1826 :     lvl_idx = 4;

	mov	BYTE PTR _lvl_idx$[ebp], 4

; 1827 :     break;

	jmp	SHORT $LN2@validate_h
$LN11@validate_h:

; 1828 :   case 40:
; 1829 :     lvl_idx = 5;

	mov	BYTE PTR _lvl_idx$[ebp], 5

; 1830 :     break;

	jmp	SHORT $LN2@validate_h
$LN12@validate_h:

; 1831 :   case 41:
; 1832 :     lvl_idx = 6;

	mov	BYTE PTR _lvl_idx$[ebp], 6

; 1833 :     break;

	jmp	SHORT $LN2@validate_h
$LN13@validate_h:

; 1834 :   case 50:
; 1835 :     lvl_idx = 7;

	mov	BYTE PTR _lvl_idx$[ebp], 7

; 1836 :     break;

	jmp	SHORT $LN2@validate_h
$LN14@validate_h:

; 1837 :   case 51:
; 1838 :     lvl_idx = 8;

	mov	BYTE PTR _lvl_idx$[ebp], 8

; 1839 :     break;

	jmp	SHORT $LN2@validate_h
$LN15@validate_h:

; 1840 :   case 52:
; 1841 :     lvl_idx = 9;

	mov	BYTE PTR _lvl_idx$[ebp], 9

; 1842 :     break;

	jmp	SHORT $LN2@validate_h
$LN16@validate_h:

; 1843 :   case 60:
; 1844 :     lvl_idx = 10;

	mov	BYTE PTR _lvl_idx$[ebp], 10		; 0000000aH

; 1845 :     break;

	jmp	SHORT $LN2@validate_h
$LN17@validate_h:

; 1846 :   case 61:
; 1847 :     lvl_idx = 11;

	mov	BYTE PTR _lvl_idx$[ebp], 11		; 0000000bH

; 1848 :     break;

	jmp	SHORT $LN2@validate_h
$LN18@validate_h:

; 1849 :   case 62:
; 1850 :     lvl_idx = 12;

	mov	BYTE PTR _lvl_idx$[ebp], 12		; 0000000cH

; 1851 :     break;

	jmp	SHORT $LN2@validate_h
$LN19@validate_h:

; 1852 : 
; 1853 :   default:
; 1854 :     fprintf(stderr, "Input error: %g is an invalid level value\n", lvl);

	cvtss2sd xmm0, DWORD PTR _lvl$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CL@EKMHGODE@Input?5error?3?5?$CFg?5is?5an?5invalid?5l@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1855 :     return 1;

	mov	eax, 1
	jmp	$LN29@validate_h
$LN2@validate_h:

; 1856 :   }
; 1857 : 
; 1858 :   if (cfg->high_tier && cfg->level < 40) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2418]
	test	ecx, ecx
	je	SHORT $LN20@validate_h
	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2416]
	cmp	ecx, 40					; 00000028H
	jge	SHORT $LN20@validate_h

; 1859 :     fprintf(stderr, "Input error: high tier requires at least level 4\n");

	push	OFFSET ??_C@_0DC@JBLKDAIN@Input?5error?3?5high?5tier?5requires@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1860 :     return 1;

	mov	eax, 1
	jmp	$LN29@validate_h
$LN20@validate_h:

; 1861 :   }
; 1862 : 
; 1863 :   // max luma sample rate
; 1864 :   uint32_t max_lsr = LEVEL_CONSTRAINTS[lvl_idx].lsr;

	movzx	eax, BYTE PTR _lvl_idx$[ebp]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR ?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9[ecx]
	mov	DWORD PTR _max_lsr$[ebp], edx

; 1865 : 
; 1866 :   // max luma picture size
; 1867 :   uint32_t max_lps = LEVEL_CONSTRAINTS[lvl_idx].lps;

	movzx	eax, BYTE PTR _lvl_idx$[ebp]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR ?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9[ecx+4]
	mov	DWORD PTR _max_lps$[ebp], edx

; 1868 : 
; 1869 :   if (cfg->high_tier) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2418]
	test	ecx, ecx
	je	SHORT $LN21@validate_h

; 1870 :     cfg->max_bitrate = HIGH_TIER_BITRATES[lvl_idx - 5] * 1000;

	movzx	eax, BYTE PTR _lvl_idx$[ebp]
	imul	ecx, DWORD PTR ?HIGH_TIER_BITRATES@?1??validate_hevc_level@@9@9[eax*4-20], 1000
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+2420], ecx

; 1871 :   } else {

	jmp	SHORT $LN22@validate_h
$LN21@validate_h:

; 1872 :     cfg->max_bitrate = LEVEL_CONSTRAINTS[lvl_idx].main_bitrate * 1000;

	movzx	eax, BYTE PTR _lvl_idx$[ebp]
	imul	ecx, eax, 12
	imul	edx, DWORD PTR ?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9[ecx+8], 1000
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2420], edx
$LN22@validate_h:

; 1873 :   }
; 1874 : 
; 1875 :   if (cfg->target_bitrate > cfg->max_bitrate) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [eax+2328]
	cmp	edx, DWORD PTR [ecx+2420]
	jbe	SHORT $LN23@validate_h

; 1876 :     fprintf(stderr, "%s: target bitrate exceeds %i, which is the maximum %s tier level %g bitrate\n",

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2418]
	test	ecx, ecx
	je	SHORT $LN31@validate_h
	mov	DWORD PTR tv157[ebp], OFFSET ??_C@_04DGANLAON@high@
	jmp	SHORT $LN32@validate_h
$LN31@validate_h:
	mov	DWORD PTR tv157[ebp], OFFSET ??_C@_04GHJNJNPO@main@
$LN32@validate_h:
	cvtss2sd xmm0, DWORD PTR _lvl$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR tv157[ebp]
	push	edx
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2420]
	push	ecx
	mov	edx, DWORD PTR _level_err_prefix$[ebp]
	push	edx
	push	OFFSET ??_C@_0EO@PCCBAODD@?$CFs?3?5target?5bitrate?5exceeds?5?$CFi?0?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 28					; 0000001cH

; 1877 :       level_err_prefix, cfg->max_bitrate, cfg->high_tier?"high":"main", lvl);
; 1878 :     level_error = 1;

	mov	DWORD PTR _level_error$[ebp], 1
$LN23@validate_h:

; 1879 :   }
; 1880 : 
; 1881 :   // check the conformance to the level limits
; 1882 : 
; 1883 :   // luma samples
; 1884 :   uint64_t cfg_samples = cfg->width * cfg->height;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [eax+12]
	imul	eax, DWORD PTR [ecx+16]
	cdq
	mov	DWORD PTR _cfg_samples$[ebp], eax
	mov	DWORD PTR _cfg_samples$[ebp+4], edx

; 1885 : 
; 1886 :   // luma sample rate
; 1887 :   double framerate = ((double)cfg->framerate_num) / ((double)cfg->framerate_denom);

	mov	eax, DWORD PTR _cfg$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cvtsi2sd xmm1, DWORD PTR [ecx+36]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _framerate$[ebp], xmm0

; 1888 :   uint64_t cfg_sample_rate = cfg_samples * (uint64_t) framerate;

	movsd	xmm0, QWORD PTR _framerate$[ebp]
	call	__dtoul3
	push	edx
	push	eax
	mov	eax, DWORD PTR _cfg_samples$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _cfg_samples$[ebp]
	push	ecx
	call	__allmul
	mov	DWORD PTR _cfg_sample_rate$[ebp], eax
	mov	DWORD PTR _cfg_sample_rate$[ebp+4], edx

; 1889 : 
; 1890 :   // square of the maximum allowed dimension
; 1891 :   uint32_t max_dimension_squared = 8 * max_lps;

	mov	eax, DWORD PTR _max_lps$[ebp]
	shl	eax, 3
	mov	DWORD PTR _max_dimension_squared$[ebp], eax

; 1892 : 
; 1893 :   // check maximum dimensions
; 1894 :   if (cfg->width * cfg->width > max_dimension_squared) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [eax+12]
	imul	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _max_dimension_squared$[ebp]
	jbe	$LN24@validate_h

; 1895 :     uint32_t max_dim = sqrtf(max_dimension_squared);

	mov	eax, DWORD PTR _max_dimension_squared$[ebp]
	mov	DWORD PTR tv315[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv315[ebp]
	mov	ecx, DWORD PTR tv315[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv319[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv319[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_sqrtf
	add	esp, 4
	fnstcw	WORD PTR tv327[ebp]
	movzx	eax, WORD PTR tv327[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv330[ebp], eax
	fldcw	WORD PTR tv330[ebp]
	fistp	QWORD PTR tv332[ebp]
	fldcw	WORD PTR tv327[ebp]
	mov	edx, DWORD PTR tv332[ebp]
	mov	DWORD PTR _max_dim$2[ebp], edx

; 1896 :     fprintf(stderr, "%s: picture width of %i is too large for this level (%g), maximum dimension is %i\n",

	mov	eax, DWORD PTR _max_dim$2[ebp]
	push	eax
	cvtss2sd xmm0, DWORD PTR _lvl$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _level_err_prefix$[ebp]
	push	eax
	push	OFFSET ??_C@_0FD@NEFLHEJP@?$CFs?3?5picture?5width?5of?5?$CFi?5is?5too?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 28					; 0000001cH

; 1897 :       level_err_prefix, cfg->width, lvl, max_dim);
; 1898 :     level_error = 1;

	mov	DWORD PTR _level_error$[ebp], 1
$LN24@validate_h:

; 1899 :   }
; 1900 :   if (cfg->height * cfg->height > max_dimension_squared) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [eax+16]
	imul	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _max_dimension_squared$[ebp]
	jbe	$LN25@validate_h

; 1901 :     uint32_t max_dim = sqrtf(max_dimension_squared);

	mov	eax, DWORD PTR _max_dimension_squared$[ebp]
	mov	DWORD PTR tv346[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv346[ebp]
	mov	ecx, DWORD PTR tv346[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv350[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv350[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_sqrtf
	add	esp, 4
	fnstcw	WORD PTR tv358[ebp]
	movzx	eax, WORD PTR tv358[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv361[ebp], eax
	fldcw	WORD PTR tv361[ebp]
	fistp	QWORD PTR tv363[ebp]
	fldcw	WORD PTR tv358[ebp]
	mov	edx, DWORD PTR tv363[ebp]
	mov	DWORD PTR _max_dim$1[ebp], edx

; 1902 :     fprintf(stderr, "%s: picture height of %i is too large for this level (%g), maximum dimension is %i\n",

	mov	eax, DWORD PTR _max_dim$1[ebp]
	push	eax
	cvtss2sd xmm0, DWORD PTR _lvl$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _level_err_prefix$[ebp]
	push	eax
	push	OFFSET ??_C@_0FE@PIOPPNDJ@?$CFs?3?5picture?5height?5of?5?$CFi?5is?5too@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 28					; 0000001cH

; 1903 :       level_err_prefix, cfg->height, lvl, max_dim);
; 1904 :     level_error = 1;

	mov	DWORD PTR _level_error$[ebp], 1
$LN25@validate_h:

; 1905 :   }
; 1906 : 
; 1907 :   // check luma picture size
; 1908 :   if (cfg_samples > max_lps) {

	mov	eax, DWORD PTR _max_lps$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR tv376[ebp], eax
	mov	DWORD PTR tv376[ebp+4], ecx
	mov	edx, DWORD PTR _cfg_samples$[ebp+4]
	cmp	edx, DWORD PTR tv376[ebp+4]
	jb	SHORT $LN26@validate_h
	ja	SHORT $LN35@validate_h
	mov	eax, DWORD PTR _cfg_samples$[ebp]
	cmp	eax, DWORD PTR tv376[ebp]
	jbe	SHORT $LN26@validate_h
$LN35@validate_h:

; 1909 :     fprintf(stderr, "%s: picture resolution of %ix%i is too large for this level (%g) (it has %llu samples, maximum is %u samples)\n",

	mov	eax, DWORD PTR _max_lps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfg_samples$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _cfg_samples$[ebp]
	push	edx
	cvtss2sd xmm0, DWORD PTR _lvl$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _level_err_prefix$[ebp]
	push	ecx
	push	OFFSET ??_C@_0GP@PNEOCGC@?$CFs?3?5picture?5resolution?5of?5?$CFix?$CFi@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 40					; 00000028H

; 1910 :       level_err_prefix, cfg->width, cfg->height, lvl, (unsigned long long) cfg_samples, max_lps);
; 1911 :     level_error = 1;

	mov	DWORD PTR _level_error$[ebp], 1
$LN26@validate_h:

; 1912 :   }
; 1913 : 
; 1914 :   // check luma sample rate
; 1915 :   if (cfg_sample_rate > max_lsr) {

	mov	eax, DWORD PTR _max_lsr$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR tv399[ebp], eax
	mov	DWORD PTR tv399[ebp+4], ecx
	mov	edx, DWORD PTR _cfg_sample_rate$[ebp+4]
	cmp	edx, DWORD PTR tv399[ebp+4]
	jb	SHORT $LN27@validate_h
	ja	SHORT $LN36@validate_h
	mov	eax, DWORD PTR _cfg_sample_rate$[ebp]
	cmp	eax, DWORD PTR tv399[ebp]
	jbe	SHORT $LN27@validate_h
$LN36@validate_h:

; 1916 :     fprintf(stderr, "%s: framerate of %g is too big for this level (%g) and picture resolution (it has the sample rate of %llu, maximum is %u\n",

	mov	eax, DWORD PTR _max_lsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfg_sample_rate$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _cfg_sample_rate$[ebp]
	push	edx
	cvtss2sd xmm0, DWORD PTR _lvl$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _framerate$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _level_err_prefix$[ebp]
	push	eax
	push	OFFSET ??_C@_0HK@GAEEDBGA@?$CFs?3?5framerate?5of?5?$CFg?5is?5too?5big?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 40					; 00000028H

; 1917 :       level_err_prefix, framerate, lvl, (unsigned long long) cfg_sample_rate, max_lsr);
; 1918 :     level_error = 1;

	mov	DWORD PTR _level_error$[ebp], 1
$LN27@validate_h:

; 1919 :   }
; 1920 : 
; 1921 :   if (cfg->force_level) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2417]
	test	ecx, ecx
	je	SHORT $LN28@validate_h

; 1922 :     // we wanted to print warnings, not get errors
; 1923 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN29@validate_h

; 1924 :   } else {

	jmp	SHORT $LN29@validate_h
$LN28@validate_h:

; 1925 :     return level_error;

	mov	eax, DWORD PTR _level_error$[ebp]
$LN29@validate_h:

; 1926 :   }
; 1927 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 376				; 00000178H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN34@validate_h:
	DD	$LN6@validate_h
	DD	$LN7@validate_h
	DD	$LN8@validate_h
	DD	$LN9@validate_h
	DD	$LN10@validate_h
	DD	$LN11@validate_h
	DD	$LN12@validate_h
	DD	$LN13@validate_h
	DD	$LN14@validate_h
	DD	$LN15@validate_h
	DD	$LN16@validate_h
	DD	$LN17@validate_h
	DD	$LN18@validate_h
	DD	$LN19@validate_h
$LN33@validate_h:
	DB	0
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	1
	DB	2
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	3
	DB	4
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	5
	DB	6
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	7
	DB	8
	DB	9
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
_validate_hevc_level ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _parse_slice_specification
_TEXT	SEGMENT
_ret$1 = -120						; size = 4
_i$ = -108						; size = 4
_values$ = -96						; size = 64
_current_value$ = -24					; size = 4
_current_arg$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_arg$ = 8						; size = 4
_nslices$ = 12						; size = 4
_array$ = 16						; size = 4
_parse_slice_specification PROC				; COMDAT

; 383  : static int parse_slice_specification(const char* const arg, int32_t * const nslices, int32_t** const array) {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 384  :   const char* current_arg = NULL;

	mov	DWORD PTR _current_arg$[ebp], 0

; 385  :   int32_t current_value;
; 386  :   int32_t values[MAX_SLICES];
; 387  : 
; 388  :   int i;
; 389  : 
; 390  :   //Free pointer in any case
; 391  :   if (*array) {

	mov	eax, DWORD PTR _array$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@parse_slic

; 392  :     FREE_POINTER(*array);

	mov	esi, esp
	mov	eax, DWORD PTR _array$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _array$[ebp]
	mov	DWORD PTR [eax], 0
$LN8@parse_slic:

; 393  :   }
; 394  : 
; 395  :   //If the arg starts with u, we want an uniform split
; 396  :   if (arg[0]=='u') {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _arg$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 117				; 00000075H
	jne	SHORT $LN9@parse_slic

; 397  :     *nslices = atoi(arg+1);

	mov	eax, DWORD PTR _arg$[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _nslices$[ebp]
	mov	DWORD PTR [ecx], eax

; 398  :     if (MAX_SLICES <= *nslices || 0 >= *nslices) {

	mov	eax, DWORD PTR _nslices$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	jge	SHORT $LN11@parse_slic
	mov	eax, DWORD PTR _nslices$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN10@parse_slic
$LN11@parse_slic:

; 399  :       fprintf(stderr, "Invalid number of tiles (0 < %d <= %d = MAX_SLICES)!\n", *nslices + 1, MAX_SLICES);

	push	16					; 00000010H
	mov	eax, DWORD PTR _nslices$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_0DG@FHPHAOPI@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 400  :       return 0;

	xor	eax, eax
	jmp	$LN1@parse_slic
$LN10@parse_slic:

; 401  :     }
; 402  :     //Done with parsing
; 403  :     return 1;

	mov	eax, 1
	jmp	$LN1@parse_slic
$LN9@parse_slic:

; 404  :   }
; 405  : 
; 406  :   //We have a comma-separated list of int for the split...
; 407  :   current_arg = arg;

	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _current_arg$[ebp], eax

; 408  :   //We always have a slice starting at 0
; 409  :   values[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _values$[ebp+ecx], 0

; 410  :   *nslices = 1;

	mov	eax, DWORD PTR _nslices$[ebp]
	mov	DWORD PTR [eax], 1
$LN4@parse_slic:

; 411  :   do {
; 412  :     int ret = sscanf(current_arg, "%d", &current_value);

	lea	eax, DWORD PTR _current_value$[ebp]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	mov	ecx, DWORD PTR _current_arg$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$1[ebp], eax

; 413  :     if (ret != 1) {

	cmp	DWORD PTR _ret$1[ebp], 1
	je	SHORT $LN12@parse_slic

; 414  :       fprintf(stderr, "Could not parse integer \"%s\"!\n", current_arg);

	mov	eax, DWORD PTR _current_arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@MANPHOLJ@Could?5not?5parse?5integer?5?$CC?$CFs?$CC?$CB?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 415  :       return 0;

	xor	eax, eax
	jmp	$LN1@parse_slic
$LN12@parse_slic:

; 416  :     }
; 417  :     current_arg = strchr(current_arg, ',');

	push	44					; 0000002cH
	mov	eax, DWORD PTR _current_arg$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _current_arg$[ebp], eax

; 418  :     //Skip the , if we found one
; 419  :     if (current_arg) ++current_arg;

	cmp	DWORD PTR _current_arg$[ebp], 0
	je	SHORT $LN13@parse_slic
	mov	eax, DWORD PTR _current_arg$[ebp]
	add	eax, 1
	mov	DWORD PTR _current_arg$[ebp], eax
$LN13@parse_slic:

; 420  :     values[*nslices] = current_value;

	mov	eax, DWORD PTR _nslices$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _current_value$[ebp]
	mov	DWORD PTR _values$[ebp+ecx*4], edx

; 421  :     ++(*nslices);

	mov	eax, DWORD PTR _nslices$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _nslices$[ebp]
	mov	DWORD PTR [edx], ecx

; 422  :     if (MAX_SLICES <= *nslices) break;

	mov	eax, DWORD PTR _nslices$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	jl	SHORT $LN2@parse_slic
	jmp	SHORT $LN3@parse_slic
$LN2@parse_slic:

; 423  :   } while (current_arg);

	cmp	DWORD PTR _current_arg$[ebp], 0
	jne	$LN4@parse_slic
$LN3@parse_slic:

; 424  : 
; 425  :   if (MAX_SLICES <= *nslices || 0 >= *nslices) {

	mov	eax, DWORD PTR _nslices$[ebp]
	cmp	DWORD PTR [eax], 16			; 00000010H
	jge	SHORT $LN16@parse_slic
	mov	eax, DWORD PTR _nslices$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN15@parse_slic
$LN16@parse_slic:

; 426  :     fprintf(stderr, "Invalid number of slices (0 < %d <= %d = MAX_SLICES)!\n", *nslices, MAX_SLICES);

	push	16					; 00000010H
	mov	eax, DWORD PTR _nslices$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DH@HFPBGNIO@Invalid?5number?5of?5slices?5?$CI0?5?$DM?5?$CF@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 427  :     return 0;

	xor	eax, eax
	jmp	$LN1@parse_slic
$LN15@parse_slic:

; 428  :   }
; 429  : 
; 430  :   *array = MALLOC(int32_t, *nslices);

	mov	eax, DWORD PTR _nslices$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _array$[ebp]
	mov	DWORD PTR [edx], eax

; 431  :   if (!*array) {

	mov	eax, DWORD PTR _array$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN17@parse_slic

; 432  :     fprintf(stderr, "Could not allocate array for slices\n");

	push	OFFSET ??_C@_0CF@BNKABEII@Could?5not?5allocate?5array?5for?5sl@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 433  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@parse_slic
$LN17@parse_slic:

; 434  :   }
; 435  : 
; 436  :   //TODO: memcpy?
; 437  :   for (i = 0; i < *nslices; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@parse_slic
$LN5@parse_slic:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@parse_slic:
	mov	eax, DWORD PTR _nslices$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN6@parse_slic

; 438  :     (*array)[i] = values[i];

	mov	eax, DWORD PTR _array$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _values$[ebp+eax*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 439  :   }

	jmp	SHORT $LN5@parse_slic
$LN6@parse_slic:

; 440  : 
; 441  :   return 1;

	mov	eax, 1
$LN1@parse_slic:

; 442  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@parse_slic
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@parse_slic:
	DD	2
	DD	$LN21@parse_slic
$LN21@parse_slic:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN19@parse_slic
	DD	-96					; ffffffa0H
	DD	64					; 00000040H
	DD	$LN20@parse_slic
$LN20@parse_slic:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN19@parse_slic:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_parse_slice_specification ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _parse_pu_depth_list
_TEXT	SEGMENT
tv141 = -268						; size = 4
tv138 = -268						; size = 4
_retval$ = -68						; size = 4
_len$ = -56						; size = 4
_ptr$ = -44						; size = 4
_i$ = -32						; size = 4
_token$ = -20						; size = 4
_list$ = -8						; size = 4
_array$ = 8						; size = 4
_depths_min$ = 12					; size = 4
_depths_max$ = 16					; size = 4
_size$ = 20						; size = 4
_parse_pu_depth_list PROC				; COMDAT

; 345  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 346  :     char *list = strdup( array );

	mov	esi, esp
	mov	eax, DWORD PTR _array$[ebp]
	push	eax
	call	DWORD PTR __imp__strdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _list$[ebp], eax

; 347  :     char *token;
; 348  :     int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 349  :     int ptr = -1;

	mov	DWORD PTR _ptr$[ebp], -1

; 350  :     int len = strlen( list );

	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 351  :     int retval = 1;

	mov	DWORD PTR _retval$[ebp], 1

; 352  : 
; 353  :     //Reset depths in case multiple pu depth parameters are given
; 354  :     if(size > 1) memset( depths_max + 1, -1, (size - 1) * sizeof( *depths_max ) );

	cmp	DWORD PTR _size$[ebp], 1
	jle	SHORT $LN8@parse_pu_d
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [eax*4-4]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _depths_max$[ebp]
	add	edx, 4
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN8@parse_pu_d:

; 355  :     if(size > 1) memset( depths_min + 1, -1, (size - 1) * sizeof( *depths_min ) );

	cmp	DWORD PTR _size$[ebp], 1
	jle	SHORT $LN9@parse_pu_d
	mov	eax, DWORD PTR _size$[ebp]
	lea	ecx, DWORD PTR [eax*4-4]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _depths_min$[ebp]
	add	edx, 4
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN9@parse_pu_d:

; 356  : 
; 357  :     token = strtok( list, "," );

	mov	esi, esp
	push	OFFSET ??_C@_01IHBHIGKO@?0@
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	DWORD PTR __imp__strtok
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _token$[ebp], eax
$LN2@parse_pu_d:

; 358  :     while( ptr < len && list[ptr + 1] == ',' )

	mov	eax, DWORD PTR _ptr$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	SHORT $LN4@parse_pu_d
	mov	eax, DWORD PTR _list$[ebp]
	add	eax, DWORD PTR _ptr$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN4@parse_pu_d

; 359  :     {
; 360  :         i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 361  :         ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 362  :     }

	jmp	SHORT $LN2@parse_pu_d
$LN4@parse_pu_d:

; 363  :     while( retval && token != NULL && i < size ) {

	cmp	DWORD PTR _retval$[ebp], 0
	je	$LN5@parse_pu_d
	cmp	DWORD PTR _token$[ebp], 0
	je	$LN5@parse_pu_d
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	$LN5@parse_pu_d

; 364  :         retval &= (sscanf( token, "%d-%d", &depths_min[i], &depths_max[i] ) == 2);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _depths_max$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _depths_min$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_05BIKBEGBP@?$CFd?9?$CFd@
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_sscanf
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	SHORT $LN12@parse_pu_d
	mov	DWORD PTR tv138[ebp], 1
	jmp	SHORT $LN13@parse_pu_d
$LN12@parse_pu_d:
	mov	DWORD PTR tv138[ebp], 0
$LN13@parse_pu_d:
	mov	ecx, DWORD PTR _retval$[ebp]
	and	ecx, DWORD PTR tv138[ebp]
	mov	DWORD PTR _retval$[ebp], ecx

; 365  :         ptr += (retval ? 4 : 0);

	je	SHORT $LN14@parse_pu_d
	mov	DWORD PTR tv141[ebp], 4
	jmp	SHORT $LN15@parse_pu_d
$LN14@parse_pu_d:
	mov	DWORD PTR tv141[ebp], 0
$LN15@parse_pu_d:
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 366  :         i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 367  :         token = strtok( NULL, "," );

	mov	esi, esp
	push	OFFSET ??_C@_01IHBHIGKO@?0@
	push	0
	call	DWORD PTR __imp__strtok
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _token$[ebp], eax
$LN6@parse_pu_d:

; 368  :         while(ptr < len && list[ptr + 1] == ',' ){

	mov	eax, DWORD PTR _ptr$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jge	SHORT $LN7@parse_pu_d
	mov	eax, DWORD PTR _list$[ebp]
	add	eax, DWORD PTR _ptr$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN7@parse_pu_d

; 369  :           i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 370  :           ptr++;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR _ptr$[ebp], eax

; 371  :         }

	jmp	SHORT $LN6@parse_pu_d
$LN7@parse_pu_d:

; 372  :     }

	jmp	$LN4@parse_pu_d
$LN5@parse_pu_d:

; 373  : 
; 374  :     if( i >= size && ( token != NULL ) ) {

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jl	SHORT $LN10@parse_pu_d
	cmp	DWORD PTR _token$[ebp], 0
	je	SHORT $LN10@parse_pu_d

; 375  :         fprintf( stderr, "parsing failed : too many values.\n" );

	push	OFFSET ??_C@_0CD@ECPHFAHJ@parsing?5failed?5?3?5too?5many?5value@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 376  :         retval = 0;

	mov	DWORD PTR _retval$[ebp], 0
$LN10@parse_pu_d:

; 377  :     }
; 378  :     
; 379  :     free( list );

	mov	esi, esp
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 380  :     return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 381  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_parse_pu_depth_list ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _parse_array
_TEXT	SEGMENT
_i$ = -44						; size = 4
_token$ = -32						; size = 4
_delim$ = -20						; size = 4
_key$ = -8						; size = 4
_array$ = 8						; size = 4
_coeff_key$ = 12					; size = 4
_size$ = 16						; size = 4
_min$ = 20						; size = 4
_max$ = 24						; size = 4
_parse_array PROC					; COMDAT

; 314  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 315  :   char *key = strdup(array);

	mov	esi, esp
	mov	eax, DWORD PTR _array$[ebp]
	push	eax
	call	DWORD PTR __imp__strdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _key$[ebp], eax

; 316  :   const char delim[] = ",;:";

	mov	eax, DWORD PTR ??_C@_03DJMIOEGN@?0?$DL?3@
	mov	DWORD PTR _delim$[ebp], eax

; 317  :   char *token;
; 318  :   int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 319  : 
; 320  :   token = strtok(key, delim);

	mov	esi, esp
	lea	eax, DWORD PTR _delim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtok
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _token$[ebp], eax
$LN2@parse_arra:

; 321  :   while(token!=NULL&&i<size){

	cmp	DWORD PTR _token$[ebp], 0
	je	SHORT $LN3@parse_arra
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN3@parse_arra

; 322  :     if (!parse_uint8(token, &coeff_key[i], min, max))

	mov	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _min$[ebp]
	push	ecx
	mov	edx, DWORD PTR _coeff_key$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_parse_uint8
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN4@parse_arra

; 323  :     {
; 324  :       free(key);

	mov	esi, esp
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 325  :       return 0;

	xor	eax, eax
	jmp	$LN1@parse_arra
$LN4@parse_arra:

; 326  :     }
; 327  :     i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 328  :     token = strtok(NULL, delim);

	mov	esi, esp
	lea	eax, DWORD PTR _delim$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__strtok
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _token$[ebp], eax

; 329  :   }

	jmp	SHORT $LN2@parse_arra
$LN3@parse_arra:

; 330  :   if(i>=size && (token != NULL)){

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jl	SHORT $LN5@parse_arra
	cmp	DWORD PTR _token$[ebp], 0
	je	SHORT $LN5@parse_arra

; 331  :     fprintf(stderr, "parsing failed : too many members.\n");

	push	OFFSET ??_C@_0CE@EEGEPHM@parsing?5failed?5?3?5too?5many?5membe@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 332  :     free(key);

	mov	esi, esp
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 333  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@parse_arra

; 334  :   }

	jmp	SHORT $LN6@parse_arra
$LN5@parse_arra:

; 335  :   else if (i<size){

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN6@parse_arra

; 336  :     fprintf(stderr, "parsing failed : too few members.\n");

	push	OFFSET ??_C@_0CD@HHLLOAHB@parsing?5failed?5?3?5too?5few?5member@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 337  :     free(key);

	mov	esi, esp
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 338  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@parse_arra
$LN6@parse_arra:

; 339  :   }
; 340  :   free(key);

	mov	esi, esp
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 341  :   return 1;

	mov	eax, 1
$LN1@parse_arra:

; 342  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@parse_arra
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@parse_arra:
	DD	1
	DD	$LN10@parse_arra
$LN10@parse_arra:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN9@parse_arra
$LN9@parse_arra:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	0
_parse_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _parse_uint8
_TEXT	SEGMENT
_d$ = -20						; size = 4
_tail$ = -8						; size = 4
_numstr$ = 8						; size = 4
_number$ = 12						; size = 4
_min$ = 16						; size = 4
_max$ = 20						; size = 4
_parse_uint8 PROC					; COMDAT

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 298  :   char *tail;
; 299  :   int d = strtol(numstr, &tail, 10);

	mov	esi, esp
	push	10					; 0000000aH
	lea	eax, DWORD PTR _tail$[ebp]
	push	eax
	mov	ecx, DWORD PTR _numstr$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _d$[ebp], eax

; 300  :   if (*tail || d < min || d > max){

	mov	eax, DWORD PTR _tail$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@parse_uint
	mov	eax, DWORD PTR _d$[ebp]
	cmp	eax, DWORD PTR _min$[ebp]
	jl	SHORT $LN4@parse_uint
	mov	eax, DWORD PTR _d$[ebp]
	cmp	eax, DWORD PTR _max$[ebp]
	jle	SHORT $LN2@parse_uint
$LN4@parse_uint:

; 301  :     fprintf(stderr, "Expected number between %d and %d\n", min, max);

	mov	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _min$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@LGDHHOIJ@Expected?5number?5between?5?$CFd?5and?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 302  :     if(number)

	cmp	DWORD PTR _number$[ebp], 0
	je	SHORT $LN5@parse_uint

; 303  :       *number = 0;

	mov	eax, DWORD PTR _number$[ebp]
	mov	BYTE PTR [eax], 0
$LN5@parse_uint:

; 304  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@parse_uint

; 305  :   } else{

	jmp	SHORT $LN1@parse_uint
$LN2@parse_uint:

; 306  :     if (number)

	cmp	DWORD PTR _number$[ebp], 0
	je	SHORT $LN6@parse_uint

; 307  :       *number = (uint8_t) d;

	mov	eax, DWORD PTR _number$[ebp]
	mov	cl, BYTE PTR _d$[ebp]
	mov	BYTE PTR [eax], cl
$LN6@parse_uint:

; 308  :     return 1;

	mov	eax, 1
$LN1@parse_uint:

; 309  :   }
; 310  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@parse_uint
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@parse_uint:
	DD	1
	DD	$LN9@parse_uint
$LN9@parse_uint:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN8@parse_uint
$LN8@parse_uint:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	0
_parse_uint8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _parse_tiles_specification
_TEXT	SEGMENT
_ret$1 = -248						; size = 4
_i$ = -236						; size = 4
_values$ = -224						; size = 192
_current_value$ = -24					; size = 4
_current_arg$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_arg$ = 8						; size = 4
_ntiles$ = 12						; size = 4
_array$ = 16						; size = 4
_parse_tiles_specification PROC				; COMDAT

; 237  : static int parse_tiles_specification(const char* const arg, int32_t * const ntiles, int32_t** const array) {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 238  :   const char* current_arg = NULL;

	mov	DWORD PTR _current_arg$[ebp], 0

; 239  :   int32_t current_value;
; 240  :   int32_t values[MAX_TILES_PER_DIM];
; 241  : 
; 242  :   int i;
; 243  : 
; 244  :   //Free pointer in any case
; 245  :   if (*array) {

	mov	eax, DWORD PTR _array$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@parse_tile

; 246  :     FREE_POINTER(*array);

	mov	esi, esp
	mov	eax, DWORD PTR _array$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _array$[ebp]
	mov	DWORD PTR [eax], 0
$LN8@parse_tile:

; 247  :   }
; 248  : 
; 249  :   //If the arg starts with u, we want an uniform split
; 250  :   if (arg[0]=='u') {

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _arg$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 117				; 00000075H
	jne	SHORT $LN9@parse_tile

; 251  :     *ntiles = atoi(arg + 1);

	mov	eax, DWORD PTR _arg$[ebp]
	add	eax, 1
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _ntiles$[ebp]
	mov	DWORD PTR [ecx], eax

; 252  :     if (MAX_TILES_PER_DIM <= *ntiles || 1 >= *ntiles) {

	mov	eax, DWORD PTR _ntiles$[ebp]
	cmp	DWORD PTR [eax], 48			; 00000030H
	jge	SHORT $LN11@parse_tile
	mov	eax, DWORD PTR _ntiles$[ebp]
	cmp	DWORD PTR [eax], 1
	jg	SHORT $LN10@parse_tile
$LN11@parse_tile:

; 253  :       fprintf(stderr, "Invalid number of tiles (1 <= %d <= %d = MAX_TILES_PER_DIM)!\n", *ntiles, MAX_TILES_PER_DIM);

	push	48					; 00000030H
	mov	eax, DWORD PTR _ntiles$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DO@DGIKDOFG@Invalid?5number?5of?5tiles?5?$CI1?5?$DM?$DN?5?$CF@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 254  :       return 0;

	xor	eax, eax
	jmp	$LN1@parse_tile
$LN10@parse_tile:

; 255  :     }
; 256  :     //Done with parsing
; 257  :     return 1;

	mov	eax, 1
	jmp	$LN1@parse_tile
$LN9@parse_tile:

; 258  :   }
; 259  : 
; 260  :   //We have a comma-separated list of int for the split...
; 261  :   current_arg = arg;

	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _current_arg$[ebp], eax

; 262  :   *ntiles = 1;

	mov	eax, DWORD PTR _ntiles$[ebp]
	mov	DWORD PTR [eax], 1
$LN4@parse_tile:

; 263  :   do {
; 264  :     int ret = sscanf(current_arg, "%d", &current_value);

	lea	eax, DWORD PTR _current_value$[ebp]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	mov	ecx, DWORD PTR _current_arg$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ret$1[ebp], eax

; 265  :     if (ret != 1) {

	cmp	DWORD PTR _ret$1[ebp], 1
	je	SHORT $LN12@parse_tile

; 266  :       fprintf(stderr, "Could not parse integer \"%s\"!\n", current_arg);

	mov	eax, DWORD PTR _current_arg$[ebp]
	push	eax
	push	OFFSET ??_C@_0BP@MANPHOLJ@Could?5not?5parse?5integer?5?$CC?$CFs?$CC?$CB?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 267  :       return 0;

	xor	eax, eax
	jmp	$LN1@parse_tile
$LN12@parse_tile:

; 268  :     }
; 269  :     current_arg = strchr(current_arg, ',');

	push	44					; 0000002cH
	mov	eax, DWORD PTR _current_arg$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _current_arg$[ebp], eax

; 270  :     //Skip the , if we found one
; 271  :     if (current_arg) ++current_arg;

	cmp	DWORD PTR _current_arg$[ebp], 0
	je	SHORT $LN13@parse_tile
	mov	eax, DWORD PTR _current_arg$[ebp]
	add	eax, 1
	mov	DWORD PTR _current_arg$[ebp], eax
$LN13@parse_tile:

; 272  :     values[*ntiles - 1] = current_value;

	mov	eax, DWORD PTR _ntiles$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _current_value$[ebp]
	mov	DWORD PTR _values$[ebp+ecx*4-4], edx

; 273  :     ++(*ntiles);

	mov	eax, DWORD PTR _ntiles$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ntiles$[ebp]
	mov	DWORD PTR [edx], ecx

; 274  :     if (MAX_TILES_PER_DIM <= *ntiles) break;

	mov	eax, DWORD PTR _ntiles$[ebp]
	cmp	DWORD PTR [eax], 48			; 00000030H
	jl	SHORT $LN2@parse_tile
	jmp	SHORT $LN3@parse_tile
$LN2@parse_tile:

; 275  :   } while (current_arg);

	cmp	DWORD PTR _current_arg$[ebp], 0
	jne	$LN4@parse_tile
$LN3@parse_tile:

; 276  : 
; 277  :   if (MAX_TILES_PER_DIM <= *ntiles || 1 >= *ntiles) {

	mov	eax, DWORD PTR _ntiles$[ebp]
	cmp	DWORD PTR [eax], 48			; 00000030H
	jge	SHORT $LN16@parse_tile
	mov	eax, DWORD PTR _ntiles$[ebp]
	cmp	DWORD PTR [eax], 1
	jg	SHORT $LN15@parse_tile
$LN16@parse_tile:

; 278  :     fprintf(stderr, "Invalid number of tiles (1 <= %d <= %d = MAX_TILES_PER_DIM)!\n", *ntiles, MAX_TILES_PER_DIM);

	push	48					; 00000030H
	mov	eax, DWORD PTR _ntiles$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DO@DGIKDOFG@Invalid?5number?5of?5tiles?5?$CI1?5?$DM?$DN?5?$CF@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 279  :     return 0;

	xor	eax, eax
	jmp	$LN1@parse_tile
$LN15@parse_tile:

; 280  :   }
; 281  : 
; 282  :   *array = MALLOC(int32_t, *ntiles - 1);

	mov	eax, DWORD PTR _ntiles$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx*4-4]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _array$[ebp]
	mov	DWORD PTR [ecx], eax

; 283  :   if (!*array) {

	mov	eax, DWORD PTR _array$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN17@parse_tile

; 284  :     fprintf(stderr, "Could not allocate array for tiles\n");

	push	OFFSET ??_C@_0CE@GJGGGHOC@Could?5not?5allocate?5array?5for?5ti@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 285  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@parse_tile
$LN17@parse_tile:

; 286  :   }
; 287  : 
; 288  :   //TODO: memcpy?
; 289  :   for (i = 0; i < *ntiles - 1; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@parse_tile
$LN5@parse_tile:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@parse_tile:
	mov	eax, DWORD PTR _ntiles$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN6@parse_tile

; 290  :     (*array)[i] = values[i];

	mov	eax, DWORD PTR _array$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _values$[ebp+eax*4]
	mov	DWORD PTR [ecx+edx*4], eax

; 291  :   }

	jmp	SHORT $LN5@parse_tile
$LN6@parse_tile:

; 292  : 
; 293  :   return 1;

	mov	eax, 1
$LN1@parse_tile:

; 294  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@parse_tile
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN22@parse_tile:
	DD	2
	DD	$LN21@parse_tile
$LN21@parse_tile:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN19@parse_tile
	DD	-224					; ffffff20H
	DD	192					; 000000c0H
	DD	$LN20@parse_tile
$LN20@parse_tile:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN19@parse_tile:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_parse_tiles_specification ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _parse_enum
_TEXT	SEGMENT
_arg$ = 8						; size = 4
_names$ = 12						; size = 4
_dst$ = 16						; size = 4
_parse_enum PROC					; COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 234  :   return parse_enum_n(arg, 255, names, dst);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _names$[ebp]
	push	ecx
	push	255					; 000000ffH
	mov	edx, DWORD PTR _arg$[ebp]
	push	edx
	call	_parse_enum_n
	add	esp, 16					; 00000010H

; 235  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_parse_enum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _parse_enum_n
_TEXT	SEGMENT
_i$ = -5						; size = 1
_arg$ = 8						; size = 4
_num_chars$ = 12					; size = 4
_names$ = 16						; size = 4
_dst$ = 20						; size = 4
_parse_enum_n PROC					; COMDAT

; 220  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 221  :   int8_t i;
; 222  :   for (i = 0; names[i]; i++) {

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN4@parse_enum
$LN2@parse_enum:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN4@parse_enum:
	movsx	eax, BYTE PTR _i$[ebp]
	mov	ecx, DWORD PTR _names$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN3@parse_enum

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	esi, esp
	mov	eax, DWORD PTR _num_chars$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _i$[ebp]
	mov	edx, DWORD PTR _names$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _arg$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN5@parse_enum

; 224  :       *dst = i;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	cl, BYTE PTR _i$[ebp]
	mov	BYTE PTR [eax], cl

; 225  :       return 1;

	mov	eax, 1
	jmp	SHORT $LN1@parse_enum
$LN5@parse_enum:

; 226  :     }
; 227  :   }

	jmp	SHORT $LN2@parse_enum
$LN3@parse_enum:

; 228  : 
; 229  :   return 0;

	xor	eax, eax
$LN1@parse_enum:

; 230  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_parse_enum_n ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _atobool
_TEXT	SEGMENT
_str$ = 8						; size = 4
_atobool PROC						; COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 208  :   if (!strcmp(str, "1")    ||
; 209  :       !strcmp(str, "true") ||

	push	OFFSET ??_C@_01HIHLOKLC@1@
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@atobool
	push	OFFSET ??_C@_04LOAJBDKD@true@
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@atobool
	push	OFFSET ??_C@_03ICICOMAL@yes@
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@atobool
$LN3@atobool:

; 210  :       !strcmp(str, "yes"))
; 211  :     return 1;

	mov	eax, 1
	jmp	SHORT $LN1@atobool
$LN2@atobool:

; 212  :   if (!strcmp(str, "0")     ||
; 213  :       !strcmp(str, "false") ||

	push	OFFSET ??_C@_01GBGANLPD@0@
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@atobool
	push	OFFSET ??_C@_05LAPONLG@false@
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@atobool
	push	OFFSET ??_C@_02KAJCLHKP@no@
	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@atobool
$LN5@atobool:

; 214  :       !strcmp(str, "no"))
; 215  :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@atobool
$LN4@atobool:

; 216  :   return 0;

	xor	eax, eax
$LN1@atobool:

; 217  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_atobool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv72 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 759  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E2865EBA_corecrt_math@h
	call	@__CheckForDebuggerJustMyCode@4

; 760  :             return (float)sqrt(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv72[ebp]
	fld	DWORD PTR tv72[ebp]

; 761  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _kvz_config_validate
_TEXT	SEGMENT
tv266 = -304						; size = 4
tv699 = -300						; size = 8
tv267 = -300						; size = 4
tv592 = -296						; size = 4
tv261 = -296						; size = 4
_prev_tile_split$1 = -96				; size = 4
_i$2 = -84						; size = 4
_prev_tile_split$3 = -72				; size = 4
_i$4 = -60						; size = 4
_i$5 = -48						; size = 4
_num_lcus$6 = -36					; size = 8
_max_lcus$7 = -20					; size = 4
_error$ = -8						; size = 4
_cfg$ = 8						; size = 4
_kvz_config_validate PROC				; COMDAT

; 1533 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 1534 :   int error = 0;

	mov	DWORD PTR _error$[ebp], 0

; 1535 : 
; 1536 :   if (cfg->vaq < 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2436], 0
	jge	SHORT $LN11@kvz_config

; 1537 :     fprintf(stderr, "vaq strength must be positive\n");

	push	OFFSET ??_C@_0BP@JEBBPBKL@vaq?5strength?5must?5be?5positive?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1538 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN11@kvz_config:

; 1539 :   }
; 1540 : 
; 1541 :   if (cfg->width <= 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jg	SHORT $LN12@kvz_config

; 1542 :     fprintf(stderr, "Input error: width must be positive\n");

	push	OFFSET ??_C@_0CF@OMEIPLBB@Input?5error?3?5width?5must?5be?5posi@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1543 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN12@kvz_config:

; 1544 :   }
; 1545 : 
; 1546 :   if (cfg->height <= 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jg	SHORT $LN13@kvz_config

; 1547 :     fprintf(stderr, "Input error: height must be positive\n");

	push	OFFSET ??_C@_0CG@DKOBNDGB@Input?5error?3?5height?5must?5be?5pos@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1548 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN13@kvz_config:

; 1549 :   }
; 1550 : 
; 1551 :   if (cfg->width % 2 != 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN77@kvz_config
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN77@kvz_config:
	test	ecx, ecx
	je	SHORT $LN14@kvz_config

; 1552 :     fprintf(stderr, "Input error: width must be a multiple of two\n");

	push	OFFSET ??_C@_0CO@GFBEMOHN@Input?5error?3?5width?5must?5be?5a?5mu@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1553 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN14@kvz_config:

; 1554 :   }
; 1555 : 
; 1556 :   if (cfg->height % 2 != 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN78@kvz_config
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN78@kvz_config:
	test	ecx, ecx
	je	SHORT $LN15@kvz_config

; 1557 :     fprintf(stderr, "Input error: height must be a multiple of two\n");

	push	OFFSET ??_C@_0CP@KJHABNME@Input?5error?3?5height?5must?5be?5a?5m@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1558 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN15@kvz_config:

; 1559 :   }
; 1560 : 
; 1561 :   if (cfg->width > 0 && cfg->height > 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jle	$LN17@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jle	$LN17@kvz_config

; 1562 :     // We must be able to store the total number of luma and chroma pixels
; 1563 :     // in an int32_t. For 4:4:4 chroma mode, the number of pixels is
; 1564 :     // 3 * width * height. Width and height are rounded up to a multiple of
; 1565 :     // LCU size.
; 1566 :     const uint32_t max_lcus = INT_MAX / (3 * LCU_WIDTH * LCU_WIDTH);

	mov	DWORD PTR _max_lcus$7[ebp], 174762	; 0002aaaaH

; 1567 :     const uint64_t num_lcus = CEILDIV((uint64_t)cfg->width,  LCU_WIDTH) *

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [eax+12]
	cdq
	add	eax, 64					; 00000040H
	adc	edx, 0
	sub	eax, 1
	sbb	edx, 0
	push	0
	push	64					; 00000040H
	push	edx
	push	eax
	call	__aulldiv
	mov	esi, eax
	mov	edi, edx
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	cdq
	add	eax, 64					; 00000040H
	adc	edx, 0
	sub	eax, 1
	sbb	edx, 0
	push	0
	push	64					; 00000040H
	push	edx
	push	eax
	call	__aulldiv
	push	edx
	push	eax
	push	edi
	push	esi
	call	__allmul
	mov	DWORD PTR _num_lcus$6[ebp], eax
	mov	DWORD PTR _num_lcus$6[ebp+4], edx

; 1568 :                               CEILDIV((uint64_t)cfg->height, LCU_WIDTH);
; 1569 :     if (num_lcus > max_lcus) {

	mov	eax, DWORD PTR _max_lcus$7[ebp]
	xor	ecx, ecx
	mov	DWORD PTR tv699[ebp], eax
	mov	DWORD PTR tv699[ebp+4], ecx
	mov	edx, DWORD PTR _num_lcus$6[ebp+4]
	cmp	edx, DWORD PTR tv699[ebp+4]
	jb	SHORT $LN17@kvz_config
	ja	SHORT $LN76@kvz_config
	mov	eax, DWORD PTR _num_lcus$6[ebp]
	cmp	eax, DWORD PTR tv699[ebp]
	jbe	SHORT $LN17@kvz_config
$LN76@kvz_config:

; 1570 :       fprintf(stderr, "Input error: resolution %dx%d too large (max %u CTUs)\n",

	mov	eax, DWORD PTR _max_lcus$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET ??_C@_0DH@KHFKCHDG@Input?5error?3?5resolution?5?$CFdx?$CFd?5t@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H

; 1571 :               cfg->width, cfg->height, max_lcus);
; 1572 :       error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN17@kvz_config:

; 1573 :     }
; 1574 :   }
; 1575 : 
; 1576 :   if (cfg->framerate < 0.0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR [eax+24]
	jbe	SHORT $LN18@kvz_config

; 1577 :     fprintf(stderr, "Input error: --input-fps must be positive\n");

	push	OFFSET ??_C@_0CL@MFFDCLEO@Input?5error?3?5?9?9input?9fps?5must?5b@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1578 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN18@kvz_config:

; 1579 :   }
; 1580 :   if (cfg->framerate_num < 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jge	SHORT $LN19@kvz_config

; 1581 :     fprintf(stderr, "Input error: --input-fps must >=0\n");

	push	OFFSET ??_C@_0CD@JGPJBDLD@Input?5error?3?5?9?9input?9fps?5must?5?$DO@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1582 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN19@kvz_config:

; 1583 :   }
; 1584 :   if (cfg->framerate_denom <= 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jg	SHORT $LN20@kvz_config

; 1585 :     fprintf(stderr, "Input error: --input-fps denominator must be >0\n");

	push	OFFSET ??_C@_0DB@OHGHIGBP@Input?5error?3?5?9?9input?9fps?5denomi@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1586 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN20@kvz_config:

; 1587 :   }
; 1588 : 
; 1589 :   if (cfg->gop_len &&
; 1590 :       cfg->intra_period > 1 &&
; 1591 :       !cfg->gop_lowdelay &&

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	test	ecx, ecx
	je	SHORT $LN21@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jle	SHORT $LN21@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+277]
	test	ecx, ecx
	jne	SHORT $LN21@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cdq
	idiv	ecx
	test	edx, edx
	je	SHORT $LN21@kvz_config

; 1592 :       cfg->intra_period % cfg->gop_len != 0)
; 1593 :   {
; 1594 :     fprintf(stderr,

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	push	ecx
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_0EE@OGJFAANK@Input?5error?3?5intra?5period?5?$CI?$CFd?$CJ?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1595 :             "Input error: intra period (%d) not a multiple of B-gop length (%d)\n",
; 1596 :             cfg->intra_period,
; 1597 :             cfg->gop_len);
; 1598 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN21@kvz_config:

; 1599 :   }
; 1600 : 
; 1601 :   if (cfg->ref_frames  < 1 || cfg->ref_frames >= MAX_REF_PIC_COUNT) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+128], 1
	jl	SHORT $LN23@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+128], 16			; 00000010H
	jl	SHORT $LN22@kvz_config
$LN23@kvz_config:

; 1602 :     fprintf(stderr, "Input error: --ref out of range [1..%d]\n", MAX_REF_PIC_COUNT - 1);

	push	15					; 0000000fH
	push	OFFSET ??_C@_0CJ@NGKFCDI@Input?5error?3?5?9?9ref?5out?5of?5range@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1603 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN22@kvz_config:

; 1604 :   }
; 1605 : 
; 1606 :   if (cfg->deblock_beta  < -6 || cfg->deblock_beta  > 6) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+96], -6			; fffffffaH
	jl	SHORT $LN25@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+96], 6
	jle	SHORT $LN24@kvz_config
$LN25@kvz_config:

; 1607 :     fprintf(stderr, "Input error: deblock beta parameter out of range [-6..6]\n");

	push	OFFSET ??_C@_0DK@DNPIANBN@Input?5error?3?5deblock?5beta?5param@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1608 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN24@kvz_config:

; 1609 :   }
; 1610 :   if (cfg->deblock_tc < -6 || cfg->deblock_tc > 6) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+100], -6			; fffffffaH
	jl	SHORT $LN27@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+100], 6
	jle	SHORT $LN26@kvz_config
$LN27@kvz_config:

; 1611 :     fprintf(stderr, "Input error: deblock tc parameter out of range [-6..6]\n");

	push	OFFSET ??_C@_0DI@JGCJLIIK@Input?5error?3?5deblock?5tc?5paramet@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1612 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN26@kvz_config:

; 1613 :   }
; 1614 : 
; 1615 :   if (cfg->rdo < 0 || cfg->rdo > 3) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jl	SHORT $LN29@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+64], 3
	jle	SHORT $LN28@kvz_config
$LN29@kvz_config:

; 1616 :     fprintf(stderr, "Input error: --rd parameter out of range [0..3]\n");

	push	OFFSET ??_C@_0DB@HNDIADEB@Input?5error?3?5?9?9rd?5parameter?5out@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1617 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN28@kvz_config:

; 1618 :   }
; 1619 : 
; 1620 :   if (cfg->tr_depth_intra < 0 || cfg->tr_depth_intra > 4) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+76], 0
	jl	SHORT $LN31@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+76], 4
	jle	SHORT $LN30@kvz_config
$LN31@kvz_config:

; 1621 :     // range is 0 .. CtbLog2SizeY - Log2MinTrafoSize
; 1622 :     fprintf(stderr, "Input error: --tr-depth-intra is out of range [0..4]\n");

	push	OFFSET ??_C@_0DG@GLNCMIMA@Input?5error?3?5?9?9tr?9depth?9intra?5i@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1623 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN30@kvz_config:

; 1624 :   }
; 1625 : 
; 1626 :   if (cfg->fme_level != 0 && cfg->fme_level > 4) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN32@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+84], 4
	jle	SHORT $LN32@kvz_config

; 1627 :     fprintf(stderr, "Input error: invalid --subme parameter (must be in range 0-4)\n");

	push	OFFSET ??_C@_0DP@IKGAFMJE@Input?5error?3?5invalid?5?9?9subme?5pa@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1628 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN32@kvz_config:

; 1629 :   }
; 1630 : 
; 1631 :   if (cfg->vui.chroma_loc < 0 || cfg->vui.chroma_loc > 5) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+120], 0
	jl	SHORT $LN34@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+120], 5
	jle	SHORT $LN33@kvz_config
$LN34@kvz_config:

; 1632 :     fprintf(stderr, "Input error: --chromaloc parameter out of range [0..5]\n");

	push	OFFSET ??_C@_0DI@LFNPHAFJ@Input?5error?3?5?9?9chromaloc?5parame@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1633 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN33@kvz_config:

; 1634 :   }
; 1635 : 
; 1636 :   if (cfg->owf < -1) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+156], -1
	jge	SHORT $LN35@kvz_config

; 1637 :     fprintf(stderr, "Input error: --owf must be nonnegative or -1\n");

	push	OFFSET ??_C@_0CO@KAPDACLP@Input?5error?3?5?9?9owf?5must?5be?5nonn@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1638 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN35@kvz_config:

; 1639 :   }
; 1640 : 
; 1641 :   if (cfg->qp != CLIP_TO_QP(cfg->qp)) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax], 51			; 00000033H
	jle	SHORT $LN68@kvz_config
	mov	DWORD PTR tv261[ebp], 51		; 00000033H
	jmp	SHORT $LN69@kvz_config
$LN68@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv261[ebp], edx
$LN69@kvz_config:
	cmp	DWORD PTR tv261[ebp], 0
	jge	SHORT $LN72@kvz_config
	mov	DWORD PTR tv267[ebp], 0
	jmp	SHORT $LN73@kvz_config
$LN72@kvz_config:
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax], 51			; 00000033H
	jle	SHORT $LN70@kvz_config
	mov	DWORD PTR tv266[ebp], 51		; 00000033H
	jmp	SHORT $LN71@kvz_config
$LN70@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv266[ebp], edx
$LN71@kvz_config:
	mov	eax, DWORD PTR tv266[ebp]
	mov	DWORD PTR tv267[ebp], eax
$LN73@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR tv267[ebp]
	je	SHORT $LN36@kvz_config

; 1642 :       fprintf(stderr, "Input error: --qp parameter out of range [0..51]\n");

	push	OFFSET ??_C@_0DC@FAGGEHMD@Input?5error?3?5?9?9qp?5parameter?5out@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1643 :       error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN36@kvz_config:

; 1644 :   }
; 1645 : 
; 1646 :   if (abs(cfg->intra_qp_offset) > 51) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2428]
	push	ecx
	call	_abs
	add	esp, 4
	cmp	eax, 51					; 00000033H
	jle	SHORT $LN37@kvz_config

; 1647 :     fprintf(stderr, "Input error: --intra-qp-offset out of range [-51..51]\n");

	push	OFFSET ??_C@_0DH@KOCLFKPI@Input?5error?3?5?9?9intra?9qp?9offset?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1648 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN37@kvz_config:

; 1649 :   }
; 1650 : 
; 1651 :   if (cfg->target_bitrate < 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2328], 0
	jge	SHORT $LN38@kvz_config

; 1652 :       fprintf(stderr, "Input error: --bitrate must be nonnegative\n");

	push	OFFSET ??_C@_0CM@CKIEFPCC@Input?5error?3?5?9?9bitrate?5must?5be?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1653 :       error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN38@kvz_config:

; 1654 :   }
; 1655 : 
; 1656 :   for( size_t i = 0; i < KVZ_MAX_GOP_LAYERS; i++ )

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN4@kvz_config
$LN2@kvz_config:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN4@kvz_config:
	cmp	DWORD PTR _i$5[ebp], 6
	jae	$LN3@kvz_config

; 1657 :   {
; 1658 :       if( cfg->pu_depth_inter.min[i] < 0 || cfg->pu_depth_inter.max[i] < 0 ) continue;

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+176], 0
	jl	SHORT $LN40@kvz_config
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+200], 0
	jge	SHORT $LN39@kvz_config
$LN40@kvz_config:
	jmp	SHORT $LN2@kvz_config
$LN39@kvz_config:

; 1659 : 
; 1660 :       if( !WITHIN( cfg->pu_depth_inter.min[i], PU_DEPTH_INTER_MIN, PU_DEPTH_INTER_MAX ) ||

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+176], 0
	jl	SHORT $LN44@kvz_config
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+176], 3
	jg	SHORT $LN44@kvz_config
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+200], 0
	jl	SHORT $LN44@kvz_config
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+200], 3
	jle	SHORT $LN41@kvz_config
$LN44@kvz_config:

; 1661 :           !WITHIN( cfg->pu_depth_inter.max[i], PU_DEPTH_INTER_MIN, PU_DEPTH_INTER_MAX ) )
; 1662 :       {
; 1663 :           fprintf( stderr, "Input error: illegal value for --pu-depth-inter (%d-%d)\n",

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+200]
	push	edx
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+176]
	push	edx
	push	OFFSET ??_C@_0DJ@PFNAMAHF@Input?5error?3?5illegal?5value?5for?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1664 :                    cfg->pu_depth_inter.min[i], cfg->pu_depth_inter.max[i] );
; 1665 :           error = 1;

	mov	DWORD PTR _error$[ebp], 1

; 1666 :       }

	jmp	SHORT $LN45@kvz_config
$LN41@kvz_config:

; 1667 :       else if( cfg->pu_depth_inter.min[i] > cfg->pu_depth_inter.max[i] )

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR _i$5[ebp]
	mov	esi, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+176]
	cmp	eax, DWORD PTR [esi+edx*4+200]
	jle	SHORT $LN45@kvz_config

; 1668 :       {
; 1669 :           fprintf( stderr, "Input error: Inter PU depth min (%d) > max (%d)\n",

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+200]
	push	edx
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+176]
	push	edx
	push	OFFSET ??_C@_0DB@NKPLDKGC@Input?5error?3?5Inter?5PU?5depth?5min@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1670 :                    cfg->pu_depth_inter.min[i], cfg->pu_depth_inter.max[i] );
; 1671 :           error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN45@kvz_config:

; 1672 :       }
; 1673 : 
; 1674 :       if( cfg->pu_depth_intra.min[i] < 0 || cfg->pu_depth_intra.max[i] < 0 ) continue;

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+224], 0
	jl	SHORT $LN47@kvz_config
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+248], 0
	jge	SHORT $LN46@kvz_config
$LN47@kvz_config:
	jmp	$LN2@kvz_config
$LN46@kvz_config:

; 1675 : 
; 1676 :       if( !WITHIN( cfg->pu_depth_intra.min[i], PU_DEPTH_INTRA_MIN, PU_DEPTH_INTRA_MAX ) ||

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+224], 0
	jl	SHORT $LN51@kvz_config
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+224], 4
	jg	SHORT $LN51@kvz_config
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+248], 0
	jl	SHORT $LN51@kvz_config
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+248], 4
	jle	SHORT $LN48@kvz_config
$LN51@kvz_config:

; 1677 :           !WITHIN( cfg->pu_depth_intra.max[i], PU_DEPTH_INTRA_MIN, PU_DEPTH_INTRA_MAX ) )
; 1678 :       {
; 1679 :           fprintf( stderr, "Input error: illegal value for --pu-depth-intra (%d-%d)\n",

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+248]
	push	edx
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+224]
	push	edx
	push	OFFSET ??_C@_0DJ@LKEEGGMM@Input?5error?3?5illegal?5value?5for?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1680 :                    cfg->pu_depth_intra.min[i], cfg->pu_depth_intra.max[i] );
; 1681 :           error = 1;

	mov	DWORD PTR _error$[ebp], 1

; 1682 :       }

	jmp	SHORT $LN52@kvz_config
$LN48@kvz_config:

; 1683 :       else if( cfg->pu_depth_intra.min[i] > cfg->pu_depth_intra.max[i] )

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR _i$5[ebp]
	mov	esi, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+224]
	cmp	eax, DWORD PTR [esi+edx*4+248]
	jle	SHORT $LN52@kvz_config

; 1684 :       {
; 1685 :           fprintf( stderr, "Input error: Intra PU depth min (%d) > max (%d)\n",

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+248]
	push	edx
	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+224]
	push	edx
	push	OFFSET ??_C@_0DB@FHKLKNFP@Input?5error?3?5Intra?5PU?5depth?5min@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1686 :                    cfg->pu_depth_intra.min[i], cfg->pu_depth_intra.max[i] );
; 1687 :           error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN52@kvz_config:

; 1688 :       }
; 1689 :   }

	jmp	$LN2@kvz_config
$LN3@kvz_config:

; 1690 : 
; 1691 :   // Tile separation should be at round position in terms of LCU, should be monotonic, and should not start by 0
; 1692 :   if (cfg->tiles_width_split) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	$LN56@kvz_config

; 1693 :     int i;
; 1694 :     int32_t prev_tile_split = 0;

	mov	DWORD PTR _prev_tile_split$3[ebp], 0

; 1695 :     for (i=0; i < cfg->tiles_width_count - 1; ++i) {

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN7@kvz_config
$LN5@kvz_config:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN7@kvz_config:
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	sub	ecx, 1
	cmp	DWORD PTR _i$4[ebp], ecx
	jge	$LN6@kvz_config

; 1696 :       if (cfg->tiles_width_split[i] <= prev_tile_split) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _prev_tile_split$3[ebp]
	jg	SHORT $LN54@kvz_config

; 1697 :         fprintf(stderr, "Input error: tile separations in width should be strictly monotonic (%d <= %d)\n", cfg->tiles_width_split[i], prev_tile_split);

	mov	eax, DWORD PTR _prev_tile_split$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	push	OFFSET ??_C@_0FA@LCOPIJJ@Input?5error?3?5tile?5separations?5i@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1698 :         error = 1;

	mov	DWORD PTR _error$[ebp], 1

; 1699 :         break;

	jmp	SHORT $LN6@kvz_config
$LN54@kvz_config:

; 1700 :       }
; 1701 :       if ((cfg->tiles_width_split[i] % LCU_WIDTH) != 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, -2147483585			; 8000003fH
	jns	SHORT $LN79@kvz_config
	dec	eax
	or	eax, -64				; ffffffc0H
	inc	eax
$LN79@kvz_config:
	test	eax, eax
	je	SHORT $LN55@kvz_config

; 1702 :         fprintf(stderr, "Input error: tile separation in width %d (at %d) is not at a multiple of LCU_WIDTH (%d)\n", i, cfg->tiles_width_split[i], LCU_WIDTH);

	push	64					; 00000040H
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _i$4[ebp]
	push	ecx
	push	OFFSET ??_C@_0FJ@MPOEBHAH@Input?5error?3?5tile?5separation?5in@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H

; 1703 :         error = 1;

	mov	DWORD PTR _error$[ebp], 1

; 1704 :         break;

	jmp	SHORT $LN6@kvz_config
$LN55@kvz_config:

; 1705 :       }
; 1706 :       prev_tile_split = cfg->tiles_width_split[i];

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _prev_tile_split$3[ebp], eax

; 1707 :     }

	jmp	$LN5@kvz_config
$LN6@kvz_config:

; 1708 :     if (cfg->tiles_width_split[cfg->tiles_width_count - 2] >= cfg->width) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4-8]
	cmp	eax, DWORD PTR [edx+12]
	jl	SHORT $LN56@kvz_config

; 1709 :       fprintf(stderr, "Input error: last x tile separation in width (%d) should smaller than image width (%d)\n", cfg->tiles_width_split[cfg->tiles_width_count - 2], cfg->width);

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR [edx+eax*4-8]
	push	eax
	push	OFFSET ??_C@_0FI@JACDALLH@Input?5error?3?5last?5x?5tile?5separa@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1710 :       error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN56@kvz_config:

; 1711 :     }
; 1712 :   }
; 1713 : 
; 1714 :   if (cfg->tiles_height_split) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+148], 0
	je	$LN60@kvz_config

; 1715 :     int i;
; 1716 :     int32_t prev_tile_split = 0;

	mov	DWORD PTR _prev_tile_split$1[ebp], 0

; 1717 :     for (i=0; i < cfg->tiles_height_count - 1; ++i) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN10@kvz_config
$LN8@kvz_config:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN10@kvz_config:
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	sub	ecx, 1
	cmp	DWORD PTR _i$2[ebp], ecx
	jge	$LN9@kvz_config

; 1718 :       if (cfg->tiles_height_split[i] <= prev_tile_split) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _prev_tile_split$1[ebp]
	jg	SHORT $LN58@kvz_config

; 1719 :         fprintf(stderr, "Input error: tile separations in height should be strictly monotonic (%d <= %d)\n", cfg->tiles_height_split[i], prev_tile_split);

	mov	eax, DWORD PTR _prev_tile_split$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	push	OFFSET ??_C@_0FB@HNBMALLF@Input?5error?3?5tile?5separations?5i@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1720 :         error = 1;

	mov	DWORD PTR _error$[ebp], 1

; 1721 :         break;

	jmp	SHORT $LN9@kvz_config
$LN58@kvz_config:

; 1722 :       }
; 1723 :       if ((cfg->tiles_height_split[i] % LCU_WIDTH) != 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, -2147483585			; 8000003fH
	jns	SHORT $LN80@kvz_config
	dec	eax
	or	eax, -64				; ffffffc0H
	inc	eax
$LN80@kvz_config:
	test	eax, eax
	je	SHORT $LN59@kvz_config

; 1724 :         fprintf(stderr, "Input error: tile separation in height %d (at %d) is not at a multiple of LCU_WIDTH (%d)\n", i, cfg->tiles_height_split[i], LCU_WIDTH);

	push	64					; 00000040H
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	push	OFFSET ??_C@_0FK@OICNJKMA@Input?5error?3?5tile?5separation?5in@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 20					; 00000014H

; 1725 :         error = 1;

	mov	DWORD PTR _error$[ebp], 1

; 1726 :         break;

	jmp	SHORT $LN9@kvz_config
$LN59@kvz_config:

; 1727 :       }
; 1728 :       prev_tile_split = cfg->tiles_height_split[i];

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _prev_tile_split$1[ebp], eax

; 1729 :     }

	jmp	$LN8@kvz_config
$LN9@kvz_config:

; 1730 : 
; 1731 :     if (cfg->tiles_height_split[cfg->tiles_height_count - 2] >= cfg->height) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4-8]
	cmp	eax, DWORD PTR [edx+16]
	jl	SHORT $LN60@kvz_config

; 1732 :       fprintf(stderr, "Input error: last tile separation in height (%d) should smaller than image height (%d)\n", cfg->tiles_height_split[cfg->tiles_height_count - 2], cfg->height);

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx+eax*4-8]
	push	eax
	push	OFFSET ??_C@_0FI@DKIHBBFK@Input?5error?3?5last?5tile?5separati@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1733 :       error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN60@kvz_config:

; 1734 :     }
; 1735 :   }
; 1736 : 
; 1737 :   if (cfg->implicit_rdpcm && !cfg->lossless) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2392], 0
	je	SHORT $LN61@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2364], 0
	jne	SHORT $LN61@kvz_config

; 1738 :     fprintf(stderr, "Input error: --implicit-rdpcm is not suppoted without --lossless\n");

	push	OFFSET ??_C@_0EC@FFAECHHG@Input?5error?3?5?9?9implicit?9rdpcm?5i@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1739 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN61@kvz_config:

; 1740 :   }
; 1741 : 
; 1742 :   if ((cfg->slices & KVZ_SLICES_WPP) && !cfg->wpp) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2408]
	and	ecx, 2
	je	SHORT $LN62@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+152], 0
	jne	SHORT $LN62@kvz_config

; 1743 :     fprintf(stderr, "Input error: --slices=wpp does not work without --wpp.\n");

	push	OFFSET ??_C@_0DI@CDMPKDBM@Input?5error?3?5?9?9slices?$DNwpp?5does?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1744 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN62@kvz_config:

; 1745 :   }
; 1746 : 
; 1747 :   if ((cfg->scaling_list == KVZ_SCALING_LIST_CUSTOM) && !cfg->cqmfile) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2440]
	cmp	ecx, 1
	jne	SHORT $LN63@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+132], 0
	jne	SHORT $LN63@kvz_config

; 1748 :     fprintf(stderr, "Input error: --scaling-list=custom does not work without --cqmfile=<FILE>.\n");

	push	OFFSET ??_C@_0EM@GGPOIEDD@Input?5error?3?5?9?9scaling?9list?$DNcus@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1749 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN63@kvz_config:

; 1750 :   }
; 1751 : 
; 1752 :   if (validate_hevc_level((kvz_config *const) cfg)) {

	mov	eax, DWORD PTR _cfg$[ebp]
	push	eax
	call	_validate_hevc_level
	add	esp, 4
	test	eax, eax
	je	SHORT $LN64@kvz_config

; 1753 :     // a level error found and it's not okay
; 1754 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN64@kvz_config:

; 1755 :   }
; 1756 : 
; 1757 :   if(cfg->target_bitrate > 0 && cfg->rc_algorithm == KVZ_NO_RC) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2328], 0
	jle	SHORT $LN65@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2452]
	test	ecx, ecx
	jne	SHORT $LN65@kvz_config

; 1758 :     fprintf(stderr, "Bitrate set but rc-algorithm is turned off.\n");

	push	OFFSET ??_C@_0CN@OHMNFLAG@Bitrate?5set?5but?5rc?9algorithm?5is@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1759 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN65@kvz_config:

; 1760 :   }
; 1761 : 
; 1762 :   if(cfg->target_bitrate == 0 && cfg->rc_algorithm != KVZ_NO_RC) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2328], 0
	jne	SHORT $LN66@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2452]
	test	ecx, ecx
	je	SHORT $LN66@kvz_config

; 1763 :     fprintf(stderr, "Rate control algorithm set but bitrate not set.\n");

	push	OFFSET ??_C@_0DB@KOOPKHAF@Rate?5control?5algorithm?5set?5but?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1764 :     error = 1;

	mov	DWORD PTR _error$[ebp], 1
$LN66@kvz_config:

; 1765 :   }
; 1766 : 
; 1767 :   return !error;

	cmp	DWORD PTR _error$[ebp], 0
	jne	SHORT $LN74@kvz_config
	mov	DWORD PTR tv592[ebp], 1
	jmp	SHORT $LN75@kvz_config
$LN74@kvz_config:
	mov	DWORD PTR tv592[ebp], 0
$LN75@kvz_config:
	mov	eax, DWORD PTR tv592[ebp]

; 1768 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_config_validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _kvz_config_process_lp_gop
_TEXT	SEGMENT
_gop_pic$1 = -168					; size = 4
_g$2 = -156						; size = 4
_i$3 = -144						; size = 4
_keyframe$4 = -132					; size = 4
_r$5 = -120						; size = 4
_gop_layer$6 = -108					; size = 4
_gop_pic$7 = -96					; size = 4
_g$8 = -84						; size = 4
_d$9 = -72						; size = 4
_depth_modulos$ = -60					; size = 32
_gop$ = -20						; size = 12
__$ArrayPad$ = -4					; size = 4
_cfg$ = 8						; size = 4
_kvz_config_process_lp_gop PROC				; COMDAT

; 1433 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-364]
	mov	ecx, 91					; 0000005bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 1434 :   struct {
; 1435 :     unsigned g;
; 1436 :     unsigned d;
; 1437 :     unsigned t;
; 1438 :   } gop;
; 1439 : 
; 1440 :   gop.g = cfg->gop_len;

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	mov	DWORD PTR _gop$[ebp], ecx

; 1441 :   gop.d = cfg->gop_lp_definition.d;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2384]
	mov	DWORD PTR _gop$[ebp+4], ecx

; 1442 :   gop.t = cfg->gop_lp_definition.t;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2388]
	mov	DWORD PTR _gop$[ebp+8], ecx

; 1443 : 
; 1444 :   // Initialize modulos for testing depth.
; 1445 :   // The picture belong to the lowest depth in which (poc % modulo) == 0.
; 1446 :   unsigned depth_modulos[8] = { 0 };

	xor	eax, eax
	mov	DWORD PTR _depth_modulos$[ebp], eax
	mov	DWORD PTR _depth_modulos$[ebp+4], eax
	mov	DWORD PTR _depth_modulos$[ebp+8], eax
	mov	DWORD PTR _depth_modulos$[ebp+12], eax
	mov	DWORD PTR _depth_modulos$[ebp+16], eax
	mov	DWORD PTR _depth_modulos$[ebp+20], eax
	mov	DWORD PTR _depth_modulos$[ebp+24], eax
	mov	DWORD PTR _depth_modulos$[ebp+28], eax

; 1447 :   for (int d = 0; d < gop.d; ++d) {

	mov	DWORD PTR _d$9[ebp], 0
	jmp	SHORT $LN4@kvz_config
$LN2@kvz_config:
	mov	eax, DWORD PTR _d$9[ebp]
	add	eax, 1
	mov	DWORD PTR _d$9[ebp], eax
$LN4@kvz_config:
	mov	eax, DWORD PTR _d$9[ebp]
	cmp	eax, DWORD PTR _gop$[ebp+4]
	jae	SHORT $LN3@kvz_config

; 1448 :     depth_modulos[gop.d - 1 - d] = 1 << d;

	mov	eax, 1
	mov	ecx, DWORD PTR _d$9[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _gop$[ebp+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _d$9[ebp]
	mov	DWORD PTR _depth_modulos$[ebp+ecx*4], eax

; 1449 :   }

	jmp	SHORT $LN2@kvz_config
$LN3@kvz_config:

; 1450 :   depth_modulos[0] = gop.g;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gop$[ebp]
	mov	DWORD PTR _depth_modulos$[ebp+ecx], edx

; 1451 : 
; 1452 :   cfg->gop_lowdelay = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+277], 1

; 1453 :   cfg->gop_len = gop.g;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cl, BYTE PTR _gop$[ebp]
	mov	BYTE PTR [eax+276], cl

; 1454 :   for (int g = 1; g <= gop.g; ++g) {

	mov	DWORD PTR _g$8[ebp], 1
	jmp	SHORT $LN7@kvz_config
$LN5@kvz_config:
	mov	eax, DWORD PTR _g$8[ebp]
	add	eax, 1
	mov	DWORD PTR _g$8[ebp], eax
$LN7@kvz_config:
	mov	eax, DWORD PTR _g$8[ebp]
	cmp	eax, DWORD PTR _gop$[ebp]
	ja	$LN6@kvz_config

; 1455 :     kvz_gop_config *gop_pic = &cfg->gop[g - 1];

	mov	eax, DWORD PTR _g$8[ebp]
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _cfg$[ebp]
	lea	edx, DWORD PTR [ecx+eax+280]
	mov	DWORD PTR _gop_pic$7[ebp], edx

; 1456 : 
; 1457 :     // Find gop depth for picture.
; 1458 :     int gop_layer = 1;

	mov	DWORD PTR _gop_layer$6[ebp], 1
$LN8@kvz_config:

; 1459 :     while (gop_layer < gop.d && (g % depth_modulos[gop_layer - 1])) {

	mov	eax, DWORD PTR _gop_layer$6[ebp]
	cmp	eax, DWORD PTR _gop$[ebp+4]
	jae	SHORT $LN9@kvz_config
	mov	ecx, DWORD PTR _gop_layer$6[ebp]
	mov	eax, DWORD PTR _g$8[ebp]
	xor	edx, edx
	div	DWORD PTR _depth_modulos$[ebp+ecx*4-4]
	test	edx, edx
	je	SHORT $LN9@kvz_config

; 1460 :       ++gop_layer;

	mov	eax, DWORD PTR _gop_layer$6[ebp]
	add	eax, 1
	mov	DWORD PTR _gop_layer$6[ebp], eax

; 1461 :     }

	jmp	SHORT $LN8@kvz_config
$LN9@kvz_config:

; 1462 : 
; 1463 :     gop_pic->poc_offset = g;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	mov	cl, BYTE PTR _g$8[ebp]
	mov	BYTE PTR [eax+9], cl

; 1464 :     gop_pic->layer = gop_layer;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	mov	cl, BYTE PTR _gop_layer$6[ebp]
	mov	BYTE PTR [eax+10], cl

; 1465 :     gop_pic->qp_offset = gop_layer;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	mov	cl, BYTE PTR _gop_layer$6[ebp]
	mov	BYTE PTR [eax+8], cl

; 1466 :     gop_pic->ref_pos_count = 0;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	mov	BYTE PTR [eax+12], 0

; 1467 :     gop_pic->ref_neg_count = cfg->ref_frames;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	dl, BYTE PTR [ecx+128]
	mov	BYTE PTR [eax+29], dl

; 1468 :     gop_pic->is_ref = 0;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	mov	BYTE PTR [eax+11], 0

; 1469 : 
; 1470 :     // Set first ref to point to previous frame, and the rest to previous
; 1471 :     // key-frames.
; 1472 :     // If gop.t > 1, have (poc % gop.t) == 0 point gop.t frames away,
; 1473 :     // instead of the previous frame. Set the frames in between to
; 1474 :     // point to the nearest frame with a lower gop-depth.
; 1475 :     if (gop.t > 1) {

	cmp	DWORD PTR _gop$[ebp+8], 1
	jbe	$LN20@kvz_config

; 1476 :       if (gop_pic->poc_offset % gop.t == 0) {

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	eax, BYTE PTR [eax+9]
	xor	edx, edx
	div	DWORD PTR _gop$[ebp+8]
	test	edx, edx
	jne	SHORT $LN22@kvz_config

; 1477 :         gop_pic->ref_neg[0] = gop.t;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gop_pic$7[ebp]
	mov	al, BYTE PTR _gop$[ebp+8]
	mov	BYTE PTR [edx+ecx+30], al

; 1478 :       } else {

	jmp	$LN26@kvz_config
$LN22@kvz_config:

; 1479 :         int r = gop_pic->poc_offset - 1;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	ecx, BYTE PTR [eax+9]
	sub	ecx, 1
	mov	DWORD PTR _r$5[ebp], ecx
$LN10@kvz_config:

; 1480 :         while (r > 0) {

	cmp	DWORD PTR _r$5[ebp], 0
	jle	SHORT $LN11@kvz_config

; 1481 :           if (cfg->gop[r].layer < gop_pic->layer) break;

	mov	eax, DWORD PTR _r$5[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _cfg$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+290]
	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	edx, ecx
	jge	SHORT $LN24@kvz_config
	jmp	SHORT $LN11@kvz_config
$LN24@kvz_config:

; 1482 :           --r;

	mov	eax, DWORD PTR _r$5[ebp]
	sub	eax, 1
	mov	DWORD PTR _r$5[ebp], eax

; 1483 :         }

	jmp	SHORT $LN10@kvz_config
$LN11@kvz_config:

; 1484 :         // Var r is now 0 or index of the pic with layer < depth.
; 1485 :         if (cfg->gop[r].layer < gop_pic->layer) {

	mov	eax, DWORD PTR _r$5[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _cfg$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+290]
	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	edx, ecx
	jge	SHORT $LN25@kvz_config

; 1486 :           gop_pic->ref_neg[0] = gop_pic->poc_offset - cfg->gop[r].poc_offset;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	ecx, BYTE PTR [eax+9]
	mov	edx, DWORD PTR _r$5[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	edx, BYTE PTR [eax+edx+289]
	sub	ecx, edx
	mov	eax, 1
	imul	edx, eax, 0
	mov	eax, DWORD PTR _gop_pic$7[ebp]
	mov	BYTE PTR [eax+edx+30], cl

; 1487 :           cfg->gop[r].is_ref = 1;

	mov	eax, DWORD PTR _r$5[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [ecx+eax+291], 1

; 1488 :         } else {

	jmp	SHORT $LN26@kvz_config
$LN25@kvz_config:

; 1489 :           // No ref was found, just refer to the previous key-frame.
; 1490 :           gop_pic->ref_neg[0] = gop_pic->poc_offset % gop.g;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	eax, BYTE PTR [eax+9]
	xor	edx, edx
	div	DWORD PTR _gop$[ebp]
	mov	ecx, 1
	imul	eax, ecx, 0
	mov	ecx, DWORD PTR _gop_pic$7[ebp]
	mov	BYTE PTR [ecx+eax+30], dl
$LN26@kvz_config:

; 1491 :         }
; 1492 :       }
; 1493 :     } else {

	jmp	SHORT $LN27@kvz_config
$LN20@kvz_config:

; 1494 :       gop_pic->ref_neg[0] = 1;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _gop_pic$7[ebp]
	mov	BYTE PTR [edx+ecx+30], 1

; 1495 :       if (gop_pic->poc_offset >= 2) {

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	ecx, BYTE PTR [eax+9]
	cmp	ecx, 2
	jl	SHORT $LN27@kvz_config

; 1496 :         cfg->gop[gop_pic->poc_offset - 2].is_ref = 1;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	ecx, BYTE PTR [eax+9]
	sub	ecx, 2
	shl	ecx, 6
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [edx+ecx+291], 1
$LN27@kvz_config:

; 1497 :       }
; 1498 :     }
; 1499 : 
; 1500 :     int keyframe = gop_pic->poc_offset;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	ecx, BYTE PTR [eax+9]
	mov	DWORD PTR _keyframe$4[ebp], ecx

; 1501 :     for (int i = 1; i < gop_pic->ref_neg_count; ++i) {

	mov	DWORD PTR _i$3[ebp], 1
	jmp	SHORT $LN14@kvz_config
$LN12@kvz_config:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN14@kvz_config:
	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsx	ecx, BYTE PTR [eax+29]
	cmp	DWORD PTR _i$3[ebp], ecx
	jge	SHORT $LN13@kvz_config
$LN15@kvz_config:

; 1502 :       while (keyframe == gop_pic->ref_neg[i - 1]) {

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	movsx	ecx, BYTE PTR [eax+29]
	cmp	DWORD PTR _keyframe$4[ebp], ecx
	jne	SHORT $LN16@kvz_config

; 1503 :         keyframe += gop.g;

	mov	eax, DWORD PTR _keyframe$4[ebp]
	add	eax, DWORD PTR _gop$[ebp]
	mov	DWORD PTR _keyframe$4[ebp], eax

; 1504 :       }

	jmp	SHORT $LN15@kvz_config
$LN16@kvz_config:

; 1505 :       gop_pic->ref_neg[i] = keyframe;

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	mov	cl, BYTE PTR _keyframe$4[ebp]
	mov	BYTE PTR [eax+30], cl

; 1506 :     }

	jmp	SHORT $LN12@kvz_config
$LN13@kvz_config:

; 1507 : 
; 1508 :     gop_pic->qp_factor = 0.4624;  // from HM

	mov	eax, DWORD PTR _gop_pic$7[ebp]
	movsd	xmm0, QWORD PTR __real@3fdd97f62b6ae7d5
	movsd	QWORD PTR [eax], xmm0

; 1509 :   }

	jmp	$LN5@kvz_config
$LN6@kvz_config:

; 1510 : 
; 1511 :   for (int g = 0; g < gop.g; ++g) {

	mov	DWORD PTR _g$2[ebp], 0
	jmp	SHORT $LN19@kvz_config
$LN17@kvz_config:
	mov	eax, DWORD PTR _g$2[ebp]
	add	eax, 1
	mov	DWORD PTR _g$2[ebp], eax
$LN19@kvz_config:
	mov	eax, DWORD PTR _g$2[ebp]
	cmp	eax, DWORD PTR _gop$[ebp]
	jae	SHORT $LN18@kvz_config

; 1512 :     kvz_gop_config *gop_pic = &cfg->gop[g];

	mov	eax, DWORD PTR _g$2[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _cfg$[ebp]
	lea	edx, DWORD PTR [ecx+eax+280]
	mov	DWORD PTR _gop_pic$1[ebp], edx

; 1513 :     if (!gop_pic->is_ref) {

	mov	eax, DWORD PTR _gop_pic$1[ebp]
	movsx	ecx, BYTE PTR [eax+11]
	test	ecx, ecx
	jne	SHORT $LN28@kvz_config

; 1514 :       gop_pic->qp_factor = 0.68 * 1.31;  // derived from HM

	mov	eax, DWORD PTR _gop_pic$1[ebp]
	movsd	xmm0, QWORD PTR __real@3fec816f0068db8d
	movsd	QWORD PTR [eax], xmm0
$LN28@kvz_config:

; 1515 :     }
; 1516 :   }

	jmp	SHORT $LN17@kvz_config
$LN18@kvz_config:

; 1517 : 
; 1518 :   // Key-frame is always a reference.
; 1519 :   cfg->gop[gop.g - 1].is_ref = 1;

	mov	eax, DWORD PTR _gop$[ebp]
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [ecx+eax+291], 1

; 1520 :   cfg->gop[gop.g - 1].qp_factor = 0.578;  // from HM

	mov	eax, DWORD PTR _gop$[ebp]
	sub	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _cfg$[ebp]
	movsd	xmm0, QWORD PTR __real@3fe27ef9db22d0e5
	movsd	QWORD PTR [ecx+eax+280], xmm0

; 1521 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN33@kvz_config
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 364				; 0000016cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN33@kvz_config:
	DD	2
	DD	$LN32@kvz_config
$LN32@kvz_config:
	DD	-20					; ffffffecH
	DD	12					; 0000000cH
	DD	$LN30@kvz_config
	DD	-60					; ffffffc4H
	DD	32					; 00000020H
	DD	$LN31@kvz_config
$LN31@kvz_config:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
$LN30@kvz_config:
	DB	103					; 00000067H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	0
_kvz_config_process_lp_gop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _kvz_config_parse
_TEXT	SEGMENT
tv1328 = -1056						; size = 4
tv1684 = -1052						; size = 8
tv1329 = -1052						; size = 4
tv1496 = -1048						; size = 4
tv1465 = -1048						; size = 4
tv1455 = -1048						; size = 4
tv1350 = -1048						; size = 4
tv1340 = -1048						; size = 4
tv1325 = -1048						; size = 4
tv1213 = -1048						; size = 4
tv1140 = -1048						; size = 4
tv1129 = -1048						; size = 4
tv993 = -1048						; size = 4
tv840 = -1048						; size = 4
tv368 = -1048						; size = 4
tv256 = -1048						; size = 4
tv245 = -1048						; size = 4
tv234 = -1048						; size = 4
tv215 = -1048						; size = 4
tv138 = -1048						; size = 4
tv75 = -1048						; size = 4
_file_format$1 = -653					; size = 1
_rc_algorithm$2 = -641					; size = 1
_fullHeight$3 = -632					; size = 4
_fullWidth$4 = -620					; size = 4
_firstCTU_y$5 = -608					; size = 4
_firstCTU_x$6 = -596					; size = 4
_max_merge$7 = -584					; size = 4
_steps$8 = -572						; size = 4
_tailptr$9 = -560					; size = 4
_matched_amount$10 = -548				; size = 4
_level$11 = -536					; size = 4
_num_second$12 = -524					; size = 4
_num_first$13 = -512					; size = 4
_number$14 = -500					; size = 4
_i$15 = -488						; size = 4
_dqp_array$16 = -476					; size = 4
_size$17 = -464						; size = 4
_height$18 = -452					; size = 4
_width$19 = -440					; size = 4
_f$20 = -428						; size = 4
_format$21 = -413					; size = 1
_result$22 = -404					; size = 4
_mode$23 = -389						; size = 1
_size_key$24 = -380					; size = 4
_encryption_compiled_in$25 = -365			; size = 1
_num_chars$26 = -356					; size = 4
_feature$27 = -341					; size = 1
_toggle$28 = -329					; size = 1
_cur$29 = -320						; size = 4
_token_begin$30 = -308					; size = 4
_result$31 = -296					; size = 4
_mode$32 = -281						; size = 1
_result$33 = -272					; size = 4
_hash$34 = -257						; size = 1
_preset_value$35 = -248					; size = 4
_preset_line$36 = -236					; size = 4
_gop$37 = -224						; size = 12
_height$38 = -204					; size = 4
_width$39 = -192					; size = 4
_retval$40 = -180					; size = 4
_retval$41 = -168					; size = 4
_result$42 = -156					; size = 4
_scaling_list$43 = -141					; size = 1
_fastrd_learning_outdir_fn$44 = -132			; size = 4
_fast_coeff_table_fn$45 = -120				; size = 4
_cqmfile$46 = -108					; size = 4
_result$47 = -96					; size = 4
_constraint$48 = -81					; size = 1
_ime_algorithm$49 = -69					; size = 1
_sao_type$50 = -57					; size = 1
_tc$51 = -48						; size = 4
_beta$52 = -36						; size = 4
_fps_denom$53 = -24					; size = 4
_fps_num$54 = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_cfg$ = 8						; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_kvz_config_parse PROC					; COMDAT

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1056				; 00000420H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1056]
	mov	ecx, 264				; 00000108H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 446  :   static const char * const me_names[]          = { "hexbs", "tz", "full", "full8", "full16", "full32", "full64", "dia", NULL };
; 447  :   static const char * const source_scan_type_names[] = { "progressive", "tff", "bff", NULL };
; 448  : 
; 449  :   static const char * const overscan_names[]    = { "undef", "show", "crop", NULL };
; 450  :   static const char * const videoformat_names[] = { "component", "pal", "ntsc", "secam", "mac", "undef", NULL };
; 451  :   static const char * const range_names[]       = { "tv", "pc", NULL };
; 452  :   static const char * const colorprim_names[]   = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m",
; 453  :                                                     "smpte240m", "film", "bt2020", NULL };
; 454  :   static const char * const transfer_names[]    = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m",
; 455  :                                                     "smpte240m", "linear", "log100", "log316", "iec61966-2-4",
; 456  :                                                     "bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-12", NULL };
; 457  :   static const char * const colormatrix_names[] = { "GBR", "bt709", "undef", "", "fcc", "bt470bg", "smpte170m",
; 458  :                                                     "smpte240m", "YCgCo", "bt2020nc", "bt2020c", NULL };
; 459  :   static const char * const mv_constraint_names[] = { "none", "frame", "tile", "frametile", "frametilemargin", NULL };
; 460  :   static const char * const hash_names[] = { "none", "checksum", "md5", NULL };
; 461  : 
; 462  :   static const char * const cu_split_termination_names[] = { "zero", "off", NULL };
; 463  :   static const char * const crypto_toggle_names[] = { "off", "on", NULL };
; 464  :   static const char * const crypto_feature_names[] = { "mvs", "mv_signs", "trans_coeffs", "trans_coeff_signs", "intra_pred_modes", NULL };
; 465  : 
; 466  :   static const char * const me_early_termination_names[] = { "off", "on", "sensitive", NULL };
; 467  : 
; 468  :   static const char * const sao_names[] = { "off", "edge", "band", "full", NULL };
; 469  : 
; 470  :   static const char * const scaling_list_names[] = { "off", "custom", "default", NULL };
; 471  : 
; 472  :   static const char * const rc_algorithm_names[] = { "no-rc", "lambda", "oba", NULL };
; 473  : 
; 474  :   static const char * const file_format_names[] = {"auto", "y4m", "yuv", NULL};
; 475  : 
; 476  :   static const char * const preset_values[11][25*2] = {
; 477  :       {
; 478  :         "ultrafast",
; 479  :         "rd", "0",
; 480  :         "pu-depth-intra", "2-3",
; 481  :         "pu-depth-inter", "1-2",
; 482  :         "me", "hexbs",
; 483  :         "gop", "8",
; 484  :         "ref", "1",
; 485  :         "bipred", "1",
; 486  :         "deblock", "0:0",
; 487  :         "signhide", "0",
; 488  :         "subme", "0",
; 489  :         "sao", "off",
; 490  :         "rdoq", "0",
; 491  :         "rdoq-skip", "0",
; 492  :         "transform-skip", "0",
; 493  :         "mv-rdo", "0",
; 494  :         "full-intra-search", "0",
; 495  :         "smp", "0",
; 496  :         "amp", "0",
; 497  :         "cu-split-termination", "zero",
; 498  :         "me-early-termination", "sensitive",
; 499  :         "intra-rdo-et", "0",
; 500  :         "early-skip", "1",
; 501  :         "fast-residual-cost", "28",
; 502  :         "max-merge", "5",
; 503  :         NULL
; 504  :       },
; 505  :       {
; 506  :         "superfast",
; 507  :         "rd", "0",
; 508  :         "pu-depth-intra", "2-3",
; 509  :         "pu-depth-inter", "1-2",
; 510  :         "me", "hexbs",
; 511  :         "gop", "8",
; 512  :         "ref", "1",
; 513  :         "bipred", "1",
; 514  :         "deblock", "0:0",
; 515  :         "signhide", "0",
; 516  :         "subme", "2",
; 517  :         "sao", "full",
; 518  :         "rdoq", "0",
; 519  :         "rdoq-skip", "0",
; 520  :         "transform-skip", "0",
; 521  :         "mv-rdo", "0",
; 522  :         "full-intra-search", "0",
; 523  :         "smp", "0",
; 524  :         "amp", "0",
; 525  :         "cu-split-termination", "zero",
; 526  :         "me-early-termination", "sensitive",
; 527  :         "intra-rdo-et", "0",
; 528  :         "early-skip", "1",
; 529  :         "fast-residual-cost", "28",
; 530  :         "max-merge", "5",
; 531  :         NULL
; 532  :       },
; 533  :       {
; 534  :         "veryfast",
; 535  :         "rd", "0",
; 536  :         "pu-depth-intra", "2-3",
; 537  :         "pu-depth-inter", "1-3",
; 538  :         "me", "hexbs",
; 539  :         "gop", "8",
; 540  :         "ref", "1",
; 541  :         "bipred", "1",
; 542  :         "deblock", "0:0",
; 543  :         "signhide", "0",
; 544  :         "subme", "2",
; 545  :         "sao", "full",
; 546  :         "rdoq", "0",
; 547  :         "rdoq-skip", "0",
; 548  :         "transform-skip", "0",
; 549  :         "mv-rdo", "0",
; 550  :         "full-intra-search", "0",
; 551  :         "smp", "0",
; 552  :         "amp", "0",
; 553  :         "cu-split-termination", "zero",
; 554  :         "me-early-termination", "sensitive",
; 555  :         "intra-rdo-et", "0",
; 556  :         "early-skip", "1",
; 557  :         "fast-residual-cost", "28",
; 558  :         "max-merge", "5",
; 559  :         NULL
; 560  :       },
; 561  :       {
; 562  :         "faster",
; 563  :         "rd", "0",
; 564  :         "pu-depth-intra", "2-3",
; 565  :         "pu-depth-inter", "1-3",
; 566  :         "me", "hexbs",
; 567  :         "gop", "8",
; 568  :         "ref", "1",
; 569  :         "bipred", "1",
; 570  :         "deblock", "0:0",
; 571  :         "signhide", "0",
; 572  :         "subme", "4",
; 573  :         "sao", "full",
; 574  :         "rdoq", "0",
; 575  :         "rdoq-skip", "0",
; 576  :         "transform-skip", "0",
; 577  :         "mv-rdo", "0",
; 578  :         "full-intra-search", "0",
; 579  :         "smp", "0",
; 580  :         "amp", "0",
; 581  :         "cu-split-termination", "zero",
; 582  :         "me-early-termination", "sensitive",
; 583  :         "intra-rdo-et", "0",
; 584  :         "early-skip", "1",
; 585  :         "fast-residual-cost", "0",
; 586  :         "max-merge", "5",
; 587  :         NULL
; 588  :       },
; 589  :       {
; 590  :         "fast",
; 591  :         "rd", "0",
; 592  :         "pu-depth-intra", "1-3",
; 593  :         "pu-depth-inter", "1-3",
; 594  :         "me", "hexbs",
; 595  :         "gop", "8",
; 596  :         "ref", "2",
; 597  :         "bipred", "1",
; 598  :         "deblock", "0:0",
; 599  :         "signhide", "0",
; 600  :         "subme", "4",
; 601  :         "sao", "full",
; 602  :         "rdoq", "0",
; 603  :         "rdoq-skip", "0",
; 604  :         "transform-skip", "0",
; 605  :         "mv-rdo", "0",
; 606  :         "full-intra-search", "0",
; 607  :         "smp", "0",
; 608  :         "amp", "0",
; 609  :         "cu-split-termination", "zero",
; 610  :         "me-early-termination", "sensitive",
; 611  :         "intra-rdo-et", "0",
; 612  :         "early-skip", "1",
; 613  :         "fast-residual-cost", "0",
; 614  :         "max-merge", "5",
; 615  :         NULL
; 616  :       },
; 617  :       {
; 618  :         "medium",
; 619  :         "rd", "0",
; 620  :         "pu-depth-intra", "1-4",
; 621  :         "pu-depth-inter", "0-3",
; 622  :         "me", "hexbs",
; 623  :         "gop", "16",
; 624  :         "ref", "4",
; 625  :         "bipred", "1",
; 626  :         "deblock", "0:0",
; 627  :         "signhide", "0",
; 628  :         "subme", "4",
; 629  :         "sao", "full",
; 630  :         "rdoq", "1",
; 631  :         "rdoq-skip", "0",
; 632  :         "transform-skip", "0",
; 633  :         "mv-rdo", "0",
; 634  :         "full-intra-search", "0",
; 635  :         "smp", "0",
; 636  :         "amp", "0",
; 637  :         "cu-split-termination", "zero",
; 638  :         "me-early-termination", "on",
; 639  :         "intra-rdo-et", "0",
; 640  :         "early-skip", "1",
; 641  :         "fast-residual-cost", "0",
; 642  :         "max-merge", "5",
; 643  :         NULL
; 644  :       },
; 645  :       {
; 646  :         "slow",
; 647  :         "rd", "1",
; 648  :         "pu-depth-intra", "1-4",
; 649  :         "pu-depth-inter", "0-3",
; 650  :         "me", "hexbs",
; 651  :         "gop", "16",
; 652  :         "ref", "4",
; 653  :         "bipred", "1",
; 654  :         "deblock", "0:0",
; 655  :         "signhide", "0",
; 656  :         "subme", "4",
; 657  :         "sao", "full",
; 658  :         "rdoq", "1",
; 659  :         "rdoq-skip", "0",
; 660  :         "transform-skip", "0",
; 661  :         "mv-rdo", "0",
; 662  :         "full-intra-search", "0",
; 663  :         "smp", "0",
; 664  :         "amp", "0",
; 665  :         "cu-split-termination", "zero",
; 666  :         "me-early-termination", "on",
; 667  :         "intra-rdo-et", "0",
; 668  :         "early-skip", "1",
; 669  :         "fast-residual-cost", "0",
; 670  :         "max-merge", "5",
; 671  :         NULL
; 672  :       },
; 673  :       {
; 674  :         "slower",
; 675  :         "rd", "2",
; 676  :         "pu-depth-intra", "1-4",
; 677  :         "pu-depth-inter", "0-3",
; 678  :         "me", "hexbs",
; 679  :         "gop", "16",
; 680  :         "ref", "4",
; 681  :         "bipred", "1",
; 682  :         "deblock", "0:0",
; 683  :         "signhide", "1",
; 684  :         "subme", "4",
; 685  :         "sao", "full",
; 686  :         "rdoq", "1",
; 687  :         "rdoq-skip", "0",
; 688  :         "transform-skip", "0",
; 689  :         "mv-rdo", "0",
; 690  :         "full-intra-search", "0",
; 691  :         "smp", "0",
; 692  :         "amp", "0",
; 693  :         "cu-split-termination", "zero",
; 694  :         "me-early-termination", "off",
; 695  :         "intra-rdo-et", "0",
; 696  :         "early-skip", "1",
; 697  :         "fast-residual-cost", "0",
; 698  :         "max-merge", "5",
; 699  :         NULL
; 700  :       },
; 701  :       {
; 702  :         "veryslow",
; 703  :         "rd", "2",
; 704  :         "pu-depth-intra", "1-4",
; 705  :         "pu-depth-inter", "0-3",
; 706  :         "me", "tz",
; 707  :         "gop", "16",
; 708  :         "ref", "4",
; 709  :         "bipred", "1",
; 710  :         "deblock", "0:0",
; 711  :         "signhide", "1",
; 712  :         "subme", "4",
; 713  :         "sao", "full",
; 714  :         "rdoq", "1",
; 715  :         "rdoq-skip", "0",
; 716  :         "transform-skip", "1",
; 717  :         "mv-rdo", "0",
; 718  :         "full-intra-search", "0",
; 719  :         "smp", "1",
; 720  :         "amp", "0",
; 721  :         "cu-split-termination", "zero",
; 722  :         "me-early-termination", "off",
; 723  :         "intra-rdo-et", "0",
; 724  :         "early-skip", "1",
; 725  :         "fast-residual-cost", "0",
; 726  :         "max-merge", "5",
; 727  :         NULL
; 728  :       },
; 729  :       {
; 730  :         "placebo",
; 731  :         "rd", "2",
; 732  :         "pu-depth-intra", "1-4",
; 733  :         "pu-depth-inter", "0-3",
; 734  :         "me", "tz",
; 735  :         "gop", "16",
; 736  :         "ref", "4",
; 737  :         "bipred", "1",
; 738  :         "deblock", "0:0",
; 739  :         "signhide", "1",
; 740  :         "subme", "4",
; 741  :         "sao", "full",
; 742  :         "rdoq", "1",
; 743  :         "rdoq-skip", "0",
; 744  :         "transform-skip", "1",
; 745  :         "mv-rdo", "1",
; 746  :         "full-intra-search", "0",
; 747  :         "smp", "1",
; 748  :         "amp", "1",
; 749  :         "cu-split-termination", "off",
; 750  :         "me-early-termination", "off",
; 751  :         "intra-rdo-et", "0",
; 752  :         "early-skip", "0",
; 753  :         "fast-residual-cost", "0",
; 754  :         "max-merge", "5",
; 755  :         NULL
; 756  :       },
; 757  :       { NULL }
; 758  :   };
; 759  : 
; 760  :   if (!name)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $LN13@kvz_config

; 761  :     return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN13@kvz_config:

; 762  : 
; 763  :   if (!value)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN14@kvz_config

; 764  :     value = "true";

	mov	DWORD PTR _value$[ebp], OFFSET ??_C@_04LOAJBDKD@true@
$LN14@kvz_config:

; 765  : 
; 766  :   // Treat "--no-param" as --param 0
; 767  :   if ((!strncmp(name, "no-", 3))) {

	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03GGODHGCB@no?9@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN15@kvz_config

; 768  :     name += 3;

	mov	eax, DWORD PTR _name$[ebp]
	add	eax, 3
	mov	DWORD PTR _name$[ebp], eax

; 769  :     value = atobool(value) ? "false" : "true";

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	je	SHORT $LN290@kvz_config
	mov	DWORD PTR tv75[ebp], OFFSET ??_C@_05LAPONLG@false@
	jmp	SHORT $LN291@kvz_config
$LN290@kvz_config:
	mov	DWORD PTR tv75[ebp], OFFSET ??_C@_04LOAJBDKD@true@
$LN291@kvz_config:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _value$[ebp], ecx
$LN15@kvz_config:

; 770  :   }
; 771  : 
; 772  : #define OPT(STR) (!strcmp(name, STR))
; 773  :   if OPT("width")

	push	OFFSET ??_C@_05IGKADHGO@width@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@kvz_config

; 774  :     cfg->width = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+12], eax
	jmp	$LN288@kvz_config
$LN16@kvz_config:

; 775  :   else if OPT("height")

	push	OFFSET ??_C@_06LNLHEAAG@height@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@kvz_config

; 776  :     cfg->height = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN288@kvz_config
$LN18@kvz_config:

; 777  :   else if OPT("input-res")

	push	OFFSET ??_C@_09JFPMGDJC@input?9res@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@kvz_config

; 778  :     if (!strcmp(value, "auto")) {

	push	OFFSET ??_C@_04HAPDLBFF@auto@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@kvz_config

; 779  :       return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config

; 780  :     } else {

	jmp	SHORT $LN23@kvz_config
$LN22@kvz_config:

; 781  :       return (sscanf(value, "%dx%d", &cfg->width, &cfg->height) == 2);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET ??_C@_05OEHCLJIP@?$CFdx?$CFd@
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_sscanf
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	SHORT $LN292@kvz_config
	mov	DWORD PTR tv138[ebp], 1
	jmp	SHORT $LN293@kvz_config
$LN292@kvz_config:
	mov	DWORD PTR tv138[ebp], 0
$LN293@kvz_config:
	mov	eax, DWORD PTR tv138[ebp]
	jmp	$LN1@kvz_config
$LN23@kvz_config:

; 782  :     }

	jmp	$LN288@kvz_config
$LN20@kvz_config:

; 783  :   else if OPT("input-fps") {

	push	OFFSET ??_C@_09FAGKMCMB@input?9fps@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@kvz_config

; 784  :     int32_t fps_num, fps_denom;
; 785  :     if (sscanf(value, "%d/%d", &fps_num, &fps_denom) == 2) {

	lea	eax, DWORD PTR _fps_denom$53[ebp]
	push	eax
	lea	ecx, DWORD PTR _fps_num$54[ebp]
	push	ecx
	push	OFFSET ??_C@_05LCKIIOJE@?$CFd?1?$CFd@
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_sscanf
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	SHORT $LN26@kvz_config

; 786  :       cfg->framerate_num = fps_num;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _fps_num$54[ebp]
	mov	DWORD PTR [eax+32], ecx

; 787  :       cfg->framerate_denom = fps_denom;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _fps_denom$53[ebp]
	mov	DWORD PTR [eax+36], ecx

; 788  :     } else {

	jmp	SHORT $LN27@kvz_config
$LN26@kvz_config:

; 789  :       // Accept decimal notation, making sure not to round 0 to 1.
; 790  :       cfg->framerate_num = (int)(atof(value) * 1000 + 0.49);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atof
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	fstp	QWORD PTR tv1684[ebp]
	movsd	xmm0, QWORD PTR tv1684[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	addsd	xmm0, QWORD PTR __real@3fdf5c28f5c28f5c
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 791  :       cfg->framerate_denom = 1000;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+36], 1000		; 000003e8H
$LN27@kvz_config:

; 792  :     }
; 793  :   }

	jmp	$LN288@kvz_config
$LN24@kvz_config:

; 794  :   else if OPT("qp")

	push	OFFSET ??_C@_02HKLCFNHM@qp@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN28@kvz_config

; 795  :     cfg->qp = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	$LN288@kvz_config
$LN28@kvz_config:

; 796  :   else if OPT("period")

	push	OFFSET ??_C@_06FBOEEHNL@period@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@kvz_config

; 797  :     cfg->intra_period = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+4], eax
	jmp	$LN288@kvz_config
$LN30@kvz_config:

; 798  :   else if OPT("vps-period")

	push	OFFSET ??_C@_0L@OMIMLMPG@vps?9period@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN32@kvz_config

; 799  :     cfg->vps_period = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	$LN288@kvz_config
$LN32@kvz_config:

; 800  :   else if OPT("ref")

	push	OFFSET ??_C@_03GCDGINBO@ref@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@kvz_config

; 801  :     cfg->ref_frames = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+128], eax
	jmp	$LN288@kvz_config
$LN34@kvz_config:

; 802  :   else if OPT("deblock") {

	push	OFFSET ??_C@_07KBNBPJMI@deblock@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@kvz_config

; 803  :     int beta, tc;
; 804  :     if (2 == sscanf(value, "%d:%d", &beta, &tc)) {

	lea	eax, DWORD PTR _tc$51[ebp]
	push	eax
	lea	ecx, DWORD PTR _beta$52[ebp]
	push	ecx
	push	OFFSET ??_C@_05NFGPCJDJ@?$CFd?3?$CFd@
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_sscanf
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	SHORT $LN38@kvz_config

; 805  :       cfg->deblock_enable = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+40], 1

; 806  :       cfg->deblock_beta   = beta;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _beta$52[ebp]
	mov	DWORD PTR [eax+96], ecx

; 807  :       cfg->deblock_tc     = tc;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _tc$51[ebp]
	mov	DWORD PTR [eax+100], ecx

; 808  :     } else {

	jmp	SHORT $LN39@kvz_config
$LN38@kvz_config:

; 809  :       cfg->deblock_enable = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+40], eax
$LN39@kvz_config:

; 810  :     }
; 811  :   }

	jmp	$LN288@kvz_config
$LN36@kvz_config:

; 812  :   else if OPT("sao") {

	push	OFFSET ??_C@_03MEBPJOO@sao@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN40@kvz_config

; 813  :     int8_t sao_type = 0;

	mov	BYTE PTR _sao_type$50[ebp], 0

; 814  :     if (!parse_enum(value, sao_names, &sao_type)) sao_type = atobool(value) ? 3 : 0;

	lea	eax, DWORD PTR _sao_type$50[ebp]
	push	eax
	push	OFFSET ?sao_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN42@kvz_config
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	je	SHORT $LN294@kvz_config
	mov	DWORD PTR tv215[ebp], 3
	jmp	SHORT $LN295@kvz_config
$LN294@kvz_config:
	mov	DWORD PTR tv215[ebp], 0
$LN295@kvz_config:
	mov	cl, BYTE PTR tv215[ebp]
	mov	BYTE PTR _sao_type$50[ebp], cl
$LN42@kvz_config:

; 815  :     cfg->sao_type = sao_type;

	movsx	eax, BYTE PTR _sao_type$50[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 816  :   }

	jmp	$LN288@kvz_config
$LN40@kvz_config:

; 817  :   else if OPT("rdoq")

	push	OFFSET ??_C@_04HLCEBPLD@rdoq@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN43@kvz_config

; 818  :     cfg->rdoq_enable = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+48], eax
	jmp	$LN288@kvz_config
$LN43@kvz_config:

; 819  :   else if OPT("signhide")

	push	OFFSET ??_C@_08NLKLMLIL@signhide@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@kvz_config

; 820  :     cfg->signhide_enable = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN296@kvz_config
	mov	DWORD PTR tv234[ebp], 0
	jmp	SHORT $LN297@kvz_config
$LN296@kvz_config:
	mov	DWORD PTR tv234[ebp], 1
$LN297@kvz_config:
	movzx	ecx, BYTE PTR tv234[ebp]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+52], ecx
	jmp	$LN288@kvz_config
$LN45@kvz_config:

; 821  :   else if OPT("smp")

	push	OFFSET ??_C@_03MIABAOBE@smp@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN47@kvz_config

; 822  :     cfg->smp_enable = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN298@kvz_config
	mov	DWORD PTR tv245[ebp], 0
	jmp	SHORT $LN299@kvz_config
$LN298@kvz_config:
	mov	DWORD PTR tv245[ebp], 1
$LN299@kvz_config:
	movzx	ecx, BYTE PTR tv245[ebp]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+56], ecx
	jmp	$LN288@kvz_config
$LN47@kvz_config:

; 823  :   else if OPT("amp")

	push	OFFSET ??_C@_03DCBBJBAA@amp@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN49@kvz_config

; 824  :     cfg->amp_enable = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN300@kvz_config
	mov	DWORD PTR tv256[ebp], 0
	jmp	SHORT $LN301@kvz_config
$LN300@kvz_config:
	mov	DWORD PTR tv256[ebp], 1
$LN301@kvz_config:
	movzx	ecx, BYTE PTR tv256[ebp]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+60], ecx
	jmp	$LN288@kvz_config
$LN49@kvz_config:

; 825  :   else if OPT("rd")

	push	OFFSET ??_C@_02FGFKDEHA@rd@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN51@kvz_config

; 826  :     cfg->rdo = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+64], eax
	jmp	$LN288@kvz_config
$LN51@kvz_config:

; 827  :   else if OPT("full-intra-search")

	push	OFFSET ??_C@_0BC@NIDONDCE@full?9intra?9search@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN53@kvz_config

; 828  :     cfg->full_intra_search = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+68], eax
	jmp	$LN288@kvz_config
$LN53@kvz_config:

; 829  :   else if OPT("transform-skip")

	push	OFFSET ??_C@_0P@KCEICG@transform?9skip@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN55@kvz_config

; 830  :     cfg->trskip_enable = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+72], eax
	jmp	$LN288@kvz_config
$LN55@kvz_config:

; 831  :   else if OPT("tr-depth-intra")

	push	OFFSET ??_C@_0P@GBNNMAAH@tr?9depth?9intra@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN57@kvz_config

; 832  :     cfg->tr_depth_intra = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+76], eax
	jmp	$LN288@kvz_config
$LN57@kvz_config:

; 833  :   else if OPT("me") {

	push	OFFSET ??_C@_02FIDLOBHM@me@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN59@kvz_config

; 834  :     int8_t ime_algorithm = 0;

	mov	BYTE PTR _ime_algorithm$49[ebp], 0

; 835  :     if (!parse_enum(value, me_names, &ime_algorithm)) return 0;

	lea	eax, DWORD PTR _ime_algorithm$49[ebp]
	push	eax
	push	OFFSET ?me_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN61@kvz_config
	xor	eax, eax
	jmp	$LN1@kvz_config
$LN61@kvz_config:

; 836  :     cfg->ime_algorithm = ime_algorithm;

	movsx	eax, BYTE PTR _ime_algorithm$49[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 837  :   }

	jmp	$LN288@kvz_config
$LN59@kvz_config:

; 838  :   else if OPT("subme")

	push	OFFSET ??_C@_05DLBDLGJF@subme@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN62@kvz_config

; 839  :     cfg->fme_level = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+84], eax
	jmp	$LN288@kvz_config
$LN62@kvz_config:

; 840  :   else if OPT("source-scan-type")

	push	OFFSET ??_C@_0BB@JEPLFBLL@source?9scan?9type@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN64@kvz_config

; 841  :     return parse_enum(value, source_scan_type_names, &cfg->source_scan_type);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	push	OFFSET ?source_scan_type_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN64@kvz_config:

; 842  :   else if OPT("mv-constraint")

	push	OFFSET ??_C@_0O@GDODIHNK@mv?9constraint@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN66@kvz_config

; 843  :   {
; 844  :     int8_t constraint = KVZ_MV_CONSTRAIN_NONE;

	mov	BYTE PTR _constraint$48[ebp], 0

; 845  :     int result = parse_enum(value, mv_constraint_names, &constraint);

	lea	eax, DWORD PTR _constraint$48[ebp]
	push	eax
	push	OFFSET ?mv_constraint_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$47[ebp], eax

; 846  :     cfg->mv_constraint = constraint;

	movsx	eax, BYTE PTR _constraint$48[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2336], eax

; 847  :     return result;

	mov	eax, DWORD PTR _result$47[ebp]
	jmp	$LN1@kvz_config

; 848  :   }

	jmp	$LN288@kvz_config
$LN66@kvz_config:

; 849  :   else if OPT("sar")

	push	OFFSET ??_C@_03PDCNJFPC@sar@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN68@kvz_config

; 850  :     return sscanf(value, "%d:%d", &cfg->vui.sar_width, &cfg->vui.sar_height) == 2;

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	push	OFFSET ??_C@_05NFGPCJDJ@?$CFd?3?$CFd@
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_sscanf
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jne	SHORT $LN302@kvz_config
	mov	DWORD PTR tv368[ebp], 1
	jmp	SHORT $LN303@kvz_config
$LN302@kvz_config:
	mov	DWORD PTR tv368[ebp], 0
$LN303@kvz_config:
	mov	eax, DWORD PTR tv368[ebp]
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN68@kvz_config:

; 851  :   else if OPT("overscan")

	push	OFFSET ??_C@_08EKPNNHHH@overscan@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN70@kvz_config

; 852  :     return parse_enum(value, overscan_names, &cfg->vui.overscan);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	push	OFFSET ?overscan_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN70@kvz_config:

; 853  :   else if OPT("videoformat")

	push	OFFSET ??_C@_0M@PKCLCCAL@videoformat@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN72@kvz_config

; 854  :     return parse_enum(value, videoformat_names, &cfg->vui.videoformat);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 113				; 00000071H
	push	eax
	push	OFFSET ?videoformat_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN72@kvz_config:

; 855  :   else if OPT("range")

	push	OFFSET ??_C@_05CCGOGOBM@range@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN74@kvz_config

; 856  :     return parse_enum(value, range_names, &cfg->vui.fullrange);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 114				; 00000072H
	push	eax
	push	OFFSET ?range_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN74@kvz_config:

; 857  :   else if OPT("colorprim")

	push	OFFSET ??_C@_09LGJOCOCA@colorprim@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN76@kvz_config

; 858  :     return parse_enum(value, colorprim_names, &cfg->vui.colorprim);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 115				; 00000073H
	push	eax
	push	OFFSET ?colorprim_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN76@kvz_config:

; 859  :   else if OPT("transfer")

	push	OFFSET ??_C@_08LGNJOGGB@transfer@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN78@kvz_config

; 860  :     return parse_enum(value, transfer_names, &cfg->vui.transfer);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	push	OFFSET ?transfer_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN78@kvz_config:

; 861  :   else if OPT("colormatrix")

	push	OFFSET ??_C@_0M@PKPDAFGD@colormatrix@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN80@kvz_config

; 862  :     return parse_enum(value, colormatrix_names, &cfg->vui.colormatrix);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 117				; 00000075H
	push	eax
	push	OFFSET ?colormatrix_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN80@kvz_config:

; 863  :   else if OPT("chromaloc")

	push	OFFSET ??_C@_09DOAGBPBM@chromaloc@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN82@kvz_config

; 864  :     cfg->vui.chroma_loc = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+120], eax
	jmp	$LN288@kvz_config
$LN82@kvz_config:

; 865  :   else if OPT("aud")

	push	OFFSET ??_C@_03OIKLEJN@aud@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN84@kvz_config

; 866  :     cfg->aud_enable = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+124], eax
	jmp	$LN288@kvz_config
$LN84@kvz_config:

; 867  :   else if OPT("cqmfile") {

	push	OFFSET ??_C@_07DDNHNHBH@cqmfile@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN86@kvz_config

; 868  :     char* cqmfile = strdup(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__strdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cqmfile$46[ebp], eax

; 869  :     if (!cqmfile) {

	cmp	DWORD PTR _cqmfile$46[ebp], 0
	jne	SHORT $LN88@kvz_config

; 870  :       fprintf(stderr, "Failed to allocate memory for CQM file name.\n");

	push	OFFSET ??_C@_0CO@OPJDAEPM@Failed?5to?5allocate?5memory?5for?5C@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 871  :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN88@kvz_config:

; 872  :     }
; 873  :     FREE_POINTER(cfg->cqmfile);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+132], 0

; 874  :     cfg->cqmfile = cqmfile;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _cqmfile$46[ebp]
	mov	DWORD PTR [eax+132], ecx

; 875  :     cfg->scaling_list = KVZ_SCALING_LIST_CUSTOM;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2440], 1

; 876  :   }

	jmp	$LN288@kvz_config
$LN86@kvz_config:

; 877  :   else if OPT("fast-coeff-table") {

	push	OFFSET ??_C@_0BB@KFGIMMCK@fast?9coeff?9table@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN89@kvz_config

; 878  :     char* fast_coeff_table_fn = strdup(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__strdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fast_coeff_table_fn$45[ebp], eax

; 879  :     if (!fast_coeff_table_fn) {

	cmp	DWORD PTR _fast_coeff_table_fn$45[ebp], 0
	jne	SHORT $LN91@kvz_config

; 880  :       fprintf(stderr, "Failed to allocate memory for fast coeff table file name.\n");

	push	OFFSET ??_C@_0DL@DIBNFNDF@Failed?5to?5allocate?5memory?5for?5f@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 881  :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN91@kvz_config:

; 882  :     }
; 883  :     FREE_POINTER(cfg->fast_coeff_table_fn);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2464]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2464], 0

; 884  :     cfg->fast_coeff_table_fn = fast_coeff_table_fn;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _fast_coeff_table_fn$45[ebp]
	mov	DWORD PTR [eax+2464], ecx

; 885  :   }

	jmp	$LN288@kvz_config
$LN89@kvz_config:

; 886  :   else if OPT("fastrd-sampling") {

	push	OFFSET ??_C@_0BA@LKPIHKKB@fastrd?9sampling@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN92@kvz_config

; 887  :     cfg->fastrd_sampling_on = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2469], 1

; 888  :   }

	jmp	$LN288@kvz_config
$LN92@kvz_config:

; 889  :   else if OPT("fastrd-accuracy-check") {

	push	OFFSET ??_C@_0BG@LLPHFMAP@fastrd?9accuracy?9check@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN94@kvz_config

; 890  :     cfg->fastrd_accuracy_check_on = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2470], 1

; 891  :   }

	jmp	$LN288@kvz_config
$LN94@kvz_config:

; 892  :   else if OPT("fastrd-outdir") {

	push	OFFSET ??_C@_0O@MBFJKMHN@fastrd?9outdir@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN96@kvz_config

; 893  :     char *fastrd_learning_outdir_fn = strdup(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__strdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fastrd_learning_outdir_fn$44[ebp], eax

; 894  :     if (!fastrd_learning_outdir_fn) {

	cmp	DWORD PTR _fastrd_learning_outdir_fn$44[ebp], 0
	jne	SHORT $LN98@kvz_config

; 895  :       fprintf(stderr, "Failed to allocate memory for fast RD learning outfile name.\n");

	push	OFFSET ??_C@_0DO@KIOOILIB@Failed?5to?5allocate?5memory?5for?5f@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 896  :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN98@kvz_config:

; 897  :     }
; 898  :     FREE_POINTER(cfg->fastrd_learning_outdir_fn);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2472]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2472], 0

; 899  :     cfg->fastrd_learning_outdir_fn = fastrd_learning_outdir_fn;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _fastrd_learning_outdir_fn$44[ebp]
	mov	DWORD PTR [eax+2472], ecx

; 900  :   }

	jmp	$LN288@kvz_config
$LN96@kvz_config:

; 901  :   else if OPT("scaling-list") {    

	push	OFFSET ??_C@_0N@DFHCBDAC@scaling?9list@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN99@kvz_config

; 902  :     int8_t scaling_list = KVZ_SCALING_LIST_OFF;

	mov	BYTE PTR _scaling_list$43[ebp], 0

; 903  :     int result = parse_enum(value, scaling_list_names, &scaling_list);

	lea	eax, DWORD PTR _scaling_list$43[ebp]
	push	eax
	push	OFFSET ?scaling_list_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$42[ebp], eax

; 904  :     cfg->scaling_list = scaling_list;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cl, BYTE PTR _scaling_list$43[ebp]
	mov	BYTE PTR [eax+2440], cl

; 905  :     return result;

	mov	eax, DWORD PTR _result$42[ebp]
	jmp	$LN1@kvz_config

; 906  :   }

	jmp	$LN288@kvz_config
$LN99@kvz_config:

; 907  :   else if OPT("tiles-width-split") {

	push	OFFSET ??_C@_0BC@GPFMDGBM@tiles?9width?9split@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN101@kvz_config

; 908  :     int retval = parse_tiles_specification(value, &cfg->tiles_width_count, &cfg->tiles_width_split);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_parse_tiles_specification
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retval$41[ebp], eax

; 909  : 
; 910  :     if (cfg->tiles_width_count > 1 && cfg->tmvp_enable) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+136], 1
	jle	SHORT $LN103@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2368], 0
	je	SHORT $LN103@kvz_config

; 911  :       cfg->tmvp_enable = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2368], 0

; 912  :       fprintf(stderr, "Disabling TMVP because tiles are used.\n");

	push	OFFSET ??_C@_0CI@IIMCKGEE@Disabling?5TMVP?5because?5tiles?5ar@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8
$LN103@kvz_config:

; 913  :     }
; 914  : 
; 915  :     if (cfg->wpp) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN104@kvz_config

; 916  :       cfg->wpp = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+152], 0

; 917  :       fprintf(stderr, "Disabling WPP because tiles were enabled.\n");

	push	OFFSET ??_C@_0CL@MLFEDNBO@Disabling?5WPP?5because?5tiles?5wer@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8
$LN104@kvz_config:

; 918  :     }
; 919  : 
; 920  :     return retval;

	mov	eax, DWORD PTR _retval$41[ebp]
	jmp	$LN1@kvz_config

; 921  :   }

	jmp	$LN288@kvz_config
$LN101@kvz_config:

; 922  :   else if OPT("tiles-height-split") {

	push	OFFSET ??_C@_0BD@PHGKEHDC@tiles?9height?9split@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN105@kvz_config

; 923  :     int retval = parse_tiles_specification(value, &cfg->tiles_height_count, &cfg->tiles_height_split);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_parse_tiles_specification
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retval$40[ebp], eax

; 924  : 
; 925  :     if (cfg->tiles_height_count > 1 && cfg->tmvp_enable) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+140], 1
	jle	SHORT $LN107@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2368], 0
	je	SHORT $LN107@kvz_config

; 926  :       cfg->tmvp_enable = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2368], 0

; 927  :       fprintf(stderr, "Disabling TMVP because tiles are used.\n");

	push	OFFSET ??_C@_0CI@IIMCKGEE@Disabling?5TMVP?5because?5tiles?5ar@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8
$LN107@kvz_config:

; 928  :     }
; 929  : 
; 930  :     if (cfg->wpp) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN108@kvz_config

; 931  :       cfg->wpp = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+152], 0

; 932  :       fprintf(stderr, "Disabling WPP because tiles were enabled.\n");

	push	OFFSET ??_C@_0CL@MLFEDNBO@Disabling?5WPP?5because?5tiles?5wer@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8
$LN108@kvz_config:

; 933  :     }
; 934  : 
; 935  :     return retval;

	mov	eax, DWORD PTR _retval$40[ebp]
	jmp	$LN1@kvz_config

; 936  :   }

	jmp	$LN288@kvz_config
$LN105@kvz_config:

; 937  :   else if OPT("tiles")

	push	OFFSET ??_C@_05HBFCGPPC@tiles@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN109@kvz_config

; 938  :   {
; 939  :     // A simpler interface for setting tiles, accepting only uniform split.
; 940  :     unsigned width;
; 941  :     unsigned height;
; 942  :     if (2 != sscanf(value, "%ux%u", &width, &height)) {

	lea	eax, DWORD PTR _height$38[ebp]
	push	eax
	lea	ecx, DWORD PTR _width$39[ebp]
	push	ecx
	push	OFFSET ??_C@_05OKCLCEKN@?$CFux?$CFu@
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_sscanf
	add	esp, 16					; 00000010H
	cmp	eax, 2
	je	SHORT $LN111@kvz_config

; 943  :       fprintf(stderr, "Wrong format for tiles. Expected \"%%ux%%u\", but got \"%s\"\n", value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0DK@GJMLLIF@Wrong?5format?5for?5tiles?4?5Expecte@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 944  :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN111@kvz_config:

; 945  :     }
; 946  : 
; 947  :     if (MAX_TILES_PER_DIM <= width || 1 > width) {

	cmp	DWORD PTR _width$39[ebp], 48		; 00000030H
	jae	SHORT $LN113@kvz_config
	cmp	DWORD PTR _width$39[ebp], 1
	jae	SHORT $LN112@kvz_config
$LN113@kvz_config:

; 948  :       fprintf(stderr, "Invalid number of tiles (0 < %d <= %d = MAX_TILES_PER_DIM)!\n", width, MAX_TILES_PER_DIM);

	push	48					; 00000030H
	mov	eax, DWORD PTR _width$39[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@HPPGLGNJ@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 949  :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN112@kvz_config:

; 950  :     }
; 951  :     if (MAX_TILES_PER_DIM <= height || 1 > height) {

	cmp	DWORD PTR _height$38[ebp], 48		; 00000030H
	jae	SHORT $LN115@kvz_config
	cmp	DWORD PTR _height$38[ebp], 1
	jae	SHORT $LN114@kvz_config
$LN115@kvz_config:

; 952  :       fprintf(stderr, "Invalid number of tiles (0 < %d <= %d = MAX_TILES_PER_DIM)!\n", height, MAX_TILES_PER_DIM);

	push	48					; 00000030H
	mov	eax, DWORD PTR _height$38[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@HPPGLGNJ@Invalid?5number?5of?5tiles?5?$CI0?5?$DM?5?$CFd@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 953  :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN114@kvz_config:

; 954  :     }
; 955  : 
; 956  :     // Free split arrays incase they have already been set by another parameter.
; 957  :     FREE_POINTER(cfg->tiles_width_split);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+144], 0

; 958  :     FREE_POINTER(cfg->tiles_height_split);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+148], 0

; 959  :     cfg->tiles_width_count = width;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _width$39[ebp]
	mov	DWORD PTR [eax+136], ecx

; 960  :     cfg->tiles_height_count = height;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _height$38[ebp]
	mov	DWORD PTR [eax+140], ecx

; 961  : 
; 962  :     if (cfg->tmvp_enable) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2368], 0
	je	SHORT $LN116@kvz_config

; 963  :       cfg->tmvp_enable = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2368], 0

; 964  :       fprintf(stderr, "Disabling TMVP because tiles are used.\n");

	push	OFFSET ??_C@_0CI@IIMCKGEE@Disabling?5TMVP?5because?5tiles?5ar@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8
$LN116@kvz_config:

; 965  :     }
; 966  : 
; 967  :     if (cfg->wpp) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN117@kvz_config

; 968  :       cfg->wpp = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+152], 0

; 969  :       fprintf(stderr, "Disabling WPP because tiles were enabled.\n");

	push	OFFSET ??_C@_0CL@MLFEDNBO@Disabling?5WPP?5because?5tiles?5wer@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8
$LN117@kvz_config:

; 970  :     }
; 971  : 
; 972  :     return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config

; 973  :   }

	jmp	$LN288@kvz_config
$LN109@kvz_config:

; 974  :   else if OPT("wpp")

	push	OFFSET ??_C@_03FDJNKJGA@wpp@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN118@kvz_config

; 975  :     cfg->wpp = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+152], eax
	jmp	$LN288@kvz_config
$LN118@kvz_config:

; 976  :   else if OPT("owf") {

	push	OFFSET ??_C@_03NPOHHFEC@owf@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN120@kvz_config

; 977  :     cfg->owf = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+156], eax

; 978  :     if (cfg->owf == 0 && !strcmp(value, "auto")) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+156], 0
	jne	SHORT $LN122@kvz_config
	push	OFFSET ??_C@_04HAPDLBFF@auto@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN122@kvz_config

; 979  :       // -1 means automatic selection
; 980  :       cfg->owf = -1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+156], -1
$LN122@kvz_config:

; 981  :     }

	jmp	$LN288@kvz_config
$LN120@kvz_config:

; 982  :   } else if OPT("slices") {

	push	OFFSET ??_C@_06DHJKELDJ@slices@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN123@kvz_config

; 983  :     if (!strcmp(value, "tiles")) {

	push	OFFSET ??_C@_05HBFCGPPC@tiles@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN125@kvz_config

; 984  :       cfg->slices = KVZ_SLICES_TILES;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2408], 1

; 985  :       return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
	jmp	$LN130@kvz_config
$LN125@kvz_config:

; 986  :     } else if (!strcmp(value, "wpp")) {

	push	OFFSET ??_C@_03FDJNKJGA@wpp@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN127@kvz_config

; 987  :       cfg->slices = KVZ_SLICES_WPP;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2408], 2

; 988  :       return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
	jmp	SHORT $LN130@kvz_config
$LN127@kvz_config:

; 989  :     } else if (!strcmp(value, "tiles+wpp")) {

	push	OFFSET ??_C@_09PLFMLLNL@tiles?$CLwpp@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN129@kvz_config

; 990  :       cfg->slices = KVZ_SLICES_TILES | KVZ_SLICES_WPP;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2408], 3

; 991  :       return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config

; 992  :     } else {

	jmp	SHORT $LN130@kvz_config
$LN129@kvz_config:

; 993  :       return parse_slice_specification(value, &cfg->slice_count, &cfg->slice_addresses_in_ts);

	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 164				; 000000a4H
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	add	ecx, 160				; 000000a0H
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_parse_slice_specification
	add	esp, 12					; 0000000cH
	jmp	$LN1@kvz_config
$LN130@kvz_config:

; 994  :     }

	jmp	$LN288@kvz_config
$LN123@kvz_config:

; 995  : 
; 996  :   } else if OPT("threads") {

	push	OFFSET ??_C@_07NFPADACG@threads@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN131@kvz_config

; 997  :     cfg->threads = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+168], eax

; 998  :     if (cfg->threads == 0 && !strcmp(value, "auto")) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+168], 0
	jne	SHORT $LN133@kvz_config
	push	OFFSET ??_C@_04HAPDLBFF@auto@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN133@kvz_config

; 999  :       // -1 means automatic selection
; 1000 :       cfg->threads = -1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+168], -1
$LN133@kvz_config:

; 1001 :     }
; 1002 :   }

	jmp	$LN288@kvz_config
$LN131@kvz_config:

; 1003 :   else if OPT("cpuid")

	push	OFFSET ??_C@_05CDPJMNMF@cpuid@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN134@kvz_config

; 1004 :     cfg->cpuid = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+172], eax
	jmp	$LN288@kvz_config
$LN134@kvz_config:

; 1005 :   else if OPT("pu-depth-inter")

	push	OFFSET ??_C@_0P@PGOKPLMD@pu?9depth?9inter@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN136@kvz_config

; 1006 :     return parse_pu_depth_list(value, cfg->pu_depth_inter.min, cfg->pu_depth_inter.max, KVZ_MAX_GOP_LAYERS);

	push	6
	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 200				; 000000c8H
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	add	ecx, 176				; 000000b0H
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_parse_pu_depth_list
	add	esp, 16					; 00000010H
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN136@kvz_config:

; 1007 :   else if OPT("pu-depth-intra")

	push	OFFSET ??_C@_0P@IOGMAPKE@pu?9depth?9intra@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN138@kvz_config

; 1008 :     return parse_pu_depth_list(value, cfg->pu_depth_intra.min, cfg->pu_depth_intra.max, KVZ_MAX_GOP_LAYERS);

	push	6
	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 248				; 000000f8H
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	add	ecx, 224				; 000000e0H
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_parse_pu_depth_list
	add	esp, 16					; 00000010H
	jmp	$LN1@kvz_config
	jmp	$LN288@kvz_config
$LN138@kvz_config:

; 1009 :   else if OPT("info")

	push	OFFSET ??_C@_04NIDJFNBE@info@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN140@kvz_config

; 1010 :     cfg->add_encoder_info = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+272], eax
	jmp	$LN288@kvz_config
$LN140@kvz_config:

; 1011 :   else if OPT("gop") {

	push	OFFSET ??_C@_03BEPOBKLC@gop@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN142@kvz_config

; 1012 :     if (!strncmp(value, "lp-", 3)) {  // Handle GOPs starting with "lp-".

	mov	esi, esp
	push	3
	push	OFFSET ??_C@_03NLJAFKOH@lp?9@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN144@kvz_config

; 1013 :       struct {
; 1014 :         unsigned g;  // length
; 1015 :         unsigned d;  // depth
; 1016 :         unsigned t;  // temporal
; 1017 :       } gop = { 0, 0, 0 };

	mov	DWORD PTR _gop$37[ebp], 0
	mov	DWORD PTR _gop$37[ebp+4], 0
	mov	DWORD PTR _gop$37[ebp+8], 0

; 1018 : 
; 1019 :       // Parse --gop=lp-g#d#t#
; 1020 :       if (sscanf(value, "lp-g%ud%ut%u", &gop.g, &gop.d, &gop.t) != 3) {

	lea	eax, DWORD PTR _gop$37[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _gop$37[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _gop$37[ebp]
	push	edx
	push	OFFSET ??_C@_0N@IDFEHDFC@lp?9g?$CFud?$CFut?$CFu@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_sscanf
	add	esp, 20					; 00000014H
	cmp	eax, 3
	je	SHORT $LN146@kvz_config

; 1021 :         fprintf(stderr, "Error in GOP syntax. Example: lp-g8d4t2\n");

	push	OFFSET ??_C@_0CJ@JBECBFMC@Error?5in?5GOP?5syntax?4?5Example?3?5l@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1022 :         return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN146@kvz_config:

; 1023 :       }
; 1024 : 
; 1025 :       if (gop.g < 1 || gop.g > 32) {

	cmp	DWORD PTR _gop$37[ebp], 1
	jb	SHORT $LN148@kvz_config
	cmp	DWORD PTR _gop$37[ebp], 32		; 00000020H
	jbe	SHORT $LN147@kvz_config
$LN148@kvz_config:

; 1026 :         fprintf(stderr, "gop.g must be between 1 and 32.\n");

	push	OFFSET ??_C@_0CB@CPLBNIGG@gop?4g?5must?5be?5between?51?5and?532?4@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1027 :         return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN147@kvz_config:

; 1028 :       }
; 1029 :       if (gop.d < 1 || gop.d > 8) {

	cmp	DWORD PTR _gop$37[ebp+4], 1
	jb	SHORT $LN150@kvz_config
	cmp	DWORD PTR _gop$37[ebp+4], 8
	jbe	SHORT $LN149@kvz_config
$LN150@kvz_config:

; 1030 :         fprintf(stderr, "gop.d must be between 1 and 8.\n");

	push	OFFSET ??_C@_0CA@PHKDDLG@gop?4d?5must?5be?5between?51?5and?58?4?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1031 :         return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN149@kvz_config:

; 1032 :       }
; 1033 :       if (gop.t < 1 || gop.t > 15) {

	cmp	DWORD PTR _gop$37[ebp+8], 1
	jb	SHORT $LN152@kvz_config
	cmp	DWORD PTR _gop$37[ebp+8], 15		; 0000000fH
	jbe	SHORT $LN151@kvz_config
$LN152@kvz_config:

; 1034 :         fprintf(stderr, "gop.t must be between 1 and 15.\n");

	push	OFFSET ??_C@_0CB@OLGGFFNG@gop?4t?5must?5be?5between?51?5and?515?4@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1035 :         return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN151@kvz_config:

; 1036 :       }
; 1037 : 
; 1038 :       cfg->gop_lowdelay = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+277], 1

; 1039 :       cfg->gop_len = gop.g;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cl, BYTE PTR _gop$37[ebp]
	mov	BYTE PTR [eax+276], cl

; 1040 :       cfg->gop_lp_definition.d = gop.d;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _gop$37[ebp+4]
	mov	DWORD PTR [eax+2384], ecx

; 1041 :       cfg->gop_lp_definition.t = gop.t;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _gop$37[ebp+8]
	mov	DWORD PTR [eax+2388], ecx

; 1042 : 
; 1043 :       cfg->intra_bit_allocation = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2453], 1

; 1044 :       cfg->clip_neighbour = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2454], 0
	jmp	$LN159@kvz_config
$LN144@kvz_config:

; 1045 :     } else if (atoi(value) == 8) {

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 8
	jne	SHORT $LN153@kvz_config

; 1046 :       cfg->gop_lowdelay = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+277], 0

; 1047 :       cfg->gop_len = sizeof(kvz_gop_ra8) / sizeof(kvz_gop_ra8[0]);

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+276], 8

; 1048 :       memcpy(cfg->gop, kvz_gop_ra8, sizeof(kvz_gop_ra8));

	push	512					; 00000200H
	push	OFFSET _kvz_gop_ra8
	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 280				; 00000118H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1049 :       cfg->intra_bit_allocation = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2453], 0

; 1050 :       cfg->clip_neighbour = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2454], 1
	jmp	$LN159@kvz_config
$LN153@kvz_config:

; 1051 : 
; 1052 :     } else if (atoi(value) == 16) {

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN155@kvz_config

; 1053 :       cfg->gop_lowdelay = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+277], 0

; 1054 :       cfg->gop_len = sizeof(kvz_gop_ra16) / sizeof(kvz_gop_ra16[0]);

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+276], 16			; 00000010H

; 1055 :       memcpy(cfg->gop, kvz_gop_ra16, sizeof(kvz_gop_ra16));

	push	1024					; 00000400H
	push	OFFSET _kvz_gop_ra16
	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 280				; 00000118H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1056 :       cfg->intra_bit_allocation = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2453], 0

; 1057 :       cfg->clip_neighbour = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2454], 1
	jmp	$LN159@kvz_config
$LN155@kvz_config:

; 1058 : 
; 1059 :     } else if (atoi(value) == 0) {

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN157@kvz_config

; 1060 :       //Disable gop
; 1061 :       cfg->gop_len = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+276], 0

; 1062 :       cfg->gop_lowdelay = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+277], 0

; 1063 :       cfg->gop_lp_definition.d = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2384], 0

; 1064 :       cfg->gop_lp_definition.t = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2388], 0
	jmp	SHORT $LN159@kvz_config
$LN157@kvz_config:

; 1065 :     } else if (atoi(value)) {

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN159@kvz_config

; 1066 :       fprintf(stderr, "Input error: unsupported gop length, must be 0 or 8\n");

	push	OFFSET ??_C@_0DF@OLEAANOI@Input?5error?3?5unsupported?5gop?5le@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1067 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN159@kvz_config:

; 1068 :     }
; 1069 :   }

	jmp	$LN288@kvz_config
$LN142@kvz_config:

; 1070 :   else if OPT("intra-qp-offset") {

	push	OFFSET ??_C@_0BA@MNBIMPFK@intra?9qp?9offset@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN160@kvz_config

; 1071 :     cfg->intra_qp_offset = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [ecx+2428], al

; 1072 :     if( cfg->intra_qp_offset == 0 && !strcmp( value, "auto" ) )

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2428]
	test	ecx, ecx
	jne	SHORT $LN162@kvz_config
	push	OFFSET ??_C@_04HAPDLBFF@auto@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN162@kvz_config

; 1073 :     {
; 1074 :         cfg->intra_qp_offset_auto = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2429], 1

; 1075 :     } else {

	jmp	SHORT $LN163@kvz_config
$LN162@kvz_config:

; 1076 :         cfg->intra_qp_offset_auto = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2429], 0
$LN163@kvz_config:

; 1077 :     }
; 1078 :   }

	jmp	$LN288@kvz_config
$LN160@kvz_config:

; 1079 :   else if OPT("open-gop") {

	push	OFFSET ??_C@_08COBIOIDI@open?9gop@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN164@kvz_config

; 1080 :     cfg->open_gop = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN304@kvz_config
	mov	DWORD PTR tv840[ebp], 0
	jmp	SHORT $LN305@kvz_config
$LN304@kvz_config:
	mov	DWORD PTR tv840[ebp], 1
$LN305@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	dl, BYTE PTR tv840[ebp]
	mov	BYTE PTR [ecx+2432], dl

; 1081 :   }

	jmp	$LN288@kvz_config
$LN164@kvz_config:

; 1082 :   else if OPT("bipred")

	push	OFFSET ??_C@_06CGCIAMGP@bipred@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN166@kvz_config

; 1083 :     cfg->bipred = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+92], eax
	jmp	$LN288@kvz_config
$LN166@kvz_config:

; 1084 :   else if OPT("bitrate") {

	push	OFFSET ??_C@_07MNHELNBG@bitrate@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN168@kvz_config

; 1085 :     cfg->target_bitrate = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2328], eax

; 1086 :     if (!cfg->rc_algorithm) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2452]
	test	ecx, ecx
	jne	SHORT $LN170@kvz_config

; 1087 :       cfg->rc_algorithm = KVZ_LAMBDA;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2452], 1
$LN170@kvz_config:

; 1088 :     }
; 1089 :   }

	jmp	$LN288@kvz_config
$LN168@kvz_config:

; 1090 :   else if OPT("preset") {

	push	OFFSET ??_C@_06OFAGBOBG@preset@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN171@kvz_config

; 1091 :     int preset_line = 0;

	mov	DWORD PTR _preset_line$36[ebp], 0

; 1092 : 
; 1093 :     // Accept numbers from 0 to 9.
; 1094 :     if ((atoi(value) == 0 && !strcmp(value, "0")) || (atoi(value) >= 1 && atoi(value) <= 9)) {

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN176@kvz_config
	push	OFFSET ??_C@_01GBGANLPD@0@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN175@kvz_config
$LN176@kvz_config:
	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jl	SHORT $LN173@kvz_config
	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 9
	jg	SHORT $LN173@kvz_config
$LN175@kvz_config:

; 1095 :       preset_line = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _preset_line$36[ebp], eax

; 1096 :     } else {

	jmp	SHORT $LN3@kvz_config
$LN173@kvz_config:

; 1097 :       // Find the selected preset from the list
; 1098 :       while (preset_values[preset_line][0] != NULL) {

	imul	eax, DWORD PTR _preset_line$36[ebp], 200
	mov	ecx, 4
	imul	edx, ecx, 0
	cmp	DWORD PTR ?preset_values@?1??kvz_config_parse@@9@9[eax+edx], 0
	je	SHORT $LN3@kvz_config

; 1099 :         if (!strcmp(value, preset_values[preset_line][0])) {

	imul	eax, DWORD PTR _preset_line$36[ebp], 200
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR ?preset_values@?1??kvz_config_parse@@9@9[eax+edx]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN177@kvz_config

; 1100 :           break;

	jmp	SHORT $LN3@kvz_config
$LN177@kvz_config:

; 1101 :         }
; 1102 :         preset_line++;

	mov	eax, DWORD PTR _preset_line$36[ebp]
	add	eax, 1
	mov	DWORD PTR _preset_line$36[ebp], eax

; 1103 :       }

	jmp	SHORT $LN173@kvz_config
$LN3@kvz_config:

; 1104 :     }
; 1105 : 
; 1106 :     if (preset_values[preset_line][0] != NULL) {

	imul	eax, DWORD PTR _preset_line$36[ebp], 200
	mov	ecx, 4
	imul	edx, ecx, 0
	cmp	DWORD PTR ?preset_values@?1??kvz_config_parse@@9@9[eax+edx], 0
	je	$LN178@kvz_config

; 1107 :       fprintf(stderr, "Using preset %s: ", value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@PJLALGNI@Using?5preset?5?$CFs?3?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1108 :       // Loop all the name and value pairs and push to the config parser
; 1109 :       for (int preset_value = 1; preset_values[preset_line][preset_value] != NULL; preset_value += 2) {

	mov	DWORD PTR _preset_value$35[ebp], 1
	jmp	SHORT $LN6@kvz_config
$LN4@kvz_config:
	mov	eax, DWORD PTR _preset_value$35[ebp]
	add	eax, 2
	mov	DWORD PTR _preset_value$35[ebp], eax
$LN6@kvz_config:
	imul	eax, DWORD PTR _preset_line$36[ebp], 200
	mov	ecx, DWORD PTR _preset_value$35[ebp]
	cmp	DWORD PTR ?preset_values@?1??kvz_config_parse@@9@9[eax+ecx*4], 0
	je	$LN5@kvz_config

; 1110 :         fprintf(stderr, "--%s=%s ", preset_values[preset_line][preset_value], preset_values[preset_line][preset_value + 1]);

	imul	eax, DWORD PTR _preset_line$36[ebp], 200
	mov	ecx, DWORD PTR _preset_value$35[ebp]
	mov	edx, DWORD PTR ?preset_values@?1??kvz_config_parse@@9@9[eax+ecx*4+4]
	push	edx
	imul	eax, DWORD PTR _preset_line$36[ebp], 200
	mov	ecx, DWORD PTR _preset_value$35[ebp]
	mov	edx, DWORD PTR ?preset_values@?1??kvz_config_parse@@9@9[eax+ecx*4]
	push	edx
	push	OFFSET ??_C@_08BFGGEBOG@?9?9?$CFs?$DN?$CFs?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1111 :         kvz_config_parse(cfg, preset_values[preset_line][preset_value], preset_values[preset_line][preset_value + 1]);

	imul	eax, DWORD PTR _preset_line$36[ebp], 200
	mov	ecx, DWORD PTR _preset_value$35[ebp]
	mov	edx, DWORD PTR ?preset_values@?1??kvz_config_parse@@9@9[eax+ecx*4+4]
	push	edx
	imul	eax, DWORD PTR _preset_line$36[ebp], 200
	mov	ecx, DWORD PTR _preset_value$35[ebp]
	mov	edx, DWORD PTR ?preset_values@?1??kvz_config_parse@@9@9[eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _cfg$[ebp]
	push	eax
	call	_kvz_config_parse
	add	esp, 12					; 0000000cH

; 1112 :       }

	jmp	$LN4@kvz_config
$LN5@kvz_config:

; 1113 :       fprintf(stderr, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1114 :     } else {

	jmp	SHORT $LN179@kvz_config
$LN178@kvz_config:

; 1115 :       fprintf(stderr, "Input error: unknown preset \"%s\"\n", value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0CC@GGPECPGC@Input?5error?3?5unknown?5preset?5?$CC?$CFs@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1116 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN179@kvz_config:

; 1117 :     }
; 1118 :   }

	jmp	$LN288@kvz_config
$LN171@kvz_config:

; 1119 :   else if OPT("mv-rdo")

	push	OFFSET ??_C@_06FFHEEO@mv?9rdo@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN180@kvz_config

; 1120 :     cfg->mv_rdo = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [ecx+2332], al
	jmp	$LN288@kvz_config
$LN180@kvz_config:

; 1121 :   else if OPT("psnr")

	push	OFFSET ??_C@_04OGMFBKAB@psnr@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN182@kvz_config

; 1122 :     cfg->calc_psnr = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN306@kvz_config
	mov	DWORD PTR tv993[ebp], 0
	jmp	SHORT $LN307@kvz_config
$LN306@kvz_config:
	mov	DWORD PTR tv993[ebp], 1
$LN307@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	dl, BYTE PTR tv993[ebp]
	mov	BYTE PTR [ecx+2333], dl
	jmp	$LN288@kvz_config
$LN182@kvz_config:

; 1123 :   else if OPT("hash")

	push	OFFSET ??_C@_04OIJGJDKO@hash@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN184@kvz_config

; 1124 :   {
; 1125 :     int8_t hash;
; 1126 :     int result;
; 1127 :     if ((result = parse_enum(value, hash_names, &hash))) {

	lea	eax, DWORD PTR _hash$34[ebp]
	push	eax
	push	OFFSET ?hash_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$33[ebp], eax
	cmp	DWORD PTR _result$33[ebp], 0
	je	SHORT $LN186@kvz_config

; 1128 :       cfg->hash = hash;

	movsx	eax, BYTE PTR _hash$34[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2340], eax
$LN186@kvz_config:

; 1129 :     }
; 1130 :     return result;

	mov	eax, DWORD PTR _result$33[ebp]
	jmp	$LN1@kvz_config

; 1131 :   }

	jmp	$LN288@kvz_config
$LN184@kvz_config:

; 1132 :   else if OPT("cu-split-termination")

	push	OFFSET ??_C@_0BF@MFJMPGDP@cu?9split?9termination@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN187@kvz_config

; 1133 :   {
; 1134 :     int8_t mode = KVZ_CU_SPLIT_TERMINATION_ZERO;

	mov	BYTE PTR _mode$32[ebp], 0

; 1135 :     int result = parse_enum(value, cu_split_termination_names, &mode);

	lea	eax, DWORD PTR _mode$32[ebp]
	push	eax
	push	OFFSET ?cu_split_termination_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$31[ebp], eax

; 1136 :     cfg->cu_split_termination = mode;

	movsx	eax, BYTE PTR _mode$32[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2344], eax

; 1137 :     return result;

	mov	eax, DWORD PTR _result$31[ebp]
	jmp	$LN1@kvz_config

; 1138 :   }

	jmp	$LN288@kvz_config
$LN187@kvz_config:

; 1139 :   else if OPT("crypto")

	push	OFFSET ??_C@_06LAEHEPPF@crypto@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN189@kvz_config

; 1140 :   {
; 1141 :     // on, off, feature1+feature2
; 1142 : 
; 1143 :     const char *token_begin = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR _token_begin$30[ebp], eax

; 1144 :     const char *cur = token_begin;

	mov	eax, DWORD PTR _token_begin$30[ebp]
	mov	DWORD PTR _cur$29[ebp], eax

; 1145 : 
; 1146 :     cfg->crypto_features = KVZ_CRYPTO_OFF;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2348], 0

; 1147 : 
; 1148 :     // If value is on or off, set all features to on or off.
; 1149 :     int8_t toggle = 0;

	mov	BYTE PTR _toggle$28[ebp], 0

; 1150 :     if (parse_enum(token_begin, crypto_toggle_names, &toggle)) {

	lea	eax, DWORD PTR _toggle$28[ebp]
	push	eax
	push	OFFSET ?crypto_toggle_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _token_begin$30[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN191@kvz_config

; 1151 :       if (toggle == 1) {

	movsx	eax, BYTE PTR _toggle$28[ebp]
	cmp	eax, 1
	jne	SHORT $LN193@kvz_config

; 1152 :         cfg->crypto_features = KVZ_CRYPTO_ON;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2348], 31		; 0000001fH
$LN193@kvz_config:

; 1153 :       }
; 1154 :     } else {

	jmp	$LN8@kvz_config
$LN191@kvz_config:
$LN7@kvz_config:

; 1155 :       // Try and parse "feature1+feature2" type list.
; 1156 :       for (;;) {
; 1157 :         if (*cur == '+' || *cur == '\0') {

	mov	eax, DWORD PTR _cur$29[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	je	SHORT $LN195@kvz_config
	mov	eax, DWORD PTR _cur$29[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN194@kvz_config
$LN195@kvz_config:

; 1158 :           int8_t feature = 0;

	mov	BYTE PTR _feature$27[ebp], 0

; 1159 :           int num_chars = cur - token_begin;

	mov	eax, DWORD PTR _cur$29[ebp]
	sub	eax, DWORD PTR _token_begin$30[ebp]
	mov	DWORD PTR _num_chars$26[ebp], eax

; 1160 :           if (parse_enum_n(token_begin, num_chars, crypto_feature_names, &feature)) {

	lea	eax, DWORD PTR _feature$27[ebp]
	push	eax
	push	OFFSET ?crypto_feature_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _num_chars$26[ebp]
	push	ecx
	mov	edx, DWORD PTR _token_begin$30[ebp]
	push	edx
	call	_parse_enum_n
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN196@kvz_config

; 1161 :             cfg->crypto_features |= (1 << feature);

	movsx	ecx, BYTE PTR _feature$27[ebp]
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _cfg$[ebp]
	or	eax, DWORD PTR [ecx+2348]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+2348], eax

; 1162 :           } else {

	jmp	SHORT $LN197@kvz_config
$LN196@kvz_config:

; 1163 :             cfg->crypto_features = KVZ_CRYPTO_OFF;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2348], 0

; 1164 :             return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN197@kvz_config:

; 1165 :           }
; 1166 :           token_begin = cur + 1;

	mov	eax, DWORD PTR _cur$29[ebp]
	add	eax, 1
	mov	DWORD PTR _token_begin$30[ebp], eax
$LN194@kvz_config:

; 1167 :         }
; 1168 : 
; 1169 :         if (*cur == '\0') {

	mov	eax, DWORD PTR _cur$29[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN198@kvz_config

; 1170 :           break;

	jmp	SHORT $LN8@kvz_config

; 1171 :         } else {

	jmp	SHORT $LN199@kvz_config
$LN198@kvz_config:

; 1172 :           ++cur;

	mov	eax, DWORD PTR _cur$29[ebp]
	add	eax, 1
	mov	DWORD PTR _cur$29[ebp], eax
$LN199@kvz_config:

; 1173 :         }
; 1174 :       }

	jmp	$LN7@kvz_config
$LN8@kvz_config:

; 1175 :     }
; 1176 : 
; 1177 :     // Disallow turning on the encryption when it's not compiled in.
; 1178 :     bool encryption_compiled_in = false;

	mov	BYTE PTR _encryption_compiled_in$25[ebp], 0

; 1179 : #ifdef KVZ_SEL_ENCRYPTION
; 1180 :     encryption_compiled_in = true;
; 1181 : #endif
; 1182 :     if (!encryption_compiled_in && cfg->crypto_features) {

	movzx	eax, BYTE PTR _encryption_compiled_in$25[ebp]
	test	eax, eax
	jne	SHORT $LN200@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2348], 0
	je	SHORT $LN200@kvz_config

; 1183 :       fprintf(stderr, "--crypto cannot be enabled because it's not compiled in.\n");

	push	OFFSET ??_C@_0DK@PJFMFHIP@?9?9crypto?5cannot?5be?5enabled?5beca@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1184 :       cfg->crypto_features = KVZ_CRYPTO_OFF;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2348], 0

; 1185 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN200@kvz_config:

; 1186 :     }
; 1187 : 
; 1188 :     return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config

; 1189 :   }

	jmp	$LN288@kvz_config
$LN189@kvz_config:

; 1190 :   else if OPT("key"){

	push	OFFSET ??_C@_03ICHNJLJF@key@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN201@kvz_config

; 1191 :     int size_key = 16;

	mov	DWORD PTR _size_key$24[ebp], 16		; 00000010H

; 1192 :     FREE_POINTER(cfg->optional_key);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2352]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2352], 0

; 1193 :     cfg->optional_key = (uint8_t *)malloc(sizeof(uint8_t)*size_key);

	mov	esi, esp
	mov	eax, DWORD PTR _size_key$24[ebp]
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2352], eax

; 1194 :     return parse_array(value, cfg->optional_key, size_key, 0, 255);

	push	255					; 000000ffH
	push	0
	mov	eax, DWORD PTR _size_key$24[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+2352]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_parse_array
	add	esp, 20					; 00000014H
	jmp	$LN1@kvz_config

; 1195 :   }

	jmp	$LN288@kvz_config
$LN201@kvz_config:

; 1196 :   else if OPT("me-early-termination"){

	push	OFFSET ??_C@_0BF@EGFOFOM@me?9early?9termination@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN203@kvz_config

; 1197 :     int8_t mode = 0;

	mov	BYTE PTR _mode$23[ebp], 0

; 1198 :     int result = parse_enum(value, me_early_termination_names, &mode);

	lea	eax, DWORD PTR _mode$23[ebp]
	push	eax
	push	OFFSET ?me_early_termination_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$22[ebp], eax

; 1199 :     cfg->me_early_termination = mode;

	movsx	eax, BYTE PTR _mode$23[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2356], eax

; 1200 :     return result;

	mov	eax, DWORD PTR _result$22[ebp]
	jmp	$LN1@kvz_config

; 1201 :   }

	jmp	$LN288@kvz_config
$LN203@kvz_config:

; 1202 :   else if OPT("intra-rdo-et")

	push	OFFSET ??_C@_0N@IJEFOOGB@intra?9rdo?9et@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN205@kvz_config

; 1203 :     cfg->intra_rdo_et = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN308@kvz_config
	mov	DWORD PTR tv1129[ebp], 0
	jmp	SHORT $LN309@kvz_config
$LN308@kvz_config:
	mov	DWORD PTR tv1129[ebp], 1
$LN309@kvz_config:
	movzx	ecx, BYTE PTR tv1129[ebp]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+2360], ecx
	jmp	$LN288@kvz_config
$LN205@kvz_config:

; 1204 :   else if OPT("lossless")

	push	OFFSET ??_C@_08PIMDPPGO@lossless@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN207@kvz_config

; 1205 :     cfg->lossless = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN310@kvz_config
	mov	DWORD PTR tv1140[ebp], 0
	jmp	SHORT $LN311@kvz_config
$LN310@kvz_config:
	mov	DWORD PTR tv1140[ebp], 1
$LN311@kvz_config:
	movzx	ecx, BYTE PTR tv1140[ebp]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+2364], ecx
	jmp	$LN288@kvz_config
$LN207@kvz_config:

; 1206 :   else if OPT("tmvp") {

	push	OFFSET ??_C@_04IDIAAMCH@tmvp@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN209@kvz_config

; 1207 :     cfg->tmvp_enable = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2368], eax

; 1208 :     if (cfg->tiles_width_count > 1 || cfg->tiles_height_count > 1) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+136], 1
	jg	SHORT $LN212@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+140], 1
	jle	SHORT $LN211@kvz_config
$LN212@kvz_config:

; 1209 :       fprintf(stderr, "Cannot enable TMVP because tiles are used.\n");

	push	OFFSET ??_C@_0CM@PFAEIPPG@Cannot?5enable?5TMVP?5because?5tile@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1210 :       cfg->tmvp_enable = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2368], 0
$LN211@kvz_config:

; 1211 :     }
; 1212 :   }

	jmp	$LN288@kvz_config
$LN209@kvz_config:

; 1213 :   else if OPT("rdoq-skip"){

	push	OFFSET ??_C@_09CNMMAOKA@rdoq?9skip@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN213@kvz_config

; 1214 :     cfg->rdoq_skip = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2372], eax

; 1215 :   }

	jmp	$LN288@kvz_config
$LN213@kvz_config:

; 1216 :   else if OPT("input-format") {

	push	OFFSET ??_C@_0N@MACMGKGI@input?9format@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN215@kvz_config

; 1217 :     static enum kvz_input_format const formats[] = { KVZ_FORMAT_P400, KVZ_FORMAT_P420 };
; 1218 :     static const char * const format_names[] = { "P400", "P420", NULL };
; 1219 : 
; 1220 :     int8_t format = 0;

	mov	BYTE PTR _format$21[ebp], 0

; 1221 :     if (!parse_enum(value, format_names, &format)) {

	lea	eax, DWORD PTR _format$21[ebp]
	push	eax
	push	OFFSET ?format_names@?GA@??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN217@kvz_config

; 1222 :       fprintf(stderr, "input-format not recognized.\n");

	push	OFFSET ??_C@_0BO@CJEIIFDP@input?9format?5not?5recognized?4?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1223 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN217@kvz_config:

; 1224 :     }
; 1225 : 
; 1226 :     cfg->input_format = formats[format];

	movsx	eax, BYTE PTR _format$21[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR ?formats@?GA@??kvz_config_parse@@9@9[eax*4]
	mov	DWORD PTR [ecx+2376], edx

; 1227 :   }

	jmp	$LN288@kvz_config
$LN215@kvz_config:

; 1228 :   else if OPT("input-bitdepth") {

	push	OFFSET ??_C@_0P@FLCBIFAI@input?9bitdepth@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN218@kvz_config

; 1229 :     cfg->input_bitdepth = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2380], eax

; 1230 :     if (cfg->input_bitdepth < 8 || cfg->input_bitdepth > 16) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2380], 8
	jl	SHORT $LN221@kvz_config
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2380], 16		; 00000010H
	jle	SHORT $LN220@kvz_config
$LN221@kvz_config:

; 1231 :       fprintf(stderr, "input-bitdepth not between 8 and 16.\n");

	push	OFFSET ??_C@_0CG@FHKGEIAH@input?9bitdepth?5not?5between?58?5an@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1232 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN220@kvz_config:

; 1233 :     }
; 1234 :     if (cfg->input_bitdepth > 8 && KVZ_BIT_DEPTH == 8) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2380], 8
	jle	SHORT $LN222@kvz_config
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN222@kvz_config

; 1235 :       // Because the image is read straight into the reference buffers,
; 1236 :       // reading >8 bit samples doesn't work when sizeof(kvz_pixel)==1.
; 1237 :       fprintf(stderr, "input-bitdepth can't be set to larger than 8 because"

	push	OFFSET ??_C@_0GA@LAOEBOAK@input?9bitdepth?5can?8t?5be?5set?5to?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1238 :                       " Kvazaar is compiled with KVZ_BIT_DEPTH=8.\n");
; 1239 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN222@kvz_config:

; 1240 :     }
; 1241 :   }

	jmp	$LN288@kvz_config
$LN218@kvz_config:

; 1242 :   else if OPT("implicit-rdpcm")

	push	OFFSET ??_C@_0P@MLHFGKE@implicit?9rdpcm@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN223@kvz_config

; 1243 :     cfg->implicit_rdpcm = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN312@kvz_config
	mov	DWORD PTR tv1213[ebp], 0
	jmp	SHORT $LN313@kvz_config
$LN312@kvz_config:
	mov	DWORD PTR tv1213[ebp], 1
$LN313@kvz_config:
	movzx	ecx, BYTE PTR tv1213[ebp]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+2392], ecx
	jmp	$LN288@kvz_config
$LN223@kvz_config:

; 1244 :   else if OPT("roi") {

	push	OFFSET ??_C@_03OIDJBEAH@roi@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN225@kvz_config

; 1245 :     // The ROI description is as follows:
; 1246 :     // First number is width, second number is height,
; 1247 :     // then follows width * height number of dqp values.
; 1248 :     FILE* f = fopen(value, "rb");

	mov	esi, esp
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _f$20[ebp], eax

; 1249 :     if (!f) {

	cmp	DWORD PTR _f$20[ebp], 0
	jne	SHORT $LN227@kvz_config

; 1250 :       fprintf(stderr, "Could not open ROI file.\n");

	push	OFFSET ??_C@_0BK@HCGIMNIK@Could?5not?5open?5ROI?5file?4?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1251 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN227@kvz_config:

; 1252 :     }
; 1253 : 
; 1254 :     int width = 0;

	mov	DWORD PTR _width$19[ebp], 0

; 1255 :     int height = 0;

	mov	DWORD PTR _height$18[ebp], 0

; 1256 :     if (!fscanf(f, "%d", &width) || !fscanf(f, "%d", &height)) {

	lea	eax, DWORD PTR _width$19[ebp]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	mov	ecx, DWORD PTR _f$20[ebp]
	push	ecx
	call	_fscanf
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN229@kvz_config
	lea	eax, DWORD PTR _height$18[ebp]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	mov	ecx, DWORD PTR _f$20[ebp]
	push	ecx
	call	_fscanf
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN228@kvz_config
$LN229@kvz_config:

; 1257 :       fprintf(stderr, "Failed to read ROI size.\n");

	push	OFFSET ??_C@_0BK@OKJNPDNA@Failed?5to?5read?5ROI?5size?4?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1258 :       fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$20[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1259 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN228@kvz_config:

; 1260 :     }
; 1261 : 
; 1262 :     if (width <= 0 || height <= 0) {

	cmp	DWORD PTR _width$19[ebp], 0
	jle	SHORT $LN231@kvz_config
	cmp	DWORD PTR _height$18[ebp], 0
	jg	SHORT $LN230@kvz_config
$LN231@kvz_config:

; 1263 :       fprintf(stderr, "Invalid ROI size: %dx%d.\n", width, height);

	mov	eax, DWORD PTR _height$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$19[ebp]
	push	ecx
	push	OFFSET ??_C@_0BK@PIHOEAGH@Invalid?5ROI?5size?3?5?$CFdx?$CFd?4?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 1264 :       fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$20[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1265 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN230@kvz_config:

; 1266 :     }
; 1267 : 
; 1268 :     if (width > 10000 || height > 10000) {

	cmp	DWORD PTR _width$19[ebp], 10000		; 00002710H
	jg	SHORT $LN233@kvz_config
	cmp	DWORD PTR _height$18[ebp], 10000	; 00002710H
	jle	SHORT $LN232@kvz_config
$LN233@kvz_config:

; 1269 :       fprintf(stderr, "ROI dimensions exceed arbitrary value of 10000.\n");

	push	OFFSET ??_C@_0DB@NFHNEBEH@ROI?5dimensions?5exceed?5arbitrary@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1270 :       fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$20[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1271 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN232@kvz_config:

; 1272 :     }
; 1273 : 
; 1274 :     const unsigned size = width * height;

	mov	eax, DWORD PTR _width$19[ebp]
	imul	eax, DWORD PTR _height$18[ebp]
	mov	DWORD PTR _size$17[ebp], eax

; 1275 :     int8_t *dqp_array  = calloc((size_t)size, sizeof(cfg->roi.dqps[0]));

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _size$17[ebp]
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dqp_array$16[ebp], eax

; 1276 :     if (!dqp_array) {

	cmp	DWORD PTR _dqp_array$16[ebp], 0
	jne	SHORT $LN234@kvz_config

; 1277 :       fprintf(stderr, "Failed to allocate memory for ROI table.\n");

	push	OFFSET ??_C@_0CK@CFIEFPOB@Failed?5to?5allocate?5memory?5for?5R@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1278 :       fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$20[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1279 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN234@kvz_config:

; 1280 :     }
; 1281 : 
; 1282 :     FREE_POINTER(cfg->roi.dqps);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2404]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2404], 0

; 1283 :     cfg->roi.dqps   = dqp_array;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _dqp_array$16[ebp]
	mov	DWORD PTR [eax+2404], ecx

; 1284 :     cfg->roi.width  = width;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _width$19[ebp]
	mov	DWORD PTR [eax+2396], ecx

; 1285 :     cfg->roi.height = height;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _height$18[ebp]
	mov	DWORD PTR [eax+2400], ecx

; 1286 : 
; 1287 :     for (int i = 0; i < size; ++i) {

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN12@kvz_config
$LN10@kvz_config:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN12@kvz_config:
	mov	eax, DWORD PTR _i$15[ebp]
	cmp	eax, DWORD PTR _size$17[ebp]
	jae	$LN11@kvz_config

; 1288 :       int number; // Need a pointer to int for fscanf
; 1289 :       if (fscanf(f, "%d", &number) != 1) {

	lea	eax, DWORD PTR _number$14[ebp]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd@
	mov	ecx, DWORD PTR _f$20[ebp]
	push	ecx
	call	_fscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN235@kvz_config

; 1290 :         fprintf(stderr, "Reading ROI file failed.\n");

	push	OFFSET ??_C@_0BK@CEKLAFEC@Reading?5ROI?5file?5failed?4?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1291 :         fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$20[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1292 :         return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN235@kvz_config:

; 1293 :       }
; 1294 :       dqp_array[i] = CLIP(-51, 51, number);

	cmp	DWORD PTR _number$14[ebp], 51		; 00000033H
	jle	SHORT $LN314@kvz_config
	mov	DWORD PTR tv1325[ebp], 51		; 00000033H
	jmp	SHORT $LN315@kvz_config
$LN314@kvz_config:
	mov	eax, DWORD PTR _number$14[ebp]
	mov	DWORD PTR tv1325[ebp], eax
$LN315@kvz_config:
	cmp	DWORD PTR tv1325[ebp], -51		; ffffffcdH
	jge	SHORT $LN318@kvz_config
	mov	DWORD PTR tv1329[ebp], -51		; ffffffcdH
	jmp	SHORT $LN319@kvz_config
$LN318@kvz_config:
	cmp	DWORD PTR _number$14[ebp], 51		; 00000033H
	jle	SHORT $LN316@kvz_config
	mov	DWORD PTR tv1328[ebp], 51		; 00000033H
	jmp	SHORT $LN317@kvz_config
$LN316@kvz_config:
	mov	ecx, DWORD PTR _number$14[ebp]
	mov	DWORD PTR tv1328[ebp], ecx
$LN317@kvz_config:
	mov	edx, DWORD PTR tv1328[ebp]
	mov	DWORD PTR tv1329[ebp], edx
$LN319@kvz_config:
	mov	eax, DWORD PTR _dqp_array$16[ebp]
	add	eax, DWORD PTR _i$15[ebp]
	mov	cl, BYTE PTR tv1329[ebp]
	mov	BYTE PTR [eax], cl

; 1295 :     }

	jmp	$LN10@kvz_config
$LN11@kvz_config:

; 1296 : 
; 1297 :     fclose(f);

	mov	esi, esp
	mov	eax, DWORD PTR _f$20[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1298 :   }

	jmp	$LN288@kvz_config
$LN225@kvz_config:

; 1299 :   else if OPT("set-qp-in-cu") {

	push	OFFSET ??_C@_0N@BFIGBNPD@set?9qp?9in?9cu@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN236@kvz_config

; 1300 :     cfg->set_qp_in_cu = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN320@kvz_config
	mov	DWORD PTR tv1340[ebp], 0
	jmp	SHORT $LN321@kvz_config
$LN320@kvz_config:
	mov	DWORD PTR tv1340[ebp], 1
$LN321@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	dl, BYTE PTR tv1340[ebp]
	mov	BYTE PTR [ecx+2431], dl

; 1301 :   }

	jmp	$LN288@kvz_config
$LN236@kvz_config:

; 1302 :   else if OPT("erp-aqp") {

	push	OFFSET ??_C@_07LCMEECMI@erp?9aqp@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN238@kvz_config

; 1303 :     cfg->erp_aqp = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN322@kvz_config
	mov	DWORD PTR tv1350[ebp], 0
	jmp	SHORT $LN323@kvz_config
$LN322@kvz_config:
	mov	DWORD PTR tv1350[ebp], 1
$LN323@kvz_config:
	movzx	ecx, BYTE PTR tv1350[ebp]
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+2412], ecx

; 1304 :   }

	jmp	$LN288@kvz_config
$LN238@kvz_config:

; 1305 :   else if (OPT("level") || OPT("force-level")) {

	push	OFFSET ??_C@_05KJNJLLGA@level@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN242@kvz_config
	push	OFFSET ??_C@_0M@MGLOGJPN@force?9level@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN240@kvz_config
$LN242@kvz_config:

; 1306 :     if OPT("force-level") {

	push	OFFSET ??_C@_0M@MGLOGJPN@force?9level@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN243@kvz_config

; 1307 :       cfg->force_level = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2417], 1

; 1308 :     } else {

	jmp	SHORT $LN244@kvz_config
$LN243@kvz_config:

; 1309 :       cfg->force_level = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2417], 0
$LN244@kvz_config:

; 1310 :     }
; 1311 : 
; 1312 :     unsigned int num_first, num_second, level;
; 1313 :     int matched_amount = sscanf(value, "%u.%u", &num_first, &num_second);

	lea	eax, DWORD PTR _num_second$12[ebp]
	push	eax
	lea	ecx, DWORD PTR _num_first$13[ebp]
	push	ecx
	push	OFFSET ??_C@_05EENHEND@?$CFu?4?$CFu@
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	_sscanf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _matched_amount$10[ebp], eax

; 1314 : 
; 1315 :     if (matched_amount == 2) {

	cmp	DWORD PTR _matched_amount$10[ebp], 2
	jne	SHORT $LN245@kvz_config

; 1316 :       // of form x.y
; 1317 :       level = num_first * 10 + num_second;

	imul	eax, DWORD PTR _num_first$13[ebp], 10
	add	eax, DWORD PTR _num_second$12[ebp]
	mov	DWORD PTR _level$11[ebp], eax
	jmp	SHORT $LN248@kvz_config
$LN245@kvz_config:

; 1318 :     } else if (matched_amount == 1) {

	cmp	DWORD PTR _matched_amount$10[ebp], 1
	jne	SHORT $LN247@kvz_config

; 1319 :       // no dot
; 1320 :       if (num_first < 10) {

	cmp	DWORD PTR _num_first$13[ebp], 10	; 0000000aH
	jae	SHORT $LN249@kvz_config

; 1321 :         // of form x
; 1322 :         level = num_first * 10;

	imul	eax, DWORD PTR _num_first$13[ebp], 10
	mov	DWORD PTR _level$11[ebp], eax

; 1323 :       } else {

	jmp	SHORT $LN250@kvz_config
$LN249@kvz_config:

; 1324 :         // of form xx
; 1325 :         level = num_first;

	mov	eax, DWORD PTR _num_first$13[ebp]
	mov	DWORD PTR _level$11[ebp], eax
$LN250@kvz_config:

; 1326 :       }
; 1327 :     } else {

	jmp	SHORT $LN248@kvz_config
$LN247@kvz_config:

; 1328 :       fprintf(stderr, "Invalid level value: \"%s\"\n", value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@DMMKLPHB@Invalid?5level?5value?3?5?$CC?$CFs?$CC?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1329 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN248@kvz_config:

; 1330 :     }
; 1331 :     if (level < 10 || level > 62) {

	cmp	DWORD PTR _level$11[ebp], 10		; 0000000aH
	jb	SHORT $LN252@kvz_config
	cmp	DWORD PTR _level$11[ebp], 62		; 0000003eH
	jbe	SHORT $LN251@kvz_config
$LN252@kvz_config:

; 1332 :       fprintf(stderr, "Level value of %s is out of bounds\n", value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0CE@KCLEDEOI@Level?5value?5of?5?$CFs?5is?5out?5of?5bou@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1333 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN251@kvz_config:

; 1334 :     }
; 1335 : 
; 1336 :     cfg->level = level;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cl, BYTE PTR _level$11[ebp]
	mov	BYTE PTR [eax+2416], cl

; 1337 :   }

	jmp	$LN288@kvz_config
$LN240@kvz_config:

; 1338 :   else if (OPT("high-tier")) {

	push	OFFSET ??_C@_09OOKJLFAD@high?9tier@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN253@kvz_config

; 1339 :     cfg->high_tier = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2418], 1

; 1340 :   }

	jmp	$LN288@kvz_config
$LN253@kvz_config:

; 1341 :   else if (OPT("me-steps")) {

	push	OFFSET ??_C@_08FPEEAHBF@me?9steps@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN255@kvz_config

; 1342 :     char * tailptr = NULL;

	mov	DWORD PTR _tailptr$9[ebp], 0

; 1343 :     long steps = strtol(value, &tailptr, 0);

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _tailptr$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _steps$8[ebp], eax

; 1344 : 
; 1345 :     if (*tailptr != '\0') {

	mov	eax, DWORD PTR _tailptr$9[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN257@kvz_config

; 1346 :       fprintf(stderr, "Invalid me-steps value: \"%s\"", value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@HLDNCNIO@Invalid?5me?9steps?5value?3?5?$CC?$CFs?$CC@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1347 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN257@kvz_config:

; 1348 :     }
; 1349 :     if (steps < -1 || steps > UINT32_MAX) {

	cmp	DWORD PTR _steps$8[ebp], -1
	jl	SHORT $LN259@kvz_config
	cmp	DWORD PTR _steps$8[ebp], -1
	jbe	SHORT $LN258@kvz_config
$LN259@kvz_config:

; 1350 :       fprintf(stderr, "me-steps value is out of bounds: \"%s\"", value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0CG@BLDCDBOL@me?9steps?5value?5is?5out?5of?5bounds@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1351 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN258@kvz_config:

; 1352 :     }
; 1353 : 
; 1354 :     cfg->me_max_steps = (uint32_t)steps;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR _steps$8[ebp]
	mov	DWORD PTR [eax+2424], ecx

; 1355 :   }

	jmp	$LN288@kvz_config
$LN255@kvz_config:

; 1356 :   else if (OPT("fast-residual-cost"))

	push	OFFSET ??_C@_0BD@NKHCCIBG@fast?9residual?9cost@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN260@kvz_config

; 1357 :     cfg->fast_residual_cost_limit = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [ecx+2430], al
	jmp	$LN288@kvz_config
$LN260@kvz_config:

; 1358 :   else if (OPT("vaq")) {

	push	OFFSET ??_C@_03OPNODGAD@vaq@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN262@kvz_config

; 1359 :     cfg->vaq = (int)atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2436], eax

; 1360 :   }

	jmp	$LN288@kvz_config
$LN262@kvz_config:

; 1361 :   else if (OPT("max-merge")) {

	push	OFFSET ??_C@_09NDDHJBDO@max?9merge@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN264@kvz_config

; 1362 :     int max_merge = atoi(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _max_merge$7[ebp], eax

; 1363 :     if (max_merge < 1 || max_merge > 5) {

	cmp	DWORD PTR _max_merge$7[ebp], 1
	jl	SHORT $LN267@kvz_config
	cmp	DWORD PTR _max_merge$7[ebp], 5
	jle	SHORT $LN266@kvz_config
$LN267@kvz_config:

; 1364 :       fprintf(stderr, "max-merge needs to be between 1 and 5\n");

	push	OFFSET ??_C@_0CH@LLCDBEMB@max?9merge?5needs?5to?5be?5between?51@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 1365 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN266@kvz_config:

; 1366 :     }
; 1367 :     cfg->max_merge = (uint8_t)max_merge;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cl, BYTE PTR _max_merge$7[ebp]
	mov	BYTE PTR [eax+2441], cl

; 1368 :   }

	jmp	$LN288@kvz_config
$LN264@kvz_config:

; 1369 :   else if OPT("early-skip") {

	push	OFFSET ??_C@_0L@CKGBKFNE@early?9skip@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN268@kvz_config

; 1370 :     cfg->early_skip = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN324@kvz_config
	mov	DWORD PTR tv1455[ebp], 0
	jmp	SHORT $LN325@kvz_config
$LN324@kvz_config:
	mov	DWORD PTR tv1455[ebp], 1
$LN325@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	dl, BYTE PTR tv1455[ebp]
	mov	BYTE PTR [ecx+2442], dl

; 1371 :   }

	jmp	$LN288@kvz_config
$LN268@kvz_config:

; 1372 :   else if OPT("ml-pu-depth-intra") {

	push	OFFSET ??_C@_0BC@NCEMMCMO@ml?9pu?9depth?9intra@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN270@kvz_config

; 1373 :     cfg->ml_pu_depth_intra = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN326@kvz_config
	mov	DWORD PTR tv1465[ebp], 0
	jmp	SHORT $LN327@kvz_config
$LN326@kvz_config:
	mov	DWORD PTR tv1465[ebp], 1
$LN327@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	dl, BYTE PTR tv1465[ebp]
	mov	BYTE PTR [ecx+2443], dl

; 1374 :   }

	jmp	$LN288@kvz_config
$LN270@kvz_config:

; 1375 :   else if OPT("partial-coding") {

	push	OFFSET ??_C@_0P@OELGANC@partial?9coding@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN272@kvz_config

; 1376 :     uint32_t firstCTU_x;
; 1377 :     uint32_t firstCTU_y;
; 1378 :     uint32_t fullWidth;
; 1379 :     uint32_t fullHeight;
; 1380 :     if (4 != sscanf(value, "%u!%u!%u!%u", &firstCTU_x,

	lea	eax, DWORD PTR _fullHeight$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullWidth$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _firstCTU_y$5[ebp]
	push	edx
	lea	eax, DWORD PTR _firstCTU_x$6[ebp]
	push	eax
	push	OFFSET ??_C@_0M@HMFNFDMO@?$CFu?$CB?$CFu?$CB?$CFu?$CB?$CFu@
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_sscanf
	add	esp, 24					; 00000018H
	cmp	eax, 4
	je	SHORT $LN274@kvz_config

; 1381 :       &firstCTU_y, &fullWidth, &fullHeight)) {
; 1382 :       fprintf(stderr, "invalid partial-coding options. Expected \"%%u!%%u!%%u!%%u\", but got \"%s\"\n", value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	push	OFFSET ??_C@_0EK@CAEPCCID@invalid?5partial?9coding?5options?4@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 1383 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN274@kvz_config:

; 1384 :     }
; 1385 :     cfg->partial_coding.startCTU_x = firstCTU_x;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cl, BYTE PTR _firstCTU_x$6[ebp]
	mov	BYTE PTR [eax+2444], cl

; 1386 :     cfg->partial_coding.startCTU_y = firstCTU_y;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cl, BYTE PTR _firstCTU_y$5[ebp]
	mov	BYTE PTR [eax+2445], cl

; 1387 :     cfg->partial_coding.fullWidth = fullWidth;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cx, WORD PTR _fullWidth$4[ebp]
	mov	WORD PTR [eax+2446], cx

; 1388 :     cfg->partial_coding.fullHeight = fullHeight;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cx, WORD PTR _fullHeight$3[ebp]
	mov	WORD PTR [eax+2448], cx

; 1389 :   }

	jmp	$LN288@kvz_config
$LN272@kvz_config:

; 1390 :   else if OPT("zero-coeff-rdo") {

	push	OFFSET ??_C@_0P@MOHBBPPH@zero?9coeff?9rdo@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN275@kvz_config

; 1391 :   cfg->zero_coeff_rdo = (bool)atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN328@kvz_config
	mov	DWORD PTR tv1496[ebp], 0
	jmp	SHORT $LN329@kvz_config
$LN328@kvz_config:
	mov	DWORD PTR tv1496[ebp], 1
$LN329@kvz_config:
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	dl, BYTE PTR tv1496[ebp]
	mov	BYTE PTR [ecx+2450], dl

; 1392 :   }

	jmp	$LN288@kvz_config
$LN275@kvz_config:

; 1393 :   else if OPT("rc-algorithm") {

	push	OFFSET ??_C@_0N@LLEHIFIF@rc?9algorithm@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN277@kvz_config

; 1394 :     int8_t rc_algorithm = 0;

	mov	BYTE PTR _rc_algorithm$2[ebp], 0

; 1395 :     if (!parse_enum(value, rc_algorithm_names, &rc_algorithm)) {

	lea	eax, DWORD PTR _rc_algorithm$2[ebp]
	push	eax
	push	OFFSET ?rc_algorithm_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN279@kvz_config

; 1396 :       fprintf(stderr, "Invalid rate control algorithm %s. Valid values include %s, %s, and %s\n", value, 

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?rc_algorithm_names@?1??kvz_config_parse@@9@9[eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR ?rc_algorithm_names@?1??kvz_config_parse@@9@9[edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR ?rc_algorithm_names@?1??kvz_config_parse@@9@9[edx]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EI@KNFFFLOD@Invalid?5rate?5control?5algorithm?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 24					; 00000018H

; 1397 :         rc_algorithm_names[0],
; 1398 :         rc_algorithm_names[1],
; 1399 :         rc_algorithm_names[2]);
; 1400 :       return 0;

	xor	eax, eax
	jmp	$LN1@kvz_config
$LN279@kvz_config:

; 1401 :     }
; 1402 :     cfg->rc_algorithm = rc_algorithm;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	cl, BYTE PTR _rc_algorithm$2[ebp]
	mov	BYTE PTR [eax+2452], cl

; 1403 :   }

	jmp	$LN288@kvz_config
$LN277@kvz_config:

; 1404 :   else if OPT("intra-bits") {

	push	OFFSET ??_C@_0L@FHDAPBPN@intra?9bits@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN280@kvz_config

; 1405 :     cfg->intra_bit_allocation = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [ecx+2453], al

; 1406 :   }

	jmp	$LN288@kvz_config
$LN280@kvz_config:

; 1407 :   else if OPT("clip-neighbour") {

	push	OFFSET ??_C@_0P@EOCPJIEH@clip?9neighbour@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN282@kvz_config

; 1408 :     cfg->clip_neighbour = atobool(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_atobool
	add	esp, 4
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [ecx+2454], al

; 1409 :   }

	jmp	$LN288@kvz_config
$LN282@kvz_config:

; 1410 :   else if OPT("input-file-format") {

	push	OFFSET ??_C@_0BC@FCLHPMHP@input?9file?9format@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN284@kvz_config

; 1411 :     int8_t file_format = 0;

	mov	BYTE PTR _file_format$1[ebp], 0

; 1412 :     if (!parse_enum(value, file_format_names, &file_format)) {

	lea	eax, DWORD PTR _file_format$1[ebp]
	push	eax
	push	OFFSET ?file_format_names@?1??kvz_config_parse@@9@9
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_parse_enum
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN286@kvz_config

; 1413 :       fprintf(stderr, "Invalid input file format %s. Valid values include %s, %s, and %s\n", value,

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR ?file_format_names@?1??kvz_config_parse@@9@9[eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR ?file_format_names@?1??kvz_config_parse@@9@9[edx]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR ?file_format_names@?1??kvz_config_parse@@9@9[edx]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	OFFSET ??_C@_0ED@OHMCJCOI@Invalid?5input?5file?5format?5?$CFs?4?5V@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 24					; 00000018H

; 1414 :         file_format_names[0],
; 1415 :         file_format_names[1], 
; 1416 :         file_format_names[2]);
; 1417 :       return 0;

	xor	eax, eax
	jmp	SHORT $LN1@kvz_config
$LN286@kvz_config:

; 1418 :     }
; 1419 :     cfg->file_format = file_format;

	movsx	eax, BYTE PTR _file_format$1[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2456], eax

; 1420 :   }

	jmp	SHORT $LN288@kvz_config
$LN284@kvz_config:

; 1421 :   else if OPT("stats-file-prefix") {

	push	OFFSET ??_C@_0BC@MDLEJHHN@stats?9file?9prefix@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN287@kvz_config

; 1422 :     cfg->stats_file_prefix = strdup(value);

	mov	esi, esp
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__strdup
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+2460], eax

; 1423 :   }

	jmp	SHORT $LN288@kvz_config
$LN287@kvz_config:

; 1424 :   else {
; 1425 :     return 0;

	xor	eax, eax
	jmp	SHORT $LN1@kvz_config
$LN288@kvz_config:

; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
$LN1@kvz_config:

; 1430 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN360@kvz_config
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1056				; 00000420H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN360@kvz_config:
	DD	29					; 0000001dH
	DD	$LN359@kvz_config
$LN359@kvz_config:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN330@kvz_config
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN331@kvz_config
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN332@kvz_config
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN333@kvz_config
	DD	-57					; ffffffc7H
	DD	1
	DD	$LN334@kvz_config
	DD	-69					; ffffffbbH
	DD	1
	DD	$LN335@kvz_config
	DD	-81					; ffffffafH
	DD	1
	DD	$LN336@kvz_config
	DD	-141					; ffffff73H
	DD	1
	DD	$LN337@kvz_config
	DD	-192					; ffffff40H
	DD	4
	DD	$LN338@kvz_config
	DD	-204					; ffffff34H
	DD	4
	DD	$LN339@kvz_config
	DD	-224					; ffffff20H
	DD	12					; 0000000cH
	DD	$LN340@kvz_config
	DD	-257					; fffffeffH
	DD	1
	DD	$LN341@kvz_config
	DD	-281					; fffffee7H
	DD	1
	DD	$LN342@kvz_config
	DD	-329					; fffffeb7H
	DD	1
	DD	$LN343@kvz_config
	DD	-341					; fffffeabH
	DD	1
	DD	$LN344@kvz_config
	DD	-389					; fffffe7bH
	DD	1
	DD	$LN345@kvz_config
	DD	-413					; fffffe63H
	DD	1
	DD	$LN346@kvz_config
	DD	-440					; fffffe48H
	DD	4
	DD	$LN347@kvz_config
	DD	-452					; fffffe3cH
	DD	4
	DD	$LN348@kvz_config
	DD	-500					; fffffe0cH
	DD	4
	DD	$LN349@kvz_config
	DD	-512					; fffffe00H
	DD	4
	DD	$LN350@kvz_config
	DD	-524					; fffffdf4H
	DD	4
	DD	$LN351@kvz_config
	DD	-560					; fffffdd0H
	DD	4
	DD	$LN352@kvz_config
	DD	-596					; fffffdacH
	DD	4
	DD	$LN353@kvz_config
	DD	-608					; fffffda0H
	DD	4
	DD	$LN354@kvz_config
	DD	-620					; fffffd94H
	DD	4
	DD	$LN355@kvz_config
	DD	-632					; fffffd88H
	DD	4
	DD	$LN356@kvz_config
	DD	-641					; fffffd7fH
	DD	1
	DD	$LN357@kvz_config
	DD	-653					; fffffd73H
	DD	1
	DD	$LN358@kvz_config
$LN358@kvz_config:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
$LN357@kvz_config:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	103					; 00000067H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	109					; 0000006dH
	DB	0
$LN356@kvz_config:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	72					; 00000048H
	DB	101					; 00000065H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	0
$LN355@kvz_config:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN354@kvz_config:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	84					; 00000054H
	DB	85					; 00000055H
	DB	95					; 0000005fH
	DB	121					; 00000079H
	DB	0
$LN353@kvz_config:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	84					; 00000054H
	DB	85					; 00000055H
	DB	95					; 0000005fH
	DB	120					; 00000078H
	DB	0
$LN352@kvz_config:
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN351@kvz_config:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN350@kvz_config:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN349@kvz_config:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN348@kvz_config:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	0
$LN347@kvz_config:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN346@kvz_config:
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
$LN345@kvz_config:
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN344@kvz_config:
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	0
$LN343@kvz_config:
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	103					; 00000067H
	DB	103					; 00000067H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN342@kvz_config:
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN341@kvz_config:
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	0
$LN340@kvz_config:
	DB	103					; 00000067H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	0
$LN339@kvz_config:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	0
$LN338@kvz_config:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN337@kvz_config:
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN336@kvz_config:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN335@kvz_config:
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	103					; 00000067H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	109					; 0000006dH
	DB	0
$LN334@kvz_config:
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	111					; 0000006fH
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
$LN333@kvz_config:
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	0
$LN332@kvz_config:
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN331@kvz_config:
	DB	102					; 00000066H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	0
$LN330@kvz_config:
	DB	102					; 00000066H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	0
_kvz_config_parse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _kvz_config_destroy
_TEXT	SEGMENT
_cfg$ = 8						; size = 4
_kvz_config_destroy PROC				; COMDAT

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 191  :   if (cfg) {

	cmp	DWORD PTR _cfg$[ebp], 0
	je	$LN2@kvz_config

; 192  :     FREE_POINTER(cfg->cqmfile);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+132], 0

; 193  :     FREE_POINTER(cfg->fast_coeff_table_fn);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2464]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2464], 0

; 194  :     FREE_POINTER(cfg->tiles_width_split);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+144], 0

; 195  :     FREE_POINTER(cfg->tiles_height_split);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+148], 0

; 196  :     FREE_POINTER(cfg->slice_addresses_in_ts);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+164], 0

; 197  :     FREE_POINTER(cfg->roi.dqps);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2404]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2404], 0

; 198  :     FREE_POINTER(cfg->optional_key);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2352]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2352], 0

; 199  :     FREE_POINTER(cfg->fastrd_learning_outdir_fn);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2472]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2472], 0
$LN2@kvz_config:

; 200  :   }
; 201  :   free(cfg);

	mov	esi, esp
	mov	eax, DWORD PTR _cfg$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 202  : 
; 203  :   return 1;

	mov	eax, 1

; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_config_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _kvz_config_init
_TEXT	SEGMENT
_cfg$ = 8						; size = 4
_kvz_config_init PROC					; COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 50   :   cfg->width           = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+12], 0

; 51   :   cfg->height          = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+16], 0

; 52   :   cfg->framerate       = 25; // deprecated and will be removed.

	mov	eax, DWORD PTR _cfg$[ebp]
	movsd	xmm0, QWORD PTR __real@4039000000000000
	movsd	QWORD PTR [eax+24], xmm0

; 53   :   cfg->framerate_num   = 25;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+32], 25			; 00000019H

; 54   :   cfg->framerate_denom = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+36], 1

; 55   :   cfg->qp              = 22;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax], 22			; 00000016H

; 56   :   cfg->intra_qp_offset = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2428], 0

; 57   :   cfg->intra_qp_offset_auto = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2429], 1

; 58   :   cfg->intra_period    = 64;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+4], 64			; 00000040H

; 59   :   cfg->vps_period      = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+8], 0

; 60   :   cfg->deblock_enable  = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+40], 1

; 61   :   cfg->deblock_beta    = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+96], 0

; 62   :   cfg->deblock_tc      = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+100], 0

; 63   :   cfg->sao_type        = 3;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+44], 3

; 64   :   cfg->rdoq_enable     = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+48], 1

; 65   :   cfg->rdoq_skip       = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2372], 1

; 66   :   cfg->signhide_enable = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+52], 1

; 67   :   cfg->smp_enable      = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+56], 0

; 68   :   cfg->amp_enable      = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+60], 0

; 69   :   cfg->rdo             = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+64], 1

; 70   :   cfg->mv_rdo          = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2332], 0

; 71   :   cfg->full_intra_search = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+68], 0

; 72   :   cfg->trskip_enable   = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+72], 0

; 73   :   cfg->tr_depth_intra  = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+76], 0

; 74   :   cfg->ime_algorithm   = 0; /* hexbs */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+80], 0

; 75   :   cfg->fme_level       = 4;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+84], 4

; 76   :   cfg->source_scan_type = 0; /* progressive */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+88], 0

; 77   :   cfg->vui.sar_width   = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+104], 0

; 78   :   cfg->vui.sar_height  = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+108], 0

; 79   :   cfg->vui.overscan    = 0; /* undef */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+112], 0

; 80   :   cfg->vui.videoformat = 5; /* undef */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+113], 5

; 81   :   cfg->vui.fullrange   = 0; /* limited range */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+114], 0

; 82   :   cfg->vui.colorprim   = 2; /* undef */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+115], 2

; 83   :   cfg->vui.transfer    = 2; /* undef */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+116], 2

; 84   :   cfg->vui.colormatrix = 2; /* undef */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+117], 2

; 85   :   cfg->vui.chroma_loc  = 0; /* left center */

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+120], 0

; 86   :   cfg->aud_enable      = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+124], 0

; 87   :   cfg->cqmfile         = NULL;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+132], 0

; 88   :   cfg->fast_coeff_table_fn = NULL;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2464], 0

; 89   :   cfg->ref_frames      = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+128], 1

; 90   :   cfg->gop_len         = 4;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+276], 4

; 91   :   cfg->gop_lowdelay    = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+277], 1

; 92   :   cfg->bipred          = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+92], 0

; 93   :   cfg->target_bitrate  = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2328], 0

; 94   :   cfg->hash            = KVZ_HASH_CHECKSUM;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2340], 1

; 95   :   cfg->lossless        = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2364], 0

; 96   :   cfg->tmvp_enable     = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2368], 1

; 97   :   cfg->implicit_rdpcm  = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2392], 0

; 98   :   cfg->fast_residual_cost_limit = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2430], 0

; 99   : 
; 100  :   cfg->cu_split_termination = KVZ_CU_SPLIT_TERMINATION_ZERO;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2344], 0

; 101  : 
; 102  :   cfg->tiles_width_count  = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+136], 1

; 103  :   cfg->tiles_height_count = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+140], 1

; 104  :   cfg->tiles_width_split  = NULL;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+144], 0

; 105  :   cfg->tiles_height_split = NULL;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+148], 0

; 106  : 
; 107  :   cfg->wpp = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+152], 1

; 108  :   cfg->owf = -1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+156], -1

; 109  :   cfg->slice_count = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+160], 1

; 110  :   cfg->slice_addresses_in_ts = MALLOC(int32_t, 1);

	mov	esi, esp
	push	4
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [ecx+164], eax

; 111  :   cfg->slice_addresses_in_ts[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	DWORD PTR [ecx+eax], 0

; 112  : 
; 113  :   cfg->threads = -1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+168], -1

; 114  :   cfg->cpuid = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+172], 1

; 115  : 
; 116  :   // Defaults for what sizes of PUs are tried.
; 117  :   memset( cfg->pu_depth_inter.min, -1, sizeof( cfg->pu_depth_inter.min ) );

	push	24					; 00000018H
	push	-1
	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 118  :   memset( cfg->pu_depth_inter.max, -1, sizeof( cfg->pu_depth_inter.max ) );

	push	24					; 00000018H
	push	-1
	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 200				; 000000c8H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 119  :   memset( cfg->pu_depth_intra.min, -1, sizeof( cfg->pu_depth_intra.min ) );

	push	24					; 00000018H
	push	-1
	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 224				; 000000e0H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 120  :   memset( cfg->pu_depth_intra.max, -1, sizeof( cfg->pu_depth_intra.max ) );

	push	24					; 00000018H
	push	-1
	mov	eax, DWORD PTR _cfg$[ebp]
	add	eax, 248				; 000000f8H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 121  :   *cfg->pu_depth_inter.min = 2; // 0-3

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+ecx+176], 2

; 122  :   *cfg->pu_depth_inter.max = 3; // 0-3

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+ecx+200], 3

; 123  :   *cfg->pu_depth_intra.min = 2; // 0-4

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+ecx+224], 2

; 124  :   *cfg->pu_depth_intra.max = 3; // 0-4

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [edx+ecx+248], 3

; 125  : 
; 126  :   cfg->add_encoder_info = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+272], 1

; 127  :   cfg->calc_psnr = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2333], 1

; 128  : 
; 129  :   cfg->mv_constraint = KVZ_MV_CONSTRAIN_NONE;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2336], 0

; 130  :   cfg->crypto_features = KVZ_CRYPTO_OFF;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2348], 0

; 131  : 
; 132  :   cfg->me_early_termination = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2356], 1

; 133  :   cfg->intra_rdo_et         = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2360], 0

; 134  : 
; 135  :   cfg->input_format = KVZ_FORMAT_P420;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2376], 1

; 136  :   cfg->input_bitdepth = 8;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2380], 8

; 137  : 
; 138  :   cfg->gop_lp_definition.d = 3;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2384], 3

; 139  :   cfg->gop_lp_definition.t = 1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2388], 1

; 140  :   cfg->open_gop = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2432], 1

; 141  : 
; 142  :   cfg->roi.width = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2396], 0

; 143  :   cfg->roi.height = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2400], 0

; 144  :   cfg->roi.dqps = NULL;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2404], 0

; 145  :   cfg->set_qp_in_cu = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2431], 0

; 146  : 
; 147  :   cfg->erp_aqp = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2412], 0

; 148  : 
; 149  :   cfg->slices = KVZ_SLICES_NONE;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2408], 0

; 150  : 
; 151  :   cfg->optional_key = NULL;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2352], 0

; 152  : 
; 153  :   cfg->level = 62; // default hevc level, 6.2 (the highest)

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2416], 62			; 0000003eH

; 154  :   cfg->force_level = true; // don't care about level limits by-default

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2417], 1

; 155  :   cfg->high_tier = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2418], 0

; 156  : 
; 157  :   cfg->me_max_steps = (uint32_t)-1;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2424], -1

; 158  : 
; 159  :   cfg->vaq = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2436], 0

; 160  : 
; 161  :   cfg->scaling_list = KVZ_SCALING_LIST_OFF;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2440], 0

; 162  : 
; 163  :   cfg->max_merge = 5;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2441], 5

; 164  :   cfg->early_skip = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2442], 1

; 165  : 
; 166  :   cfg->ml_pu_depth_intra = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2443], 0

; 167  : 
; 168  :   cfg->partial_coding.startCTU_x = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2444], 0

; 169  :   cfg->partial_coding.startCTU_y = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2445], 0

; 170  :   cfg->partial_coding.fullWidth = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	WORD PTR [ecx+2446], ax

; 171  :   cfg->partial_coding.fullHeight = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	WORD PTR [ecx+2448], ax

; 172  : 
; 173  :   cfg->zero_coeff_rdo = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2450], 1

; 174  : 
; 175  :   cfg->rc_algorithm = KVZ_NO_RC;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2452], 0

; 176  :   cfg->intra_bit_allocation = false;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2453], 0

; 177  :   cfg->clip_neighbour = true;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2454], 1

; 178  : 
; 179  :   cfg->file_format = KVZ_FORMAT_AUTO;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2456], 0

; 180  : 
; 181  :   cfg->stats_file_prefix = NULL;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2460], 0

; 182  : 
; 183  :   cfg->fastrd_sampling_on = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2469], 0

; 184  :   cfg->fastrd_accuracy_check_on = 0;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	BYTE PTR [eax+2470], 0

; 185  :   cfg->fastrd_learning_outdir_fn = NULL;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	DWORD PTR [eax+2472], 0

; 186  :   return 1;

	mov	eax, 1

; 187  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_config_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
;	COMDAT _kvz_config_alloc
_TEXT	SEGMENT
_kvz_config_alloc PROC					; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __80A96665_cfg@c
	call	@__CheckForDebuggerJustMyCode@4

; 45   :   return calloc(1, sizeof(kvz_config));

	mov	esi, esp
	push	2480					; 000009b0H
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 46   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_config_alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2270 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 2271 :         int _Result;
; 2272 :         va_list _ArgList;
; 2273 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 2274 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buffer$[ebp]
	push	edx
	call	__vsscanf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 2275 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 2276 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2277 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsscanf_l PROC					; COMDAT

; 2175 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 2176 :         return __stdio_common_vsscanf(

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	___local_stdio_scanf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2177 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2178 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2179 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fscanf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fscanf	PROC						; COMDAT

; 1204 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1205 :         int _Result;
; 1206 :         va_list _ArgList;
; 1207 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1208 :         _Result = _vfscanf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfscanf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1209 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1210 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1211 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfscanf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfscanf_l PROC					; COMDAT

; 1062 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1063 :         return __stdio_common_vfscanf(

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_scanf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfscanf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1064 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 1065 :             _Stream, _Format, _Locale, _ArgList);
; 1066 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 644  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 96   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1850469A_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 97   :         static unsigned __int64 _OptionsStorage;
; 98   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 99   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1850469A_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
