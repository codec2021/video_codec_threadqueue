; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_kvz_g_go_rice_range
PUBLIC	_kvz_g_go_rice_prefix_len
PUBLIC	_kvz_entropy_bits
PUBLIC	_kvz_f_entropy_bits
PUBLIC	??_C@_0P@FIMIKDEG@array_checksum@		; `string'
PUBLIC	??_C@_09INHMEIKP@array_md5@			; `string'
PUBLIC	??_C@_07DDJKLCAH@reg_sad@			; `string'
PUBLIC	??_C@_07CCGEEBAL@sad_4x4@			; `string'
PUBLIC	??_C@_07MEAHLBLP@sad_8x8@			; `string'
PUBLIC	??_C@_09CIFGAEGF@sad_16x16@			; `string'
PUBLIC	??_C@_09PHPGBCME@sad_32x32@			; `string'
PUBLIC	??_C@_09HIOKBDLK@sad_64x64@			; `string'
PUBLIC	??_C@_08GDBJPAOD@satd_4x4@			; `string'
PUBLIC	??_C@_08IFHKAAFH@satd_8x8@			; `string'
PUBLIC	??_C@_0L@CJHLPOG@satd_16x16@			; `string'
PUBLIC	??_C@_0L@NNDHKJEH@satd_32x32@			; `string'
PUBLIC	??_C@_0L@FCCLKIDJ@satd_64x64@			; `string'
PUBLIC	??_C@_0O@FHJAMJMP@satd_any_size@		; `string'
PUBLIC	??_C@_0N@PBMCJFCI@sad_4x4_dual@			; `string'
PUBLIC	??_C@_0N@NAFGAMEI@sad_8x8_dual@			; `string'
PUBLIC	??_C@_0P@KGAKCNHP@sad_16x16_dual@		; `string'
PUBLIC	??_C@_0P@EBOHBHKK@sad_32x32_dual@		; `string'
PUBLIC	??_C@_0P@BGJOPAPB@sad_64x64_dual@		; `string'
PUBLIC	??_C@_0O@PJODLFIO@satd_4x4_dual@		; `string'
PUBLIC	??_C@_0O@NIHHCMOO@satd_8x8_dual@		; `string'
PUBLIC	??_C@_0BA@GFDJBOPJ@satd_16x16_dual@		; `string'
PUBLIC	??_C@_0BA@ICNECECM@satd_32x32_dual@		; `string'
PUBLIC	??_C@_0BA@NFKNMDHH@satd_64x64_dual@		; `string'
PUBLIC	??_C@_0BD@EFOGIBKC@satd_any_size_quad@		; `string'
PUBLIC	??_C@_0BA@BPDFDAFM@pixels_calc_ssd@		; `string'
PUBLIC	??_C@_0P@FIKELBGI@bipred_average@		; `string'
PUBLIC	??_C@_0BC@IMILIHON@get_optimized_sad@		; `string'
PUBLIC	??_C@_07OEMLCPNF@ver_sad@			; `string'
PUBLIC	??_C@_07CJIKFDIC@hor_sad@			; `string'
PUBLIC	??_C@_09GDPKBOJB@pixel_var@			; `string'
PUBLIC	??_C@_0BF@BJKPGPEP@fast_forward_dst_4x4@	; `string'
PUBLIC	??_C@_07MAFDGKIL@dct_4x4@			; `string'
PUBLIC	??_C@_07CGDAJKDP@dct_8x8@			; `string'
PUBLIC	??_C@_09LPGJIHFJ@dct_16x16@			; `string'
PUBLIC	??_C@_09GAMJJBPI@dct_32x32@			; `string'
PUBLIC	??_C@_0BF@LGIDMEOF@fast_inverse_dst_4x4@	; `string'
PUBLIC	??_C@_08LDLIJGLD@idct_4x4@			; `string'
PUBLIC	??_C@_08FFNLGGAH@idct_8x8@			; `string'
PUBLIC	??_C@_0L@BMPNPGHO@idct_16x16@			; `string'
PUBLIC	??_C@_0L@MDFNOANP@idct_32x32@			; `string'
PUBLIC	??_C@_0CA@KBMGLOML@filter_hpel_blocks_hor_ver_luma@ ; `string'
PUBLIC	??_C@_0BN@LGIFMJCD@filter_hpel_blocks_diag_luma@ ; `string'
PUBLIC	??_C@_0CA@HAFBJKBM@filter_qpel_blocks_hor_ver_luma@ ; `string'
PUBLIC	??_C@_0BN@LBBJMBKC@filter_qpel_blocks_diag_luma@ ; `string'
PUBLIC	??_C@_0BH@DGLFPIPB@sample_quarterpel_luma@	; `string'
PUBLIC	??_C@_0BF@HOLGGLNK@sample_octpel_chroma@	; `string'
PUBLIC	??_C@_0BK@LCPNGAOF@sample_quarterpel_luma_hi@	; `string'
PUBLIC	??_C@_0BI@EFIAEBMP@sample_octpel_chroma_hi@	; `string'
PUBLIC	??_C@_0BD@MPANGNDO@get_extended_block@		; `string'
PUBLIC	??_C@_05DFPBCFDJ@quant@				; `string'
PUBLIC	??_C@_0BC@MPMPMGJB@quantize_residual@		; `string'
PUBLIC	??_C@_07GMDOJGPA@dequant@			; `string'
PUBLIC	??_C@_0O@ECIHPEON@coeff_abs_sum@		; `string'
PUBLIC	??_C@_0BA@HMNKAKOO@fast_coeff_cost@		; `string'
PUBLIC	??_C@_0N@NMFCEONC@angular_pred@			; `string'
PUBLIC	??_C@_0BC@KPOCLILL@intra_pred_planar@		; `string'
PUBLIC	??_C@_0BH@EAOLFJGL@intra_pred_filtered_dc@	; `string'
PUBLIC	??_C@_0BF@LGILOHOJ@sao_edge_ddistortion@	; `string'
PUBLIC	??_C@_0BC@OCNKGNNI@calc_sao_edge_dir@		; `string'
PUBLIC	??_C@_0BG@IJPOOFFG@sao_reconstruct_color@	; `string'
PUBLIC	??_C@_0BF@HDNLAKN@sao_band_ddistortion@		; `string'
PUBLIC	??_C@_0BB@GDIDDFDB@encode_coeff_nxn@		; `string'
PUBLIC	??_C@_09HEJCJCBI@?1?$CF02i?4txt@		; `string'
EXTRN	_kvz_array_checksum:DWORD
EXTRN	_kvz_array_md5:DWORD
EXTRN	_kvz_reg_sad:DWORD
EXTRN	_kvz_sad_4x4:DWORD
EXTRN	_kvz_sad_8x8:DWORD
EXTRN	_kvz_sad_16x16:DWORD
EXTRN	_kvz_sad_32x32:DWORD
EXTRN	_kvz_sad_64x64:DWORD
EXTRN	_kvz_satd_4x4:DWORD
EXTRN	_kvz_satd_8x8:DWORD
EXTRN	_kvz_satd_16x16:DWORD
EXTRN	_kvz_satd_32x32:DWORD
EXTRN	_kvz_satd_64x64:DWORD
EXTRN	_kvz_satd_any_size:DWORD
EXTRN	_kvz_sad_4x4_dual:DWORD
EXTRN	_kvz_sad_8x8_dual:DWORD
EXTRN	_kvz_sad_16x16_dual:DWORD
EXTRN	_kvz_sad_32x32_dual:DWORD
EXTRN	_kvz_sad_64x64_dual:DWORD
EXTRN	_kvz_satd_4x4_dual:DWORD
EXTRN	_kvz_satd_8x8_dual:DWORD
EXTRN	_kvz_satd_16x16_dual:DWORD
EXTRN	_kvz_satd_32x32_dual:DWORD
EXTRN	_kvz_satd_64x64_dual:DWORD
EXTRN	_kvz_satd_any_size_quad:DWORD
EXTRN	_kvz_pixels_calc_ssd:DWORD
EXTRN	_kvz_bipred_average:DWORD
EXTRN	_kvz_get_optimized_sad:DWORD
EXTRN	_kvz_ver_sad:DWORD
EXTRN	_kvz_hor_sad:DWORD
EXTRN	_kvz_pixel_var:DWORD
EXTRN	_kvz_fast_forward_dst_4x4:DWORD
EXTRN	_kvz_dct_4x4:DWORD
EXTRN	_kvz_dct_8x8:DWORD
EXTRN	_kvz_dct_16x16:DWORD
EXTRN	_kvz_dct_32x32:DWORD
EXTRN	_kvz_fast_inverse_dst_4x4:DWORD
EXTRN	_kvz_idct_4x4:DWORD
EXTRN	_kvz_idct_8x8:DWORD
EXTRN	_kvz_idct_16x16:DWORD
EXTRN	_kvz_idct_32x32:DWORD
EXTRN	_kvz_filter_hpel_blocks_hor_ver_luma:DWORD
EXTRN	_kvz_filter_hpel_blocks_diag_luma:DWORD
EXTRN	_kvz_filter_qpel_blocks_hor_ver_luma:DWORD
EXTRN	_kvz_filter_qpel_blocks_diag_luma:DWORD
EXTRN	_kvz_get_extended_block:DWORD
EXTRN	_kvz_sample_quarterpel_luma:DWORD
EXTRN	_kvz_sample_octpel_chroma:DWORD
EXTRN	_kvz_sample_quarterpel_luma_hi:DWORD
EXTRN	_kvz_sample_octpel_chroma_hi:DWORD
EXTRN	_kvz_quant:DWORD
EXTRN	_kvz_quantize_residual:DWORD
EXTRN	_kvz_dequant:DWORD
EXTRN	_kvz_coeff_abs_sum:DWORD
EXTRN	_kvz_fast_coeff_cost:DWORD
EXTRN	_kvz_angular_pred:DWORD
EXTRN	_kvz_intra_pred_planar:DWORD
EXTRN	_kvz_intra_pred_filtered_dc:DWORD
EXTRN	_kvz_sao_edge_ddistortion:DWORD
EXTRN	_kvz_calc_sao_edge_dir:DWORD
EXTRN	_kvz_sao_reconstruct_color:DWORD
EXTRN	_kvz_sao_band_ddistortion:DWORD
EXTRN	_kvz_encode_coeff_nxn:DWORD
msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__6C65A336_cu@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__546CF5FC_crypto@h DB 01H
__6BE1C69C_encoderstate@h DB 01H
__79334164_rdo@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_09HEJCJCBI@?1?$CF02i?4txt@
CONST	SEGMENT
??_C@_09HEJCJCBI@?1?$CF02i?4txt@ DB '/%02i.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GDIDDFDB@encode_coeff_nxn@
CONST	SEGMENT
??_C@_0BB@GDIDDFDB@encode_coeff_nxn@ DB 'encode_coeff_nxn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HDNLAKN@sao_band_ddistortion@
CONST	SEGMENT
??_C@_0BF@HDNLAKN@sao_band_ddistortion@ DB 'sao_band_ddistortion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IJPOOFFG@sao_reconstruct_color@
CONST	SEGMENT
??_C@_0BG@IJPOOFFG@sao_reconstruct_color@ DB 'sao_reconstruct_color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OCNKGNNI@calc_sao_edge_dir@
CONST	SEGMENT
??_C@_0BC@OCNKGNNI@calc_sao_edge_dir@ DB 'calc_sao_edge_dir', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LGILOHOJ@sao_edge_ddistortion@
CONST	SEGMENT
??_C@_0BF@LGILOHOJ@sao_edge_ddistortion@ DB 'sao_edge_ddistortion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EAOLFJGL@intra_pred_filtered_dc@
CONST	SEGMENT
??_C@_0BH@EAOLFJGL@intra_pred_filtered_dc@ DB 'intra_pred_filtered_dc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KPOCLILL@intra_pred_planar@
CONST	SEGMENT
??_C@_0BC@KPOCLILL@intra_pred_planar@ DB 'intra_pred_planar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NMFCEONC@angular_pred@
CONST	SEGMENT
??_C@_0N@NMFCEONC@angular_pred@ DB 'angular_pred', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HMNKAKOO@fast_coeff_cost@
CONST	SEGMENT
??_C@_0BA@HMNKAKOO@fast_coeff_cost@ DB 'fast_coeff_cost', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ECIHPEON@coeff_abs_sum@
CONST	SEGMENT
??_C@_0O@ECIHPEON@coeff_abs_sum@ DB 'coeff_abs_sum', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMDOJGPA@dequant@
CONST	SEGMENT
??_C@_07GMDOJGPA@dequant@ DB 'dequant', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MPMPMGJB@quantize_residual@
CONST	SEGMENT
??_C@_0BC@MPMPMGJB@quantize_residual@ DB 'quantize_residual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFPBCFDJ@quant@
CONST	SEGMENT
??_C@_05DFPBCFDJ@quant@ DB 'quant', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MPANGNDO@get_extended_block@
CONST	SEGMENT
??_C@_0BD@MPANGNDO@get_extended_block@ DB 'get_extended_block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EFIAEBMP@sample_octpel_chroma_hi@
CONST	SEGMENT
??_C@_0BI@EFIAEBMP@sample_octpel_chroma_hi@ DB 'sample_octpel_chroma_hi', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LCPNGAOF@sample_quarterpel_luma_hi@
CONST	SEGMENT
??_C@_0BK@LCPNGAOF@sample_quarterpel_luma_hi@ DB 'sample_quarterpel_luma_'
	DB	'hi', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOLGGLNK@sample_octpel_chroma@
CONST	SEGMENT
??_C@_0BF@HOLGGLNK@sample_octpel_chroma@ DB 'sample_octpel_chroma', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DGLFPIPB@sample_quarterpel_luma@
CONST	SEGMENT
??_C@_0BH@DGLFPIPB@sample_quarterpel_luma@ DB 'sample_quarterpel_luma', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LBBJMBKC@filter_qpel_blocks_diag_luma@
CONST	SEGMENT
??_C@_0BN@LBBJMBKC@filter_qpel_blocks_diag_luma@ DB 'filter_qpel_blocks_d'
	DB	'iag_luma', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HAFBJKBM@filter_qpel_blocks_hor_ver_luma@
CONST	SEGMENT
??_C@_0CA@HAFBJKBM@filter_qpel_blocks_hor_ver_luma@ DB 'filter_qpel_block'
	DB	's_hor_ver_luma', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGIFMJCD@filter_hpel_blocks_diag_luma@
CONST	SEGMENT
??_C@_0BN@LGIFMJCD@filter_hpel_blocks_diag_luma@ DB 'filter_hpel_blocks_d'
	DB	'iag_luma', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KBMGLOML@filter_hpel_blocks_hor_ver_luma@
CONST	SEGMENT
??_C@_0CA@KBMGLOML@filter_hpel_blocks_hor_ver_luma@ DB 'filter_hpel_block'
	DB	's_hor_ver_luma', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MDFNOANP@idct_32x32@
CONST	SEGMENT
??_C@_0L@MDFNOANP@idct_32x32@ DB 'idct_32x32', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BMPNPGHO@idct_16x16@
CONST	SEGMENT
??_C@_0L@BMPNPGHO@idct_16x16@ DB 'idct_16x16', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFNLGGAH@idct_8x8@
CONST	SEGMENT
??_C@_08FFNLGGAH@idct_8x8@ DB 'idct_8x8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LDLIJGLD@idct_4x4@
CONST	SEGMENT
??_C@_08LDLIJGLD@idct_4x4@ DB 'idct_4x4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LGIDMEOF@fast_inverse_dst_4x4@
CONST	SEGMENT
??_C@_0BF@LGIDMEOF@fast_inverse_dst_4x4@ DB 'fast_inverse_dst_4x4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GAMJJBPI@dct_32x32@
CONST	SEGMENT
??_C@_09GAMJJBPI@dct_32x32@ DB 'dct_32x32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LPGJIHFJ@dct_16x16@
CONST	SEGMENT
??_C@_09LPGJIHFJ@dct_16x16@ DB 'dct_16x16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CGDAJKDP@dct_8x8@
CONST	SEGMENT
??_C@_07CGDAJKDP@dct_8x8@ DB 'dct_8x8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MAFDGKIL@dct_4x4@
CONST	SEGMENT
??_C@_07MAFDGKIL@dct_4x4@ DB 'dct_4x4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BJKPGPEP@fast_forward_dst_4x4@
CONST	SEGMENT
??_C@_0BF@BJKPGPEP@fast_forward_dst_4x4@ DB 'fast_forward_dst_4x4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDPKBOJB@pixel_var@
CONST	SEGMENT
??_C@_09GDPKBOJB@pixel_var@ DB 'pixel_var', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CJIKFDIC@hor_sad@
CONST	SEGMENT
??_C@_07CJIKFDIC@hor_sad@ DB 'hor_sad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OEMLCPNF@ver_sad@
CONST	SEGMENT
??_C@_07OEMLCPNF@ver_sad@ DB 'ver_sad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IMILIHON@get_optimized_sad@
CONST	SEGMENT
??_C@_0BC@IMILIHON@get_optimized_sad@ DB 'get_optimized_sad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FIKELBGI@bipred_average@
CONST	SEGMENT
??_C@_0P@FIKELBGI@bipred_average@ DB 'bipred_average', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BPDFDAFM@pixels_calc_ssd@
CONST	SEGMENT
??_C@_0BA@BPDFDAFM@pixels_calc_ssd@ DB 'pixels_calc_ssd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EFOGIBKC@satd_any_size_quad@
CONST	SEGMENT
??_C@_0BD@EFOGIBKC@satd_any_size_quad@ DB 'satd_any_size_quad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NFKNMDHH@satd_64x64_dual@
CONST	SEGMENT
??_C@_0BA@NFKNMDHH@satd_64x64_dual@ DB 'satd_64x64_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ICNECECM@satd_32x32_dual@
CONST	SEGMENT
??_C@_0BA@ICNECECM@satd_32x32_dual@ DB 'satd_32x32_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GFDJBOPJ@satd_16x16_dual@
CONST	SEGMENT
??_C@_0BA@GFDJBOPJ@satd_16x16_dual@ DB 'satd_16x16_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NIHHCMOO@satd_8x8_dual@
CONST	SEGMENT
??_C@_0O@NIHHCMOO@satd_8x8_dual@ DB 'satd_8x8_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PJODLFIO@satd_4x4_dual@
CONST	SEGMENT
??_C@_0O@PJODLFIO@satd_4x4_dual@ DB 'satd_4x4_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BGJOPAPB@sad_64x64_dual@
CONST	SEGMENT
??_C@_0P@BGJOPAPB@sad_64x64_dual@ DB 'sad_64x64_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EBOHBHKK@sad_32x32_dual@
CONST	SEGMENT
??_C@_0P@EBOHBHKK@sad_32x32_dual@ DB 'sad_32x32_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KGAKCNHP@sad_16x16_dual@
CONST	SEGMENT
??_C@_0P@KGAKCNHP@sad_16x16_dual@ DB 'sad_16x16_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAFGAMEI@sad_8x8_dual@
CONST	SEGMENT
??_C@_0N@NAFGAMEI@sad_8x8_dual@ DB 'sad_8x8_dual', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PBMCJFCI@sad_4x4_dual@
CONST	SEGMENT
??_C@_0N@PBMCJFCI@sad_4x4_dual@ DB 'sad_4x4_dual', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHJAMJMP@satd_any_size@
CONST	SEGMENT
??_C@_0O@FHJAMJMP@satd_any_size@ DB 'satd_any_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FCCLKIDJ@satd_64x64@
CONST	SEGMENT
??_C@_0L@FCCLKIDJ@satd_64x64@ DB 'satd_64x64', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNDHKJEH@satd_32x32@
CONST	SEGMENT
??_C@_0L@NNDHKJEH@satd_32x32@ DB 'satd_32x32', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CJHLPOG@satd_16x16@
CONST	SEGMENT
??_C@_0L@CJHLPOG@satd_16x16@ DB 'satd_16x16', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IFHKAAFH@satd_8x8@
CONST	SEGMENT
??_C@_08IFHKAAFH@satd_8x8@ DB 'satd_8x8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDBJPAOD@satd_4x4@
CONST	SEGMENT
??_C@_08GDBJPAOD@satd_4x4@ DB 'satd_4x4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HIOKBDLK@sad_64x64@
CONST	SEGMENT
??_C@_09HIOKBDLK@sad_64x64@ DB 'sad_64x64', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHPGBCME@sad_32x32@
CONST	SEGMENT
??_C@_09PHPGBCME@sad_32x32@ DB 'sad_32x32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CIFGAEGF@sad_16x16@
CONST	SEGMENT
??_C@_09CIFGAEGF@sad_16x16@ DB 'sad_16x16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEAHLBLP@sad_8x8@
CONST	SEGMENT
??_C@_07MEAHLBLP@sad_8x8@ DB 'sad_8x8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCGEEBAL@sad_4x4@
CONST	SEGMENT
??_C@_07CCGEEBAL@sad_4x4@ DB 'sad_4x4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDJKLCAH@reg_sad@
CONST	SEGMENT
??_C@_07DDJKLCAH@reg_sad@ DB 'reg_sad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09INHMEIKP@array_md5@
CONST	SEGMENT
??_C@_09INHMEIKP@array_md5@ DB 'array_md5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FIMIKDEG@array_checksum@
CONST	SEGMENT
??_C@_0P@FIMIKDEG@array_checksum@ DB 'array_checksum', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
_cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
_default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
_g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
_g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
_g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
_g_sig_last_scan_cg DD FLAT:_g_sig_last_scan_8x8
	DD	FLAT:_g_sig_last_scan_8x8+16
	DD	FLAT:_g_sig_last_scan_8x8+32
	DD	FLAT:_g_sig_last_scan_8x8
	DD	FLAT:_g_sig_last_scan_8x8+16
	DD	FLAT:_g_sig_last_scan_8x8+32
	DD	FLAT:_g_sig_last_scan_16x16
	DD	00H
	DD	00H
	DD	FLAT:_g_sig_last_scan_32x32
	DD	00H
	DD	00H
_g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
_g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+2
_kvz_g_go_rice_range DD 07H
	DD	0eH
	DD	01aH
	DD	02eH
	DD	04eH
_kvz_g_go_rice_prefix_len DD 08H
	DD	07H
	DD	06H
	DD	05H
	DD	04H
	ORG $+4
_kvz_entropy_bits DD 08000H
	DD	08000H
	DD	076daH
	DD	089a0H
	DD	06e92H
	DD	09340H
	DD	0670aH
	DD	09cdfH
	DD	06029H
	DD	0a67fH
	DD	059ddH
	DD	0b01fH
	DD	05413H
	DD	0b9bfH
	DD	04ebfH
	DD	0c35fH
	DD	049d3H
	DD	0ccffH
	DD	04546H
	DD	0d69eH
	DD	0410dH
	DD	0e03eH
	DD	03d22H
	DD	0e9deH
	DD	0397dH
	DD	0f37eH
	DD	03619H
	DD	0fd1eH
	DD	032eeH
	DD	0106beH
	DD	02ffaH
	DD	01105dH
	DD	02d37H
	DD	0119fdH
	DD	02aa2H
	DD	01239dH
	DD	02836H
	DD	012d3dH
	DD	025f2H
	DD	0136ddH
	DD	023d1H
	DD	01407cH
	DD	021d2H
	DD	014a1cH
	DD	01ff2H
	DD	0153bcH
	DD	01e2fH
	DD	015d5cH
	DD	01c87H
	DD	0166fcH
	DD	01af7H
	DD	01709bH
	DD	0197fH
	DD	017a3bH
	DD	0181dH
	DD	0183dbH
	DD	016d0H
	DD	018d7bH
	DD	01595H
	DD	01971bH
	DD	0146cH
	DD	01a0bbH
	DD	01354H
	DD	01aa5aH
	DD	0124cH
	DD	01b3faH
	DD	01153H
	DD	01bd9aH
	DD	01067H
	DD	01c73aH
	DD	0f89H
	DD	01d0daH
	DD	0eb7H
	DD	01da79H
	DD	0df0H
	DD	01e419H
	DD	0d34H
	DD	01edb9H
	DD	0c82H
	DD	01f759H
	DD	0bdaH
	DD	0200f9H
	DD	0b3cH
	DD	020a99H
	DD	0aa5H
	DD	021438H
	DD	0a17H
	DD	021dd8H
	DD	0990H
	DD	022778H
	DD	0911H
	DD	023118H
	DD	0898H
	DD	023ab8H
	DD	0826H
	DD	024458H
	DD	07baH
	DD	024df7H
	DD	0753H
	DD	025797H
	DD	06f2H
	DD	026137H
	DD	0696H
	DD	026ad7H
	DD	063fH
	DD	027477H
	DD	05edH
	DD	027e17H
	DD	059fH
	DD	0287b6H
	DD	0554H
	DD	029156H
	DD	050eH
	DD	029af6H
	DD	04ccH
	DD	02a497H
	DD	048dH
	DD	02ae35H
	DD	0451H
	DD	02b7d6H
	DD	0418H
	DD	02c176H
	DD	03e2H
	DD	02cb15H
	DD	03afH
	DD	02d4b5H
	DD	037fH
	DD	02de55H
_kvz_f_entropy_bits DD 03f800000r		; 1
	DD	03f800000r			; 1
	DD	03f6db400r			; 0.928528
	DD	03f89a000r			; 1.0752
	DD	03f5d2400r			; 0.863831
	DD	03f934000r			; 1.15039
	DD	03f4e1400r			; 0.804993
	DD	03f9cdf00r			; 1.22556
	DD	03f405200r			; 0.751251
	DD	03fa67f00r			; 1.30075
	DD	03f33ba00r			; 0.702057
	DD	03fb01f00r			; 1.37595
	DD	03f282600r			; 0.65683
	DD	03fb9bf00r			; 1.45114
	DD	03f1d7e00r			; 0.615204
	DD	03fc35f00r			; 1.52634
	DD	03f13a600r			; 0.576752
	DD	03fccff00r			; 1.60153
	DD	03f0a8c00r			; 0.541199
	DD	03fd69e00r			; 1.6767
	DD	03f021a00r			; 0.508209
	DD	03fe03e00r			; 1.75189
	DD	03ef48800r			; 0.4776
	DD	03fe9de00r			; 1.82709
	DD	03ee5f400r			; 0.449127
	DD	03ff37e00r			; 1.90228
	DD	03ed86400r			; 0.422638
	DD	03ffd1e00r			; 1.97748
	DD	03ecbb800r			; 0.397888
	DD	040035f00r			; 2.05267
	DD	03ebfe800r			; 0.374817
	DD	040082e80r			; 2.12784
	DD	03eb4dc00r			; 0.353241
	DD	0400cfe80r			; 2.20303
	DD	03eaa8800r			; 0.333069
	DD	04011ce80r			; 2.27823
	DD	03ea0d800r			; 0.314148
	DD	040169e80r			; 2.35342
	DD	03e97c800r			; 0.296448
	DD	0401b6e80r			; 2.42862
	DD	03e8f4400r			; 0.279816
	DD	040203e00r			; 2.50378
	DD	03e874800r			; 0.264221
	DD	040250e00r			; 2.57898
	DD	03e7f9000r			; 0.249573
	DD	04029de00r			; 2.65417
	DD	03e717800r			; 0.235809
	DD	0402eae00r			; 2.72937
	DD	03e643800r			; 0.22287
	DD	040337e00r			; 2.80457
	DD	03e57b800r			; 0.210663
	DD	040384d80r			; 2.87973
	DD	03e4bf800r			; 0.199188
	DD	0403d1d80r			; 2.95493
	DD	03e40e800r			; 0.188385
	DD	04041ed80r			; 3.03012
	DD	03e368000r			; 0.178223
	DD	04046bd80r			; 3.10532
	DD	03e2ca800r			; 0.16861
	DD	0404b8d80r			; 3.18051
	DD	03e236000r			; 0.159546
	DD	040505d80r			; 3.25571
	DD	03e1aa000r			; 0.151001
	DD	040552d00r			; 3.33087
	DD	03e126000r			; 0.142944
	DD	04059fd00r			; 3.40607
	DD	03e0a9800r			; 0.135345
	DD	0405ecd00r			; 3.48126
	DD	03e033800r			; 0.128143
	DD	040639d00r			; 3.55646
	DD	03df89000r			; 0.121368
	DD	040686d00r			; 3.63165
	DD	03deb7000r			; 0.11496
	DD	0406d3c80r			; 3.70682
	DD	03ddf0000r			; 0.108887
	DD	040720c80r			; 3.78201
	DD	03dd34000r			; 0.103149
	DD	04076dc80r			; 3.85721
	DD	03dc82000r			; 0.0977173
	DD	0407bac80r			; 3.9324
	DD	03dbda000r			; 0.0925903
	DD	040803e40r			; 4.0076
	DD	03db3c000r			; 0.0877686
	DD	04082a640r			; 4.08279
	DD	03daa5000r			; 0.0831604
	DD	040850e00r			; 4.15796
	DD	03da17000r			; 0.0788269
	DD	040877600r			; 4.23315
	DD	03d990000r			; 0.074707
	DD	04089de00r			; 4.30835
	DD	03d911000r			; 0.0708313
	DD	0408c4600r			; 4.38354
	DD	03d898000r			; 0.0671387
	DD	0408eae00r			; 4.45874
	DD	03d826000r			; 0.0636597
	DD	040911600r			; 4.53394
	DD	03d774000r			; 0.0603638
	DD	040937dc0r			; 4.6091
	DD	03d6a6000r			; 0.0572205
	DD	04095e5c0r			; 4.6843
	DD	03d5e4000r			; 0.0542603
	DD	040984dc0r			; 4.75949
	DD	03d52c000r			; 0.0514526
	DD	0409ab5c0r			; 4.83469
	DD	03d47e000r			; 0.0487976
	DD	0409d1dc0r			; 4.90988
	DD	03d3da000r			; 0.0462952
	DD	0409f85c0r			; 4.98508
	DD	03d33e000r			; 0.0439148
	DD	040a1ed80r			; 5.06024
	DD	03d2a8000r			; 0.041626
	DD	040a45580r			; 5.13544
	DD	03d21c000r			; 0.0394897
	DD	040a6bd80r			; 5.21063
	DD	03d198000r			; 0.0374756
	DD	040a925c0r			; 5.28586
	DD	03d11a000r			; 0.035553
	DD	040ab8d40r			; 5.36099
	DD	03d0a2000r			; 0.0337219
	DD	040adf580r			; 5.43622
	DD	03d030000r			; 0.0319824
	DD	040b05d80r			; 5.51141
	DD	03cf88000r			; 0.0303345
	DD	040b2c540r			; 5.58658
	DD	03cebc000r			; 0.0287781
	DD	040b52d40r			; 5.66177
	DD	03cdfc000r			; 0.0273132
	DD	040b79540r			; 5.73697
_g_sao_edge_offsets DD 0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
_strategies_to_select DD FLAT:??_C@_0P@FIMIKDEG@array_checksum@
	DD	FLAT:_kvz_array_checksum
	DD	FLAT:??_C@_09INHMEIKP@array_md5@
	DD	FLAT:_kvz_array_md5
	DD	FLAT:??_C@_07DDJKLCAH@reg_sad@
	DD	FLAT:_kvz_reg_sad
	DD	FLAT:??_C@_07CCGEEBAL@sad_4x4@
	DD	FLAT:_kvz_sad_4x4
	DD	FLAT:??_C@_07MEAHLBLP@sad_8x8@
	DD	FLAT:_kvz_sad_8x8
	DD	FLAT:??_C@_09CIFGAEGF@sad_16x16@
	DD	FLAT:_kvz_sad_16x16
	DD	FLAT:??_C@_09PHPGBCME@sad_32x32@
	DD	FLAT:_kvz_sad_32x32
	DD	FLAT:??_C@_09HIOKBDLK@sad_64x64@
	DD	FLAT:_kvz_sad_64x64
	DD	FLAT:??_C@_08GDBJPAOD@satd_4x4@
	DD	FLAT:_kvz_satd_4x4
	DD	FLAT:??_C@_08IFHKAAFH@satd_8x8@
	DD	FLAT:_kvz_satd_8x8
	DD	FLAT:??_C@_0L@CJHLPOG@satd_16x16@
	DD	FLAT:_kvz_satd_16x16
	DD	FLAT:??_C@_0L@NNDHKJEH@satd_32x32@
	DD	FLAT:_kvz_satd_32x32
	DD	FLAT:??_C@_0L@FCCLKIDJ@satd_64x64@
	DD	FLAT:_kvz_satd_64x64
	DD	FLAT:??_C@_0O@FHJAMJMP@satd_any_size@
	DD	FLAT:_kvz_satd_any_size
	DD	FLAT:??_C@_0N@PBMCJFCI@sad_4x4_dual@
	DD	FLAT:_kvz_sad_4x4_dual
	DD	FLAT:??_C@_0N@NAFGAMEI@sad_8x8_dual@
	DD	FLAT:_kvz_sad_8x8_dual
	DD	FLAT:??_C@_0P@KGAKCNHP@sad_16x16_dual@
	DD	FLAT:_kvz_sad_16x16_dual
	DD	FLAT:??_C@_0P@EBOHBHKK@sad_32x32_dual@
	DD	FLAT:_kvz_sad_32x32_dual
	DD	FLAT:??_C@_0P@BGJOPAPB@sad_64x64_dual@
	DD	FLAT:_kvz_sad_64x64_dual
	DD	FLAT:??_C@_0O@PJODLFIO@satd_4x4_dual@
	DD	FLAT:_kvz_satd_4x4_dual
	DD	FLAT:??_C@_0O@NIHHCMOO@satd_8x8_dual@
	DD	FLAT:_kvz_satd_8x8_dual
	DD	FLAT:??_C@_0BA@GFDJBOPJ@satd_16x16_dual@
	DD	FLAT:_kvz_satd_16x16_dual
	DD	FLAT:??_C@_0BA@ICNECECM@satd_32x32_dual@
	DD	FLAT:_kvz_satd_32x32_dual
	DD	FLAT:??_C@_0BA@NFKNMDHH@satd_64x64_dual@
	DD	FLAT:_kvz_satd_64x64_dual
	DD	FLAT:??_C@_0BD@EFOGIBKC@satd_any_size_quad@
	DD	FLAT:_kvz_satd_any_size_quad
	DD	FLAT:??_C@_0BA@BPDFDAFM@pixels_calc_ssd@
	DD	FLAT:_kvz_pixels_calc_ssd
	DD	FLAT:??_C@_0P@FIKELBGI@bipred_average@
	DD	FLAT:_kvz_bipred_average
	DD	FLAT:??_C@_0BC@IMILIHON@get_optimized_sad@
	DD	FLAT:_kvz_get_optimized_sad
	DD	FLAT:??_C@_07OEMLCPNF@ver_sad@
	DD	FLAT:_kvz_ver_sad
	DD	FLAT:??_C@_07CJIKFDIC@hor_sad@
	DD	FLAT:_kvz_hor_sad
	DD	FLAT:??_C@_09GDPKBOJB@pixel_var@
	DD	FLAT:_kvz_pixel_var
	DD	FLAT:??_C@_0BF@BJKPGPEP@fast_forward_dst_4x4@
	DD	FLAT:_kvz_fast_forward_dst_4x4
	DD	FLAT:??_C@_07MAFDGKIL@dct_4x4@
	DD	FLAT:_kvz_dct_4x4
	DD	FLAT:??_C@_07CGDAJKDP@dct_8x8@
	DD	FLAT:_kvz_dct_8x8
	DD	FLAT:??_C@_09LPGJIHFJ@dct_16x16@
	DD	FLAT:_kvz_dct_16x16
	DD	FLAT:??_C@_09GAMJJBPI@dct_32x32@
	DD	FLAT:_kvz_dct_32x32
	DD	FLAT:??_C@_0BF@LGIDMEOF@fast_inverse_dst_4x4@
	DD	FLAT:_kvz_fast_inverse_dst_4x4
	DD	FLAT:??_C@_08LDLIJGLD@idct_4x4@
	DD	FLAT:_kvz_idct_4x4
	DD	FLAT:??_C@_08FFNLGGAH@idct_8x8@
	DD	FLAT:_kvz_idct_8x8
	DD	FLAT:??_C@_0L@BMPNPGHO@idct_16x16@
	DD	FLAT:_kvz_idct_16x16
	DD	FLAT:??_C@_0L@MDFNOANP@idct_32x32@
	DD	FLAT:_kvz_idct_32x32
	DD	FLAT:??_C@_0CA@KBMGLOML@filter_hpel_blocks_hor_ver_luma@
	DD	FLAT:_kvz_filter_hpel_blocks_hor_ver_luma
	DD	FLAT:??_C@_0BN@LGIFMJCD@filter_hpel_blocks_diag_luma@
	DD	FLAT:_kvz_filter_hpel_blocks_diag_luma
	DD	FLAT:??_C@_0CA@HAFBJKBM@filter_qpel_blocks_hor_ver_luma@
	DD	FLAT:_kvz_filter_qpel_blocks_hor_ver_luma
	DD	FLAT:??_C@_0BN@LBBJMBKC@filter_qpel_blocks_diag_luma@
	DD	FLAT:_kvz_filter_qpel_blocks_diag_luma
	DD	FLAT:??_C@_0BH@DGLFPIPB@sample_quarterpel_luma@
	DD	FLAT:_kvz_sample_quarterpel_luma
	DD	FLAT:??_C@_0BF@HOLGGLNK@sample_octpel_chroma@
	DD	FLAT:_kvz_sample_octpel_chroma
	DD	FLAT:??_C@_0BK@LCPNGAOF@sample_quarterpel_luma_hi@
	DD	FLAT:_kvz_sample_quarterpel_luma_hi
	DD	FLAT:??_C@_0BI@EFIAEBMP@sample_octpel_chroma_hi@
	DD	FLAT:_kvz_sample_octpel_chroma_hi
	DD	FLAT:??_C@_0BD@MPANGNDO@get_extended_block@
	DD	FLAT:_kvz_get_extended_block
	DD	FLAT:??_C@_05DFPBCFDJ@quant@
	DD	FLAT:_kvz_quant
	DD	FLAT:??_C@_0BC@MPMPMGJB@quantize_residual@
	DD	FLAT:_kvz_quantize_residual
	DD	FLAT:??_C@_07GMDOJGPA@dequant@
	DD	FLAT:_kvz_dequant
	DD	FLAT:??_C@_0O@ECIHPEON@coeff_abs_sum@
	DD	FLAT:_kvz_coeff_abs_sum
	DD	FLAT:??_C@_0BA@HMNKAKOO@fast_coeff_cost@
	DD	FLAT:_kvz_fast_coeff_cost
	DD	FLAT:??_C@_0N@NMFCEONC@angular_pred@
	DD	FLAT:_kvz_angular_pred
	DD	FLAT:??_C@_0BC@KPOCLILL@intra_pred_planar@
	DD	FLAT:_kvz_intra_pred_planar
	DD	FLAT:??_C@_0BH@EAOLFJGL@intra_pred_filtered_dc@
	DD	FLAT:_kvz_intra_pred_filtered_dc
	DD	FLAT:??_C@_0BF@LGILOHOJ@sao_edge_ddistortion@
	DD	FLAT:_kvz_sao_edge_ddistortion
	DD	FLAT:??_C@_0BC@OCNKGNNI@calc_sao_edge_dir@
	DD	FLAT:_kvz_calc_sao_edge_dir
	DD	FLAT:??_C@_0BG@IJPOOFFG@sao_reconstruct_color@
	DD	FLAT:_kvz_sao_reconstruct_color
	DD	FLAT:??_C@_0BF@HDNLAKN@sao_band_ddistortion@
	DD	FLAT:_kvz_sao_band_ddistortion
	DD	FLAT:??_C@_0BB@GDIDDFDB@encode_coeff_nxn@
	DD	FLAT:_kvz_encode_coeff_nxn
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_vsnprintf
PUBLIC	_snprintf
PUBLIC	_kvz_init_rdcost_outfiles
PUBLIC	_kvz_close_rdcost_outfiles
PUBLIC	_kvz_rdoq
PUBLIC	_kvz_get_coeff_cost
PUBLIC	_kvz_get_ic_rate
PUBLIC	_kvz_get_coded_level
PUBLIC	_kvz_calc_mvd_cost_cabac
PUBLIC	_kvz_get_mvd_coding_cost_cabac
PUBLIC	_kvz_rdoq_sign_hiding
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??kvz_init_rdcost_outfiles@@9@9	; `kvz_init_rdcost_outfiles'::`1'::__LINE__Var
PUBLIC	??_C@_1GE@KKEFIIPC@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ ; `string'
PUBLIC	??_C@_1GC@KANFJCIN@?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAf?$AAn?$AA_?$AAt?$AAe?$AAm?$AAp?$AAl@ ; `string'
PUBLIC	??_C@_0BI@BHFDFFJM@Failed?5to?5create?5mutex?6@	; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0BH@MBLPFB@Failed?5to?5open?5?$CFs?3?5?$CFs?6@ ; `string'
PUBLIC	?__LINE__Var@?0??save_ccc@@9@9			; `save_ccc'::`1'::__LINE__Var
PUBLIC	??_C@_1DM@LBICGNLH@?$AAq?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAR?$AAD?$AA_?$AAS?$AAA?$AAM?$AAP?$AAL?$AAI@ ; `string'
PUBLIC	?__LINE__Var@?0??save_accuracy@@9@9		; `save_accuracy'::`1'::__LINE__Var
PUBLIC	??_C@_06FKABJIPB@?$CFu?5?$CFu?6@		; `string'
PUBLIC	?__LINE__Var@?0??kvz_get_coeff_cost@@9@9	; `kvz_get_coeff_cost'::`1'::__LINE__Var
PUBLIC	??_C@_1HM@LHMCIFBA@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAF?$AAa?$AAs?$AAt?$AA?5?$AAR?$AAD?$AA?5?$AAs@ ; `string'
PUBLIC	?__LINE__Var@?0??kvz_rdoq@@9@9			; `kvz_rdoq'::`1'::__LINE__Var
PUBLIC	??_C@_04BIJMKPLJ@?$AA?$AD?$AB?$AC@		; `string'
PUBLIC	??_C@_1HC@GANJHONP@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAh?$AAe?$AAr?$AAe?$AA?5?$AAs?$AAh?$AAo@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4030000000000000
PUBLIC	__real@7fee42d130773b76
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp___wassert:PROC
EXTRN	__imp___errno:PROC
EXTRN	_abs:PROC
EXTRN	_llabs:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strerror:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncat:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_kvz_cabac_encode_bin:PROC
EXTRN	_kvz_cabac_encode_bin_ep:PROC
EXTRN	_kvz_cabac_write_unary_max_symbol:PROC
EXTRN	_pthread_mutex_destroy:PROC
EXTRN	_pthread_mutex_init:PROC
EXTRN	_pthread_mutex_lock:PROC
EXTRN	_pthread_mutex_unlock:PROC
EXTRN	_kvz_fast_coeff_get_weights:PROC
EXTRN	_kvz_context_calc_pattern_sig_ctx:PROC
EXTRN	_kvz_context_get_sig_coeff_group:PROC
EXTRN	_kvz_context_get_sig_ctx_inc:PROC
EXTRN	_kvz_encode_mvd:PROC
EXTRN	_kvz_get_scaled_qp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allmul:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtol3:PROC
EXTRN	__dtoui3:PROC
EXTRN	_kvz_g_sig_last_scan:BYTE
EXTRN	_kvz_g_convert_to_bit:BYTE
EXTRN	_kvz_g_inv_quant_scales:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_fastrd_learning_outfile DD 033H DUP (?)
_outfile_mutex DD 033H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@7fee42d130773b76
CONST	SEGMENT
__real@7fee42d130773b76 DQ 07fee42d130773b76r	; 1.7e+308
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1HC@GANJHONP@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAh?$AAe?$AAr?$AAe?$AA?5?$AAs?$AAh?$AAo@
CONST	SEGMENT
??_C@_1HC@GANJHONP@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAh?$AAe?$AAr?$AAe?$AA?5?$AAs?$AAh?$AAo@ DB '0'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'T', 00H
	DB	'h', 00H, 'e', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'h'
	DB	00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'b', 00H
	DB	'e', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '4', 00H, ','
	DB	00H, ' ', 00H, '1', 00H, '6', 00H, ' ', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, '6', 00H, '4', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'e'
	DB	00H, 'f', 00H, 'f', 00H, 'i', 00H, 'c', 00H, 'i', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'g', 00H, 'r', 00H, 'o', 00H, 'u'
	DB	00H, 'p', 00H, 's', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BIJMKPLJ@?$AA?$AD?$AB?$AC@
CONST	SEGMENT
??_C@_04BIJMKPLJ@?$AA?$AD?$AB?$AC@ DB 00H, 03H, 01H, 02H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_rdoq@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_rdoq@@9@9 DD 02a2H			; `kvz_rdoq'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1HM@LHMCIFBA@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAF?$AAa?$AAs?$AAt?$AA?5?$AAR?$AAD?$AA?5?$AAs@
CONST	SEGMENT
??_C@_1HM@LHMCIFBA@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAF?$AAa?$AAs?$AAt?$AA?5?$AAR?$AAD?$AA?5?$AAs@ DB '0'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'F', 00H
	DB	'a', 00H, 's', 00H, 't', 00H, ' ', 00H, 'R', 00H, 'D', 00H, ' '
	DB	00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'o', 00H, 'e', 00H, 's'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'w', 00H
	DB	'o', 00H, 'r', 00H, 'k', 00H, ' ', 00H, 'w', 00H, 'i', 00H, 't'
	DB	00H, 'h', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 's', 00H, 't', 00H
	DB	'-', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'i', 00H, 'd', 00H, 'u'
	DB	00H, 'a', 00H, 'l', 00H, '-', 00H, 'c', 00H, 'o', 00H, 's', 00H
	DB	't', 00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_get_coeff_cost@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_get_coeff_cost@@9@9 DD 013eH	; `kvz_get_coeff_cost'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_06FKABJIPB@?$CFu?5?$CFu?6@
CONST	SEGMENT
??_C@_06FKABJIPB@?$CFu?5?$CFu?6@ DB '%u %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??save_accuracy@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??save_accuracy@@9@9 DD 0126H		; `save_accuracy'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DM@LBICGNLH@?$AAq?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAR?$AAD?$AA_?$AAS?$AAA?$AAM?$AAP?$AAL?$AAI@
CONST	SEGMENT
??_C@_1DM@LBICGNLH@?$AAq?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAR?$AAD?$AA_?$AAS?$AAA?$AAM?$AAP?$AAL?$AAI@ DB 'q'
	DB	00H, 'p', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'R', 00H
	DB	'D', 00H, '_', 00H, 'S', 00H, 'A', 00H, 'M', 00H, 'P', 00H, 'L'
	DB	00H, 'I', 00H, 'N', 00H, 'G', 00H, '_', 00H, 'M', 00H, 'A', 00H
	DB	'X', 00H, '_', 00H, 'L', 00H, 'A', 00H, 'S', 00H, 'T', 00H, '_'
	DB	00H, 'Q', 00H, 'P', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??save_ccc@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??save_ccc@@9@9 DD 0116H			; `save_ccc'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@MBLPFB@Failed?5to?5open?5?$CFs?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@MBLPFB@Failed?5to?5open?5?$CFs?3?5?$CFs?6@ DB 'Failed to open %'
	DB	's: %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BHFDFFJM@Failed?5to?5create?5mutex?6@
CONST	SEGMENT
??_C@_0BI@BHFDFFJM@Failed?5to?5create?5mutex?6@ DB 'Failed to create mute'
	DB	'x', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@KANFJCIN@?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAf?$AAn?$AA_?$AAt?$AAe?$AAm?$AAp?$AAl@
CONST	SEGMENT
??_C@_1GC@KANFJCIN@?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAf?$AAn?$AA_?$AAt?$AAe?$AAm?$AAp?$AAl@ DB 's'
	DB	00H, 't', 00H, 'r', 00H, 'l', 00H, 'e', 00H, 'n', 00H, '(', 00H
	DB	'f', 00H, 'n', 00H, '_', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'p'
	DB	00H, 'l', 00H, 'a', 00H, 't', 00H, 'e', 00H, ')', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, 'R', 00H, 'D', 00H, '_', 00H, 'S'
	DB	00H, 'A', 00H, 'M', 00H, 'P', 00H, 'L', 00H, 'I', 00H, 'N', 00H
	DB	'G', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'X', 00H, '_', 00H, 'F'
	DB	00H, 'N', 00H, '_', 00H, 'L', 00H, 'E', 00H, 'N', 00H, 'G', 00H
	DB	'T', 00H, 'H', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1GE@KKEFIIPC@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
CONST	SEGMENT
??_C@_1GE@KKEFIIPC@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ DB 'F'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c', 00H, '_'
	DB	00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H, '_', 00H
	DB	'2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k', 00H, 'v'
	DB	00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H, '-', 00H
	DB	'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'r', 00H, 'd', 00H
	DB	'o', 00H, '.', 00H, 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?basename_tmpl@?1??kvz_init_rdcost_outfiles@@9@9 DD FLAT:??_C@_09HEJCJCBI@?1?$CF02i?4txt@ ; `kvz_init_rdcost_outfiles'::`2'::basename_tmpl
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_init_rdcost_outfiles@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_init_rdcost_outfiles@@9@9 DD 0a5H	; `kvz_init_rdcost_outfiles'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_rdoq_sign_hiding
_TEXT	SEGMENT
tv262 = -504						; size = 4
tv165 = -504						; size = 4
tv152 = -504						; size = 4
_bits$1 = -304						; size = 4
_dec_bits$2 = -292					; size = 8
_inc_bits$3 = -276					; size = 8
_abs_coeff$4 = -260					; size = 2
_quant_cost_in_bits$5 = -248				; size = 8
_coeff_scan$6 = -232					; size = 4
_last_coeff_scan$7 = -220				; size = 4
_best$8 = -208						; size = 16
_current$9 = -184					; size = 16
_coeff_scan$10 = -160					; size = 4
_abs_coeff_sum$11 = -148				; size = 4
_signbit$12 = -136					; size = 4
_coeff_i$13 = -124					; size = 4
_first_nz_scan$14 = -112				; size = 4
_coeff_i$15 = -100					; size = 4
_last_nz_scan$16 = -88					; size = 4
_cg_coeff_scan$17 = -76					; size = 4
_cg_scan$18 = -64					; size = 4
_last_cg$ = -52						; size = 4
_rd_factor$ = -40					; size = 8
_inv_quant$ = -24					; size = 4
_ctrl$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_qp_scaled$ = 12					; size = 4
_scan2raster$ = 16					; size = 4
_sh_rates$ = 20						; size = 4
_last_pos$ = 24						; size = 4
_coeffs$ = 28						; size = 4
_quant_coeffs$ = 32					; size = 4
_kvz_rdoq_sign_hiding PROC				; COMDAT

; 537  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 504				; 000001f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-504]
	mov	ecx, 126				; 0000007eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 538  :   const encoder_control_t * const ctrl = state->encoder_control;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ctrl$[ebp], ecx

; 539  : 
; 540  :   int inv_quant = kvz_g_inv_quant_scales[qp_scaled % 6];

	mov	eax, DWORD PTR _qp_scaled$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	movsx	edx, WORD PTR _kvz_g_inv_quant_scales[edx*2]
	mov	DWORD PTR _inv_quant$[ebp], edx

; 541  :   // This somehow scales quant_delta into fractional bits. Instead of the bits
; 542  :   // being multiplied by lambda, the residual is divided by it, or something
; 543  :   // like that.
; 544  :   const int64_t rd_factor = (inv_quant * inv_quant * (1 << (2 * (qp_scaled / 6)))

	mov	esi, DWORD PTR _inv_quant$[ebp]
	imul	esi, DWORD PTR _inv_quant$[ebp]
	mov	eax, DWORD PTR _qp_scaled$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	shl	eax, 1
	mov	edx, 1
	mov	ecx, eax
	shl	edx, cl
	imul	esi, edx
	cvtsi2sd xmm0, esi
	mov	eax, DWORD PTR _state$[ebp]
	divsd	xmm0, QWORD PTR [eax+296]
	divsd	xmm0, QWORD PTR __real@4030000000000000
	mov	ecx, DWORD PTR _ctrl$[ebp]
	movsx	edx, BYTE PTR [ecx+2532]
	lea	ecx, DWORD PTR [edx+edx-16]
	mov	eax, 1
	shl	eax, cl
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	call	__dtol3
	mov	DWORD PTR _rd_factor$[ebp], eax
	mov	DWORD PTR _rd_factor$[ebp+4], edx

; 545  :                       / state->lambda / 16 / (1 << (2 * (ctrl->bitdepth - 8))) + 0.5);
; 546  :   const int last_cg = (last_pos - 1) >> LOG2_SCAN_SET_SIZE;

	mov	eax, DWORD PTR _last_pos$[ebp]
	sub	eax, 1
	sar	eax, 4
	mov	DWORD PTR _last_cg$[ebp], eax

; 547  : 
; 548  :   for (int32_t cg_scan = last_cg; cg_scan >= 0; cg_scan--) {

	mov	eax, DWORD PTR _last_cg$[ebp]
	mov	DWORD PTR _cg_scan$18[ebp], eax
	jmp	SHORT $LN4@kvz_rdoq_s
$LN2@kvz_rdoq_s:
	mov	eax, DWORD PTR _cg_scan$18[ebp]
	sub	eax, 1
	mov	DWORD PTR _cg_scan$18[ebp], eax
$LN4@kvz_rdoq_s:
	cmp	DWORD PTR _cg_scan$18[ebp], 0
	jl	$LN3@kvz_rdoq_s

; 549  :     const int32_t cg_coeff_scan = cg_scan << LOG2_SCAN_SET_SIZE;

	mov	eax, DWORD PTR _cg_scan$18[ebp]
	shl	eax, 4
	mov	DWORD PTR _cg_coeff_scan$17[ebp], eax

; 550  :     
; 551  :     // Find positions of first and last non-zero coefficients in the CG.
; 552  :     int32_t last_nz_scan = -1;

	mov	DWORD PTR _last_nz_scan$16[ebp], -1

; 553  :     for (int32_t coeff_i = SCAN_SET_SIZE - 1; coeff_i >= 0; --coeff_i) {

	mov	DWORD PTR _coeff_i$15[ebp], 15		; 0000000fH
	jmp	SHORT $LN7@kvz_rdoq_s
$LN5@kvz_rdoq_s:
	mov	eax, DWORD PTR _coeff_i$15[ebp]
	sub	eax, 1
	mov	DWORD PTR _coeff_i$15[ebp], eax
$LN7@kvz_rdoq_s:
	cmp	DWORD PTR _coeff_i$15[ebp], 0
	jl	SHORT $LN6@kvz_rdoq_s

; 554  :       if (quant_coeffs[scan2raster[coeff_i + cg_coeff_scan]]) {

	mov	eax, DWORD PTR _coeff_i$15[ebp]
	add	eax, DWORD PTR _cg_coeff_scan$17[ebp]
	mov	ecx, DWORD PTR _scan2raster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _quant_coeffs$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	test	ecx, ecx
	je	SHORT $LN17@kvz_rdoq_s

; 555  :         last_nz_scan = coeff_i;

	mov	eax, DWORD PTR _coeff_i$15[ebp]
	mov	DWORD PTR _last_nz_scan$16[ebp], eax

; 556  :         break;

	jmp	SHORT $LN6@kvz_rdoq_s
$LN17@kvz_rdoq_s:

; 557  :       }
; 558  :     }

	jmp	SHORT $LN5@kvz_rdoq_s
$LN6@kvz_rdoq_s:

; 559  :     int32_t first_nz_scan = SCAN_SET_SIZE;

	mov	DWORD PTR _first_nz_scan$14[ebp], 16	; 00000010H

; 560  :     for (int32_t coeff_i = 0; coeff_i <= last_nz_scan; coeff_i++) {

	mov	DWORD PTR _coeff_i$13[ebp], 0
	jmp	SHORT $LN10@kvz_rdoq_s
$LN8@kvz_rdoq_s:
	mov	eax, DWORD PTR _coeff_i$13[ebp]
	add	eax, 1
	mov	DWORD PTR _coeff_i$13[ebp], eax
$LN10@kvz_rdoq_s:
	mov	eax, DWORD PTR _coeff_i$13[ebp]
	cmp	eax, DWORD PTR _last_nz_scan$16[ebp]
	jg	SHORT $LN9@kvz_rdoq_s

; 561  :       if (quant_coeffs[scan2raster[coeff_i + cg_coeff_scan]]) {

	mov	eax, DWORD PTR _coeff_i$13[ebp]
	add	eax, DWORD PTR _cg_coeff_scan$17[ebp]
	mov	ecx, DWORD PTR _scan2raster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _quant_coeffs$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	test	ecx, ecx
	je	SHORT $LN18@kvz_rdoq_s

; 562  :         first_nz_scan = coeff_i;

	mov	eax, DWORD PTR _coeff_i$13[ebp]
	mov	DWORD PTR _first_nz_scan$14[ebp], eax

; 563  :         break;

	jmp	SHORT $LN9@kvz_rdoq_s
$LN18@kvz_rdoq_s:

; 564  :       }
; 565  :     }

	jmp	SHORT $LN8@kvz_rdoq_s
$LN9@kvz_rdoq_s:

; 566  : 
; 567  :     if (last_nz_scan - first_nz_scan < SBH_THRESHOLD) {

	mov	eax, DWORD PTR _last_nz_scan$16[ebp]
	sub	eax, DWORD PTR _first_nz_scan$14[ebp]
	cmp	eax, 4
	jge	SHORT $LN19@kvz_rdoq_s

; 568  :       continue;

	jmp	$LN2@kvz_rdoq_s
$LN19@kvz_rdoq_s:

; 569  :     }
; 570  : 
; 571  :     const int32_t signbit = quant_coeffs[scan2raster[cg_coeff_scan + first_nz_scan]] <= 0;

	mov	eax, DWORD PTR _cg_coeff_scan$17[ebp]
	add	eax, DWORD PTR _first_nz_scan$14[ebp]
	mov	ecx, DWORD PTR _scan2raster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _quant_coeffs$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	test	ecx, ecx
	jg	SHORT $LN36@kvz_rdoq_s
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN37@kvz_rdoq_s
$LN36@kvz_rdoq_s:
	mov	DWORD PTR tv152[ebp], 0
$LN37@kvz_rdoq_s:
	mov	edx, DWORD PTR tv152[ebp]
	mov	DWORD PTR _signbit$12[ebp], edx

; 572  :     unsigned abs_coeff_sum = 0;

	mov	DWORD PTR _abs_coeff_sum$11[ebp], 0

; 573  :     for (int32_t coeff_scan = first_nz_scan; coeff_scan <= last_nz_scan; coeff_scan++) {

	mov	eax, DWORD PTR _first_nz_scan$14[ebp]
	mov	DWORD PTR _coeff_scan$10[ebp], eax
	jmp	SHORT $LN13@kvz_rdoq_s
$LN11@kvz_rdoq_s:
	mov	eax, DWORD PTR _coeff_scan$10[ebp]
	add	eax, 1
	mov	DWORD PTR _coeff_scan$10[ebp], eax
$LN13@kvz_rdoq_s:
	mov	eax, DWORD PTR _coeff_scan$10[ebp]
	cmp	eax, DWORD PTR _last_nz_scan$16[ebp]
	jg	SHORT $LN12@kvz_rdoq_s

; 574  :       abs_coeff_sum += quant_coeffs[scan2raster[coeff_scan + cg_coeff_scan]];

	mov	eax, DWORD PTR _coeff_scan$10[ebp]
	add	eax, DWORD PTR _cg_coeff_scan$17[ebp]
	mov	ecx, DWORD PTR _scan2raster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _quant_coeffs$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	add	ecx, DWORD PTR _abs_coeff_sum$11[ebp]
	mov	DWORD PTR _abs_coeff_sum$11[ebp], ecx

; 575  :     }

	jmp	SHORT $LN11@kvz_rdoq_s
$LN12@kvz_rdoq_s:

; 576  :     if (signbit == (abs_coeff_sum & 0x1)) {

	mov	eax, DWORD PTR _abs_coeff_sum$11[ebp]
	and	eax, 1
	cmp	DWORD PTR _signbit$12[ebp], eax
	jne	SHORT $LN20@kvz_rdoq_s

; 577  :       // Sign already matches with the parity, no need to modify coefficients.
; 578  :       continue;

	jmp	$LN2@kvz_rdoq_s
$LN20@kvz_rdoq_s:

; 579  :     }
; 580  : 
; 581  :     // Otherwise, search for the best coeff to change by one and change it.
; 582  : 
; 583  :     struct {
; 584  :       int64_t cost;
; 585  :       int pos;
; 586  :       int change;
; 587  :     } current, best = { MAX_INT64, 0, 0 };

	mov	DWORD PTR _best$8[ebp], -1
	mov	DWORD PTR _best$8[ebp+4], 2147483647	; 7fffffffH
	mov	DWORD PTR _best$8[ebp+8], 0
	mov	DWORD PTR _best$8[ebp+12], 0

; 588  : 
; 589  :     const int last_coeff_scan = (cg_scan == last_cg ? last_nz_scan : SCAN_SET_SIZE - 1);

	mov	eax, DWORD PTR _cg_scan$18[ebp]
	cmp	eax, DWORD PTR _last_cg$[ebp]
	jne	SHORT $LN38@kvz_rdoq_s
	mov	ecx, DWORD PTR _last_nz_scan$16[ebp]
	mov	DWORD PTR tv165[ebp], ecx
	jmp	SHORT $LN39@kvz_rdoq_s
$LN38@kvz_rdoq_s:
	mov	DWORD PTR tv165[ebp], 15		; 0000000fH
$LN39@kvz_rdoq_s:
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR _last_coeff_scan$7[ebp], edx

; 590  :     for (int coeff_scan = last_coeff_scan; coeff_scan >= 0; --coeff_scan) {

	mov	eax, DWORD PTR _last_coeff_scan$7[ebp]
	mov	DWORD PTR _coeff_scan$6[ebp], eax
	jmp	SHORT $LN16@kvz_rdoq_s
$LN14@kvz_rdoq_s:
	mov	eax, DWORD PTR _coeff_scan$6[ebp]
	sub	eax, 1
	mov	DWORD PTR _coeff_scan$6[ebp], eax
$LN16@kvz_rdoq_s:
	cmp	DWORD PTR _coeff_scan$6[ebp], 0
	jl	$LN15@kvz_rdoq_s

; 591  :       current.pos = scan2raster[coeff_scan + cg_coeff_scan];

	mov	eax, DWORD PTR _coeff_scan$6[ebp]
	add	eax, DWORD PTR _cg_coeff_scan$17[ebp]
	mov	ecx, DWORD PTR _scan2raster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _current$9[ebp+8], edx

; 592  :       // Shift the calculation back into original precision to avoid
; 593  :       // changing the bitstream.
; 594  : #     define PRECISION_INC (15 - CTX_FRAC_BITS)
; 595  :       int64_t quant_cost_in_bits = rd_factor * sh_rates->quant_delta[current.pos];

	mov	eax, DWORD PTR _current$9[ebp+8]
	mov	ecx, DWORD PTR _sh_rates$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+12288]
	cdq
	push	edx
	push	eax
	mov	edx, DWORD PTR _rd_factor$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _rd_factor$[ebp]
	push	eax
	call	__allmul
	mov	DWORD PTR _quant_cost_in_bits$5[ebp], eax
	mov	DWORD PTR _quant_cost_in_bits$5[ebp+4], edx

; 596  : 
; 597  :       coeff_t abs_coeff = abs(quant_coeffs[current.pos]);

	mov	eax, DWORD PTR _current$9[ebp+8]
	mov	ecx, DWORD PTR _quant_coeffs$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	push	edx
	call	_abs
	add	esp, 4
	mov	WORD PTR _abs_coeff$4[ebp], ax

; 598  : 
; 599  :       if (abs_coeff != 0) {

	movsx	eax, WORD PTR _abs_coeff$4[ebp]
	test	eax, eax
	je	$LN21@kvz_rdoq_s

; 600  :         // Choose between incrementing and decrementing a non-zero coeff.
; 601  : 
; 602  :         int64_t inc_bits = sh_rates->inc[current.pos];

	mov	eax, DWORD PTR _current$9[ebp+8]
	mov	ecx, DWORD PTR _sh_rates$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cdq
	mov	DWORD PTR _inc_bits$3[ebp], eax
	mov	DWORD PTR _inc_bits$3[ebp+4], edx

; 603  :         int64_t dec_bits = sh_rates->dec[current.pos];

	mov	eax, DWORD PTR _current$9[ebp+8]
	mov	ecx, DWORD PTR _sh_rates$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+4096]
	cdq
	mov	DWORD PTR _dec_bits$2[ebp], eax
	mov	DWORD PTR _dec_bits$2[ebp+4], edx

; 604  :         if (abs_coeff == 1) {

	movsx	eax, WORD PTR _abs_coeff$4[ebp]
	cmp	eax, 1
	jne	SHORT $LN23@kvz_rdoq_s

; 605  :           // We save sign bit and sig_coeff goes to zero.
; 606  :           dec_bits -= CTX_FRAC_ONE_BIT + sh_rates->sig_coeff_inc[current.pos];

	mov	eax, DWORD PTR _current$9[ebp+8]
	mov	ecx, DWORD PTR _sh_rates$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+8192]
	add	eax, 32768				; 00008000H
	cdq
	mov	ecx, DWORD PTR _dec_bits$2[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR _dec_bits$2[ebp+4]
	sbb	eax, edx
	mov	DWORD PTR _dec_bits$2[ebp], ecx
	mov	DWORD PTR _dec_bits$2[ebp+4], eax
$LN23@kvz_rdoq_s:

; 607  :         }
; 608  :         if (cg_scan == last_cg && last_nz_scan == coeff_scan && abs_coeff == 1) {

	mov	eax, DWORD PTR _cg_scan$18[ebp]
	cmp	eax, DWORD PTR _last_cg$[ebp]
	jne	SHORT $LN24@kvz_rdoq_s
	mov	eax, DWORD PTR _last_nz_scan$16[ebp]
	cmp	eax, DWORD PTR _coeff_scan$6[ebp]
	jne	SHORT $LN24@kvz_rdoq_s
	movsx	eax, WORD PTR _abs_coeff$4[ebp]
	cmp	eax, 1
	jne	SHORT $LN24@kvz_rdoq_s

; 609  :           // Changing the last non-zero bit in the last cg to zero.
; 610  :           // This might save a lot of bits if the next bits are already
; 611  :           // zeros, or just a coupple fractional bits if they are not.
; 612  :           // TODO: Check if calculating the real savings makes sense.
; 613  :           dec_bits -= 4 * CTX_FRAC_ONE_BIT;

	mov	eax, DWORD PTR _dec_bits$2[ebp]
	sub	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _dec_bits$2[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR _dec_bits$2[ebp], eax
	mov	DWORD PTR _dec_bits$2[ebp+4], ecx
$LN24@kvz_rdoq_s:

; 614  :         }
; 615  : 
; 616  :         inc_bits = -quant_cost_in_bits + inc_bits * (1 << PRECISION_INC);

	mov	eax, DWORD PTR _quant_cost_in_bits$5[ebp]
	neg	eax
	mov	ecx, DWORD PTR _quant_cost_in_bits$5[ebp+4]
	adc	ecx, 0
	neg	ecx
	add	eax, DWORD PTR _inc_bits$3[ebp]
	adc	ecx, DWORD PTR _inc_bits$3[ebp+4]
	mov	DWORD PTR _inc_bits$3[ebp], eax
	mov	DWORD PTR _inc_bits$3[ebp+4], ecx

; 617  :         dec_bits = quant_cost_in_bits + dec_bits * (1 << PRECISION_INC);

	mov	eax, DWORD PTR _quant_cost_in_bits$5[ebp]
	add	eax, DWORD PTR _dec_bits$2[ebp]
	mov	ecx, DWORD PTR _quant_cost_in_bits$5[ebp+4]
	adc	ecx, DWORD PTR _dec_bits$2[ebp+4]
	mov	DWORD PTR _dec_bits$2[ebp], eax
	mov	DWORD PTR _dec_bits$2[ebp+4], ecx

; 618  : 
; 619  :         if (inc_bits < dec_bits) {

	mov	eax, DWORD PTR _inc_bits$3[ebp+4]
	cmp	eax, DWORD PTR _dec_bits$2[ebp+4]
	jg	SHORT $LN25@kvz_rdoq_s
	jl	SHORT $LN42@kvz_rdoq_s
	mov	ecx, DWORD PTR _inc_bits$3[ebp]
	cmp	ecx, DWORD PTR _dec_bits$2[ebp]
	jae	SHORT $LN25@kvz_rdoq_s
$LN42@kvz_rdoq_s:

; 620  :           current.change = 1;

	mov	DWORD PTR _current$9[ebp+12], 1

; 621  :           current.cost = inc_bits;

	mov	eax, DWORD PTR _inc_bits$3[ebp]
	mov	DWORD PTR _current$9[ebp], eax
	mov	ecx, DWORD PTR _inc_bits$3[ebp+4]
	mov	DWORD PTR _current$9[ebp+4], ecx

; 622  :         } else {

	jmp	SHORT $LN27@kvz_rdoq_s
$LN25@kvz_rdoq_s:

; 623  :           current.change = -1;

	mov	DWORD PTR _current$9[ebp+12], -1

; 624  :           current.cost = dec_bits;

	mov	eax, DWORD PTR _dec_bits$2[ebp]
	mov	DWORD PTR _current$9[ebp], eax
	mov	ecx, DWORD PTR _dec_bits$2[ebp+4]
	mov	DWORD PTR _current$9[ebp+4], ecx

; 625  : 
; 626  :           if (coeff_scan == first_nz_scan && abs_coeff == 1) {

	mov	eax, DWORD PTR _coeff_scan$6[ebp]
	cmp	eax, DWORD PTR _first_nz_scan$14[ebp]
	jne	SHORT $LN27@kvz_rdoq_s
	movsx	eax, WORD PTR _abs_coeff$4[ebp]
	cmp	eax, 1
	jne	SHORT $LN27@kvz_rdoq_s

; 627  :             // Don't turn first non-zero coeff into zero.
; 628  :             // Seems kind of arbitrary. It's probably because it could lead to
; 629  :             // breaking SBH_THRESHOLD.
; 630  :             current.cost = MAX_INT64;

	mov	DWORD PTR _current$9[ebp], -1
	mov	DWORD PTR _current$9[ebp+4], 2147483647	; 7fffffffH
$LN27@kvz_rdoq_s:

; 631  :           }
; 632  :         }
; 633  :       } else {

	jmp	$LN29@kvz_rdoq_s
$LN21@kvz_rdoq_s:

; 634  :         // Try incrementing a zero coeff.
; 635  : 
; 636  :         // Add sign bit, other bits and sig_coeff goes to one.
; 637  :         int bits = CTX_FRAC_ONE_BIT + sh_rates->inc[current.pos] + sh_rates->sig_coeff_inc[current.pos];

	mov	eax, DWORD PTR _current$9[ebp+8]
	mov	ecx, DWORD PTR _sh_rates$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _current$9[ebp+8]
	mov	ecx, DWORD PTR _sh_rates$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+8192]
	lea	ecx, DWORD PTR [edx+eax+32768]
	mov	DWORD PTR _bits$1[ebp], ecx

; 638  :         current.cost = -llabs(quant_cost_in_bits) + bits * (1 << PRECISION_INC);

	mov	eax, DWORD PTR _quant_cost_in_bits$5[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _quant_cost_in_bits$5[ebp]
	push	ecx
	call	_llabs
	add	esp, 8
	mov	ecx, eax
	mov	esi, edx
	neg	ecx
	adc	esi, 0
	neg	esi
	mov	eax, DWORD PTR _bits$1[ebp]
	cdq
	add	ecx, eax
	adc	esi, edx
	mov	DWORD PTR _current$9[ebp], ecx
	mov	DWORD PTR _current$9[ebp+4], esi

; 639  :         current.change = 1;

	mov	DWORD PTR _current$9[ebp+12], 1

; 640  : 
; 641  :         if (coeff_scan < first_nz_scan) {

	mov	eax, DWORD PTR _coeff_scan$6[ebp]
	cmp	eax, DWORD PTR _first_nz_scan$14[ebp]
	jge	SHORT $LN29@kvz_rdoq_s

; 642  :           if (((coeffs[current.pos] >= 0) ? 0 : 1) != signbit) {

	mov	eax, DWORD PTR _current$9[ebp+8]
	mov	ecx, DWORD PTR _coeffs$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	jl	SHORT $LN40@kvz_rdoq_s
	mov	DWORD PTR tv262[ebp], 0
	jmp	SHORT $LN41@kvz_rdoq_s
$LN40@kvz_rdoq_s:
	mov	DWORD PTR tv262[ebp], 1
$LN41@kvz_rdoq_s:
	mov	eax, DWORD PTR tv262[ebp]
	cmp	eax, DWORD PTR _signbit$12[ebp]
	je	SHORT $LN29@kvz_rdoq_s

; 643  :             current.cost = MAX_INT64;

	mov	DWORD PTR _current$9[ebp], -1
	mov	DWORD PTR _current$9[ebp+4], 2147483647	; 7fffffffH
$LN29@kvz_rdoq_s:

; 644  :           }
; 645  :         }
; 646  :       }
; 647  : 
; 648  :       if (current.cost < best.cost) {

	mov	eax, DWORD PTR _current$9[ebp+4]
	cmp	eax, DWORD PTR _best$8[ebp+4]
	jg	SHORT $LN30@kvz_rdoq_s
	jl	SHORT $LN43@kvz_rdoq_s
	mov	ecx, DWORD PTR _current$9[ebp]
	cmp	ecx, DWORD PTR _best$8[ebp]
	jae	SHORT $LN30@kvz_rdoq_s
$LN43@kvz_rdoq_s:

; 649  :         best = current;

	mov	eax, DWORD PTR _current$9[ebp]
	mov	DWORD PTR _best$8[ebp], eax
	mov	ecx, DWORD PTR _current$9[ebp+4]
	mov	DWORD PTR _best$8[ebp+4], ecx
	mov	edx, DWORD PTR _current$9[ebp+8]
	mov	DWORD PTR _best$8[ebp+8], edx
	mov	eax, DWORD PTR _current$9[ebp+12]
	mov	DWORD PTR _best$8[ebp+12], eax
$LN30@kvz_rdoq_s:

; 650  :       }
; 651  :     }

	jmp	$LN14@kvz_rdoq_s
$LN15@kvz_rdoq_s:

; 652  : 
; 653  :     if (quant_coeffs[best.pos] == 32767 || quant_coeffs[best.pos] == -32768) {

	mov	eax, DWORD PTR _best$8[ebp+8]
	mov	ecx, DWORD PTR _quant_coeffs$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	cmp	edx, 32767				; 00007fffH
	je	SHORT $LN32@kvz_rdoq_s
	mov	eax, DWORD PTR _best$8[ebp+8]
	mov	ecx, DWORD PTR _quant_coeffs$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	cmp	edx, -32768				; ffff8000H
	jne	SHORT $LN31@kvz_rdoq_s
$LN32@kvz_rdoq_s:

; 654  :       best.change = -1;

	mov	DWORD PTR _best$8[ebp+12], -1
$LN31@kvz_rdoq_s:

; 655  :     }
; 656  : 
; 657  :     if (coeffs[best.pos] >= 0) {

	mov	eax, DWORD PTR _best$8[ebp+8]
	mov	ecx, DWORD PTR _coeffs$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	jl	SHORT $LN33@kvz_rdoq_s

; 658  :       quant_coeffs[best.pos] += best.change;

	mov	eax, DWORD PTR _best$8[ebp+8]
	mov	ecx, DWORD PTR _quant_coeffs$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	add	edx, DWORD PTR _best$8[ebp+12]
	mov	eax, DWORD PTR _best$8[ebp+8]
	mov	ecx, DWORD PTR _quant_coeffs$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 659  :     } else {

	jmp	SHORT $LN34@kvz_rdoq_s
$LN33@kvz_rdoq_s:

; 660  :       quant_coeffs[best.pos] -= best.change;

	mov	eax, DWORD PTR _best$8[ebp+8]
	mov	ecx, DWORD PTR _quant_coeffs$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	sub	edx, DWORD PTR _best$8[ebp+12]
	mov	eax, DWORD PTR _best$8[ebp+8]
	mov	ecx, DWORD PTR _quant_coeffs$[ebp]
	mov	WORD PTR [ecx+eax*2], dx
$LN34@kvz_rdoq_s:

; 661  :     }
; 662  :   }

	jmp	$LN2@kvz_rdoq_s
$LN3@kvz_rdoq_s:

; 663  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN47@kvz_rdoq_s
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 504				; 000001f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN47@kvz_rdoq_s:
	DD	2
	DD	$LN46@kvz_rdoq_s
$LN46@kvz_rdoq_s:
	DD	-184					; ffffff48H
	DD	16					; 00000010H
	DD	$LN44@kvz_rdoq_s
	DD	-208					; ffffff30H
	DD	16					; 00000010H
	DD	$LN45@kvz_rdoq_s
$LN45@kvz_rdoq_s:
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN44@kvz_rdoq_s:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_kvz_rdoq_sign_hiding ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _calc_last_bits
_TEXT	SEGMENT
tv154 = -340						; size = 4
tv143 = -340						; size = 4
tv132 = -340						; size = 4
tv87 = -340						; size = 4
tv74 = -340						; size = 4
tv69 = -340						; size = 4
_ctx_offset$1 = -140					; size = 4
_ctx_offset$2 = -128					; size = 4
_base_ctx_y$ = -116					; size = 4
_base_ctx_x$ = -104					; size = 4
_ctx$ = -92						; size = 4
_shiftY$ = -80						; size = 4
_shiftX$ = -68						; size = 4
_blk_size_offset_y$ = -56				; size = 4
_blk_size_offset_x$ = -44				; size = 4
_bits_y$ = -32						; size = 4
_bits_x$ = -20						; size = 4
_cabac$ = -8						; size = 4
_state$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_type$ = 20						; size = 1
_last_x_bits$ = 24					; size = 4
_last_y_bits$ = 28					; size = 4
_calc_last_bits PROC					; COMDAT

; 492  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 493  :   cabac_data_t * const cabac = &state->cabac;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _cabac$[ebp], eax

; 494  :   int32_t bits_x = 0, bits_y = 0;

	mov	DWORD PTR _bits_x$[ebp], 0
	mov	DWORD PTR _bits_y$[ebp], 0

; 495  :   int32_t blk_size_offset_x, blk_size_offset_y, shiftX, shiftY;
; 496  :   int32_t ctx;
; 497  : 
; 498  :   cabac_ctx_t *base_ctx_x = (type ? cabac->ctx.cu_ctx_last_x_chroma : cabac->ctx.cu_ctx_last_x_luma);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN9@calc_last_
	mov	ecx, DWORD PTR _cabac$[ebp]
	add	ecx, 155				; 0000009bH
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN10@calc_last_
$LN9@calc_last_:
	mov	edx, DWORD PTR _cabac$[ebp]
	add	edx, 140				; 0000008cH
	mov	DWORD PTR tv69[ebp], edx
$LN10@calc_last_:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _base_ctx_x$[ebp], eax

; 499  :   cabac_ctx_t *base_ctx_y = (type ? cabac->ctx.cu_ctx_last_y_chroma : cabac->ctx.cu_ctx_last_y_luma);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN11@calc_last_
	mov	ecx, DWORD PTR _cabac$[ebp]
	add	ecx, 125				; 0000007dH
	mov	DWORD PTR tv74[ebp], ecx
	jmp	SHORT $LN12@calc_last_
$LN11@calc_last_:
	mov	edx, DWORD PTR _cabac$[ebp]
	add	edx, 110				; 0000006eH
	mov	DWORD PTR tv74[ebp], edx
$LN12@calc_last_:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR _base_ctx_y$[ebp], eax

; 500  : 
; 501  :   blk_size_offset_x = type ? 0: (kvz_g_convert_to_bit[ width ] *3 + ((kvz_g_convert_to_bit[ width ] +1)>>2));

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN13@calc_last_
	mov	DWORD PTR tv87[ebp], 0
	jmp	SHORT $LN14@calc_last_
$LN13@calc_last_:
	mov	ecx, DWORD PTR _width$[ebp]
	movsx	edx, BYTE PTR _kvz_g_convert_to_bit[ecx]
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _width$[ebp]
	movsx	edx, BYTE PTR _kvz_g_convert_to_bit[ecx]
	add	edx, 1
	sar	edx, 2
	add	eax, edx
	mov	DWORD PTR tv87[ebp], eax
$LN14@calc_last_:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR _blk_size_offset_x$[ebp], eax

; 502  :   blk_size_offset_y = type ? 0: (kvz_g_convert_to_bit[ height ]*3 + ((kvz_g_convert_to_bit[ height ]+1)>>2));

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN15@calc_last_
	mov	DWORD PTR tv132[ebp], 0
	jmp	SHORT $LN16@calc_last_
$LN15@calc_last_:
	mov	ecx, DWORD PTR _height$[ebp]
	movsx	edx, BYTE PTR _kvz_g_convert_to_bit[ecx]
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _height$[ebp]
	movsx	edx, BYTE PTR _kvz_g_convert_to_bit[ecx]
	add	edx, 1
	sar	edx, 2
	add	eax, edx
	mov	DWORD PTR tv132[ebp], eax
$LN16@calc_last_:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR _blk_size_offset_y$[ebp], eax

; 503  :   shiftX = type ? kvz_g_convert_to_bit[ width  ] :((kvz_g_convert_to_bit[ width  ]+3)>>2);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN17@calc_last_
	mov	ecx, DWORD PTR _width$[ebp]
	movsx	edx, BYTE PTR _kvz_g_convert_to_bit[ecx]
	mov	DWORD PTR tv143[ebp], edx
	jmp	SHORT $LN18@calc_last_
$LN17@calc_last_:
	mov	eax, DWORD PTR _width$[ebp]
	movsx	ecx, BYTE PTR _kvz_g_convert_to_bit[eax]
	add	ecx, 3
	sar	ecx, 2
	mov	DWORD PTR tv143[ebp], ecx
$LN18@calc_last_:
	mov	edx, DWORD PTR tv143[ebp]
	mov	DWORD PTR _shiftX$[ebp], edx

; 504  :   shiftY = type ? kvz_g_convert_to_bit[ height ] :((kvz_g_convert_to_bit[ height ]+3)>>2);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN19@calc_last_
	mov	ecx, DWORD PTR _height$[ebp]
	movsx	edx, BYTE PTR _kvz_g_convert_to_bit[ecx]
	mov	DWORD PTR tv154[ebp], edx
	jmp	SHORT $LN20@calc_last_
$LN19@calc_last_:
	mov	eax, DWORD PTR _height$[ebp]
	movsx	ecx, BYTE PTR _kvz_g_convert_to_bit[eax]
	add	ecx, 3
	sar	ecx, 2
	mov	DWORD PTR tv154[ebp], ecx
$LN20@calc_last_:
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR _shiftY$[ebp], edx

; 505  : 
; 506  : 
; 507  :   for (ctx = 0; ctx < g_group_idx[ width - 1 ]; ctx++) {

	mov	DWORD PTR _ctx$[ebp], 0
	jmp	SHORT $LN4@calc_last_
$LN2@calc_last_:
	mov	eax, DWORD PTR _ctx$[ebp]
	add	eax, 1
	mov	DWORD PTR _ctx$[ebp], eax
$LN4@calc_last_:
	mov	eax, DWORD PTR _width$[ebp]
	movzx	ecx, BYTE PTR _g_group_idx[eax-1]
	cmp	DWORD PTR _ctx$[ebp], ecx
	jge	SHORT $LN3@calc_last_

; 508  :     int32_t ctx_offset = blk_size_offset_x + (ctx >>shiftX);

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR _shiftX$[ebp]
	sar	eax, cl
	add	eax, DWORD PTR _blk_size_offset_x$[ebp]
	mov	DWORD PTR _ctx_offset$2[ebp], eax

; 509  :     last_x_bits[ ctx ] = bits_x + CTX_ENTROPY_BITS(&base_ctx_x[ ctx_offset ],0);

	mov	eax, DWORD PTR _base_ctx_x$[ebp]
	add	eax, DWORD PTR _ctx_offset$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 0
	mov	edx, DWORD PTR _bits_x$[ebp]
	add	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR _last_x_bits$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 510  :     bits_x += CTX_ENTROPY_BITS(&base_ctx_x[ ctx_offset ],1);

	mov	eax, DWORD PTR _base_ctx_x$[ebp]
	add	eax, DWORD PTR _ctx_offset$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 1
	mov	edx, DWORD PTR _bits_x$[ebp]
	add	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR _bits_x$[ebp], edx

; 511  :   }

	jmp	SHORT $LN2@calc_last_
$LN3@calc_last_:

; 512  :   last_x_bits[ctx] = bits_x;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR _last_x_bits$[ebp]
	mov	edx, DWORD PTR _bits_x$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 513  :   for (ctx = 0; ctx < g_group_idx[ height - 1 ]; ctx++) {

	mov	DWORD PTR _ctx$[ebp], 0
	jmp	SHORT $LN7@calc_last_
$LN5@calc_last_:
	mov	eax, DWORD PTR _ctx$[ebp]
	add	eax, 1
	mov	DWORD PTR _ctx$[ebp], eax
$LN7@calc_last_:
	mov	eax, DWORD PTR _height$[ebp]
	movzx	ecx, BYTE PTR _g_group_idx[eax-1]
	cmp	DWORD PTR _ctx$[ebp], ecx
	jge	SHORT $LN6@calc_last_

; 514  :     int32_t ctx_offset = blk_size_offset_y + (ctx >>shiftY);

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR _shiftY$[ebp]
	sar	eax, cl
	add	eax, DWORD PTR _blk_size_offset_y$[ebp]
	mov	DWORD PTR _ctx_offset$1[ebp], eax

; 515  :     last_y_bits[ ctx ] = bits_y + CTX_ENTROPY_BITS(&base_ctx_y[ ctx_offset ],0);

	mov	eax, DWORD PTR _base_ctx_y$[ebp]
	add	eax, DWORD PTR _ctx_offset$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 0
	mov	edx, DWORD PTR _bits_y$[ebp]
	add	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR _last_y_bits$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 516  :     bits_y +=  CTX_ENTROPY_BITS(&base_ctx_y[ ctx_offset ],1);

	mov	eax, DWORD PTR _base_ctx_y$[ebp]
	add	eax, DWORD PTR _ctx_offset$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 1
	mov	edx, DWORD PTR _bits_y$[ebp]
	add	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR _bits_y$[ebp], edx

; 517  :   }

	jmp	SHORT $LN5@calc_last_
$LN6@calc_last_:

; 518  :   last_y_bits[ctx] = bits_y;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	ecx, DWORD PTR _last_y_bits$[ebp]
	mov	edx, DWORD PTR _bits_y$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_last_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _get_rate_last
_TEXT	SEGMENT
tv146 = -240						; size = 8
tv139 = -236						; size = 4
tv133 = -236						; size = 4
_uiCost$ = -36						; size = 8
_ctx_y$ = -20						; size = 4
_ctx_x$ = -8						; size = 4
_state$ = 8						; size = 4
_pos_x$ = 12						; size = 4
_pos_y$ = 16						; size = 4
_last_x_bits$ = 20					; size = 4
_last_y_bits$ = 24					; size = 4
_get_rate_last PROC					; COMDAT

; 477  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 478  :   uint32_t ctx_x   = g_group_idx[pos_x];

	mov	eax, DWORD PTR _pos_x$[ebp]
	movzx	ecx, BYTE PTR _g_group_idx[eax]
	mov	DWORD PTR _ctx_x$[ebp], ecx

; 479  :   uint32_t ctx_y   = g_group_idx[pos_y];

	mov	eax, DWORD PTR _pos_y$[ebp]
	movzx	ecx, BYTE PTR _g_group_idx[eax]
	mov	DWORD PTR _ctx_y$[ebp], ecx

; 480  :   double uiCost = last_x_bits[ ctx_x ] + last_y_bits[ ctx_y ];

	mov	eax, DWORD PTR _ctx_x$[ebp]
	mov	ecx, DWORD PTR _last_x_bits$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _ctx_y$[ebp]
	mov	ecx, DWORD PTR _last_y_bits$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR _uiCost$[ebp], xmm0

; 481  :   if( ctx_x > 3 ) {

	cmp	DWORD PTR _ctx_x$[ebp], 3
	jbe	SHORT $LN2@get_rate_l

; 482  :     uiCost += CTX_FRAC_ONE_BIT * ((ctx_x - 2) >> 1);

	mov	eax, DWORD PTR _ctx_x$[ebp]
	sub	eax, 2
	shr	eax, 1
	shl	eax, 15					; 0000000fH
	mov	DWORD PTR tv133[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv133[ebp]
	mov	ecx, DWORD PTR tv133[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	addsd	xmm0, QWORD PTR _uiCost$[ebp]
	movsd	QWORD PTR _uiCost$[ebp], xmm0
$LN2@get_rate_l:

; 483  :   }
; 484  :   if( ctx_y > 3 ) {

	cmp	DWORD PTR _ctx_y$[ebp], 3
	jbe	SHORT $LN3@get_rate_l

; 485  :     uiCost += CTX_FRAC_ONE_BIT * ((ctx_y - 2) >> 1);

	mov	eax, DWORD PTR _ctx_y$[ebp]
	sub	eax, 2
	shr	eax, 1
	shl	eax, 15					; 0000000fH
	mov	DWORD PTR tv139[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv139[ebp]
	mov	ecx, DWORD PTR tv139[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	addsd	xmm0, QWORD PTR _uiCost$[ebp]
	movsd	QWORD PTR _uiCost$[ebp], xmm0
$LN3@get_rate_l:

; 486  :   }
; 487  :   return state->lambda * uiCost;

	mov	eax, DWORD PTR _state$[ebp]
	movsd	xmm0, QWORD PTR [eax+296]
	mulsd	xmm0, QWORD PTR _uiCost$[ebp]
	movsd	QWORD PTR tv146[ebp], xmm0
	fld	QWORD PTR tv146[ebp]

; 488  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_get_rate_last ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _save_accuracy
_TEXT	SEGMENT
_mtx$ = -8						; size = 4
_qp$ = 8						; size = 4
_ccc$ = 12						; size = 4
_fast_cost$ = 16					; size = 4
_save_accuracy PROC					; COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 295  :   pthread_mutex_t *mtx = outfile_mutex + qp;

	mov	eax, DWORD PTR _qp$[ebp]
	lea	ecx, DWORD PTR _outfile_mutex[eax*4]
	mov	DWORD PTR _mtx$[ebp], ecx

; 296  : 
; 297  :   assert(qp <= RD_SAMPLING_MAX_LAST_QP);

	cmp	DWORD PTR _qp$[ebp], 50			; 00000032H
	jle	SHORT $LN3@save_accur
	mov	eax, DWORD PTR ?__LINE__Var@?0??save_accuracy@@9@9
	add	eax, 3
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1GE@KKEFIIPC@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1DM@LBICGNLH@?$AAq?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAR?$AAD?$AA_?$AAS?$AAA?$AAM?$AAP?$AAL?$AAI@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@save_accur:

; 298  : 
; 299  :   pthread_mutex_lock(mtx);

	mov	eax, DWORD PTR _mtx$[ebp]
	push	eax
	call	_pthread_mutex_lock
	add	esp, 4

; 300  :   fprintf(fastrd_learning_outfile[qp], "%u %u\n", fast_cost, ccc);

	mov	eax, DWORD PTR _ccc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fast_cost$[ebp]
	push	ecx
	push	OFFSET ??_C@_06FKABJIPB@?$CFu?5?$CFu?6@
	mov	edx, DWORD PTR _qp$[ebp]
	mov	eax, DWORD PTR _fastrd_learning_outfile[edx*4]
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 301  :   pthread_mutex_unlock(mtx);

	mov	eax, DWORD PTR _mtx$[ebp]
	push	eax
	call	_pthread_mutex_unlock
	add	esp, 4

; 302  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_save_accuracy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _save_ccc
_TEXT	SEGMENT
_mtx$ = -8						; size = 4
_qp$ = 8						; size = 4
_coeff$ = 12						; size = 4
_size$ = 16						; size = 4
_ccc$ = 20						; size = 4
_save_ccc PROC						; COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 279  :   pthread_mutex_t *mtx = outfile_mutex + qp;

	mov	eax, DWORD PTR _qp$[ebp]
	lea	ecx, DWORD PTR _outfile_mutex[eax*4]
	mov	DWORD PTR _mtx$[ebp], ecx

; 280  : 
; 281  :   assert(sizeof(coeff_t) == sizeof(int16_t));
; 282  :   assert(qp <= RD_SAMPLING_MAX_LAST_QP);

	cmp	DWORD PTR _qp$[ebp], 50			; 00000032H
	jle	SHORT $LN3@save_ccc
	mov	eax, DWORD PTR ?__LINE__Var@?0??save_ccc@@9@9
	add	eax, 4
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1GE@KKEFIIPC@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1DM@LBICGNLH@?$AAq?$AAp?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAR?$AAD?$AA_?$AAS?$AAA?$AAM?$AAP?$AAL?$AAI@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@save_ccc:

; 283  : 
; 284  :   pthread_mutex_lock(mtx);

	mov	eax, DWORD PTR _mtx$[ebp]
	push	eax
	call	_pthread_mutex_lock
	add	esp, 4

; 285  : 
; 286  :   fwrite(&size,  sizeof(size),     1,    fastrd_learning_outfile[qp]);

	mov	esi, esp
	mov	eax, DWORD PTR _qp$[ebp]
	mov	ecx, DWORD PTR _fastrd_learning_outfile[eax*4]
	push	ecx
	push	1
	push	4
	lea	edx, DWORD PTR _size$[ebp]
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 287  :   fwrite(&ccc,   sizeof(ccc),      1,    fastrd_learning_outfile[qp]);

	mov	esi, esp
	mov	eax, DWORD PTR _qp$[ebp]
	mov	ecx, DWORD PTR _fastrd_learning_outfile[eax*4]
	push	ecx
	push	1
	push	4
	lea	edx, DWORD PTR _ccc$[ebp]
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 288  :   fwrite( coeff, sizeof(coeff_t),  size, fastrd_learning_outfile[qp]);

	mov	esi, esp
	mov	eax, DWORD PTR _qp$[ebp]
	mov	ecx, DWORD PTR _fastrd_learning_outfile[eax*4]
	push	ecx
	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _coeff$[ebp]
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 289  : 
; 290  :   pthread_mutex_unlock(mtx);

	mov	eax, DWORD PTR _mtx$[ebp]
	push	eax
	call	_pthread_mutex_unlock
	add	esp, 4

; 291  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_save_ccc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _get_coeff_cabac_cost
_TEXT	SEGMENT
_cabac_copy$ = -248					; size = 216
_i$1 = -24						; size = 4
_found$ = -9						; size = 1
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_coeff$ = 12						; size = 4
_width$ = 16						; size = 4
_type$ = 20						; size = 4
_scan_mode$ = 24					; size = 1
_get_coeff_cabac_cost PROC				; COMDAT

; 242  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 243  :   // Make sure there are coeffs present
; 244  :   bool found = false;

	mov	BYTE PTR _found$[ebp], 0

; 245  :   for (int i = 0; i < width*width; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@get_coeff_
$LN2@get_coeff_:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@get_coeff_:
	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	cmp	DWORD PTR _i$1[ebp], eax
	jge	SHORT $LN3@get_coeff_

; 246  :     if (coeff[i] != 0) {

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _coeff$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $LN5@get_coeff_

; 247  :       found = 1;

	mov	BYTE PTR _found$[ebp], 1

; 248  :       break;

	jmp	SHORT $LN3@get_coeff_
$LN5@get_coeff_:

; 249  :     }
; 250  :   }

	jmp	SHORT $LN2@get_coeff_
$LN3@get_coeff_:

; 251  :   if (!found) return 0;

	movzx	eax, BYTE PTR _found$[ebp]
	test	eax, eax
	jne	SHORT $LN6@get_coeff_
	xor	eax, eax
	jmp	SHORT $LN1@get_coeff_
$LN6@get_coeff_:

; 252  : 
; 253  :   // Take a copy of the CABAC so that we don't overwrite the contexts when
; 254  :   // counting the bits.
; 255  :   cabac_data_t cabac_copy;
; 256  :   memcpy(&cabac_copy, &state->cabac, sizeof(cabac_copy));

	push	216					; 000000d8H
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _cabac_copy$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 257  : 
; 258  :   // Clear bytes and bits and set mode to "count"
; 259  :   cabac_copy.only_count = 1;

	mov	BYTE PTR _cabac_copy$[ebp+24], 1

; 260  :   cabac_copy.num_buffered_bytes = 0;

	mov	DWORD PTR _cabac_copy$[ebp+16], 0

; 261  :   cabac_copy.bits_left = 23;

	mov	DWORD PTR _cabac_copy$[ebp+20], 23	; 00000017H

; 262  : 
; 263  :   // Execute the coding function.
; 264  :   // It is safe to drop the const modifier since state won't be modified
; 265  :   // when cabac.only_count is set.
; 266  :   kvz_encode_coeff_nxn((encoder_state_t*) state,

	mov	esi, esp
	push	0
	movzx	eax, BYTE PTR _scan_mode$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _type$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _coeff$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cabac_copy$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	DWORD PTR _kvz_encode_coeff_nxn
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 267  :                        &cabac_copy,
; 268  :                        coeff,
; 269  :                        width,
; 270  :                        type,
; 271  :                        scan_mode,
; 272  :                        0);
; 273  : 
; 274  :   return (23 - cabac_copy.bits_left) + (cabac_copy.num_buffered_bytes << 3);

	mov	eax, 23					; 00000017H
	sub	eax, DWORD PTR _cabac_copy$[ebp+20]
	mov	ecx, DWORD PTR _cabac_copy$[ebp+16]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN1@get_coeff_:

; 275  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@get_coeff_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@get_coeff_:
	DD	1
	DD	$LN9@get_coeff_
$LN9@get_coeff_:
	DD	-248					; ffffff08H
	DD	216					; 000000d8H
	DD	$LN8@get_coeff_
$LN8@get_coeff_:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	121					; 00000079H
	DB	0
_get_coeff_cabac_cost ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_get_mvd_coding_cost_cabac
_TEXT	SEGMENT
_bitcost$ = -236					; size = 4
_cabac_copy$ = -224					; size = 216
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_cabac$ = 12						; size = 4
_mvd_hor$ = 16						; size = 4
_mvd_ver$ = 20						; size = 4
_kvz_get_mvd_coding_cost_cabac PROC			; COMDAT

; 1014 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 432				; 000001b0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-432]
	mov	ecx, 108				; 0000006cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 1015 :   cabac_data_t cabac_copy = *cabac;

	mov	ecx, 54					; 00000036H
	mov	esi, DWORD PTR _cabac$[ebp]
	lea	edi, DWORD PTR _cabac_copy$[ebp]
	rep movsd

; 1016 :   cabac_copy.only_count = 1;

	mov	BYTE PTR _cabac_copy$[ebp+24], 1

; 1017 : 
; 1018 :   // It is safe to drop const here because cabac->only_count is set.
; 1019 :   kvz_encode_mvd((encoder_state_t*) state, &cabac_copy, mvd_hor, mvd_ver);

	mov	eax, DWORD PTR _mvd_ver$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mvd_hor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cabac_copy$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_encode_mvd
	add	esp, 16					; 00000010H

; 1020 : 
; 1021 :   uint32_t bitcost =

	mov	eax, 23					; 00000017H
	sub	eax, DWORD PTR _cabac_copy$[ebp+20]
	mov	ecx, DWORD PTR _cabac_copy$[ebp+16]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _cabac$[ebp]
	mov	ecx, 23					; 00000017H
	sub	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _cabac$[ebp]
	mov	eax, DWORD PTR [eax+16]
	lea	ecx, DWORD PTR [ecx+eax*8]
	sub	edx, ecx
	mov	DWORD PTR _bitcost$[ebp], edx

; 1022 :     ((23 - cabac_copy.bits_left) + (cabac_copy.num_buffered_bytes << 3)) -
; 1023 :     ((23 - cabac->bits_left)     + (cabac->num_buffered_bytes << 3));
; 1024 : 
; 1025 :   return bitcost;

	mov	eax, DWORD PTR _bitcost$[ebp]

; 1026 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@kvz_get_mv
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 432				; 000001b0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@kvz_get_mv:
	DD	1
	DD	$LN4@kvz_get_mv
$LN4@kvz_get_mv:
	DD	-224					; ffffff20H
	DD	216					; 000000d8H
	DD	$LN3@kvz_get_mv
$LN3@kvz_get_mv:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	121					; 00000079H
	DB	0
_kvz_get_mvd_coding_cost_cabac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_calc_mvd_cost_cabac
_TEXT	SEGMENT
tv314 = -656						; size = 4
tv299 = -656						; size = 4
tv250 = -656						; size = 4
_symbol$1 = -456					; size = 4
_ref_num$2 = -444					; size = 4
_i$3 = -432						; size = 4
_ref_frame$4 = -420					; size = 4
_ref_list$5 = -408					; size = 8
_j$6 = -392						; size = 4
_ref_list_idx$7 = -380					; size = 4
_symbol$8 = -368					; size = 4
_ui$9 = -356						; size = 4
_cand2_cost$10 = -344					; size = 4
_cand1_cost$11 = -332					; size = 4
_mvd2$12 = -320						; size = 8
_mvd1$13 = -304						; size = 8
_cur_mv_cand$ = -285					; size = 1
_merged$ = -273						; size = 1
_mvd$ = -264						; size = 8
_merge_idx$ = -248					; size = 4
_cabac$ = -236						; size = 4
_state_cabac_copy$ = -224				; size = 216
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_mv_shift$ = 20						; size = 4
_mv_cand$ = 24						; size = 4
_merge_cand$ = 28					; size = 4
_num_cand$ = 32						; size = 2
_ref_idx$ = 36						; size = 4
_bitcost$ = 40						; size = 4
_kvz_calc_mvd_cost_cabac PROC				; COMDAT

; 1041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-656]
	mov	ecx, 164				; 000000a4H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 1042 :   cabac_data_t state_cabac_copy;
; 1043 :   cabac_data_t* cabac;
; 1044 :   uint32_t merge_idx;
; 1045 :   vector2d_t mvd = { 0, 0 };

	mov	DWORD PTR _mvd$[ebp], 0
	mov	DWORD PTR _mvd$[ebp+4], 0

; 1046 :   int8_t merged = 0;

	mov	BYTE PTR _merged$[ebp], 0

; 1047 :   int8_t cur_mv_cand = 0;

	mov	BYTE PTR _cur_mv_cand$[ebp], 0

; 1048 : 
; 1049 :   x *= 1 << mv_shift;

	mov	eax, 1
	mov	ecx, DWORD PTR _mv_shift$[ebp]
	shl	eax, cl
	imul	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 1050 :   y *= 1 << mv_shift;

	mov	eax, 1
	mov	ecx, DWORD PTR _mv_shift$[ebp]
	shl	eax, cl
	imul	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 1051 : 
; 1052 :   // Check every candidate to find a match
; 1053 :   for (merge_idx = 0; merge_idx < (uint32_t)num_cand; merge_idx++) {

	mov	DWORD PTR _merge_idx$[ebp], 0
	jmp	SHORT $LN4@kvz_calc_m
$LN2@kvz_calc_m:
	mov	eax, DWORD PTR _merge_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _merge_idx$[ebp], eax
$LN4@kvz_calc_m:
	movsx	eax, WORD PTR _num_cand$[ebp]
	cmp	DWORD PTR _merge_idx$[ebp], eax
	jae	$LN3@kvz_calc_m

; 1054 :     if (merge_cand[merge_idx].dir == 3) continue;

	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	ecx, DWORD PTR _merge_cand$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 3
	jne	SHORT $LN17@kvz_calc_m
	jmp	SHORT $LN2@kvz_calc_m
$LN17@kvz_calc_m:

; 1055 :     if (merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][0] == x &&
; 1056 :       merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][1] == y &&

	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	imul	ecx, DWORD PTR _merge_idx$[ebp], 12
	mov	edx, DWORD PTR _merge_cand$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, 2
	imul	ecx, eax, 0
	movsx	edx, WORD PTR [edx+ecx]
	cmp	edx, DWORD PTR _x$[ebp]
	jne	SHORT $LN18@kvz_calc_m
	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	imul	ecx, DWORD PTR _merge_idx$[ebp], 12
	mov	edx, DWORD PTR _merge_cand$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	cmp	ecx, DWORD PTR _y$[ebp]
	jne	SHORT $LN18@kvz_calc_m
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	edx, DWORD PTR _merge_idx$[ebp], 12
	mov	eax, DWORD PTR _merge_cand$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	sub	edx, 1
	shl	edx, 4
	lea	eax, DWORD PTR [ecx+edx+45]
	imul	ecx, DWORD PTR _merge_idx$[ebp], 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	imul	edx, DWORD PTR _merge_idx$[ebp], 12
	mov	esi, DWORD PTR _merge_cand$[ebp]
	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [ecx+edx]
	movzx	edx, BYTE PTR [eax+ecx]
	cmp	edx, DWORD PTR _ref_idx$[ebp]
	jne	SHORT $LN18@kvz_calc_m

; 1057 :       state->frame->ref_LX[merge_cand[merge_idx].dir - 1][
; 1058 :         merge_cand[merge_idx].ref[merge_cand[merge_idx].dir - 1]
; 1059 :       ] == ref_idx)
; 1060 :     {
; 1061 :       merged = 1;

	mov	BYTE PTR _merged$[ebp], 1

; 1062 :       break;

	jmp	SHORT $LN3@kvz_calc_m
$LN18@kvz_calc_m:

; 1063 :     }
; 1064 :   }

	jmp	$LN2@kvz_calc_m
$LN3@kvz_calc_m:

; 1065 : 
; 1066 :   // Store cabac state and contexts
; 1067 :   memcpy(&state_cabac_copy, &state->cabac, sizeof(cabac_data_t));

	push	216					; 000000d8H
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _state_cabac_copy$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1068 : 
; 1069 :   // Clear bytes and bits and set mode to "count"
; 1070 :   state_cabac_copy.only_count = 1;

	mov	BYTE PTR _state_cabac_copy$[ebp+24], 1

; 1071 :   state_cabac_copy.num_buffered_bytes = 0;

	mov	DWORD PTR _state_cabac_copy$[ebp+16], 0

; 1072 :   state_cabac_copy.bits_left = 23;

	mov	DWORD PTR _state_cabac_copy$[ebp+20], 23 ; 00000017H

; 1073 : 
; 1074 :   cabac = &state_cabac_copy;

	lea	eax, DWORD PTR _state_cabac_copy$[ebp]
	mov	DWORD PTR _cabac$[ebp], eax

; 1075 : 
; 1076 :   if (!merged) {

	movsx	eax, BYTE PTR _merged$[ebp]
	test	eax, eax
	jne	$LN21@kvz_calc_m

; 1077 :     vector2d_t mvd1 = {

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _mv_cand$[ebp]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _mvd1$13[ebp], edx
	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _mv_cand$[ebp]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _mvd1$13[ebp+4], ecx

; 1078 :       x - mv_cand[0][0],
; 1079 :       y - mv_cand[0][1],
; 1080 :     };
; 1081 :     vector2d_t mvd2 = {

	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _mv_cand$[ebp]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _mvd2$12[ebp], ecx
	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _mv_cand$[ebp]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, edx
	mov	DWORD PTR _mvd2$12[ebp+4], eax

; 1082 :       x - mv_cand[1][0],
; 1083 :       y - mv_cand[1][1],
; 1084 :     };
; 1085 :     uint32_t cand1_cost = kvz_get_mvd_coding_cost_cabac(state, cabac, mvd1.x, mvd1.y);

	mov	eax, DWORD PTR _mvd1$13[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mvd1$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _cabac$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_get_mvd_coding_cost_cabac
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cand1_cost$11[ebp], eax

; 1086 :     uint32_t cand2_cost = kvz_get_mvd_coding_cost_cabac(state, cabac, mvd2.x, mvd2.y);

	mov	eax, DWORD PTR _mvd2$12[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mvd2$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _cabac$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_get_mvd_coding_cost_cabac
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cand2_cost$10[ebp], eax

; 1087 : 
; 1088 :     // Select candidate 1 if it has lower cost
; 1089 :     if (cand2_cost < cand1_cost) {

	mov	eax, DWORD PTR _cand2_cost$10[ebp]
	cmp	eax, DWORD PTR _cand1_cost$11[ebp]
	jae	SHORT $LN20@kvz_calc_m

; 1090 :       cur_mv_cand = 1;

	mov	BYTE PTR _cur_mv_cand$[ebp], 1

; 1091 :       mvd = mvd2;

	mov	eax, DWORD PTR _mvd2$12[ebp]
	mov	DWORD PTR _mvd$[ebp], eax
	mov	ecx, DWORD PTR _mvd2$12[ebp+4]
	mov	DWORD PTR _mvd$[ebp+4], ecx

; 1092 :     } else {

	jmp	SHORT $LN21@kvz_calc_m
$LN20@kvz_calc_m:

; 1093 :       mvd = mvd1;

	mov	eax, DWORD PTR _mvd1$13[ebp]
	mov	DWORD PTR _mvd$[ebp], eax
	mov	ecx, DWORD PTR _mvd1$13[ebp+4]
	mov	DWORD PTR _mvd$[ebp+4], ecx
$LN21@kvz_calc_m:

; 1094 :     }
; 1095 :   }
; 1096 : 
; 1097 :   cabac->cur_ctx = &(cabac->ctx.cu_merge_flag_ext_model);

	mov	eax, DWORD PTR _cabac$[ebp]
	add	eax, 205				; 000000cdH
	mov	ecx, DWORD PTR _cabac$[ebp]
	mov	DWORD PTR [ecx], eax

; 1098 : 
; 1099 :   CABAC_BIN(cabac, merged, "MergeFlag");

	movsx	eax, BYTE PTR _merged$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cabac$[ebp]
	push	ecx
	call	_kvz_cabac_encode_bin
	add	esp, 8

; 1100 :   num_cand = state->encoder_control->cfg.max_merge;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	dx, BYTE PTR [ecx+2441]
	mov	WORD PTR _num_cand$[ebp], dx

; 1101 :   if (merged) {

	movsx	eax, BYTE PTR _merged$[ebp]
	test	eax, eax
	je	$LN22@kvz_calc_m

; 1102 :     if (num_cand > 1) {

	movsx	eax, WORD PTR _num_cand$[ebp]
	cmp	eax, 1
	jle	$LN6@kvz_calc_m

; 1103 :       int32_t ui;
; 1104 :       for (ui = 0; ui < num_cand - 1; ui++) {

	mov	DWORD PTR _ui$9[ebp], 0
	jmp	SHORT $LN7@kvz_calc_m
$LN5@kvz_calc_m:
	mov	eax, DWORD PTR _ui$9[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$9[ebp], eax
$LN7@kvz_calc_m:
	movsx	eax, WORD PTR _num_cand$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _ui$9[ebp], eax
	jge	$LN6@kvz_calc_m

; 1105 :         int32_t symbol = (ui != merge_idx);

	mov	eax, DWORD PTR _ui$9[ebp]
	cmp	eax, DWORD PTR _merge_idx$[ebp]
	je	SHORT $LN39@kvz_calc_m
	mov	DWORD PTR tv250[ebp], 1
	jmp	SHORT $LN40@kvz_calc_m
$LN39@kvz_calc_m:
	mov	DWORD PTR tv250[ebp], 0
$LN40@kvz_calc_m:
	mov	ecx, DWORD PTR tv250[ebp]
	mov	DWORD PTR _symbol$8[ebp], ecx

; 1106 :         if (ui == 0) {

	cmp	DWORD PTR _ui$9[ebp], 0
	jne	SHORT $LN25@kvz_calc_m

; 1107 :           cabac->cur_ctx = &(cabac->ctx.cu_merge_idx_ext_model);

	mov	eax, DWORD PTR _cabac$[ebp]
	add	eax, 204				; 000000ccH
	mov	ecx, DWORD PTR _cabac$[ebp]
	mov	DWORD PTR [ecx], eax

; 1108 :           CABAC_BIN(cabac, symbol, "MergeIndex");

	mov	eax, DWORD PTR _symbol$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _cabac$[ebp]
	push	ecx
	call	_kvz_cabac_encode_bin
	add	esp, 8

; 1109 :         } else {

	jmp	SHORT $LN26@kvz_calc_m
$LN25@kvz_calc_m:

; 1110 :           CABAC_BIN_EP(cabac, symbol, "MergeIndex");

	mov	eax, DWORD PTR _symbol$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _cabac$[ebp]
	push	ecx
	call	_kvz_cabac_encode_bin_ep
	add	esp, 8
$LN26@kvz_calc_m:

; 1111 :         }
; 1112 :         if (symbol == 0) break;

	cmp	DWORD PTR _symbol$8[ebp], 0
	jne	SHORT $LN27@kvz_calc_m
	jmp	SHORT $LN6@kvz_calc_m
$LN27@kvz_calc_m:

; 1113 :       }

	jmp	$LN5@kvz_calc_m
$LN6@kvz_calc_m:

; 1114 :     }
; 1115 :   } else {

	jmp	$LN12@kvz_calc_m
$LN22@kvz_calc_m:

; 1116 :     uint32_t ref_list_idx;
; 1117 :     uint32_t j;
; 1118 :     int ref_list[2] = { 0, 0 };

	mov	DWORD PTR _ref_list$5[ebp], 0
	mov	DWORD PTR _ref_list$5[ebp+4], 0

; 1119 :     for (j = 0; j < state->frame->ref->used_size; j++) {

	mov	DWORD PTR _j$6[ebp], 0
	jmp	SHORT $LN10@kvz_calc_m
$LN8@kvz_calc_m:
	mov	eax, DWORD PTR _j$6[ebp]
	add	eax, 1
	mov	DWORD PTR _j$6[ebp], eax
$LN10@kvz_calc_m:
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _j$6[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jae	SHORT $LN9@kvz_calc_m

; 1120 :       if (state->frame->ref->pocs[j] < state->frame->poc) {

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _j$6[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, DWORD PTR [edx+12]
	jge	SHORT $LN28@kvz_calc_m

; 1121 :         ref_list[0]++;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ref_list$5[ebp+ecx]
	add	edx, 1
	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _ref_list$5[ebp+ecx], edx

; 1122 :       } else {

	jmp	SHORT $LN29@kvz_calc_m
$LN28@kvz_calc_m:

; 1123 :         ref_list[1]++;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ref_list$5[ebp+eax]
	add	ecx, 1
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _ref_list$5[ebp+edx], ecx
$LN29@kvz_calc_m:

; 1124 :       }
; 1125 :     }

	jmp	$LN8@kvz_calc_m
$LN9@kvz_calc_m:

; 1126 : 
; 1127 :     //ToDo: bidir mv support
; 1128 :     for (ref_list_idx = 0; ref_list_idx < 2; ref_list_idx++) {

	mov	DWORD PTR _ref_list_idx$7[ebp], 0
	jmp	SHORT $LN13@kvz_calc_m
$LN11@kvz_calc_m:
	mov	eax, DWORD PTR _ref_list_idx$7[ebp]
	add	eax, 1
	mov	DWORD PTR _ref_list_idx$7[ebp], eax
$LN13@kvz_calc_m:
	cmp	DWORD PTR _ref_list_idx$7[ebp], 2
	jae	$LN12@kvz_calc_m

; 1129 :       if (/*cur_cu->inter.mv_dir*/ 1 & (1 << ref_list_idx)) {

	mov	eax, 1
	mov	ecx, DWORD PTR _ref_list_idx$7[ebp]
	shl	eax, cl
	and	eax, 1
	je	$LN30@kvz_calc_m

; 1130 :         if (ref_list[ref_list_idx] > 1) {

	mov	eax, DWORD PTR _ref_list_idx$7[ebp]
	cmp	DWORD PTR _ref_list$5[ebp+eax*4], 1
	jle	$LN15@kvz_calc_m

; 1131 :           // parseRefFrmIdx
; 1132 :           int32_t ref_frame = ref_idx;

	mov	eax, DWORD PTR _ref_idx$[ebp]
	mov	DWORD PTR _ref_frame$4[ebp], eax

; 1133 : 
; 1134 :           cabac->cur_ctx = &(cabac->ctx.cu_ref_pic_model[0]);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cabac$[ebp]
	lea	eax, DWORD PTR [edx+ecx+209]
	mov	ecx, DWORD PTR _cabac$[ebp]
	mov	DWORD PTR [ecx], eax

; 1135 :           CABAC_BIN(cabac, (ref_frame != 0), "ref_idx_lX");

	cmp	DWORD PTR _ref_frame$4[ebp], 0
	je	SHORT $LN41@kvz_calc_m
	mov	DWORD PTR tv299[ebp], 1
	jmp	SHORT $LN42@kvz_calc_m
$LN41@kvz_calc_m:
	mov	DWORD PTR tv299[ebp], 0
$LN42@kvz_calc_m:
	mov	eax, DWORD PTR tv299[ebp]
	push	eax
	mov	ecx, DWORD PTR _cabac$[ebp]
	push	ecx
	call	_kvz_cabac_encode_bin
	add	esp, 8

; 1136 : 
; 1137 :           if (ref_frame > 0) {

	cmp	DWORD PTR _ref_frame$4[ebp], 0
	jle	$LN15@kvz_calc_m

; 1138 :             int32_t i;
; 1139 :             int32_t ref_num = ref_list[ref_list_idx] - 2;

	mov	eax, DWORD PTR _ref_list_idx$7[ebp]
	mov	ecx, DWORD PTR _ref_list$5[ebp+eax*4]
	sub	ecx, 2
	mov	DWORD PTR _ref_num$2[ebp], ecx

; 1140 : 
; 1141 :             cabac->cur_ctx = &(cabac->ctx.cu_ref_pic_model[1]);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cabac$[ebp]
	lea	edx, DWORD PTR [ecx+eax+209]
	mov	eax, DWORD PTR _cabac$[ebp]
	mov	DWORD PTR [eax], edx

; 1142 :             ref_frame--;

	mov	eax, DWORD PTR _ref_frame$4[ebp]
	sub	eax, 1
	mov	DWORD PTR _ref_frame$4[ebp], eax

; 1143 : 
; 1144 :             for (i = 0; i < ref_num; ++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN16@kvz_calc_m
$LN14@kvz_calc_m:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN16@kvz_calc_m:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _ref_num$2[ebp]
	jge	SHORT $LN15@kvz_calc_m

; 1145 :               const uint32_t symbol = (i == ref_frame) ? 0 : 1;

	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _ref_frame$4[ebp]
	jne	SHORT $LN43@kvz_calc_m
	mov	DWORD PTR tv314[ebp], 0
	jmp	SHORT $LN44@kvz_calc_m
$LN43@kvz_calc_m:
	mov	DWORD PTR tv314[ebp], 1
$LN44@kvz_calc_m:
	mov	ecx, DWORD PTR tv314[ebp]
	mov	DWORD PTR _symbol$1[ebp], ecx

; 1146 : 
; 1147 :               if (i == 0) {

	cmp	DWORD PTR _i$3[ebp], 0
	jne	SHORT $LN33@kvz_calc_m

; 1148 :                 CABAC_BIN(cabac, symbol, "ref_idx_lX");

	mov	eax, DWORD PTR _symbol$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _cabac$[ebp]
	push	ecx
	call	_kvz_cabac_encode_bin
	add	esp, 8

; 1149 :               } else {

	jmp	SHORT $LN34@kvz_calc_m
$LN33@kvz_calc_m:

; 1150 :                 CABAC_BIN_EP(cabac, symbol, "ref_idx_lX");

	mov	eax, DWORD PTR _symbol$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _cabac$[ebp]
	push	ecx
	call	_kvz_cabac_encode_bin_ep
	add	esp, 8
$LN34@kvz_calc_m:

; 1151 :               }
; 1152 :               if (symbol == 0) break;

	cmp	DWORD PTR _symbol$1[ebp], 0
	jne	SHORT $LN35@kvz_calc_m
	jmp	SHORT $LN15@kvz_calc_m
$LN35@kvz_calc_m:

; 1153 :             }

	jmp	$LN14@kvz_calc_m
$LN15@kvz_calc_m:

; 1154 :           }
; 1155 :         }
; 1156 : 
; 1157 :         // ToDo: Bidir vector support
; 1158 :         if (!(state->frame->ref_list == REF_PIC_LIST_1 && /*cur_cu->inter.mv_dir == 3*/ 0)) {

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movsx	edx, BYTE PTR [ecx+44]
	cmp	edx, 1
	jne	SHORT $LN37@kvz_calc_m
	xor	eax, eax
	jne	SHORT $LN36@kvz_calc_m
$LN37@kvz_calc_m:

; 1159 :           // It is safe to drop const here because cabac->only_count is set.
; 1160 :           kvz_encode_mvd((encoder_state_t*) state, cabac, mvd.x, mvd.y);

	mov	eax, DWORD PTR _mvd$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mvd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cabac$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_encode_mvd
	add	esp, 16					; 00000010H
$LN36@kvz_calc_m:

; 1161 :         }
; 1162 : 
; 1163 :         // Signal which candidate MV to use
; 1164 :         kvz_cabac_write_unary_max_symbol(

	push	1
	push	1
	movsx	eax, BYTE PTR _cur_mv_cand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cabac$[ebp]
	add	ecx, 211				; 000000d3H
	push	ecx
	mov	edx, DWORD PTR _cabac$[ebp]
	push	edx
	call	_kvz_cabac_write_unary_max_symbol
	add	esp, 20					; 00000014H
$LN30@kvz_calc_m:

; 1165 :             cabac,
; 1166 :             cabac->ctx.mvp_idx_model,
; 1167 :             cur_mv_cand,
; 1168 :             1,
; 1169 :             AMVP_MAX_NUM_CANDS - 1);
; 1170 :       }
; 1171 :     }

	jmp	$LN11@kvz_calc_m
$LN12@kvz_calc_m:

; 1172 :   }
; 1173 : 
; 1174 :   *bitcost = (23 - state_cabac_copy.bits_left) + (state_cabac_copy.num_buffered_bytes << 3);

	mov	eax, 23					; 00000017H
	sub	eax, DWORD PTR _state_cabac_copy$[ebp+20]
	mov	ecx, DWORD PTR _state_cabac_copy$[ebp+16]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _bitcost$[ebp]
	mov	DWORD PTR [eax], edx

; 1175 : 
; 1176 :   // Store bitcost before restoring cabac
; 1177 :   return *bitcost * (uint32_t)(state->lambda_sqrt + 0.5);

	mov	eax, DWORD PTR _state$[ebp]
	movsd	xmm0, QWORD PTR [eax+304]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	call	__dtoui3
	mov	ecx, DWORD PTR _bitcost$[ebp]
	imul	eax, DWORD PTR [ecx]

; 1178 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@kvz_calc_m
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 656				; 00000290H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@kvz_calc_m:
	DD	5
	DD	$LN50@kvz_calc_m
$LN50@kvz_calc_m:
	DD	-224					; ffffff20H
	DD	216					; 000000d8H
	DD	$LN45@kvz_calc_m
	DD	-264					; fffffef8H
	DD	8
	DD	$LN46@kvz_calc_m
	DD	-304					; fffffed0H
	DD	8
	DD	$LN47@kvz_calc_m
	DD	-320					; fffffec0H
	DD	8
	DD	$LN48@kvz_calc_m
	DD	-408					; fffffe68H
	DD	8
	DD	$LN49@kvz_calc_m
$LN49@kvz_calc_m:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN48@kvz_calc_m:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	100					; 00000064H
	DB	50					; 00000032H
	DB	0
$LN47@kvz_calc_m:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	100					; 00000064H
	DB	49					; 00000031H
	DB	0
$LN46@kvz_calc_m:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	100					; 00000064H
	DB	0
$LN45@kvz_calc_m:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	121					; 00000079H
	DB	0
_kvz_calc_mvd_cost_cabac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_get_coded_level
_TEXT	SEGMENT
tv222 = -308						; size = 8
tv180 = -304						; size = 4
tv164 = -304						; size = 4
tv133 = -304						; size = 4
tv69 = -304						; size = 4
_cur_cost$1 = -104					; size = 8
_err$2 = -88						; size = 8
_base_sig_model$ = -72					; size = 4
_min_abs_level$ = -60					; size = 4
_abs_level$ = -48					; size = 4
_best_abs_level$ = -36					; size = 4
_cur_cost_sig$ = -24					; size = 8
_cabac$ = -8						; size = 4
_state$ = 8						; size = 4
_coded_cost$ = 12					; size = 4
_coded_cost0$ = 16					; size = 4
_coded_cost_sig$ = 20					; size = 4
_level_double$ = 24					; size = 4
_max_abs_level$ = 28					; size = 4
_ctx_num_sig$ = 32					; size = 2
_ctx_num_one$ = 36					; size = 2
_ctx_num_abs$ = 40					; size = 2
_abs_go_rice$ = 44					; size = 2
_c1_idx$ = 48						; size = 4
_c2_idx$ = 52						; size = 4
_q_bits$ = 56						; size = 4
_temp$ = 60						; size = 8
_last$ = 68						; size = 1
_type$ = 72						; size = 1
_kvz_get_coded_level PROC				; COMDAT

; 427  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 428  :   cabac_data_t * const cabac = &state->cabac;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _cabac$[ebp], eax

; 429  :   double cur_cost_sig   = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _cur_cost_sig$[ebp], xmm0

; 430  :   uint32_t best_abs_level = 0;

	mov	DWORD PTR _best_abs_level$[ebp], 0

; 431  :   int32_t abs_level;
; 432  :   int32_t min_abs_level;
; 433  :   cabac_ctx_t* base_sig_model = type?(cabac->ctx.cu_sig_model_chroma):(cabac->ctx.cu_sig_model_luma);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN11@kvz_get_co
	mov	ecx, DWORD PTR _cabac$[ebp]
	add	ecx, 95					; 0000005fH
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN12@kvz_get_co
$LN11@kvz_get_co:
	mov	edx, DWORD PTR _cabac$[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR tv69[ebp], edx
$LN12@kvz_get_co:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _base_sig_model$[ebp], eax

; 434  : 
; 435  :   if( !last && max_abs_level < 3 ) {

	movsx	eax, BYTE PTR _last$[ebp]
	test	eax, eax
	jne	SHORT $LN5@kvz_get_co
	cmp	DWORD PTR _max_abs_level$[ebp], 3
	jae	SHORT $LN5@kvz_get_co

; 436  :     *coded_cost_sig = state->lambda * CTX_ENTROPY_BITS(&base_sig_model[ctx_num_sig], 0);

	movzx	eax, WORD PTR _ctx_num_sig$[ebp]
	mov	ecx, DWORD PTR _base_sig_model$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 0
	mov	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR tv164[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv164[ebp]
	mov	ecx, DWORD PTR tv164[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [edx+296]
	mov	eax, DWORD PTR _coded_cost_sig$[ebp]
	movsd	QWORD PTR [eax], xmm0

; 437  :     *coded_cost     = *coded_cost0 + *coded_cost_sig;

	mov	eax, DWORD PTR _coded_cost0$[ebp]
	mov	ecx, DWORD PTR _coded_cost_sig$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	addsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _coded_cost$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 438  :     if (max_abs_level == 0) return best_abs_level;

	cmp	DWORD PTR _max_abs_level$[ebp], 0
	jne	SHORT $LN7@kvz_get_co
	mov	eax, DWORD PTR _best_abs_level$[ebp]
	jmp	$LN1@kvz_get_co
$LN7@kvz_get_co:

; 439  :   } else {

	jmp	SHORT $LN6@kvz_get_co
$LN5@kvz_get_co:

; 440  :     *coded_cost = MAX_DOUBLE;

	mov	eax, DWORD PTR _coded_cost$[ebp]
	movsd	xmm0, QWORD PTR __real@7fee42d130773b76
	movsd	QWORD PTR [eax], xmm0
$LN6@kvz_get_co:

; 441  :   }
; 442  : 
; 443  :   if( !last ) {

	movsx	eax, BYTE PTR _last$[ebp]
	test	eax, eax
	jne	SHORT $LN8@kvz_get_co

; 444  :     cur_cost_sig = state->lambda * CTX_ENTROPY_BITS(&base_sig_model[ctx_num_sig], 1);

	movzx	eax, WORD PTR _ctx_num_sig$[ebp]
	mov	ecx, DWORD PTR _base_sig_model$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 1
	mov	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR tv180[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv180[ebp]
	mov	ecx, DWORD PTR tv180[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [edx+296]
	movsd	QWORD PTR _cur_cost_sig$[ebp], xmm0
$LN8@kvz_get_co:

; 445  :   }
; 446  : 
; 447  :   min_abs_level    = ( max_abs_level > 1 ? max_abs_level - 1 : 1 );

	cmp	DWORD PTR _max_abs_level$[ebp], 1
	jbe	SHORT $LN13@kvz_get_co
	mov	eax, DWORD PTR _max_abs_level$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN14@kvz_get_co
$LN13@kvz_get_co:
	mov	DWORD PTR tv133[ebp], 1
$LN14@kvz_get_co:
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR _min_abs_level$[ebp], ecx

; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	mov	eax, DWORD PTR _max_abs_level$[ebp]
	mov	DWORD PTR _abs_level$[ebp], eax
	jmp	SHORT $LN4@kvz_get_co
$LN2@kvz_get_co:
	mov	eax, DWORD PTR _abs_level$[ebp]
	sub	eax, 1
	mov	DWORD PTR _abs_level$[ebp], eax
$LN4@kvz_get_co:
	mov	eax, DWORD PTR _abs_level$[ebp]
	cmp	eax, DWORD PTR _min_abs_level$[ebp]
	jl	$LN3@kvz_get_co

; 449  :     double err       = (double)(level_double - ( abs_level * (1 << q_bits) ) );

	mov	eax, 1
	mov	ecx, DWORD PTR _q_bits$[ebp]
	shl	eax, cl
	imul	eax, DWORD PTR _abs_level$[ebp]
	mov	ecx, DWORD PTR _level_double$[ebp]
	sub	ecx, eax
	cvtsi2sd xmm0, ecx
	movsd	QWORD PTR _err$2[ebp], xmm0

; 450  :     double cur_cost  = err * err * temp + state->lambda *

	movsd	xmm0, QWORD PTR _err$2[ebp]
	mulsd	xmm0, QWORD PTR _err$2[ebp]
	mulsd	xmm0, QWORD PTR _temp$[ebp]
	movzx	eax, BYTE PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c2_idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c1_idx$[ebp]
	push	edx
	movzx	eax, WORD PTR _abs_go_rice$[ebp]
	push	eax
	movzx	ecx, WORD PTR _ctx_num_abs$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ctx_num_one$[ebp]
	push	edx
	mov	eax, DWORD PTR _abs_level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	movsd	QWORD PTR tv222[ebp], xmm0
	call	_kvz_get_ic_rate
	add	esp, 32					; 00000020H
	cvtsi2sd xmm0, eax
	mov	edx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [edx+296]
	movsd	xmm1, QWORD PTR tv222[ebp]
	addsd	xmm1, xmm0
	movsd	QWORD PTR _cur_cost$1[ebp], xmm1

; 451  :                        kvz_get_ic_rate( state, abs_level, ctx_num_one, ctx_num_abs,
; 452  :                                     abs_go_rice, c1_idx, c2_idx, type);
; 453  :     cur_cost        += cur_cost_sig;

	movsd	xmm0, QWORD PTR _cur_cost$1[ebp]
	addsd	xmm0, QWORD PTR _cur_cost_sig$[ebp]
	movsd	QWORD PTR _cur_cost$1[ebp], xmm0

; 454  : 
; 455  :     if( cur_cost < *coded_cost ) {

	mov	eax, DWORD PTR _coded_cost$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	comisd	xmm0, QWORD PTR _cur_cost$1[ebp]
	jbe	SHORT $LN9@kvz_get_co

; 456  :       best_abs_level  = abs_level;

	mov	eax, DWORD PTR _abs_level$[ebp]
	mov	DWORD PTR _best_abs_level$[ebp], eax

; 457  :       *coded_cost     = cur_cost;

	mov	eax, DWORD PTR _coded_cost$[ebp]
	movsd	xmm0, QWORD PTR _cur_cost$1[ebp]
	movsd	QWORD PTR [eax], xmm0

; 458  :       *coded_cost_sig = cur_cost_sig;

	mov	eax, DWORD PTR _coded_cost_sig$[ebp]
	movsd	xmm0, QWORD PTR _cur_cost_sig$[ebp]
	movsd	QWORD PTR [eax], xmm0
$LN9@kvz_get_co:

; 459  :     }
; 460  :   }

	jmp	$LN2@kvz_get_co
$LN3@kvz_get_co:

; 461  : 
; 462  :   return best_abs_level;

	mov	eax, DWORD PTR _best_abs_level$[ebp]
$LN1@kvz_get_co:

; 463  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_get_coded_level ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_get_ic_rate
_TEXT	SEGMENT
tv69 = -284						; size = 4
tv87 = -280						; size = 4
tv78 = -280						; size = 4
tv67 = -280						; size = 4
_length$1 = -80						; size = 4
_symbol$2 = -68						; size = 4
_base_abs_ctx$ = -56					; size = 4
_base_one_ctx$ = -44					; size = 4
_base_level$ = -32					; size = 4
_rate$ = -20						; size = 4
_cabac$ = -8						; size = 4
_state$ = 8						; size = 4
_abs_level$ = 12					; size = 4
_ctx_num_one$ = 16					; size = 2
_ctx_num_abs$ = 20					; size = 2
_abs_go_rice$ = 24					; size = 2
_c1_idx$ = 28						; size = 4
_c2_idx$ = 32						; size = 4
_type$ = 36						; size = 1
_kvz_get_ic_rate PROC					; COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 366  :   cabac_data_t * const cabac = &state->cabac;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _cabac$[ebp], eax

; 367  :   int32_t rate = 1 << CTX_FRAC_BITS;

	mov	DWORD PTR _rate$[ebp], 32768		; 00008000H

; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	cmp	DWORD PTR _c1_idx$[ebp], 8
	jae	SHORT $LN16@kvz_get_ic
	cmp	DWORD PTR _c2_idx$[ebp], 1
	jae	SHORT $LN14@kvz_get_ic
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN15@kvz_get_ic
$LN14@kvz_get_ic:
	mov	DWORD PTR tv67[ebp], 0
$LN15@kvz_get_ic:
	mov	eax, DWORD PTR tv67[ebp]
	add	eax, 2
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN17@kvz_get_ic
$LN16@kvz_get_ic:
	mov	DWORD PTR tv69[ebp], 1
$LN17@kvz_get_ic:
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _base_level$[ebp], ecx

; 369  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN18@kvz_get_ic
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cabac$[ebp]
	lea	ecx, DWORD PTR [eax+edx+170]
	mov	DWORD PTR tv78[ebp], ecx
	jmp	SHORT $LN19@kvz_get_ic
$LN18@kvz_get_ic:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cabac$[ebp]
	lea	edx, DWORD PTR [ecx+eax+186]
	mov	DWORD PTR tv78[ebp], edx
$LN19@kvz_get_ic:
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR _base_one_ctx$[ebp], eax

; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN20@kvz_get_ic
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cabac$[ebp]
	lea	ecx, DWORD PTR [eax+edx+194]
	mov	DWORD PTR tv87[ebp], ecx
	jmp	SHORT $LN21@kvz_get_ic
$LN20@kvz_get_ic:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cabac$[ebp]
	lea	edx, DWORD PTR [ecx+eax+198]
	mov	DWORD PTR tv87[ebp], edx
$LN21@kvz_get_ic:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR _base_abs_ctx$[ebp], eax

; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	mov	eax, DWORD PTR _abs_level$[ebp]
	cmp	eax, DWORD PTR _base_level$[ebp]
	jb	$LN4@kvz_get_ic

; 373  :     int32_t symbol     = abs_level - base_level;

	mov	eax, DWORD PTR _abs_level$[ebp]
	sub	eax, DWORD PTR _base_level$[ebp]
	mov	DWORD PTR _symbol$2[ebp], eax

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	movzx	ecx, WORD PTR _abs_go_rice$[ebp]
	mov	eax, 3
	shl	eax, cl
	cmp	DWORD PTR _symbol$2[ebp], eax
	jge	SHORT $LN6@kvz_get_ic

; 376  :       length = symbol>>abs_go_rice;

	movzx	ecx, WORD PTR _abs_go_rice$[ebp]
	mov	eax, DWORD PTR _symbol$2[ebp]
	sar	eax, cl
	mov	DWORD PTR _length$1[ebp], eax

; 377  :       rate += (length+1+abs_go_rice) * (1 << CTX_FRAC_BITS);

	movzx	eax, WORD PTR _abs_go_rice$[ebp]
	mov	ecx, DWORD PTR _length$1[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	shl	edx, 15					; 0000000fH
	add	edx, DWORD PTR _rate$[ebp]
	mov	DWORD PTR _rate$[ebp], edx

; 378  :     } else {

	jmp	SHORT $LN7@kvz_get_ic
$LN6@kvz_get_ic:

; 379  :       length = abs_go_rice;

	movzx	eax, WORD PTR _abs_go_rice$[ebp]
	mov	DWORD PTR _length$1[ebp], eax

; 380  :       symbol  = symbol - ( COEF_REMAIN_BIN_REDUCTION << abs_go_rice);

	movzx	ecx, WORD PTR _abs_go_rice$[ebp]
	mov	eax, 3
	shl	eax, cl
	mov	ecx, DWORD PTR _symbol$2[ebp]
	sub	ecx, eax
	mov	DWORD PTR _symbol$2[ebp], ecx
$LN2@kvz_get_ic:

; 381  :       while (symbol >= (1<<length)) {

	mov	eax, 1
	mov	ecx, DWORD PTR _length$1[ebp]
	shl	eax, cl
	cmp	DWORD PTR _symbol$2[ebp], eax
	jl	SHORT $LN3@kvz_get_ic

; 382  :         symbol -=  (1<<(length++));

	mov	eax, 1
	mov	ecx, DWORD PTR _length$1[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _symbol$2[ebp]
	sub	ecx, eax
	mov	DWORD PTR _symbol$2[ebp], ecx
	mov	edx, DWORD PTR _length$1[ebp]
	add	edx, 1
	mov	DWORD PTR _length$1[ebp], edx

; 383  :       }

	jmp	SHORT $LN2@kvz_get_ic
$LN3@kvz_get_ic:

; 384  :       rate += (COEF_REMAIN_BIN_REDUCTION+length+1-abs_go_rice+length) * (1 << CTX_FRAC_BITS);

	mov	eax, DWORD PTR _length$1[ebp]
	add	eax, 4
	movzx	ecx, WORD PTR _abs_go_rice$[ebp]
	sub	eax, ecx
	add	eax, DWORD PTR _length$1[ebp]
	shl	eax, 15					; 0000000fH
	add	eax, DWORD PTR _rate$[ebp]
	mov	DWORD PTR _rate$[ebp], eax
$LN7@kvz_get_ic:

; 385  :     }
; 386  :     if (c1_idx < C1FLAG_NUMBER) {

	cmp	DWORD PTR _c1_idx$[ebp], 8
	jae	SHORT $LN8@kvz_get_ic

; 387  :       rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, WORD PTR _ctx_num_one$[ebp]
	mov	ecx, DWORD PTR _base_one_ctx$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 1
	mov	eax, DWORD PTR _rate$[ebp]
	add	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR _rate$[ebp], eax

; 388  : 
; 389  :       if (c2_idx < C2FLAG_NUMBER) {

	cmp	DWORD PTR _c2_idx$[ebp], 1
	jae	SHORT $LN8@kvz_get_ic

; 390  :         rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],1);

	movzx	eax, WORD PTR _ctx_num_abs$[ebp]
	mov	ecx, DWORD PTR _base_abs_ctx$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 1
	mov	eax, DWORD PTR _rate$[ebp]
	add	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR _rate$[ebp], eax
$LN8@kvz_get_ic:

; 391  :       }
; 392  :     }
; 393  :   }

	jmp	SHORT $LN5@kvz_get_ic
$LN4@kvz_get_ic:

; 394  :   else if( abs_level == 1 ) {

	cmp	DWORD PTR _abs_level$[ebp], 1
	jne	SHORT $LN10@kvz_get_ic

; 395  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],0);

	movzx	eax, WORD PTR _ctx_num_one$[ebp]
	mov	ecx, DWORD PTR _base_one_ctx$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 0
	mov	eax, DWORD PTR _rate$[ebp]
	add	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR _rate$[ebp], eax
	jmp	SHORT $LN5@kvz_get_ic
$LN10@kvz_get_ic:

; 396  :   } else if( abs_level == 2 ) {

	cmp	DWORD PTR _abs_level$[ebp], 2
	jne	SHORT $LN5@kvz_get_ic

; 397  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, WORD PTR _ctx_num_one$[ebp]
	mov	ecx, DWORD PTR _base_one_ctx$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 1
	mov	eax, DWORD PTR _rate$[ebp]
	add	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR _rate$[ebp], eax

; 398  :     rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],0);

	movzx	eax, WORD PTR _ctx_num_abs$[ebp]
	mov	ecx, DWORD PTR _base_abs_ctx$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 0
	mov	eax, DWORD PTR _rate$[ebp]
	add	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR _rate$[ebp], eax
$LN5@kvz_get_ic:

; 399  :   }
; 400  : 
; 401  :   return rate;

	mov	eax, DWORD PTR _rate$[ebp]

; 402  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_get_ic_rate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_get_coeff_cost
_TEXT	SEGMENT
_ccc$1 = -72						; size = 4
_ccc$2 = -60						; size = 4
_fast_cost$3 = -48					; size = 4
_weights$4 = -36					; size = 8
_check_accuracy$ = -17					; size = 1
_save_cccs$ = -5					; size = 1
_state$ = 8						; size = 4
_coeff$ = 12						; size = 4
_width$ = 16						; size = 4
_type$ = 20						; size = 4
_scan_mode$ = 24					; size = 1
_kvz_get_coeff_cost PROC				; COMDAT

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 319  :   uint8_t save_cccs = state->encoder_control->cfg.fastrd_sampling_on;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+2469]
	mov	BYTE PTR _save_cccs$[ebp], dl

; 320  :   uint8_t check_accuracy = state->encoder_control->cfg.fastrd_accuracy_check_on;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+2470]
	mov	BYTE PTR _check_accuracy$[ebp], dl

; 321  : 
; 322  :   if (state->qp < state->encoder_control->cfg.fast_residual_cost_limit &&

	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, BYTE PTR [eax+312]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	edx, BYTE PTR [eax+2430]
	cmp	ecx, edx
	jge	$LN2@kvz_get_co
	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, BYTE PTR [eax+312]
	cmp	ecx, 50					; 00000032H
	jge	$LN2@kvz_get_co

; 323  :       state->qp < MAX_FAST_COEFF_COST_QP) {
; 324  :     // TODO: do we need to assert(0) out of the fast-estimation branch if we
; 325  :     // are to save block costs, or should we just warn about it somewhere
; 326  :     // earlier (configuration validation I guess)?
; 327  :     if (save_cccs) {

	movzx	eax, BYTE PTR _save_cccs$[ebp]
	test	eax, eax
	je	SHORT $LN4@kvz_get_co

; 328  :       assert(0 && "Fast RD sampling does not work with fast-residual-cost");

	xor	eax, eax
	jne	SHORT $LN9@kvz_get_co
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_get_coeff_cost@@9@9
	add	ecx, 10					; 0000000aH
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1GE@KKEFIIPC@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1HM@LHMCIFBA@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAF?$AAa?$AAs?$AAt?$AA?5?$AAR?$AAD?$AA?5?$AAs@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@kvz_get_co:

; 329  :       return UINT32_MAX; // Hush little compiler don't you cry, not really gonna return anything after assert(0)

	or	eax, -1
	jmp	$LN1@kvz_get_co

; 330  :     } else {

	jmp	SHORT $LN5@kvz_get_co
$LN4@kvz_get_co:

; 331  :       uint64_t weights = kvz_fast_coeff_get_weights(state);

	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_fast_coeff_get_weights
	add	esp, 4
	mov	DWORD PTR _weights$4[ebp], eax
	mov	DWORD PTR _weights$4[ebp+4], edx

; 332  :       uint32_t fast_cost = kvz_fast_coeff_cost(coeff, width, weights);

	mov	esi, esp
	mov	eax, DWORD PTR _weights$4[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _weights$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _coeff$[ebp]
	push	eax
	call	DWORD PTR _kvz_fast_coeff_cost
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fast_cost$3[ebp], eax

; 333  :       if (check_accuracy) {

	movzx	eax, BYTE PTR _check_accuracy$[ebp]
	test	eax, eax
	je	SHORT $LN6@kvz_get_co

; 334  :         uint32_t ccc = get_coeff_cabac_cost(state, coeff, width, type, scan_mode);

	movzx	eax, BYTE PTR _scan_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _coeff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_get_coeff_cabac_cost
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ccc$2[ebp], eax

; 335  :         save_accuracy(state->qp, ccc, fast_cost);

	mov	eax, DWORD PTR _fast_cost$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _ccc$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	movsx	eax, BYTE PTR [edx+312]
	push	eax
	call	_save_accuracy
	add	esp, 12					; 0000000cH
$LN6@kvz_get_co:

; 336  :       }
; 337  :       return fast_cost;

	mov	eax, DWORD PTR _fast_cost$3[ebp]
	jmp	SHORT $LN1@kvz_get_co
$LN5@kvz_get_co:

; 338  :     }
; 339  :   } else {

	jmp	SHORT $LN1@kvz_get_co
$LN2@kvz_get_co:

; 340  :     uint32_t ccc = get_coeff_cabac_cost(state, coeff, width, type, scan_mode);

	movzx	eax, BYTE PTR _scan_mode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _coeff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_get_coeff_cabac_cost
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ccc$1[ebp], eax

; 341  :     if (save_cccs) {

	movzx	eax, BYTE PTR _save_cccs$[ebp]
	test	eax, eax
	je	SHORT $LN7@kvz_get_co

; 342  :       save_ccc(state->qp, coeff, width * width, ccc);

	mov	eax, DWORD PTR _ccc$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	imul	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _coeff$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	movsx	ecx, BYTE PTR [eax+312]
	push	ecx
	call	_save_ccc
	add	esp, 16					; 00000010H
$LN7@kvz_get_co:

; 343  :     }
; 344  :     return ccc;

	mov	eax, DWORD PTR _ccc$1[ebp]
$LN1@kvz_get_co:

; 345  :   }
; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_get_coeff_cost ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_rdoq
_TEXT	SEGMENT
tv824 = -44756						; size = 8
tv760 = -44756						; size = 4
tv535 = -44756						; size = 4
tv1379 = -44752						; size = 4
tv1370 = -44752						; size = 4
tv1356 = -44752						; size = 4
tv1347 = -44752						; size = 4
tv1319 = -44752						; size = 4
tv1304 = -44752						; size = 4
tv1293 = -44752						; size = 4
tv1272 = -44752						; size = 4
tv861 = -44752						; size = 4
tv762 = -44752						; size = 4
tv755 = -44752						; size = 4
tv570 = -44752						; size = 4
tv553 = -44752						; size = 4
tv546 = -44752						; size = 4
tv533 = -44752						; size = 4
tv369 = -44752						; size = 4
tv276 = -44752						; size = 4
tv267 = -44752						; size = 4
tv238 = -44752						; size = 4
tv229 = -44752						; size = 4
tv196 = -44752						; size = 4
tv80 = -44752						; size = 4
_scanpos$1 = -43208					; size = 4
_level$2 = -43196					; size = 4
_blkPos$3 = -43184					; size = 4
_scanpos$4 = -43172					; size = 4
_abs_sum$ = -43160					; size = 4
_totalCost$5 = -43148					; size = 8
_cost_last$6 = -43132					; size = 8
_pos_x$7 = -43116					; size = 4
_pos_y$8 = -43104					; size = 4
_blkpos$9 = -43092					; size = 4
_scanpos$10 = -43080					; size = 4
_scanpos_in_cg$11 = -43068				; size = 4
_cg_blkpos$12 = -43056					; size = 4
_cg_scanpos$13 = -43044					; size = 4
_base_cbf_model$14 = -43032				; size = 4
_best_last_idx_p1$ = -43020				; size = 4
_found_last$ = -43005					; size = 1
_ctx_cbf$ = -42996					; size = 4
_best_cost$ = -42984					; size = 8
_blkpos$15 = -42968					; size = 4
_scanpos$16 = -42956					; size = 4
_scanpos_in_cg$17 = -42944				; size = 4
_ctx_sig$18 = -42932					; size = 4
_cost_zero_cg$19 = -42920				; size = 8
_ctx_sig$20 = -42904					; size = 4
_rate_down$21 = -42892					; size = 4
_rate_up$22 = -42880					; size = 4
_rate_now$23 = -42868					; size = 4
_zero$24 = -42856					; size = 4
_greater_than_zero$25 = -42844				; size = 4
_ctx_sig$26 = -42832					; size = 2
_pos_x$27 = -42820					; size = 4
_pos_y$28 = -42808					; size = 4
_abs_ctx$29 = -42796					; size = 2
_one_ctx$30 = -42784					; size = 2
_level$31 = -42772					; size = 4
_err$32 = -42760					; size = 8
_max_abs_level$33 = -42744				; size = 4
_level_double$34 = -42732				; size = 4
_temp$35 = -42720					; size = 8
_q$36 = -42704						; size = 4
_blkpos$37 = -42692					; size = 4
_scanpos$38 = -42680					; size = 4
_scanpos_in_cg$39 = -42668				; size = 4
_pattern_sig_ctx$40 = -42656				; size = 4
_cg_pos_x$41 = -42644					; size = 4
_cg_pos_y$42 = -42632					; size = 4
_cg_blkpos$43 = -42620					; size = 4
_cg_scanpos$44 = -42608					; size = 4
_last_y_bits$ = -42596					; size = 128
_last_x_bits$ = -42460					; size = 128
_max_abs_level$45 = -42324				; size = 4
_level_double$46 = -42312				; size = 4
_q$47 = -42300						; size = 4
_blkpos$48 = -42288					; size = 4
_scanpos$49 = -42276					; size = 4
_scanpos_in_cg$50 = -42264				; size = 4
_cg_scanpos$ = -42252					; size = 4
_rd_stats$ = -42240					; size = 40
_base_one_ctx$ = -42192					; size = 4
_baseCtx$ = -42180					; size = 4
_base_coeff_group_ctx$ = -42168				; size = 4
_temp_ptr$51 = -42156					; size = 4
_temp_ptr$52 = -42144					; size = 4
_temp_ptr$53 = -42132					; size = 4
_temp_ptr$54 = -42120					; size = 4
_cg_num$ = -42108					; size = 4
_last_scanpos$ = -42096					; size = 4
_cg_last_scanpos$ = -42084				; size = 4
_scan$ = -42072						; size = 4
_base_level$ = -42060					; size = 4
_c2_idx$ = -42048					; size = 4
_c1_idx$ = -42036					; size = 4
_base_cost$ = -42024					; size = 8
_c2$ = -42008						; size = 2
_c1$ = -41996						; size = 2
_ctx_set$ = -41984					; size = 2
_sig_coeffgroup_flag$ = -41972				; size = 256
_cost_coeffgroup_sig$ = -41708				; size = 512
_num_blk_side$ = -41188					; size = 4
_shift$ = -41176					; size = 4
_cg_size$ = -41164					; size = 4
_scan_cg$ = -41152					; size = 4
_sh_rates$ = -41140					; size = 16384
_cost_coeff0$ = -24748					; size = 8192
_cost_sig$ = -16548					; size = 8192
_cost_coeff$ = -8348					; size = 8192
_block_uncoded_cost$ = -148				; size = 8
_err_scale$ = -132					; size = 4
_quant_coeff$ = -120					; size = 4
_q_bits$ = -108						; size = 4
_qp_scaled$ = -96					; size = 4
_scalinglist_type$ = -84				; size = 4
_log2_block_size$ = -72					; size = 4
_go_rice_param$ = -60					; size = 2
_transform_shift$ = -48					; size = 4
_log2_tr_size$ = -36					; size = 4
_cabac$ = -24						; size = 4
_encoder$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_coef$ = 12						; size = 4
_dest_coeff$ = 16					; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
_type$ = 28						; size = 1
_scan_mode$ = 32					; size = 1
_block_type$ = 36					; size = 1
_tr_depth$ = 40						; size = 1
_kvz_rdoq PROC						; COMDAT

; 674  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 44756				; 0000aed4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44756]
	mov	ecx, 11189				; 00002bb5H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 675  :   const encoder_control_t * const encoder = state->encoder_control;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _encoder$[ebp], ecx

; 676  :   cabac_data_t * const cabac = &state->cabac;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _cabac$[ebp], eax

; 677  :   uint32_t log2_tr_size      = kvz_g_convert_to_bit[ width ] + 2;

	mov	eax, DWORD PTR _width$[ebp]
	movsx	ecx, BYTE PTR _kvz_g_convert_to_bit[eax]
	add	ecx, 2
	mov	DWORD PTR _log2_tr_size$[ebp], ecx

; 678  :   int32_t  transform_shift   = MAX_TR_DYNAMIC_RANGE - encoder->bitdepth - log2_tr_size;  // Represents scaling through forward transform

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+2532]
	mov	edx, 15					; 0000000fH
	sub	edx, ecx
	sub	edx, DWORD PTR _log2_tr_size$[ebp]
	mov	DWORD PTR _transform_shift$[ebp], edx

; 679  :   uint16_t go_rice_param     = 0;

	xor	eax, eax
	mov	WORD PTR _go_rice_param$[ebp], ax

; 680  :   uint32_t log2_block_size   = kvz_g_convert_to_bit[ width ] + 2;

	mov	eax, DWORD PTR _width$[ebp]
	movsx	ecx, BYTE PTR _kvz_g_convert_to_bit[eax]
	add	ecx, 2
	mov	DWORD PTR _log2_block_size$[ebp], ecx

; 681  :   int32_t  scalinglist_type= (block_type == CU_INTRA ? 0 : 3) + (int8_t)("\0\3\1\2"[type]);

	movsx	eax, BYTE PTR _block_type$[ebp]
	cmp	eax, 1
	jne	SHORT $LN79@kvz_rdoq
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN80@kvz_rdoq
$LN79@kvz_rdoq:
	mov	DWORD PTR tv80[ebp], 3
$LN80@kvz_rdoq:
	movsx	ecx, BYTE PTR _type$[ebp]
	movsx	edx, BYTE PTR ??_C@_04BIJMKPLJ@?$AA?$AD?$AB?$AC@[ecx]
	add	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _scalinglist_type$[ebp], edx

; 682  : 
; 683  :   int32_t qp_scaled = kvz_get_scaled_qp(type, state->qp, (encoder->bitdepth - 8) * 6);

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+2532]
	sub	ecx, 8
	imul	edx, ecx, 6
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	movzx	ecx, BYTE PTR [eax+312]
	push	ecx
	movzx	edx, BYTE PTR _type$[ebp]
	push	edx
	call	_kvz_get_scaled_qp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _qp_scaled$[ebp], eax

; 684  :   
; 685  :   int32_t q_bits = QUANT_SHIFT + qp_scaled/6 + transform_shift;

	mov	eax, DWORD PTR _qp_scaled$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	mov	edx, DWORD PTR _transform_shift$[ebp]
	lea	eax, DWORD PTR [eax+edx+14]
	mov	DWORD PTR _q_bits$[ebp], eax

; 686  : 
; 687  :   const int32_t *quant_coeff  = encoder->scaling_list.quant_coeff[log2_tr_size-2][scalinglist_type][qp_scaled%6];

	mov	eax, DWORD PTR _log2_tr_size$[ebp]
	sub	eax, 2
	imul	ecx, eax, 144
	mov	edx, DWORD PTR _encoder$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+2748]
	imul	edx, DWORD PTR _scalinglist_type$[ebp], 24
	add	ecx, edx
	mov	eax, DWORD PTR _qp_scaled$[ebp]
	cdq
	mov	esi, 6
	idiv	esi
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _quant_coeff$[ebp], eax

; 688  :   const double *err_scale     = encoder->scaling_list.error_scale[log2_tr_size-2][scalinglist_type][qp_scaled%6];

	mov	eax, DWORD PTR _log2_tr_size$[ebp]
	sub	eax, 2
	imul	ecx, eax, 144
	mov	edx, DWORD PTR _encoder$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+3900]
	imul	edx, DWORD PTR _scalinglist_type$[ebp], 24
	add	ecx, edx
	mov	eax, DWORD PTR _qp_scaled$[ebp]
	cdq
	mov	esi, 6
	idiv	esi
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _err_scale$[ebp], eax

; 689  : 
; 690  :   double block_uncoded_cost = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _block_uncoded_cost$[ebp], xmm0

; 691  :   
; 692  :   double cost_coeff [ 32 * 32 ];
; 693  :   double cost_sig   [ 32 * 32 ];
; 694  :   double cost_coeff0[ 32 * 32 ];
; 695  : 
; 696  :   struct sh_rates_t sh_rates;
; 697  : 
; 698  :   const uint32_t *scan_cg = g_sig_last_scan_cg[log2_block_size - 2][scan_mode];

	mov	eax, DWORD PTR _log2_block_size$[ebp]
	sub	eax, 2
	imul	ecx, eax, 12
	movsx	edx, BYTE PTR _scan_mode$[ebp]
	mov	eax, DWORD PTR _g_sig_last_scan_cg[ecx+edx*4]
	mov	DWORD PTR _scan_cg$[ebp], eax

; 699  :   const uint32_t cg_size = 16;

	mov	DWORD PTR _cg_size$[ebp], 16		; 00000010H

; 700  :   const int32_t  shift = 4 >> 1;

	mov	DWORD PTR _shift$[ebp], 2

; 701  :   const uint32_t num_blk_side = width >> shift;

	mov	eax, DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR _shift$[ebp]
	sar	eax, cl
	mov	DWORD PTR _num_blk_side$[ebp], eax

; 702  :   double   cost_coeffgroup_sig[ 64 ];
; 703  :   uint32_t sig_coeffgroup_flag[ 64 ];
; 704  : 
; 705  :   uint16_t    ctx_set    = 0;

	xor	eax, eax
	mov	WORD PTR _ctx_set$[ebp], ax

; 706  :   int16_t     c1         = 1;

	mov	eax, 1
	mov	WORD PTR _c1$[ebp], ax

; 707  :   int16_t     c2         = 0;

	xor	eax, eax
	mov	WORD PTR _c2$[ebp], ax

; 708  :   double      base_cost  = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 709  : 
; 710  :   uint32_t    c1_idx     = 0;

	mov	DWORD PTR _c1_idx$[ebp], 0

; 711  :   uint32_t    c2_idx     = 0;

	mov	DWORD PTR _c2_idx$[ebp], 0

; 712  :   int32_t     base_level;
; 713  : 
; 714  :   const uint32_t *scan = kvz_g_sig_last_scan[ scan_mode ][ log2_block_size - 1 ];

	movsx	eax, BYTE PTR _scan_mode$[ebp]
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _log2_block_size$[ebp]
	mov	eax, DWORD PTR _kvz_g_sig_last_scan[ecx+edx*4-4]
	mov	DWORD PTR _scan$[ebp], eax

; 715  : 
; 716  :   int32_t cg_last_scanpos = -1;

	mov	DWORD PTR _cg_last_scanpos$[ebp], -1

; 717  :   int32_t last_scanpos = -1;

	mov	DWORD PTR _last_scanpos$[ebp], -1

; 718  : 
; 719  :   uint32_t cg_num = width * height >> 4;

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	sar	eax, 4
	mov	DWORD PTR _cg_num$[ebp], eax

; 720  : 
; 721  :   // Explicitly tell the only possible numbers of elements to be zeroed.
; 722  :   // Hope the compiler is able to utilize this information.
; 723  :   switch (cg_num) {

	mov	eax, DWORD PTR _cg_num$[ebp]
	mov	DWORD PTR tv196[ebp], eax
	mov	ecx, DWORD PTR tv196[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv196[ebp], ecx
	cmp	DWORD PTR tv196[ebp], 63		; 0000003fH
	ja	$LN38@kvz_rdoq
	mov	edx, DWORD PTR tv196[ebp]
	movzx	eax, BYTE PTR $LN112@kvz_rdoq[edx]
	jmp	DWORD PTR $LN113@kvz_rdoq[eax*4]
$LN34@kvz_rdoq:

; 724  :     case  1: FILL_ARRAY(sig_coeffgroup_flag, 0,  1); break;

	lea	eax, DWORD PTR _sig_coeffgroup_flag$[ebp]
	mov	DWORD PTR _temp_ptr$54[ebp], eax
	push	4
	push	0
	mov	eax, DWORD PTR _temp_ptr$54[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	$LN2@kvz_rdoq
$LN35@kvz_rdoq:

; 725  :     case  4: FILL_ARRAY(sig_coeffgroup_flag, 0,  4); break;

	lea	eax, DWORD PTR _sig_coeffgroup_flag$[ebp]
	mov	DWORD PTR _temp_ptr$53[ebp], eax
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _temp_ptr$53[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@kvz_rdoq
$LN36@kvz_rdoq:

; 726  :     case 16: FILL_ARRAY(sig_coeffgroup_flag, 0, 16); break;

	lea	eax, DWORD PTR _sig_coeffgroup_flag$[ebp]
	mov	DWORD PTR _temp_ptr$52[ebp], eax
	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _temp_ptr$52[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@kvz_rdoq
$LN37@kvz_rdoq:

; 727  :     case 64: FILL_ARRAY(sig_coeffgroup_flag, 0, 64); break;

	lea	eax, DWORD PTR _sig_coeffgroup_flag$[ebp]
	mov	DWORD PTR _temp_ptr$51[ebp], eax
	push	256					; 00000100H
	push	0
	mov	eax, DWORD PTR _temp_ptr$51[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@kvz_rdoq
$LN38@kvz_rdoq:

; 728  :     default: assert(0 && "There should be 1, 4, 16 or 64 coefficient groups");

	xor	eax, eax
	jne	SHORT $LN81@kvz_rdoq
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_rdoq@@9@9
	add	ecx, 54					; 00000036H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1GE@KKEFIIPC@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1HC@GANJHONP@?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAh?$AAe?$AAr?$AAe?$AA?5?$AAs?$AAh?$AAo@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN81@kvz_rdoq:
$LN2@kvz_rdoq:

; 729  :   }
; 730  : 
; 731  :   cabac_ctx_t *base_coeff_group_ctx = &(cabac->ctx.cu_sig_coeff_group_model[type]);

	movsx	eax, BYTE PTR _type$[ebp]
	mov	ecx, DWORD PTR _cabac$[ebp]
	lea	edx, DWORD PTR [ecx+eax+64]
	mov	DWORD PTR _base_coeff_group_ctx$[ebp], edx

; 732  :   cabac_ctx_t *baseCtx              = (type == 0) ? &(cabac->ctx.cu_sig_model_luma[0]) : &(cabac->ctx.cu_sig_model_chroma[0]);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN82@kvz_rdoq
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cabac$[ebp]
	lea	ecx, DWORD PTR [eax+edx+68]
	mov	DWORD PTR tv229[ebp], ecx
	jmp	SHORT $LN83@kvz_rdoq
$LN82@kvz_rdoq:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cabac$[ebp]
	lea	edx, DWORD PTR [ecx+eax+95]
	mov	DWORD PTR tv229[ebp], edx
$LN83@kvz_rdoq:
	mov	eax, DWORD PTR tv229[ebp]
	mov	DWORD PTR _baseCtx$[ebp], eax

; 733  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN84@kvz_rdoq
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cabac$[ebp]
	lea	ecx, DWORD PTR [eax+edx+170]
	mov	DWORD PTR tv238[ebp], ecx
	jmp	SHORT $LN85@kvz_rdoq
$LN84@kvz_rdoq:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cabac$[ebp]
	lea	edx, DWORD PTR [ecx+eax+186]
	mov	DWORD PTR tv238[ebp], edx
$LN85@kvz_rdoq:
	mov	eax, DWORD PTR tv238[ebp]
	mov	DWORD PTR _base_one_ctx$[ebp], eax

; 734  : 
; 735  :   struct {
; 736  :     double coded_level_and_dist;
; 737  :     double uncoded_dist;
; 738  :     double sig_cost;
; 739  :     double sig_cost_0;
; 740  :     int32_t nnz_before_pos0;
; 741  :   } rd_stats;
; 742  : 
; 743  :   //Find last cg and last scanpos
; 744  :   int32_t cg_scanpos;
; 745  :   for (cg_scanpos = (cg_num - 1); cg_scanpos >= 0; cg_scanpos--)

	mov	eax, DWORD PTR _cg_num$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cg_scanpos$[ebp], eax
	jmp	SHORT $LN6@kvz_rdoq
$LN4@kvz_rdoq:
	mov	eax, DWORD PTR _cg_scanpos$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cg_scanpos$[ebp], eax
$LN6@kvz_rdoq:
	cmp	DWORD PTR _cg_scanpos$[ebp], 0
	jl	$LN5@kvz_rdoq

; 746  :   {
; 747  :     for (int32_t scanpos_in_cg = (cg_size - 1); scanpos_in_cg >= 0; scanpos_in_cg--)

	mov	eax, DWORD PTR _cg_size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _scanpos_in_cg$50[ebp], eax
	jmp	SHORT $LN9@kvz_rdoq
$LN7@kvz_rdoq:
	mov	eax, DWORD PTR _scanpos_in_cg$50[ebp]
	sub	eax, 1
	mov	DWORD PTR _scanpos_in_cg$50[ebp], eax
$LN9@kvz_rdoq:
	cmp	DWORD PTR _scanpos_in_cg$50[ebp], 0
	jl	$LN8@kvz_rdoq

; 748  :     {
; 749  :       int32_t  scanpos        = cg_scanpos*cg_size + scanpos_in_cg;

	mov	eax, DWORD PTR _cg_scanpos$[ebp]
	imul	eax, DWORD PTR _cg_size$[ebp]
	add	eax, DWORD PTR _scanpos_in_cg$50[ebp]
	mov	DWORD PTR _scanpos$49[ebp], eax

; 750  :       uint32_t blkpos         = scan[scanpos];

	mov	eax, DWORD PTR _scanpos$49[ebp]
	mov	ecx, DWORD PTR _scan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _blkpos$48[ebp], edx

; 751  :       int32_t q               = quant_coeff[blkpos];

	mov	eax, DWORD PTR _blkpos$48[ebp]
	mov	ecx, DWORD PTR _quant_coeff$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _q$47[ebp], edx

; 752  :       int32_t level_double    = coef[blkpos];

	mov	eax, DWORD PTR _blkpos$48[ebp]
	mov	ecx, DWORD PTR _coef$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _level_double$46[ebp], edx

; 753  :       level_double            = MIN(abs(level_double) * q, MAX_INT - (1 << (q_bits - 1)));

	mov	eax, DWORD PTR _level_double$46[ebp]
	push	eax
	call	_abs
	add	esp, 4
	imul	eax, DWORD PTR _q$47[ebp]
	mov	ecx, DWORD PTR _q_bits$[ebp]
	sub	ecx, 1
	mov	edx, 1
	shl	edx, cl
	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, edx
	cmp	eax, ecx
	jge	SHORT $LN86@kvz_rdoq
	mov	edx, DWORD PTR _level_double$46[ebp]
	push	edx
	call	_abs
	add	esp, 4
	imul	eax, DWORD PTR _q$47[ebp]
	mov	DWORD PTR tv267[ebp], eax
	jmp	SHORT $LN87@kvz_rdoq
$LN86@kvz_rdoq:
	mov	ecx, DWORD PTR _q_bits$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, eax
	mov	DWORD PTR tv267[ebp], ecx
$LN87@kvz_rdoq:
	mov	edx, DWORD PTR tv267[ebp]
	mov	DWORD PTR _level_double$46[ebp], edx

; 754  :       uint32_t max_abs_level  = (level_double + (1 << (q_bits - 1))) >> q_bits;

	mov	ecx, DWORD PTR _q_bits$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	add	eax, DWORD PTR _level_double$46[ebp]
	mov	ecx, DWORD PTR _q_bits$[ebp]
	sar	eax, cl
	mov	DWORD PTR _max_abs_level$45[ebp], eax

; 755  : 
; 756  :       if (max_abs_level > 0) {

	cmp	DWORD PTR _max_abs_level$45[ebp], 0
	jbe	SHORT $LN39@kvz_rdoq

; 757  :         last_scanpos    = scanpos;

	mov	eax, DWORD PTR _scanpos$49[ebp]
	mov	DWORD PTR _last_scanpos$[ebp], eax

; 758  :         ctx_set         = (scanpos > 0 && type == 0) ? 2 : 0;

	cmp	DWORD PTR _scanpos$49[ebp], 0
	jle	SHORT $LN88@kvz_rdoq
	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN88@kvz_rdoq
	mov	DWORD PTR tv276[ebp], 2
	jmp	SHORT $LN89@kvz_rdoq
$LN88@kvz_rdoq:
	mov	DWORD PTR tv276[ebp], 0
$LN89@kvz_rdoq:
	mov	cx, WORD PTR tv276[ebp]
	mov	WORD PTR _ctx_set$[ebp], cx

; 759  :         cg_last_scanpos = cg_scanpos;

	mov	eax, DWORD PTR _cg_scanpos$[ebp]
	mov	DWORD PTR _cg_last_scanpos$[ebp], eax

; 760  :         sh_rates.sig_coeff_inc[blkpos] = 0;

	mov	eax, DWORD PTR _blkpos$48[ebp]
	mov	DWORD PTR _sh_rates$[ebp+eax*4+8192], 0

; 761  :         break;

	jmp	SHORT $LN8@kvz_rdoq
$LN39@kvz_rdoq:

; 762  :       }
; 763  :       dest_coeff[blkpos] = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _blkpos$48[ebp]
	mov	edx, DWORD PTR _dest_coeff$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 764  :     }

	jmp	$LN7@kvz_rdoq
$LN8@kvz_rdoq:

; 765  :     if (last_scanpos != -1) break;

	cmp	DWORD PTR _last_scanpos$[ebp], -1
	je	SHORT $LN40@kvz_rdoq
	jmp	SHORT $LN5@kvz_rdoq
$LN40@kvz_rdoq:

; 766  :   }

	jmp	$LN4@kvz_rdoq
$LN5@kvz_rdoq:

; 767  : 
; 768  :   if (last_scanpos == -1) {

	cmp	DWORD PTR _last_scanpos$[ebp], -1
	jne	SHORT $LN41@kvz_rdoq

; 769  :     return;

	jmp	$LN77@kvz_rdoq
$LN41@kvz_rdoq:

; 770  :   }

	jmp	SHORT $LN12@kvz_rdoq
$LN10@kvz_rdoq:

; 771  : 
; 772  :   for (; cg_scanpos >= 0; cg_scanpos--) cost_coeffgroup_sig[cg_scanpos] = 0;

	mov	eax, DWORD PTR _cg_scanpos$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cg_scanpos$[ebp], eax
$LN12@kvz_rdoq:
	cmp	DWORD PTR _cg_scanpos$[ebp], 0
	jl	SHORT $LN11@kvz_rdoq
	mov	eax, DWORD PTR _cg_scanpos$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR _cost_coeffgroup_sig$[ebp+eax*8], xmm0
	jmp	SHORT $LN10@kvz_rdoq
$LN11@kvz_rdoq:

; 773  : 
; 774  :   int32_t last_x_bits[32], last_y_bits[32];
; 775  :   calc_last_bits(state, width, height, type, last_x_bits, last_y_bits);

	lea	eax, DWORD PTR _last_y_bits$[ebp]
	push	eax
	lea	ecx, DWORD PTR _last_x_bits$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _type$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_calc_last_bits
	add	esp, 24					; 00000018H

; 776  : 
; 777  :   for (int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	mov	eax, DWORD PTR _cg_last_scanpos$[ebp]
	mov	DWORD PTR _cg_scanpos$44[ebp], eax
	jmp	SHORT $LN15@kvz_rdoq
$LN13@kvz_rdoq:
	mov	eax, DWORD PTR _cg_scanpos$44[ebp]
	sub	eax, 1
	mov	DWORD PTR _cg_scanpos$44[ebp], eax
$LN15@kvz_rdoq:
	cmp	DWORD PTR _cg_scanpos$44[ebp], 0
	jl	$LN14@kvz_rdoq

; 778  :     uint32_t cg_blkpos  = scan_cg[cg_scanpos];

	mov	eax, DWORD PTR _cg_scanpos$44[ebp]
	mov	ecx, DWORD PTR _scan_cg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _cg_blkpos$43[ebp], edx

; 779  :     uint32_t cg_pos_y   = cg_blkpos / num_blk_side;

	mov	eax, DWORD PTR _cg_blkpos$43[ebp]
	xor	edx, edx
	div	DWORD PTR _num_blk_side$[ebp]
	mov	DWORD PTR _cg_pos_y$42[ebp], eax

; 780  :     uint32_t cg_pos_x   = cg_blkpos - (cg_pos_y * num_blk_side);

	mov	eax, DWORD PTR _cg_pos_y$42[ebp]
	imul	eax, DWORD PTR _num_blk_side$[ebp]
	mov	ecx, DWORD PTR _cg_blkpos$43[ebp]
	sub	ecx, eax
	mov	DWORD PTR _cg_pos_x$41[ebp], ecx

; 781  : 
; 782  :     int32_t pattern_sig_ctx = kvz_context_calc_pattern_sig_ctx(sig_coeffgroup_flag,

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cg_pos_y$42[ebp]
	push	ecx
	mov	edx, DWORD PTR _cg_pos_x$41[ebp]
	push	edx
	lea	eax, DWORD PTR _sig_coeffgroup_flag$[ebp]
	push	eax
	call	_kvz_context_calc_pattern_sig_ctx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pattern_sig_ctx$40[ebp], eax

; 783  :                                                            cg_pos_x, cg_pos_y, width);
; 784  : 
; 785  :     FILL(rd_stats, 0);

	push	40					; 00000028H
	push	0
	lea	eax, DWORD PTR _rd_stats$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 786  :     for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--)  {

	mov	eax, DWORD PTR _cg_size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _scanpos_in_cg$39[ebp], eax
	jmp	SHORT $LN18@kvz_rdoq
$LN16@kvz_rdoq:
	mov	eax, DWORD PTR _scanpos_in_cg$39[ebp]
	sub	eax, 1
	mov	DWORD PTR _scanpos_in_cg$39[ebp], eax
$LN18@kvz_rdoq:
	cmp	DWORD PTR _scanpos_in_cg$39[ebp], 0
	jl	$LN17@kvz_rdoq

; 787  :       int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;

	mov	eax, DWORD PTR _cg_scanpos$44[ebp]
	imul	eax, DWORD PTR _cg_size$[ebp]
	add	eax, DWORD PTR _scanpos_in_cg$39[ebp]
	mov	DWORD PTR _scanpos$38[ebp], eax

; 788  :       if (scanpos > last_scanpos) continue;

	mov	eax, DWORD PTR _scanpos$38[ebp]
	cmp	eax, DWORD PTR _last_scanpos$[ebp]
	jle	SHORT $LN42@kvz_rdoq
	jmp	SHORT $LN16@kvz_rdoq
$LN42@kvz_rdoq:

; 789  :       uint32_t blkpos         = scan[scanpos];

	mov	eax, DWORD PTR _scanpos$38[ebp]
	mov	ecx, DWORD PTR _scan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _blkpos$37[ebp], edx

; 790  :       int32_t q               = quant_coeff[blkpos];

	mov	eax, DWORD PTR _blkpos$37[ebp]
	mov	ecx, DWORD PTR _quant_coeff$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _q$36[ebp], edx

; 791  :       double temp             = err_scale[blkpos];

	mov	eax, DWORD PTR _blkpos$37[ebp]
	mov	ecx, DWORD PTR _err_scale$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax*8]
	movsd	QWORD PTR _temp$35[ebp], xmm0

; 792  :       int32_t level_double    = coef[blkpos];

	mov	eax, DWORD PTR _blkpos$37[ebp]
	mov	ecx, DWORD PTR _coef$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _level_double$34[ebp], edx

; 793  :       level_double            = MIN(abs(level_double) * q , MAX_INT - (1 << (q_bits - 1)));

	mov	eax, DWORD PTR _level_double$34[ebp]
	push	eax
	call	_abs
	add	esp, 4
	imul	eax, DWORD PTR _q$36[ebp]
	mov	ecx, DWORD PTR _q_bits$[ebp]
	sub	ecx, 1
	mov	edx, 1
	shl	edx, cl
	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, edx
	cmp	eax, ecx
	jge	SHORT $LN90@kvz_rdoq
	mov	edx, DWORD PTR _level_double$34[ebp]
	push	edx
	call	_abs
	add	esp, 4
	imul	eax, DWORD PTR _q$36[ebp]
	mov	DWORD PTR tv369[ebp], eax
	jmp	SHORT $LN91@kvz_rdoq
$LN90@kvz_rdoq:
	mov	ecx, DWORD PTR _q_bits$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	ecx, 2147483647				; 7fffffffH
	sub	ecx, eax
	mov	DWORD PTR tv369[ebp], ecx
$LN91@kvz_rdoq:
	mov	edx, DWORD PTR tv369[ebp]
	mov	DWORD PTR _level_double$34[ebp], edx

; 794  :       uint32_t max_abs_level  = (level_double + (1 << (q_bits - 1))) >> q_bits;

	mov	ecx, DWORD PTR _q_bits$[ebp]
	sub	ecx, 1
	mov	eax, 1
	shl	eax, cl
	add	eax, DWORD PTR _level_double$34[ebp]
	mov	ecx, DWORD PTR _q_bits$[ebp]
	sar	eax, cl
	mov	DWORD PTR _max_abs_level$33[ebp], eax

; 795  : 
; 796  :       double err              = (double)level_double;

	cvtsi2sd xmm0, DWORD PTR _level_double$34[ebp]
	movsd	QWORD PTR _err$32[ebp], xmm0

; 797  :       cost_coeff0[scanpos]    = err * err * temp; 

	movsd	xmm0, QWORD PTR _err$32[ebp]
	mulsd	xmm0, QWORD PTR _err$32[ebp]
	mulsd	xmm0, QWORD PTR _temp$35[ebp]
	mov	eax, DWORD PTR _scanpos$38[ebp]
	movsd	QWORD PTR _cost_coeff0$[ebp+eax*8], xmm0

; 798  :       block_uncoded_cost      += cost_coeff0[ scanpos ];

	mov	eax, DWORD PTR _scanpos$38[ebp]
	movsd	xmm0, QWORD PTR _block_uncoded_cost$[ebp]
	addsd	xmm0, QWORD PTR _cost_coeff0$[ebp+eax*8]
	movsd	QWORD PTR _block_uncoded_cost$[ebp], xmm0

; 799  :       //===== coefficient level estimation =====
; 800  :       int32_t  level;
; 801  :       uint16_t  one_ctx = 4 * ctx_set + c1;

	movzx	eax, WORD PTR _ctx_set$[ebp]
	movsx	ecx, WORD PTR _c1$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	WORD PTR _one_ctx$30[ebp], dx

; 802  :       uint16_t  abs_ctx = ctx_set + c2;

	movzx	eax, WORD PTR _ctx_set$[ebp]
	movsx	ecx, WORD PTR _c2$[ebp]
	add	eax, ecx
	mov	WORD PTR _abs_ctx$29[ebp], ax

; 803  : 
; 804  :       if( scanpos == last_scanpos ) {

	mov	eax, DWORD PTR _scanpos$38[ebp]
	cmp	eax, DWORD PTR _last_scanpos$[ebp]
	jne	$LN43@kvz_rdoq

; 805  :         level            = kvz_get_coded_level(state, &cost_coeff[ scanpos ], &cost_coeff0[ scanpos ], &cost_sig[ scanpos ],

	movzx	eax, BYTE PTR _type$[ebp]
	push	eax
	push	1
	sub	esp, 8
	movsd	xmm0, QWORD PTR _temp$35[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _q_bits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c2_idx$[ebp]
	push	edx
	mov	eax, DWORD PTR _c1_idx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _go_rice_param$[ebp]
	push	ecx
	movzx	edx, WORD PTR _abs_ctx$29[ebp]
	push	edx
	movzx	eax, WORD PTR _one_ctx$30[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _max_abs_level$33[ebp]
	push	ecx
	mov	edx, DWORD PTR _level_double$34[ebp]
	push	edx
	mov	eax, DWORD PTR _scanpos$38[ebp]
	lea	ecx, DWORD PTR _cost_sig$[ebp+eax*8]
	push	ecx
	mov	edx, DWORD PTR _scanpos$38[ebp]
	lea	eax, DWORD PTR _cost_coeff0$[ebp+edx*8]
	push	eax
	mov	ecx, DWORD PTR _scanpos$38[ebp]
	lea	edx, DWORD PTR _cost_coeff$[ebp+ecx*8]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_get_coded_level
	add	esp, 68					; 00000044H
	mov	DWORD PTR _level$31[ebp], eax

; 806  :                                              level_double, max_abs_level, 0, one_ctx, abs_ctx, go_rice_param,
; 807  :                                              c1_idx, c2_idx, q_bits, temp, 1, type );
; 808  :       } else {

	jmp	$LN45@kvz_rdoq
$LN43@kvz_rdoq:

; 809  :         uint32_t  pos_y    = blkpos >> log2_block_size;

	mov	eax, DWORD PTR _blkpos$37[ebp]
	mov	ecx, DWORD PTR _log2_block_size$[ebp]
	shr	eax, cl
	mov	DWORD PTR _pos_y$28[ebp], eax

; 810  :         uint32_t  pos_x    = blkpos - ( pos_y << log2_block_size );

	mov	eax, DWORD PTR _pos_y$28[ebp]
	mov	ecx, DWORD PTR _log2_block_size$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _blkpos$37[ebp]
	sub	ecx, eax
	mov	DWORD PTR _pos_x$27[ebp], ecx

; 811  :         uint16_t  ctx_sig  = (uint16_t)kvz_context_get_sig_ctx_inc(pattern_sig_ctx, scan_mode, pos_x, pos_y,

	movzx	eax, BYTE PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _log2_block_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos_y$28[ebp]
	push	edx
	mov	eax, DWORD PTR _pos_x$27[ebp]
	push	eax
	movsx	ecx, BYTE PTR _scan_mode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pattern_sig_ctx$40[ebp]
	push	edx
	call	_kvz_context_get_sig_ctx_inc
	add	esp, 24					; 00000018H
	mov	WORD PTR _ctx_sig$26[ebp], ax

; 812  :                                                      log2_block_size, type);
; 813  :         level              = kvz_get_coded_level(state, &cost_coeff[ scanpos ], &cost_coeff0[ scanpos ], &cost_sig[ scanpos ],

	movzx	eax, BYTE PTR _type$[ebp]
	push	eax
	push	0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _temp$35[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _q_bits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c2_idx$[ebp]
	push	edx
	mov	eax, DWORD PTR _c1_idx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _go_rice_param$[ebp]
	push	ecx
	movzx	edx, WORD PTR _abs_ctx$29[ebp]
	push	edx
	movzx	eax, WORD PTR _one_ctx$30[ebp]
	push	eax
	movzx	ecx, WORD PTR _ctx_sig$26[ebp]
	push	ecx
	mov	edx, DWORD PTR _max_abs_level$33[ebp]
	push	edx
	mov	eax, DWORD PTR _level_double$34[ebp]
	push	eax
	mov	ecx, DWORD PTR _scanpos$38[ebp]
	lea	edx, DWORD PTR _cost_sig$[ebp+ecx*8]
	push	edx
	mov	eax, DWORD PTR _scanpos$38[ebp]
	lea	ecx, DWORD PTR _cost_coeff0$[ebp+eax*8]
	push	ecx
	mov	edx, DWORD PTR _scanpos$38[ebp]
	lea	eax, DWORD PTR _cost_coeff$[ebp+edx*8]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_kvz_get_coded_level
	add	esp, 68					; 00000044H
	mov	DWORD PTR _level$31[ebp], eax

; 814  :                                              level_double, max_abs_level, ctx_sig, one_ctx, abs_ctx, go_rice_param,
; 815  :                                              c1_idx, c2_idx, q_bits, temp, 0, type );
; 816  :         if (encoder->cfg.signhide_enable) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN45@kvz_rdoq

; 817  :           int greater_than_zero = CTX_ENTROPY_BITS(&baseCtx[ctx_sig], 1);

	movzx	eax, WORD PTR _ctx_sig$26[ebp]
	mov	ecx, DWORD PTR _baseCtx$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 1
	mov	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR _greater_than_zero$25[ebp], eax

; 818  :           int zero = CTX_ENTROPY_BITS(&baseCtx[ctx_sig], 0);

	movzx	eax, WORD PTR _ctx_sig$26[ebp]
	mov	ecx, DWORD PTR _baseCtx$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 0
	mov	eax, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR _zero$24[ebp], eax

; 819  :           sh_rates.sig_coeff_inc[blkpos] = greater_than_zero - zero;

	mov	eax, DWORD PTR _greater_than_zero$25[ebp]
	sub	eax, DWORD PTR _zero$24[ebp]
	mov	ecx, DWORD PTR _blkpos$37[ebp]
	mov	DWORD PTR _sh_rates$[ebp+ecx*4+8192], eax
$LN45@kvz_rdoq:

; 820  :         }
; 821  :       }
; 822  : 
; 823  :       if (encoder->cfg.signhide_enable) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	$LN48@kvz_rdoq

; 824  :         sh_rates.quant_delta[blkpos] = (level_double - level * (1 << q_bits)) >> (q_bits - 8);

	mov	eax, 1
	mov	ecx, DWORD PTR _q_bits$[ebp]
	shl	eax, cl
	imul	eax, DWORD PTR _level$31[ebp]
	mov	edx, DWORD PTR _level_double$34[ebp]
	sub	edx, eax
	mov	ecx, DWORD PTR _q_bits$[ebp]
	sub	ecx, 8
	sar	edx, cl
	mov	eax, DWORD PTR _blkpos$37[ebp]
	mov	DWORD PTR _sh_rates$[ebp+eax*4+12288], edx

; 825  :         if (level > 0) {

	cmp	DWORD PTR _level$31[ebp], 0
	jle	$LN47@kvz_rdoq

; 826  :           int32_t rate_now  = kvz_get_ic_rate(state, level, one_ctx, abs_ctx, go_rice_param, c1_idx, c2_idx, type);

	movzx	eax, BYTE PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c2_idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c1_idx$[ebp]
	push	edx
	movzx	eax, WORD PTR _go_rice_param$[ebp]
	push	eax
	movzx	ecx, WORD PTR _abs_ctx$29[ebp]
	push	ecx
	movzx	edx, WORD PTR _one_ctx$30[ebp]
	push	edx
	mov	eax, DWORD PTR _level$31[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_kvz_get_ic_rate
	add	esp, 32					; 00000020H
	mov	DWORD PTR _rate_now$23[ebp], eax

; 827  :           int32_t rate_up   = kvz_get_ic_rate(state, level + 1, one_ctx, abs_ctx, go_rice_param, c1_idx, c2_idx, type);

	movzx	eax, BYTE PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c2_idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c1_idx$[ebp]
	push	edx
	movzx	eax, WORD PTR _go_rice_param$[ebp]
	push	eax
	movzx	ecx, WORD PTR _abs_ctx$29[ebp]
	push	ecx
	movzx	edx, WORD PTR _one_ctx$30[ebp]
	push	edx
	mov	eax, DWORD PTR _level$31[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_kvz_get_ic_rate
	add	esp, 32					; 00000020H
	mov	DWORD PTR _rate_up$22[ebp], eax

; 828  :           int32_t rate_down = kvz_get_ic_rate(state, level - 1, one_ctx, abs_ctx, go_rice_param, c1_idx, c2_idx, type);

	movzx	eax, BYTE PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c2_idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c1_idx$[ebp]
	push	edx
	movzx	eax, WORD PTR _go_rice_param$[ebp]
	push	eax
	movzx	ecx, WORD PTR _abs_ctx$29[ebp]
	push	ecx
	movzx	edx, WORD PTR _one_ctx$30[ebp]
	push	edx
	mov	eax, DWORD PTR _level$31[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_kvz_get_ic_rate
	add	esp, 32					; 00000020H
	mov	DWORD PTR _rate_down$21[ebp], eax

; 829  :           sh_rates.inc[blkpos] = rate_up - rate_now;

	mov	eax, DWORD PTR _rate_up$22[ebp]
	sub	eax, DWORD PTR _rate_now$23[ebp]
	mov	ecx, DWORD PTR _blkpos$37[ebp]
	mov	DWORD PTR _sh_rates$[ebp+ecx*4], eax

; 830  :           sh_rates.dec[blkpos] = rate_down - rate_now;

	mov	eax, DWORD PTR _rate_down$21[ebp]
	sub	eax, DWORD PTR _rate_now$23[ebp]
	mov	ecx, DWORD PTR _blkpos$37[ebp]
	mov	DWORD PTR _sh_rates$[ebp+ecx*4+4096], eax

; 831  :         } else { // level == 0

	jmp	SHORT $LN48@kvz_rdoq
$LN47@kvz_rdoq:

; 832  :           sh_rates.inc[blkpos]   = CTX_ENTROPY_BITS(&base_one_ctx[one_ctx], 0);

	movzx	eax, WORD PTR _one_ctx$30[ebp]
	mov	ecx, DWORD PTR _base_one_ctx$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	xor	edx, 0
	mov	eax, DWORD PTR _blkpos$37[ebp]
	mov	ecx, DWORD PTR _kvz_entropy_bits[edx*4]
	mov	DWORD PTR _sh_rates$[ebp+eax*4], ecx
$LN48@kvz_rdoq:

; 833  :         }
; 834  :       }
; 835  :       dest_coeff[blkpos] = (coeff_t)level;

	mov	eax, DWORD PTR _blkpos$37[ebp]
	mov	ecx, DWORD PTR _dest_coeff$[ebp]
	mov	dx, WORD PTR _level$31[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 836  :       base_cost         += cost_coeff[scanpos];

	mov	eax, DWORD PTR _scanpos$38[ebp]
	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	addsd	xmm0, QWORD PTR _cost_coeff$[ebp+eax*8]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 837  : 
; 838  :       base_level = (c1_idx < C1FLAG_NUMBER) ? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	cmp	DWORD PTR _c1_idx$[ebp], 8
	jae	SHORT $LN94@kvz_rdoq
	cmp	DWORD PTR _c2_idx$[ebp], 1
	jae	SHORT $LN92@kvz_rdoq
	mov	DWORD PTR tv533[ebp], 1
	jmp	SHORT $LN93@kvz_rdoq
$LN92@kvz_rdoq:
	mov	DWORD PTR tv533[ebp], 0
$LN93@kvz_rdoq:
	mov	eax, DWORD PTR tv533[ebp]
	add	eax, 2
	mov	DWORD PTR tv535[ebp], eax
	jmp	SHORT $LN95@kvz_rdoq
$LN94@kvz_rdoq:
	mov	DWORD PTR tv535[ebp], 1
$LN95@kvz_rdoq:
	mov	ecx, DWORD PTR tv535[ebp]
	mov	DWORD PTR _base_level$[ebp], ecx

; 839  :       if (level >= base_level) {

	mov	eax, DWORD PTR _level$31[ebp]
	cmp	eax, DWORD PTR _base_level$[ebp]
	jl	SHORT $LN50@kvz_rdoq

; 840  :         if(level  > 3*(1<<go_rice_param)) {

	movzx	ecx, WORD PTR _go_rice_param$[ebp]
	mov	eax, 1
	shl	eax, cl
	imul	ecx, eax, 3
	cmp	DWORD PTR _level$31[ebp], ecx
	jle	SHORT $LN50@kvz_rdoq

; 841  :           go_rice_param = MIN(go_rice_param + 1, 4);

	movzx	eax, WORD PTR _go_rice_param$[ebp]
	add	eax, 1
	cmp	eax, 4
	jge	SHORT $LN96@kvz_rdoq
	movzx	ecx, WORD PTR _go_rice_param$[ebp]
	add	ecx, 1
	mov	DWORD PTR tv546[ebp], ecx
	jmp	SHORT $LN97@kvz_rdoq
$LN96@kvz_rdoq:
	mov	DWORD PTR tv546[ebp], 4
$LN97@kvz_rdoq:
	mov	dx, WORD PTR tv546[ebp]
	mov	WORD PTR _go_rice_param$[ebp], dx
$LN50@kvz_rdoq:

; 842  :         }
; 843  :       }
; 844  :       if (level >= 1) c1_idx ++;

	cmp	DWORD PTR _level$31[ebp], 1
	jl	SHORT $LN51@kvz_rdoq
	mov	eax, DWORD PTR _c1_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _c1_idx$[ebp], eax
$LN51@kvz_rdoq:

; 845  : 
; 846  :       //===== update bin model =====
; 847  :       if (level > 1) {

	cmp	DWORD PTR _level$31[ebp], 1
	jle	SHORT $LN52@kvz_rdoq

; 848  :         c1 = 0;

	xor	eax, eax
	mov	WORD PTR _c1$[ebp], ax

; 849  :         c2 += (c2 < 2);

	movsx	eax, WORD PTR _c2$[ebp]
	cmp	eax, 2
	jge	SHORT $LN98@kvz_rdoq
	mov	DWORD PTR tv553[ebp], 1
	jmp	SHORT $LN99@kvz_rdoq
$LN98@kvz_rdoq:
	mov	DWORD PTR tv553[ebp], 0
$LN99@kvz_rdoq:
	movsx	ecx, WORD PTR _c2$[ebp]
	add	ecx, DWORD PTR tv553[ebp]
	mov	WORD PTR _c2$[ebp], cx

; 850  :         c2_idx ++;

	mov	eax, DWORD PTR _c2_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _c2_idx$[ebp], eax
	jmp	SHORT $LN54@kvz_rdoq
$LN52@kvz_rdoq:

; 851  :       } else if( (c1 < 3) && (c1 > 0) && level) {

	movsx	eax, WORD PTR _c1$[ebp]
	cmp	eax, 3
	jge	SHORT $LN54@kvz_rdoq
	movsx	eax, WORD PTR _c1$[ebp]
	test	eax, eax
	jle	SHORT $LN54@kvz_rdoq
	cmp	DWORD PTR _level$31[ebp], 0
	je	SHORT $LN54@kvz_rdoq

; 852  :         c1++;

	mov	ax, WORD PTR _c1$[ebp]
	add	ax, 1
	mov	WORD PTR _c1$[ebp], ax
$LN54@kvz_rdoq:

; 853  :       }
; 854  : 
; 855  :       //===== context set update =====
; 856  :       if ((scanpos % SCAN_SET_SIZE == 0) && scanpos > 0) {

	mov	eax, DWORD PTR _scanpos$38[ebp]
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN125@kvz_rdoq
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN125@kvz_rdoq:
	test	eax, eax
	jne	$LN55@kvz_rdoq
	cmp	DWORD PTR _scanpos$38[ebp], 0
	jle	$LN55@kvz_rdoq

; 857  :         c2                = 0;

	xor	eax, eax
	mov	WORD PTR _c2$[ebp], ax

; 858  :         go_rice_param     = 0;

	xor	eax, eax
	mov	WORD PTR _go_rice_param$[ebp], ax

; 859  : 
; 860  :         c1_idx   = 0;

	mov	DWORD PTR _c1_idx$[ebp], 0

; 861  :         c2_idx   = 0;

	mov	DWORD PTR _c2_idx$[ebp], 0

; 862  :         ctx_set = (scanpos == SCAN_SET_SIZE || type != 0) ? 0 : 2;

	cmp	DWORD PTR _scanpos$38[ebp], 16		; 00000010H
	je	SHORT $LN100@kvz_rdoq
	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	SHORT $LN100@kvz_rdoq
	mov	DWORD PTR tv570[ebp], 2
	jmp	SHORT $LN101@kvz_rdoq
$LN100@kvz_rdoq:
	mov	DWORD PTR tv570[ebp], 0
$LN101@kvz_rdoq:
	mov	cx, WORD PTR tv570[ebp]
	mov	WORD PTR _ctx_set$[ebp], cx

; 863  :         if( c1 == 0 ) {

	movsx	eax, WORD PTR _c1$[ebp]
	test	eax, eax
	jne	SHORT $LN56@kvz_rdoq

; 864  :           ctx_set++;

	mov	ax, WORD PTR _ctx_set$[ebp]
	add	ax, 1
	mov	WORD PTR _ctx_set$[ebp], ax
$LN56@kvz_rdoq:

; 865  :         }
; 866  :         c1 = 1;

	mov	eax, 1
	mov	WORD PTR _c1$[ebp], ax
$LN55@kvz_rdoq:

; 867  :       }
; 868  : 
; 869  :       rd_stats.sig_cost += cost_sig[scanpos];

	mov	eax, DWORD PTR _scanpos$38[ebp]
	movsd	xmm0, QWORD PTR _rd_stats$[ebp+16]
	addsd	xmm0, QWORD PTR _cost_sig$[ebp+eax*8]
	movsd	QWORD PTR _rd_stats$[ebp+16], xmm0

; 870  :       if ( scanpos_in_cg == 0 ) {

	cmp	DWORD PTR _scanpos_in_cg$39[ebp], 0
	jne	SHORT $LN57@kvz_rdoq

; 871  :         rd_stats.sig_cost_0 = cost_sig[scanpos];

	mov	eax, DWORD PTR _scanpos$38[ebp]
	movsd	xmm0, QWORD PTR _cost_sig$[ebp+eax*8]
	movsd	QWORD PTR _rd_stats$[ebp+24], xmm0
$LN57@kvz_rdoq:

; 872  :       }
; 873  :       if ( dest_coeff[blkpos] )  {

	mov	eax, DWORD PTR _blkpos$37[ebp]
	mov	ecx, DWORD PTR _dest_coeff$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $LN59@kvz_rdoq

; 874  :         sig_coeffgroup_flag[cg_blkpos] = 1;

	mov	eax, DWORD PTR _cg_blkpos$43[ebp]
	mov	DWORD PTR _sig_coeffgroup_flag$[ebp+eax*4], 1

; 875  :         rd_stats.coded_level_and_dist   += cost_coeff[scanpos] - cost_sig[scanpos];

	mov	eax, DWORD PTR _scanpos$38[ebp]
	mov	ecx, DWORD PTR _scanpos$38[ebp]
	movsd	xmm0, QWORD PTR _cost_coeff$[ebp+eax*8]
	subsd	xmm0, QWORD PTR _cost_sig$[ebp+ecx*8]
	addsd	xmm0, QWORD PTR _rd_stats$[ebp]
	movsd	QWORD PTR _rd_stats$[ebp], xmm0

; 876  :         rd_stats.uncoded_dist           += cost_coeff0[scanpos];

	mov	eax, DWORD PTR _scanpos$38[ebp]
	movsd	xmm0, QWORD PTR _rd_stats$[ebp+8]
	addsd	xmm0, QWORD PTR _cost_coeff0$[ebp+eax*8]
	movsd	QWORD PTR _rd_stats$[ebp+8], xmm0

; 877  :         if ( scanpos_in_cg != 0 ) {

	cmp	DWORD PTR _scanpos_in_cg$39[ebp], 0
	je	SHORT $LN59@kvz_rdoq

; 878  :           rd_stats.nnz_before_pos0++;

	mov	eax, DWORD PTR _rd_stats$[ebp+32]
	add	eax, 1
	mov	DWORD PTR _rd_stats$[ebp+32], eax
$LN59@kvz_rdoq:

; 879  :         }
; 880  :       }
; 881  :     } //end for (scanpos_in_cg)

	jmp	$LN16@kvz_rdoq
$LN17@kvz_rdoq:

; 882  : 
; 883  :     if( cg_scanpos ) {

	cmp	DWORD PTR _cg_scanpos$44[ebp], 0
	je	$LN60@kvz_rdoq

; 884  :       if (sig_coeffgroup_flag[cg_blkpos] == 0) {

	mov	eax, DWORD PTR _cg_blkpos$43[ebp]
	cmp	DWORD PTR _sig_coeffgroup_flag$[ebp+eax*4], 0
	jne	$LN62@kvz_rdoq

; 885  :         uint32_t ctx_sig  = kvz_context_get_sig_coeff_group(sig_coeffgroup_flag, cg_pos_x,

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cg_pos_y$42[ebp]
	push	ecx
	mov	edx, DWORD PTR _cg_pos_x$41[ebp]
	push	edx
	lea	eax, DWORD PTR _sig_coeffgroup_flag$[ebp]
	push	eax
	call	_kvz_context_get_sig_coeff_group
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ctx_sig$20[ebp], eax

; 886  :                                                         cg_pos_y, width);
; 887  :         cost_coeffgroup_sig[cg_scanpos] = state->lambda *CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig],0);

	mov	eax, DWORD PTR _base_coeff_group_ctx$[ebp]
	add	eax, DWORD PTR _ctx_sig$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 0
	mov	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR tv1272[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1272[ebp]
	mov	eax, DWORD PTR tv1272[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+296]
	mov	edx, DWORD PTR _cg_scanpos$44[ebp]
	movsd	QWORD PTR _cost_coeffgroup_sig$[ebp+edx*8], xmm0

; 888  :         base_cost += cost_coeffgroup_sig[cg_scanpos]  - rd_stats.sig_cost;

	mov	eax, DWORD PTR _cg_scanpos$44[ebp]
	movsd	xmm0, QWORD PTR _cost_coeffgroup_sig$[ebp+eax*8]
	subsd	xmm0, QWORD PTR _rd_stats$[ebp+16]
	addsd	xmm0, QWORD PTR _base_cost$[ebp]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 889  :       } else {

	jmp	$LN20@kvz_rdoq
$LN62@kvz_rdoq:

; 890  :         if (cg_scanpos < cg_last_scanpos){

	mov	eax, DWORD PTR _cg_scanpos$44[ebp]
	cmp	eax, DWORD PTR _cg_last_scanpos$[ebp]
	jge	$LN20@kvz_rdoq

; 891  :           double cost_zero_cg;
; 892  :           uint32_t ctx_sig;
; 893  :           if (rd_stats.nnz_before_pos0 == 0) {

	cmp	DWORD PTR _rd_stats$[ebp+32], 0
	jne	SHORT $LN65@kvz_rdoq

; 894  :             base_cost -= rd_stats.sig_cost_0;

	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	subsd	xmm0, QWORD PTR _rd_stats$[ebp+24]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 895  :             rd_stats.sig_cost -= rd_stats.sig_cost_0;

	movsd	xmm0, QWORD PTR _rd_stats$[ebp+16]
	subsd	xmm0, QWORD PTR _rd_stats$[ebp+24]
	movsd	QWORD PTR _rd_stats$[ebp+16], xmm0
$LN65@kvz_rdoq:

; 896  :           }
; 897  :           // rd-cost if SigCoeffGroupFlag = 0, initialization
; 898  :           cost_zero_cg = base_cost;

	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	movsd	QWORD PTR _cost_zero_cg$19[ebp], xmm0

; 899  : 
; 900  :           // add SigCoeffGroupFlag cost to total cost
; 901  :           ctx_sig = kvz_context_get_sig_coeff_group(sig_coeffgroup_flag, cg_pos_x,

	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cg_pos_y$42[ebp]
	push	ecx
	mov	edx, DWORD PTR _cg_pos_x$41[ebp]
	push	edx
	lea	eax, DWORD PTR _sig_coeffgroup_flag$[ebp]
	push	eax
	call	_kvz_context_get_sig_coeff_group
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ctx_sig$18[ebp], eax

; 902  :             cg_pos_y, width);
; 903  : 
; 904  :           cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 1);

	mov	eax, DWORD PTR _base_coeff_group_ctx$[ebp]
	add	eax, DWORD PTR _ctx_sig$18[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 1
	mov	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR tv1293[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1293[ebp]
	mov	eax, DWORD PTR tv1293[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+296]
	mov	edx, DWORD PTR _cg_scanpos$44[ebp]
	movsd	QWORD PTR _cost_coeffgroup_sig$[ebp+edx*8], xmm0

; 905  :           base_cost += cost_coeffgroup_sig[cg_scanpos];

	mov	eax, DWORD PTR _cg_scanpos$44[ebp]
	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	addsd	xmm0, QWORD PTR _cost_coeffgroup_sig$[ebp+eax*8]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 906  :           cost_zero_cg += state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);

	mov	eax, DWORD PTR _base_coeff_group_ctx$[ebp]
	add	eax, DWORD PTR _ctx_sig$18[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 0
	mov	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR tv1304[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1304[ebp]
	mov	eax, DWORD PTR tv1304[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+296]
	addsd	xmm0, QWORD PTR _cost_zero_cg$19[ebp]
	movsd	QWORD PTR _cost_zero_cg$19[ebp], xmm0

; 907  : 
; 908  :           // try to convert the current coeff group from non-zero to all-zero
; 909  :           cost_zero_cg += rd_stats.uncoded_dist;          // distortion for resetting non-zero levels to zero levels

	movsd	xmm0, QWORD PTR _cost_zero_cg$19[ebp]
	addsd	xmm0, QWORD PTR _rd_stats$[ebp+8]
	movsd	QWORD PTR _cost_zero_cg$19[ebp], xmm0

; 910  :           cost_zero_cg -= rd_stats.coded_level_and_dist;  // distortion and level cost for keeping all non-zero levels

	movsd	xmm0, QWORD PTR _cost_zero_cg$19[ebp]
	subsd	xmm0, QWORD PTR _rd_stats$[ebp]
	movsd	QWORD PTR _cost_zero_cg$19[ebp], xmm0

; 911  :           cost_zero_cg -= rd_stats.sig_cost;              // sig cost for all coeffs, including zero levels and non-zerl levels

	movsd	xmm0, QWORD PTR _cost_zero_cg$19[ebp]
	subsd	xmm0, QWORD PTR _rd_stats$[ebp+16]
	movsd	QWORD PTR _cost_zero_cg$19[ebp], xmm0

; 912  : 
; 913  :           // if we can save cost, change this block to all-zero block
; 914  :           if (cost_zero_cg < base_cost) {

	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	comisd	xmm0, QWORD PTR _cost_zero_cg$19[ebp]
	jbe	$LN20@kvz_rdoq

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;

	mov	eax, DWORD PTR _cg_blkpos$43[ebp]
	mov	DWORD PTR _sig_coeffgroup_flag$[ebp+eax*4], 0

; 917  :             base_cost = cost_zero_cg;

	movsd	xmm0, QWORD PTR _cost_zero_cg$19[ebp]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);

	mov	eax, DWORD PTR _base_coeff_group_ctx$[ebp]
	add	eax, DWORD PTR _ctx_sig$18[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 0
	mov	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR tv1319[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1319[ebp]
	mov	eax, DWORD PTR tv1319[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+296]
	mov	edx, DWORD PTR _cg_scanpos$44[ebp]
	movsd	QWORD PTR _cost_coeffgroup_sig$[ebp+edx*8], xmm0

; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {

	mov	eax, DWORD PTR _cg_size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _scanpos_in_cg$17[ebp], eax
	jmp	SHORT $LN21@kvz_rdoq
$LN19@kvz_rdoq:
	mov	eax, DWORD PTR _scanpos_in_cg$17[ebp]
	sub	eax, 1
	mov	DWORD PTR _scanpos_in_cg$17[ebp], eax
$LN21@kvz_rdoq:
	cmp	DWORD PTR _scanpos_in_cg$17[ebp], 0
	jl	$LN20@kvz_rdoq

; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;

	mov	eax, DWORD PTR _cg_scanpos$44[ebp]
	imul	eax, DWORD PTR _cg_size$[ebp]
	add	eax, DWORD PTR _scanpos_in_cg$17[ebp]
	mov	DWORD PTR _scanpos$16[ebp], eax

; 924  :               uint32_t blkpos = scan[scanpos];

	mov	eax, DWORD PTR _scanpos$16[ebp]
	mov	ecx, DWORD PTR _scan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _blkpos$15[ebp], edx

; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR _blkpos$15[ebp]
	mov	ecx, DWORD PTR _dest_coeff$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $LN67@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _blkpos$15[ebp]
	mov	edx, DWORD PTR _dest_coeff$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	eax, DWORD PTR _scanpos$16[ebp]
	mov	ecx, DWORD PTR _scanpos$16[ebp]
	movsd	xmm0, QWORD PTR _cost_coeff0$[ebp+ecx*8]
	movsd	QWORD PTR _cost_coeff$[ebp+eax*8], xmm0

; 928  :                 cost_sig[scanpos] = 0;

	mov	eax, DWORD PTR _scanpos$16[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR _cost_sig$[ebp+eax*8], xmm0
$LN67@kvz_rdoq:

; 929  :               }
; 930  :             }

	jmp	$LN19@kvz_rdoq
$LN20@kvz_rdoq:

; 931  :           } // end if ( cost_all_zeros < base_cost )
; 932  :         }
; 933  :       } // end if if (sig_coeffgroup_flag[ cg_blkpos ] == 0)
; 934  :     } else {

	jmp	SHORT $LN61@kvz_rdoq
$LN60@kvz_rdoq:

; 935  :       sig_coeffgroup_flag[cg_blkpos] = 1;

	mov	eax, DWORD PTR _cg_blkpos$43[ebp]
	mov	DWORD PTR _sig_coeffgroup_flag$[ebp+eax*4], 1
$LN61@kvz_rdoq:

; 936  :     }
; 937  :   } //end for (cg_scanpos)

	jmp	$LN13@kvz_rdoq
$LN14@kvz_rdoq:

; 938  : 
; 939  :   //===== estimate last position =====
; 940  :   double  best_cost        = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _best_cost$[ebp], xmm0

; 941  :   int32_t ctx_cbf          = 0;

	mov	DWORD PTR _ctx_cbf$[ebp], 0

; 942  :   int8_t found_last        = 0;

	mov	BYTE PTR _found_last$[ebp], 0

; 943  :   int32_t best_last_idx_p1 = 0;

	mov	DWORD PTR _best_last_idx_p1$[ebp], 0

; 944  : 
; 945  :   if( block_type != CU_INTRA && !type/* && pcCU->getTransformIdx( uiAbsPartIdx ) == 0*/ ) {

	movsx	eax, BYTE PTR _block_type$[ebp]
	cmp	eax, 1
	je	$LN68@kvz_rdoq
	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	jne	$LN68@kvz_rdoq

; 946  :     best_cost  = block_uncoded_cost +   state->lambda * CTX_ENTROPY_BITS(&(cabac->ctx.cu_qt_root_cbf_model),0);

	mov	eax, DWORD PTR _cabac$[ebp]
	movzx	ecx, BYTE PTR [eax+213]
	xor	ecx, 0
	mov	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR tv1347[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1347[ebp]
	mov	eax, DWORD PTR tv1347[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+296]
	addsd	xmm0, QWORD PTR _block_uncoded_cost$[ebp]
	movsd	QWORD PTR _best_cost$[ebp], xmm0

; 947  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&(cabac->ctx.cu_qt_root_cbf_model),1);

	mov	eax, DWORD PTR _cabac$[ebp]
	movzx	ecx, BYTE PTR [eax+213]
	xor	ecx, 1
	mov	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR tv1356[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1356[ebp]
	mov	eax, DWORD PTR tv1356[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+296]
	addsd	xmm0, QWORD PTR _base_cost$[ebp]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 948  :   } else {

	jmp	$LN69@kvz_rdoq
$LN68@kvz_rdoq:

; 949  :     cabac_ctx_t* base_cbf_model = type?(cabac->ctx.qt_cbf_model_chroma):(cabac->ctx.qt_cbf_model_luma);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN102@kvz_rdoq
	mov	ecx, DWORD PTR _cabac$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR tv755[ebp], ecx
	jmp	SHORT $LN103@kvz_rdoq
$LN102@kvz_rdoq:
	mov	edx, DWORD PTR _cabac$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR tv755[ebp], edx
$LN103@kvz_rdoq:
	mov	eax, DWORD PTR tv755[ebp]
	mov	DWORD PTR _base_cbf_model$14[ebp], eax

; 950  :     ctx_cbf    = ( type ? tr_depth : !tr_depth);

	movsx	eax, BYTE PTR _type$[ebp]
	test	eax, eax
	je	SHORT $LN106@kvz_rdoq
	movsx	ecx, BYTE PTR _tr_depth$[ebp]
	mov	DWORD PTR tv762[ebp], ecx
	jmp	SHORT $LN107@kvz_rdoq
$LN106@kvz_rdoq:
	movsx	edx, BYTE PTR _tr_depth$[ebp]
	test	edx, edx
	jne	SHORT $LN104@kvz_rdoq
	mov	DWORD PTR tv760[ebp], 1
	jmp	SHORT $LN105@kvz_rdoq
$LN104@kvz_rdoq:
	mov	DWORD PTR tv760[ebp], 0
$LN105@kvz_rdoq:
	mov	eax, DWORD PTR tv760[ebp]
	mov	DWORD PTR tv762[ebp], eax
$LN107@kvz_rdoq:
	mov	ecx, DWORD PTR tv762[ebp]
	mov	DWORD PTR _ctx_cbf$[ebp], ecx

; 951  :     best_cost  = block_uncoded_cost +  state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],0);

	mov	eax, DWORD PTR _base_cbf_model$14[ebp]
	add	eax, DWORD PTR _ctx_cbf$[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 0
	mov	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR tv1370[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1370[ebp]
	mov	eax, DWORD PTR tv1370[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+296]
	addsd	xmm0, QWORD PTR _block_uncoded_cost$[ebp]
	movsd	QWORD PTR _best_cost$[ebp], xmm0

; 952  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],1);

	mov	eax, DWORD PTR _base_cbf_model$14[ebp]
	add	eax, DWORD PTR _ctx_cbf$[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, 1
	mov	edx, DWORD PTR _kvz_entropy_bits[ecx*4]
	mov	DWORD PTR tv1379[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1379[ebp]
	mov	eax, DWORD PTR tv1379[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+296]
	addsd	xmm0, QWORD PTR _base_cost$[ebp]
	movsd	QWORD PTR _base_cost$[ebp], xmm0
$LN69@kvz_rdoq:

; 953  :   }
; 954  : 
; 955  :   for ( int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	mov	eax, DWORD PTR _cg_last_scanpos$[ebp]
	mov	DWORD PTR _cg_scanpos$13[ebp], eax
	jmp	SHORT $LN24@kvz_rdoq
$LN22@kvz_rdoq:
	mov	eax, DWORD PTR _cg_scanpos$13[ebp]
	sub	eax, 1
	mov	DWORD PTR _cg_scanpos$13[ebp], eax
$LN24@kvz_rdoq:
	cmp	DWORD PTR _cg_scanpos$13[ebp], 0
	jl	$LN23@kvz_rdoq

; 956  :     uint32_t cg_blkpos = scan_cg[cg_scanpos];

	mov	eax, DWORD PTR _cg_scanpos$13[ebp]
	mov	ecx, DWORD PTR _scan_cg$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _cg_blkpos$12[ebp], edx

; 957  :     base_cost -= cost_coeffgroup_sig[cg_scanpos];

	mov	eax, DWORD PTR _cg_scanpos$13[ebp]
	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	subsd	xmm0, QWORD PTR _cost_coeffgroup_sig$[ebp+eax*8]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 958  : 
; 959  :     if (sig_coeffgroup_flag[ cg_blkpos ]) {

	mov	eax, DWORD PTR _cg_blkpos$12[ebp]
	cmp	DWORD PTR _sig_coeffgroup_flag$[ebp+eax*4], 0
	je	$LN76@kvz_rdoq

; 960  :       for ( int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {

	mov	eax, DWORD PTR _cg_size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _scanpos_in_cg$11[ebp], eax
	jmp	SHORT $LN27@kvz_rdoq
$LN25@kvz_rdoq:
	mov	eax, DWORD PTR _scanpos_in_cg$11[ebp]
	sub	eax, 1
	mov	DWORD PTR _scanpos_in_cg$11[ebp], eax
$LN27@kvz_rdoq:
	cmp	DWORD PTR _scanpos_in_cg$11[ebp], 0
	jl	$LN26@kvz_rdoq

; 961  :         int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;

	mov	eax, DWORD PTR _cg_scanpos$13[ebp]
	imul	eax, DWORD PTR _cg_size$[ebp]
	add	eax, DWORD PTR _scanpos_in_cg$11[ebp]
	mov	DWORD PTR _scanpos$10[ebp], eax

; 962  :         if (scanpos > last_scanpos) continue;

	mov	eax, DWORD PTR _scanpos$10[ebp]
	cmp	eax, DWORD PTR _last_scanpos$[ebp]
	jle	SHORT $LN71@kvz_rdoq
	jmp	SHORT $LN25@kvz_rdoq
$LN71@kvz_rdoq:

; 963  :         uint32_t blkpos  = scan[scanpos];

	mov	eax, DWORD PTR _scanpos$10[ebp]
	mov	ecx, DWORD PTR _scan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _blkpos$9[ebp], edx

; 964  : 
; 965  :         if( dest_coeff[ blkpos ] ) {

	mov	eax, DWORD PTR _blkpos$9[ebp]
	mov	ecx, DWORD PTR _dest_coeff$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	$LN72@kvz_rdoq

; 966  :           uint32_t   pos_y = blkpos >> log2_block_size;

	mov	eax, DWORD PTR _blkpos$9[ebp]
	mov	ecx, DWORD PTR _log2_block_size$[ebp]
	shr	eax, cl
	mov	DWORD PTR _pos_y$8[ebp], eax

; 967  :           uint32_t   pos_x = blkpos - ( pos_y << log2_block_size );

	mov	eax, DWORD PTR _pos_y$8[ebp]
	mov	ecx, DWORD PTR _log2_block_size$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _blkpos$9[ebp]
	sub	ecx, eax
	mov	DWORD PTR _pos_x$7[ebp], ecx

; 968  : 
; 969  :           double cost_last = (scan_mode == SCAN_VER) ? get_rate_last(state, pos_y, pos_x,last_x_bits,last_y_bits) : get_rate_last(state, pos_x, pos_y, last_x_bits,last_y_bits );

	movsx	eax, BYTE PTR _scan_mode$[ebp]
	cmp	eax, 2
	jne	SHORT $LN108@kvz_rdoq
	lea	ecx, DWORD PTR _last_y_bits$[ebp]
	push	ecx
	lea	edx, DWORD PTR _last_x_bits$[ebp]
	push	edx
	mov	eax, DWORD PTR _pos_x$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _pos_y$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_get_rate_last
	add	esp, 20					; 00000014H
	fstp	QWORD PTR tv824[ebp]
	jmp	SHORT $LN109@kvz_rdoq
$LN108@kvz_rdoq:
	lea	eax, DWORD PTR _last_y_bits$[ebp]
	push	eax
	lea	ecx, DWORD PTR _last_x_bits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pos_y$8[ebp]
	push	edx
	mov	eax, DWORD PTR _pos_x$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_get_rate_last
	add	esp, 20					; 00000014H
	fstp	QWORD PTR tv824[ebp]
$LN109@kvz_rdoq:
	movsd	xmm0, QWORD PTR tv824[ebp]
	movsd	QWORD PTR _cost_last$6[ebp], xmm0

; 970  :           double totalCost = base_cost + cost_last - cost_sig[ scanpos ];

	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	addsd	xmm0, QWORD PTR _cost_last$6[ebp]
	mov	eax, DWORD PTR _scanpos$10[ebp]
	subsd	xmm0, QWORD PTR _cost_sig$[ebp+eax*8]
	movsd	QWORD PTR _totalCost$5[ebp], xmm0

; 971  : 
; 972  :           if( totalCost < best_cost ) {

	movsd	xmm0, QWORD PTR _best_cost$[ebp]
	comisd	xmm0, QWORD PTR _totalCost$5[ebp]
	jbe	SHORT $LN74@kvz_rdoq

; 973  :             best_last_idx_p1 = scanpos + 1;

	mov	eax, DWORD PTR _scanpos$10[ebp]
	add	eax, 1
	mov	DWORD PTR _best_last_idx_p1$[ebp], eax

; 974  :             best_cost        = totalCost;

	movsd	xmm0, QWORD PTR _totalCost$5[ebp]
	movsd	QWORD PTR _best_cost$[ebp], xmm0
$LN74@kvz_rdoq:

; 975  :           }
; 976  :           if( dest_coeff[ blkpos ] > 1 ) {

	mov	eax, DWORD PTR _blkpos$9[ebp]
	mov	ecx, DWORD PTR _dest_coeff$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	cmp	edx, 1
	jle	SHORT $LN75@kvz_rdoq

; 977  :             found_last = 1;

	mov	BYTE PTR _found_last$[ebp], 1

; 978  :             break;

	jmp	SHORT $LN26@kvz_rdoq
$LN75@kvz_rdoq:

; 979  :           }
; 980  :           base_cost -= cost_coeff[scanpos];

	mov	eax, DWORD PTR _scanpos$10[ebp]
	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	subsd	xmm0, QWORD PTR _cost_coeff$[ebp+eax*8]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 981  :           base_cost += cost_coeff0[scanpos];

	mov	eax, DWORD PTR _scanpos$10[ebp]
	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	addsd	xmm0, QWORD PTR _cost_coeff0$[ebp+eax*8]
	movsd	QWORD PTR _base_cost$[ebp], xmm0

; 982  :         } else {

	jmp	SHORT $LN73@kvz_rdoq
$LN72@kvz_rdoq:

; 983  :           base_cost -= cost_sig[scanpos];

	mov	eax, DWORD PTR _scanpos$10[ebp]
	movsd	xmm0, QWORD PTR _base_cost$[ebp]
	subsd	xmm0, QWORD PTR _cost_sig$[ebp+eax*8]
	movsd	QWORD PTR _base_cost$[ebp], xmm0
$LN73@kvz_rdoq:

; 984  :         }
; 985  :       } //end for

	jmp	$LN25@kvz_rdoq
$LN26@kvz_rdoq:

; 986  :       if (found_last) break;

	movsx	eax, BYTE PTR _found_last$[ebp]
	test	eax, eax
	je	SHORT $LN76@kvz_rdoq
	jmp	SHORT $LN23@kvz_rdoq
$LN76@kvz_rdoq:

; 987  :     } // end if (sig_coeffgroup_flag[ cg_blkpos ])
; 988  :   } // end for

	jmp	$LN22@kvz_rdoq
$LN23@kvz_rdoq:

; 989  : 
; 990  :   uint32_t abs_sum = 0;

	mov	DWORD PTR _abs_sum$[ebp], 0

; 991  :   for ( int32_t scanpos = 0; scanpos < best_last_idx_p1; scanpos++) {

	mov	DWORD PTR _scanpos$4[ebp], 0
	jmp	SHORT $LN30@kvz_rdoq
$LN28@kvz_rdoq:
	mov	eax, DWORD PTR _scanpos$4[ebp]
	add	eax, 1
	mov	DWORD PTR _scanpos$4[ebp], eax
$LN30@kvz_rdoq:
	mov	eax, DWORD PTR _scanpos$4[ebp]
	cmp	eax, DWORD PTR _best_last_idx_p1$[ebp]
	jge	$LN29@kvz_rdoq

; 992  :     int32_t blkPos     = scan[scanpos];

	mov	eax, DWORD PTR _scanpos$4[ebp]
	mov	ecx, DWORD PTR _scan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _blkPos$3[ebp], edx

; 993  :     int32_t level      = dest_coeff[blkPos];

	mov	eax, DWORD PTR _blkPos$3[ebp]
	mov	ecx, DWORD PTR _dest_coeff$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _level$2[ebp], edx

; 994  :     abs_sum            += level;

	mov	eax, DWORD PTR _abs_sum$[ebp]
	add	eax, DWORD PTR _level$2[ebp]
	mov	DWORD PTR _abs_sum$[ebp], eax

; 995  :     dest_coeff[blkPos] = (coeff_t)(( coef[blkPos] < 0 ) ? -level : level);

	mov	eax, DWORD PTR _blkPos$3[ebp]
	mov	ecx, DWORD PTR _coef$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	jge	SHORT $LN110@kvz_rdoq
	mov	eax, DWORD PTR _level$2[ebp]
	neg	eax
	mov	DWORD PTR tv861[ebp], eax
	jmp	SHORT $LN111@kvz_rdoq
$LN110@kvz_rdoq:
	mov	ecx, DWORD PTR _level$2[ebp]
	mov	DWORD PTR tv861[ebp], ecx
$LN111@kvz_rdoq:
	mov	edx, DWORD PTR _blkPos$3[ebp]
	mov	eax, DWORD PTR _dest_coeff$[ebp]
	mov	cx, WORD PTR tv861[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 996  :   }

	jmp	$LN28@kvz_rdoq
$LN29@kvz_rdoq:

; 997  :   //===== clean uncoded coefficients =====
; 998  :   for ( int32_t scanpos = best_last_idx_p1; scanpos <= last_scanpos; scanpos++) {

	mov	eax, DWORD PTR _best_last_idx_p1$[ebp]
	mov	DWORD PTR _scanpos$1[ebp], eax
	jmp	SHORT $LN33@kvz_rdoq
$LN31@kvz_rdoq:
	mov	eax, DWORD PTR _scanpos$1[ebp]
	add	eax, 1
	mov	DWORD PTR _scanpos$1[ebp], eax
$LN33@kvz_rdoq:
	mov	eax, DWORD PTR _scanpos$1[ebp]
	cmp	eax, DWORD PTR _last_scanpos$[ebp]
	jg	SHORT $LN32@kvz_rdoq

; 999  :     dest_coeff[scan[scanpos]] = 0;

	mov	eax, DWORD PTR _scanpos$1[ebp]
	mov	ecx, DWORD PTR _scan$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	xor	eax, eax
	mov	ecx, DWORD PTR _dest_coeff$[ebp]
	mov	WORD PTR [ecx+edx*2], ax

; 1000 :   }

	jmp	SHORT $LN31@kvz_rdoq
$LN32@kvz_rdoq:

; 1001 : 
; 1002 :   if (encoder->cfg.signhide_enable && abs_sum >= 2) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN77@kvz_rdoq
	cmp	DWORD PTR _abs_sum$[ebp], 2
	jb	SHORT $LN77@kvz_rdoq

; 1003 :     kvz_rdoq_sign_hiding(state, qp_scaled, scan, &sh_rates, best_last_idx_p1, coef, dest_coeff);

	mov	eax, DWORD PTR _dest_coeff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _coef$[ebp]
	push	ecx
	mov	edx, DWORD PTR _best_last_idx_p1$[ebp]
	push	edx
	lea	eax, DWORD PTR _sh_rates$[ebp]
	push	eax
	mov	ecx, DWORD PTR _scan$[ebp]
	push	ecx
	mov	edx, DWORD PTR _qp_scaled$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_rdoq_sign_hiding
	add	esp, 28					; 0000001cH
$LN77@kvz_rdoq:

; 1004 :   }
; 1005 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN124@kvz_rdoq
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 44756				; 0000aed4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN124@kvz_rdoq:
	DD	9
	DD	$LN123@kvz_rdoq
$LN123@kvz_rdoq:
	DD	-8348					; ffffdf64H
	DD	8192					; 00002000H
	DD	$LN114@kvz_rdoq
	DD	-16548					; ffffbf5cH
	DD	8192					; 00002000H
	DD	$LN115@kvz_rdoq
	DD	-24748					; ffff9f54H
	DD	8192					; 00002000H
	DD	$LN116@kvz_rdoq
	DD	-41140					; ffff5f4cH
	DD	16384					; 00004000H
	DD	$LN117@kvz_rdoq
	DD	-41708					; ffff5d14H
	DD	512					; 00000200H
	DD	$LN118@kvz_rdoq
	DD	-41972					; ffff5c0cH
	DD	256					; 00000100H
	DD	$LN119@kvz_rdoq
	DD	-42240					; ffff5b00H
	DD	40					; 00000028H
	DD	$LN120@kvz_rdoq
	DD	-42460					; ffff5a24H
	DD	128					; 00000080H
	DD	$LN121@kvz_rdoq
	DD	-42596					; ffff599cH
	DD	128					; 00000080H
	DD	$LN122@kvz_rdoq
$LN122@kvz_rdoq:
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN121@kvz_rdoq:
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	120					; 00000078H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN120@kvz_rdoq:
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN119@kvz_rdoq:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	103					; 00000067H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	0
$LN118@kvz_rdoq:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	103					; 00000067H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
$LN117@kvz_rdoq:
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN116@kvz_rdoq:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	48					; 00000030H
	DB	0
$LN115@kvz_rdoq:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
$LN114@kvz_rdoq:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	0
	npad	2
$LN113@kvz_rdoq:
	DD	$LN34@kvz_rdoq
	DD	$LN35@kvz_rdoq
	DD	$LN36@kvz_rdoq
	DD	$LN37@kvz_rdoq
	DD	$LN38@kvz_rdoq
$LN112@kvz_rdoq:
	DB	0
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_kvz_rdoq ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_close_rdcost_outfiles
_TEXT	SEGMENT
_curr_mtx$1 = -32					; size = 4
_curr$2 = -20						; size = 4
_i$ = -8						; size = 4
_kvz_close_rdcost_outfiles PROC				; COMDAT

; 1181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 1182 :   int i;
; 1183 : 
; 1184 :   for (i = 0; i < RD_SAMPLING_MAX_LAST_QP; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@kvz_close_
$LN2@kvz_close_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@kvz_close_:
	cmp	DWORD PTR _i$[ebp], 50			; 00000032H
	jge	SHORT $LN1@kvz_close_

; 1185 :     FILE *curr = fastrd_learning_outfile[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _fastrd_learning_outfile[eax*4]
	mov	DWORD PTR _curr$2[ebp], ecx

; 1186 :     pthread_mutex_t *curr_mtx = outfile_mutex + i;

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR _outfile_mutex[eax*4]
	mov	DWORD PTR _curr_mtx$1[ebp], ecx

; 1187 :     if (curr != NULL) {

	cmp	DWORD PTR _curr$2[ebp], 0
	je	SHORT $LN5@kvz_close_

; 1188 :       fclose(curr);

	mov	esi, esp
	mov	eax, DWORD PTR _curr$2[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@kvz_close_:

; 1189 :     }
; 1190 :     if (curr_mtx != NULL) {

	cmp	DWORD PTR _curr_mtx$1[ebp], 0
	je	SHORT $LN6@kvz_close_

; 1191 :       pthread_mutex_destroy(curr_mtx);

	mov	eax, DWORD PTR _curr_mtx$1[ebp]
	push	eax
	call	_pthread_mutex_destroy
	add	esp, 4
$LN6@kvz_close_:

; 1192 :     }
; 1193 :   }

	jmp	SHORT $LN2@kvz_close_
$LN1@kvz_close_:

; 1194 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_close_rdcost_outfiles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT _kvz_init_rdcost_outfiles
_TEXT	SEGMENT
$T1 = -9804						; size = 4
_curr$2 = -8256						; size = 4
_curr$3 = -8244						; size = 4
_qp$ = -8232						; size = 4
_rv$ = -8220						; size = 4
_fn$ = -8208						; size = 4096
_fn_template$ = -4104					; size = 4096
__$ArrayPad$ = -4					; size = 4
_dir_path$ = 8						; size = 4
_kvz_init_rdcost_outfiles PROC				; COMDAT

; 165  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 9808				; 00002650H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-9808]
	mov	ecx, 2452				; 00000994H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __79334164_rdo@c
	call	@__CheckForDebuggerJustMyCode@4

; 166  : #define RD_SAMPLING_MAX_FN_LENGTH 4095
; 167  :   static const char *basename_tmpl = "/%02i.txt";
; 168  :   char fn_template[RD_SAMPLING_MAX_FN_LENGTH + 1];
; 169  :   char fn[RD_SAMPLING_MAX_FN_LENGTH + 1];
; 170  :   int rv = 0, qp;

	mov	DWORD PTR _rv$[ebp], 0

; 171  : 
; 172  :   // As long as QP is a two-digit number, template and produced string should
; 173  :   // be equal in length ("%i" -> "22")
; 174  :   assert(RD_SAMPLING_MAX_LAST_QP <= 99);
; 175  :   assert(strlen(fn_template) <= RD_SAMPLING_MAX_FN_LENGTH);

	lea	eax, DWORD PTR _fn_template$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 4095				; 00000fffH
	jbe	SHORT $LN17@kvz_init_r
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_init_rdcost_outfiles@@9@9
	add	ecx, 10					; 0000000aH
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1GE@KKEFIIPC@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1GC@KANFJCIN@?$AAs?$AAt?$AAr?$AAl?$AAe?$AAn?$AA?$CI?$AAf?$AAn?$AA_?$AAt?$AAe?$AAm?$AAp?$AAl@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@kvz_init_r:

; 176  : 
; 177  :   strncpy(fn_template, dir_path, RD_SAMPLING_MAX_FN_LENGTH);

	mov	esi, esp
	push	4095					; 00000fffH
	mov	eax, DWORD PTR _dir_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fn_template$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 178  :   strncat(fn_template, basename_tmpl, RD_SAMPLING_MAX_FN_LENGTH - strlen(dir_path));

	mov	eax, DWORD PTR _dir_path$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, 4095				; 00000fffH
	sub	ecx, eax
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR ?basename_tmpl@?1??kvz_init_rdcost_outfiles@@9@9
	push	edx
	lea	eax, DWORD PTR _fn_template$[ebp]
	push	eax
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 179  : 
; 180  :   for (qp = 0; qp <= RD_SAMPLING_MAX_LAST_QP; qp++) {

	mov	DWORD PTR _qp$[ebp], 0
	jmp	SHORT $LN4@kvz_init_r
$LN2@kvz_init_r:
	mov	eax, DWORD PTR _qp$[ebp]
	add	eax, 1
	mov	DWORD PTR _qp$[ebp], eax
$LN4@kvz_init_r:
	cmp	DWORD PTR _qp$[ebp], 50			; 00000032H
	jg	SHORT $LN3@kvz_init_r

; 181  :     pthread_mutex_t *curr = outfile_mutex + qp;

	mov	eax, DWORD PTR _qp$[ebp]
	lea	ecx, DWORD PTR _outfile_mutex[eax*4]
	mov	DWORD PTR _curr$3[ebp], ecx

; 182  : 
; 183  :     if (pthread_mutex_init(curr, NULL) != 0) {

	push	0
	mov	eax, DWORD PTR _curr$3[ebp]
	push	eax
	call	_pthread_mutex_init
	add	esp, 8
	test	eax, eax
	je	SHORT $LN14@kvz_init_r

; 184  :       fprintf(stderr, "Failed to create mutex\n");

	push	OFFSET ??_C@_0BI@BHFDFFJM@Failed?5to?5create?5mutex?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 185  :       rv = -1;

	mov	DWORD PTR _rv$[ebp], -1

; 186  :       qp--;

	mov	eax, DWORD PTR _qp$[ebp]
	sub	eax, 1
	mov	DWORD PTR _qp$[ebp], eax

; 187  :       goto out_destroy_mutexes;

	jmp	$out_destroy_mutexes$24
$LN14@kvz_init_r:

; 188  :     }
; 189  :   }

	jmp	$LN2@kvz_init_r
$LN3@kvz_init_r:

; 190  : 
; 191  :   for (qp = 0; qp <= RD_SAMPLING_MAX_LAST_QP; qp++) {

	mov	DWORD PTR _qp$[ebp], 0
	jmp	SHORT $LN7@kvz_init_r
$LN5@kvz_init_r:
	mov	eax, DWORD PTR _qp$[ebp]
	add	eax, 1
	mov	DWORD PTR _qp$[ebp], eax
$LN7@kvz_init_r:
	cmp	DWORD PTR _qp$[ebp], 50			; 00000032H
	jg	$LN6@kvz_init_r

; 192  :     FILE *curr;
; 193  : 
; 194  :     snprintf(fn, RD_SAMPLING_MAX_FN_LENGTH, fn_template, qp);

	mov	eax, DWORD PTR _qp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fn_template$[ebp]
	push	ecx
	push	4095					; 00000fffH
	lea	edx, DWORD PTR _fn$[ebp]
	push	edx
	call	_snprintf
	add	esp, 16					; 00000010H

; 195  :     fn[RD_SAMPLING_MAX_FN_LENGTH] = 0;

	mov	eax, 1
	imul	ecx, eax, 4095
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 4096		; 00001000H
	jae	SHORT $LN18@kvz_init_r
	jmp	SHORT $LN19@kvz_init_r
$LN18@kvz_init_r:
	call	___report_rangecheckfailure
$LN19@kvz_init_r:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _fn$[ebp+edx], 0

; 196  :     curr = fopen(fn, "w");

	mov	esi, esp
	push	OFFSET ??_C@_01NOFIACDB@w@
	lea	eax, DWORD PTR _fn$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _curr$2[ebp], eax

; 197  :     if (curr == NULL) {

	cmp	DWORD PTR _curr$2[ebp], 0
	jne	SHORT $LN15@kvz_init_r

; 198  :       fprintf(stderr, "Failed to open %s: %s\n", fn, strerror(errno));

	mov	esi, esp
	call	DWORD PTR __imp___errno
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR __imp__strerror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR _fn$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@MBLPFB@Failed?5to?5open?5?$CFs?3?5?$CFs?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H

; 199  :       rv = -1;

	mov	DWORD PTR _rv$[ebp], -1

; 200  :       qp--;

	mov	eax, DWORD PTR _qp$[ebp]
	sub	eax, 1
	mov	DWORD PTR _qp$[ebp], eax

; 201  :       goto out_close_files;

	jmp	SHORT $out_close_files$25
$LN15@kvz_init_r:

; 202  :     }
; 203  :     fastrd_learning_outfile[qp] = curr;

	mov	eax, DWORD PTR _qp$[ebp]
	mov	ecx, DWORD PTR _curr$2[ebp]
	mov	DWORD PTR _fastrd_learning_outfile[eax*4], ecx

; 204  :   }

	jmp	$LN5@kvz_init_r
$LN6@kvz_init_r:

; 205  :   goto out;

	jmp	$out$26
$out_close_files$25:

; 206  : 
; 207  : out_close_files:
; 208  :   for (; qp >= 0; qp--) {

	jmp	SHORT $LN10@kvz_init_r
$LN8@kvz_init_r:
	mov	eax, DWORD PTR _qp$[ebp]
	sub	eax, 1
	mov	DWORD PTR _qp$[ebp], eax
$LN10@kvz_init_r:
	cmp	DWORD PTR _qp$[ebp], 0
	jl	SHORT $LN9@kvz_init_r

; 209  :     fclose(fastrd_learning_outfile[qp]);

	mov	esi, esp
	mov	eax, DWORD PTR _qp$[ebp]
	mov	ecx, DWORD PTR _fastrd_learning_outfile[eax*4]
	push	ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 210  :     fastrd_learning_outfile[qp] = NULL;

	mov	eax, DWORD PTR _qp$[ebp]
	mov	DWORD PTR _fastrd_learning_outfile[eax*4], 0

; 211  :   }

	jmp	SHORT $LN8@kvz_init_r
$LN9@kvz_init_r:

; 212  :   goto out;

	jmp	SHORT $out$26
$out_destroy_mutexes$24:

; 213  : 
; 214  : out_destroy_mutexes:
; 215  :   for (; qp >= 0; qp--) {

	jmp	SHORT $LN13@kvz_init_r
$LN11@kvz_init_r:
	mov	eax, DWORD PTR _qp$[ebp]
	sub	eax, 1
	mov	DWORD PTR _qp$[ebp], eax
$LN13@kvz_init_r:
	cmp	DWORD PTR _qp$[ebp], 0
	jl	SHORT $out$26

; 216  :     pthread_mutex_destroy(outfile_mutex + qp);

	mov	eax, DWORD PTR _qp$[ebp]
	lea	ecx, DWORD PTR _outfile_mutex[eax*4]
	push	ecx
	call	_pthread_mutex_destroy
	add	esp, 4

; 217  :   }

	jmp	SHORT $LN11@kvz_init_r
$out$26:

; 218  :   goto out;
; 219  : 
; 220  : out:
; 221  :   return rv;

	mov	eax, DWORD PTR _rv$[ebp]
$LN16@kvz_init_r:

; 222  : #undef RD_SAMPLING_MAX_FN_LENGTH
; 223  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@kvz_init_r
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 9808				; 00002650H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@kvz_init_r:
	DD	2
	DD	$LN22@kvz_init_r
$LN22@kvz_init_r:
	DD	-4104					; ffffeff8H
	DD	4096					; 00001000H
	DD	$LN20@kvz_init_r
	DD	-8208					; ffffdff0H
	DD	4096					; 00001000H
	DD	$LN21@kvz_init_r
$LN21@kvz_init_r:
	DB	102					; 00000066H
	DB	110					; 0000006eH
	DB	0
$LN20@kvz_init_r:
	DB	102					; 00000066H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
_kvz_init_rdcost_outfiles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1948 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __BufferCount$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	_vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1954 :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1955 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1956 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
tv74 = -208						; size = 4
__Result$ = -8						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 1440 :         int const _Result = __stdio_common_vsprintf(

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __BufferCount$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR [eax+4]
	push	edx
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Result$[ebp], eax

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf
$LN3@vsnprintf:
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], eax
$LN4@vsnprintf:
	mov	eax, DWORD PTR tv74[ebp]

; 1445 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 644  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1850469A_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
