; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_optarg
PUBLIC	_optind
PUBLIC	_opterr
PUBLIC	_optopt
PUBLIC	_optreset
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
_BSS	SEGMENT
_optarg	DD	01H DUP (?)
_optopt	DD	01H DUP (?)
_optreset DD	01H DUP (?)
_BSS	ENDS
msvcjmc	SEGMENT
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__24B24885_getopt@c DB 01H
msvcjmc	ENDS
CONST	SEGMENT
_recargchar DB	'option requires an argument -- %c', 00H
	ORG $+2
_recargstring DB 'option requires an argument -- %s', 00H
	ORG $+2
_ambig	DB	'ambiguous option -- %.*s', 00H
	ORG $+3
_noarg	DB	'option doesn''t take an argument -- %.*s', 00H
_illoptchar DB	'illegal option -- %c', 00H
	ORG $+3
_illoptstring DB 'illegal option -- %s', 00H
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
_optind	DD	01H
_opterr	DD	01H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_vfprintf
PUBLIC	_fprintf
PUBLIC	_getopt_long
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@		; `string'
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__getenv:PROC
EXTRN	_strchr:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_progname DD	01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
CONST	SEGMENT
??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@ DB 'POSIXLY_CORRECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5@
CONST	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5@ DB '%s: ', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_place	DD	FLAT:??_C@_00CNPNBAHC@@
_nonopt_start DD 0ffffffffH
_nonopt_end DD	0ffffffffH
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
;	COMDAT _xwarnx
_TEXT	SEGMENT
_ap$ = -8						; size = 4
_fmt$ = 8						; size = 4
_xwarnx	PROC						; COMDAT

; 94   : static void xwarnx(const char *fmt, ...) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __24B24885_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 95   : 	va_list ap;
; 96   : 
; 97   : 	va_start(ap, fmt);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _ap$[ebp], eax

; 98   : 	if (progname)

	cmp	DWORD PTR _progname, 0
	je	SHORT $LN2@xwarnx

; 99   : 		(void) fprintf(stderr, "%s: ", progname);

	mov	eax, DWORD PTR _progname
	push	eax
	push	OFFSET ??_C@_04PFAOODAA@?$CFs?3?5@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN2@xwarnx:

; 100  : 	if (fmt)

	cmp	DWORD PTR _fmt$[ebp], 0
	je	SHORT $LN3@xwarnx

; 101  : 		(void) vfprintf(stderr, fmt, ap);

	mov	eax, DWORD PTR _ap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$[ebp]
	push	ecx
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_vfprintf
	add	esp, 12					; 0000000cH
$LN3@xwarnx:

; 102  : 	(void) fprintf(stderr, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 103  : 	va_end(ap);

	mov	DWORD PTR _ap$[ebp], 0

; 104  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_xwarnx	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
;	COMDAT _permute_args
_TEXT	SEGMENT
_swap$ = -104						; size = 4
_pos$ = -92						; size = 4
_nopts$ = -80						; size = 4
_nnonopts$ = -68					; size = 4
_ncycle$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_cyclelen$ = -20					; size = 4
_cstart$ = -8						; size = 4
_nonopt_start$ = 8					; size = 4
_nonopt_end$ = 12					; size = 4
_opt_end$ = 16						; size = 4
_nargv$ = 20						; size = 4
_permute_args PROC					; COMDAT

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __24B24885_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 138  : 	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
; 139  : 	char *swap;
; 140  : 
; 141  : 	/*
; 142  : 	 * compute lengths of blocks and number and size of cycles
; 143  : 	 */
; 144  : 	nnonopts = nonopt_end - nonopt_start;

	mov	eax, DWORD PTR _nonopt_end$[ebp]
	sub	eax, DWORD PTR _nonopt_start$[ebp]
	mov	DWORD PTR _nnonopts$[ebp], eax

; 145  : 	nopts = opt_end - nonopt_end;

	mov	eax, DWORD PTR _opt_end$[ebp]
	sub	eax, DWORD PTR _nonopt_end$[ebp]
	mov	DWORD PTR _nopts$[ebp], eax

; 146  : 	ncycle = gcd(nnonopts, nopts);

	mov	eax, DWORD PTR _nopts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nnonopts$[ebp]
	push	ecx
	call	_gcd
	add	esp, 8
	mov	DWORD PTR _ncycle$[ebp], eax

; 147  : 	cyclelen = (opt_end - nonopt_start) / ncycle;

	mov	eax, DWORD PTR _opt_end$[ebp]
	sub	eax, DWORD PTR _nonopt_start$[ebp]
	cdq
	idiv	DWORD PTR _ncycle$[ebp]
	mov	DWORD PTR _cyclelen$[ebp], eax

; 148  : 
; 149  : 	for (i = 0; i < ncycle; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@permute_ar
$LN2@permute_ar:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@permute_ar:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _ncycle$[ebp]
	jge	SHORT $LN1@permute_ar

; 150  : 		cstart = nonopt_end+i;

	mov	eax, DWORD PTR _nonopt_end$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cstart$[ebp], eax

; 151  : 		pos = cstart;

	mov	eax, DWORD PTR _cstart$[ebp]
	mov	DWORD PTR _pos$[ebp], eax

; 152  : 		for (j = 0; j < cyclelen; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@permute_ar
$LN5@permute_ar:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@permute_ar:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _cyclelen$[ebp]
	jge	SHORT $LN6@permute_ar

; 153  : 			if (pos >= nonopt_end)

	mov	eax, DWORD PTR _pos$[ebp]
	cmp	eax, DWORD PTR _nonopt_end$[ebp]
	jl	SHORT $LN8@permute_ar

; 154  : 				pos -= nnonopts;

	mov	eax, DWORD PTR _pos$[ebp]
	sub	eax, DWORD PTR _nnonopts$[ebp]
	mov	DWORD PTR _pos$[ebp], eax
	jmp	SHORT $LN9@permute_ar
$LN8@permute_ar:

; 155  : 			else
; 156  : 				pos += nopts;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _nopts$[ebp]
	mov	DWORD PTR _pos$[ebp], eax
$LN9@permute_ar:

; 157  : 			swap = nargv[pos];

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _swap$[ebp], edx

; 158  : 			/* LINTED const cast */
; 159  : 			((char **) nargv)[pos] = nargv[cstart];

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR _cstart$[ebp]
	mov	esi, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 160  : 			/* LINTED const cast */
; 161  : 			((char **)nargv)[cstart] = swap;

	mov	eax, DWORD PTR _cstart$[ebp]
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR _swap$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 162  : 		}

	jmp	SHORT $LN5@permute_ar
$LN6@permute_ar:

; 163  : 	}

	jmp	$LN2@permute_ar
$LN1@permute_ar:

; 164  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_permute_args ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
;	COMDAT _gcd
_TEXT	SEGMENT
_c$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_gcd	PROC						; COMDAT

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __24B24885_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 114  : 	int c;
; 115  : 
; 116  : 	c = a % b;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _b$[ebp]
	mov	DWORD PTR _c$[ebp], edx
$LN2@gcd:

; 117  : 	while (c != 0) {

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN3@gcd

; 118  : 		a = b;

	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 119  : 		b = c;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 120  : 		c = a % b;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _b$[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 121  : 	}

	jmp	SHORT $LN2@gcd
$LN3@gcd:

; 122  : 	   
; 123  : 	return b;

	mov	eax, DWORD PTR _b$[ebp]

; 124  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_gcd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
;	COMDAT _getopt_internal
_TEXT	SEGMENT
tv152 = -224						; size = 4
tv160 = -220						; size = 4
tv151 = -220						; size = 4
_optchar$ = -20						; size = 4
_oli$ = -8						; size = 4
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_getopt_internal PROC					; COMDAT

; 176  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __24B24885_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 177  : 	char *oli;				/* option letter list index */
; 178  : 	int optchar;
; 179  : 
; 180  : 	_DIAGASSERT(nargv != NULL);
; 181  : 	_DIAGASSERT(options != NULL);
; 182  : 
; 183  : 	optarg = NULL;

	mov	DWORD PTR _optarg, 0

; 184  : 
; 185  : 	/*
; 186  : 	 * XXX Some programs (like rsyncd) expect to be able to
; 187  : 	 * XXX re-initialize optind to 0 and have getopt_long(3)
; 188  : 	 * XXX properly function again.  Work around this braindamage.
; 189  : 	 */
; 190  : 	if (optind == 0)

	cmp	DWORD PTR _optind, 0
	jne	SHORT $LN2@getopt_int

; 191  : 		optind = 1;

	mov	DWORD PTR _optind, 1
$LN2@getopt_int:

; 192  : 
; 193  : 	if (optreset)

	cmp	DWORD PTR _optreset, 0
	je	SHORT $start$49

; 194  : 		nonopt_start = nonopt_end = -1;

	mov	DWORD PTR _nonopt_end, -1
	mov	eax, DWORD PTR _nonopt_end
	mov	DWORD PTR _nonopt_start, eax
$start$49:

; 195  : start:
; 196  : 	if (optreset || !*place) {		/* update scanning pointer */

	cmp	DWORD PTR _optreset, 0
	jne	SHORT $LN5@getopt_int
	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN4@getopt_int
$LN5@getopt_int:

; 197  : 		optreset = 0;

	mov	DWORD PTR _optreset, 0

; 198  : 		if (optind >= nargc) {          /* end of argument vector */

	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _nargc$[ebp]
	jl	SHORT $LN6@getopt_int

; 199  : 			place = EMSG;

	mov	DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@@

; 200  : 			if (nonopt_end != -1) {

	cmp	DWORD PTR _nonopt_end, -1
	je	SHORT $LN7@getopt_int

; 201  : 				/* do permutation, if we have to */
; 202  : 				permute_args(nonopt_start, nonopt_end,

	mov	eax, DWORD PTR _nargv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _optind
	push	ecx
	mov	edx, DWORD PTR _nonopt_end
	push	edx
	mov	eax, DWORD PTR _nonopt_start
	push	eax
	call	_permute_args
	add	esp, 16					; 00000010H

; 203  : 				    optind, nargv);
; 204  : 				optind -= nonopt_end - nonopt_start;

	mov	eax, DWORD PTR _nonopt_end
	sub	eax, DWORD PTR _nonopt_start
	mov	ecx, DWORD PTR _optind
	sub	ecx, eax
	mov	DWORD PTR _optind, ecx

; 205  : 			}

	jmp	SHORT $LN8@getopt_int
$LN7@getopt_int:

; 206  : 			else if (nonopt_start != -1) {

	cmp	DWORD PTR _nonopt_start, -1
	je	SHORT $LN8@getopt_int

; 207  : 				/*
; 208  : 				 * If we skipped non-options, set optind
; 209  : 				 * to the first of them.
; 210  : 				 */
; 211  : 				optind = nonopt_start;

	mov	eax, DWORD PTR _nonopt_start
	mov	DWORD PTR _optind, eax
$LN8@getopt_int:

; 212  : 			}
; 213  : 			nonopt_start = nonopt_end = -1;

	mov	DWORD PTR _nonopt_end, -1
	mov	eax, DWORD PTR _nonopt_end
	mov	DWORD PTR _nonopt_start, eax

; 214  : 			return -1;

	or	eax, -1
	jmp	$LN1@getopt_int
$LN6@getopt_int:

; 215  : 		}
; 216  : 		if (*(place = nargv[optind]) != '-') {  /* found non-option */

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _place, edx
	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	$LN10@getopt_int

; 217  : 			place = EMSG;

	mov	DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@@

; 218  : 			if (IN_ORDER) {

	mov	esi, esp
	push	OFFSET ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN11@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN11@getopt_int

; 219  : 				/*
; 220  : 				 * GNU extension: 
; 221  : 				 * return non-option as argument to option 1
; 222  : 				 */
; 223  : 				optarg = nargv[optind++];

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _optarg, edx
	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 224  : 				return INORDER;

	mov	eax, 1
	jmp	$LN1@getopt_int
$LN11@getopt_int:

; 225  : 			}
; 226  : 			if (!PERMUTE) {

	mov	esi, esp
	push	OFFSET ??_C@_0BA@DMNGMDNL@POSIXLY_CORRECT@
	call	DWORD PTR __imp__getenv
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN13@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN13@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN12@getopt_int
$LN13@getopt_int:

; 227  : 				/*
; 228  : 				 * if no permutation wanted, stop parsing
; 229  : 				 * at first non-option
; 230  : 				 */
; 231  : 				return -1;

	or	eax, -1
	jmp	$LN1@getopt_int
$LN12@getopt_int:

; 232  : 			}
; 233  : 			/* do permutation */
; 234  : 			if (nonopt_start == -1)

	cmp	DWORD PTR _nonopt_start, -1
	jne	SHORT $LN15@getopt_int

; 235  : 				nonopt_start = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _nonopt_start, eax
	jmp	SHORT $LN16@getopt_int
$LN15@getopt_int:

; 236  : 			else if (nonopt_end != -1) {

	cmp	DWORD PTR _nonopt_end, -1
	je	SHORT $LN16@getopt_int

; 237  : 				permute_args(nonopt_start, nonopt_end,

	mov	eax, DWORD PTR _nargv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _optind
	push	ecx
	mov	edx, DWORD PTR _nonopt_end
	push	edx
	mov	eax, DWORD PTR _nonopt_start
	push	eax
	call	_permute_args
	add	esp, 16					; 00000010H

; 238  : 				    optind, nargv);
; 239  : 				nonopt_start = optind -

	mov	eax, DWORD PTR _nonopt_end
	sub	eax, DWORD PTR _nonopt_start
	mov	ecx, DWORD PTR _optind
	sub	ecx, eax
	mov	DWORD PTR _nonopt_start, ecx

; 240  : 				    (nonopt_end - nonopt_start);
; 241  : 				nonopt_end = -1;

	mov	DWORD PTR _nonopt_end, -1
$LN16@getopt_int:

; 242  : 			}
; 243  : 			optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 244  : 			/* process next argument */
; 245  : 			goto start;

	jmp	$start$49
$LN10@getopt_int:

; 246  : 		}
; 247  : 		if (nonopt_start != -1 && nonopt_end == -1)

	cmp	DWORD PTR _nonopt_start, -1
	je	SHORT $LN18@getopt_int
	cmp	DWORD PTR _nonopt_end, -1
	jne	SHORT $LN18@getopt_int

; 248  : 			nonopt_end = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _nonopt_end, eax
$LN18@getopt_int:

; 249  : 		if (place[1] && *++place == '-') {	/* found "--" */

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _place
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN4@getopt_int
	mov	eax, DWORD PTR _place
	add	eax, 1
	mov	DWORD PTR _place, eax
	mov	ecx, DWORD PTR _place
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN4@getopt_int

; 250  : 			place++;

	mov	eax, DWORD PTR _place
	add	eax, 1
	mov	DWORD PTR _place, eax

; 251  : 			return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN1@getopt_int
$LN4@getopt_int:

; 252  : 		}
; 253  : 	}
; 254  : 	if ((optchar = (int)*place++) == (int)':' ||

	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _optchar$[ebp], ecx
	mov	edx, DWORD PTR _optchar$[ebp]
	mov	DWORD PTR tv151[ebp], edx
	mov	eax, DWORD PTR _place
	add	eax, 1
	mov	DWORD PTR _place, eax
	cmp	DWORD PTR tv151[ebp], 58		; 0000003aH
	jne	SHORT $LN45@getopt_int
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN46@getopt_int
$LN45@getopt_int:
	mov	DWORD PTR tv152[ebp], 0
$LN46@getopt_int:
	cmp	DWORD PTR tv152[ebp], 0
	jne	SHORT $LN21@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN47@getopt_int
	mov	edx, DWORD PTR _options$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN47@getopt_int
	mov	DWORD PTR tv160[ebp], 0
	jmp	SHORT $LN48@getopt_int
$LN47@getopt_int:
	mov	DWORD PTR tv160[ebp], 1
$LN48@getopt_int:
	mov	ecx, DWORD PTR _optchar$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$[ebp]
	add	edx, DWORD PTR tv160[ebp]
	push	edx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _oli$[ebp], eax
	cmp	DWORD PTR _oli$[ebp], 0
	jne	SHORT $LN20@getopt_int
$LN21@getopt_int:

; 255  : 	    (oli = strchr(options + (IGNORE_FIRST ? 1 : 0), optchar)) == NULL) {
; 256  : 		/* option letter unknown or ':' */
; 257  : 		if (!*place)

	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN22@getopt_int

; 258  : 			++optind;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
$LN22@getopt_int:

; 259  : 		if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN23@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN24@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN25@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN23@getopt_int
$LN25@getopt_int:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN23@getopt_int
$LN24@getopt_int:

; 260  : 			xwarnx(illoptchar, optchar);

	mov	eax, DWORD PTR _optchar$[ebp]
	push	eax
	push	OFFSET _illoptchar
	call	_xwarnx
	add	esp, 8
$LN23@getopt_int:

; 261  : 		optopt = optchar;

	mov	eax, DWORD PTR _optchar$[ebp]
	mov	DWORD PTR _optopt, eax

; 262  : 		return BADCH;

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN20@getopt_int:

; 263  : 	}
; 264  : 	if (optchar == 'W' && oli[1] == ';') {		/* -W long-option */

	cmp	DWORD PTR _optchar$[ebp], 87		; 00000057H
	jne	$LN26@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _oli$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 59					; 0000003bH
	jne	$LN26@getopt_int

; 265  : 		/* XXX: what if no long options provided (called by getopt)? */
; 266  : 		if (*place) 

	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN27@getopt_int

; 267  : 			return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN1@getopt_int
$LN27@getopt_int:

; 268  : 
; 269  : 		if (++optind >= nargc) {	/* no arg */

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
	mov	ecx, DWORD PTR _optind
	cmp	ecx, DWORD PTR _nargc$[ebp]
	jl	SHORT $LN28@getopt_int

; 270  : 			place = EMSG;

	mov	DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@@

; 271  : 			if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN30@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN31@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN32@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN30@getopt_int
$LN32@getopt_int:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN30@getopt_int
$LN31@getopt_int:

; 272  : 				xwarnx(recargchar, optchar);

	mov	eax, DWORD PTR _optchar$[ebp]
	push	eax
	push	OFFSET _recargchar
	call	_xwarnx
	add	esp, 8
$LN30@getopt_int:

; 273  : 			optopt = optchar;

	mov	eax, DWORD PTR _optchar$[ebp]
	mov	DWORD PTR _optopt, eax

; 274  : 			/* XXX: GNU returns '?' if options[0] != ':' */
; 275  : 			return BADARG;

	mov	eax, 58					; 0000003aH
	jmp	$LN1@getopt_int

; 276  : 		} else				/* white space */

	jmp	SHORT $LN29@getopt_int
$LN28@getopt_int:

; 277  : 			place = nargv[optind];

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _place, edx
$LN29@getopt_int:

; 278  : 		/*
; 279  : 		 * Handle -W arg the same as --arg (which causes getopt to
; 280  : 		 * stop parsing).
; 281  : 		 */
; 282  : 		return -2;

	mov	eax, -2					; fffffffeH
	jmp	$LN1@getopt_int
$LN26@getopt_int:

; 283  : 	}
; 284  : 	if (*++oli != ':') {			/* doesn't take argument */

	mov	eax, DWORD PTR _oli$[ebp]
	add	eax, 1
	mov	DWORD PTR _oli$[ebp], eax
	mov	ecx, DWORD PTR _oli$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN33@getopt_int

; 285  : 		if (!*place)

	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN35@getopt_int

; 286  : 			++optind;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
$LN35@getopt_int:

; 287  : 	} else {				/* takes (optional) argument */

	jmp	$LN34@getopt_int
$LN33@getopt_int:

; 288  : 		optarg = NULL;

	mov	DWORD PTR _optarg, 0

; 289  : 		if (*place)			/* no white space */

	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN36@getopt_int

; 290  : 			optarg = place;

	mov	eax, DWORD PTR _place
	mov	DWORD PTR _optarg, eax
	jmp	$LN37@getopt_int
$LN36@getopt_int:

; 291  : 		/* XXX: disable test for :: if PC? (GNU doesn't) */
; 292  : 		else if (oli[1] != ':') {	/* arg not optional */

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _oli$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	je	$LN37@getopt_int

; 293  : 			if (++optind >= nargc) {	/* no arg */

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
	mov	ecx, DWORD PTR _optind
	cmp	ecx, DWORD PTR _nargc$[ebp]
	jl	SHORT $LN39@getopt_int

; 294  : 				place = EMSG;

	mov	DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@@

; 295  : 				if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN41@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN42@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN43@getopt_int
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN41@getopt_int
$LN43@getopt_int:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN41@getopt_int
$LN42@getopt_int:

; 296  : 					xwarnx(recargchar, optchar);

	mov	eax, DWORD PTR _optchar$[ebp]
	push	eax
	push	OFFSET _recargchar
	call	_xwarnx
	add	esp, 8
$LN41@getopt_int:

; 297  : 				optopt = optchar;

	mov	eax, DWORD PTR _optchar$[ebp]
	mov	DWORD PTR _optopt, eax

; 298  : 				/* XXX: GNU returns '?' if options[0] != ':' */
; 299  : 				return BADARG;

	mov	eax, 58					; 0000003aH
	jmp	SHORT $LN1@getopt_int

; 300  : 			} else

	jmp	SHORT $LN37@getopt_int
$LN39@getopt_int:

; 301  : 				optarg = nargv[optind];

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _optarg, edx
$LN37@getopt_int:

; 302  : 		}
; 303  : 		place = EMSG;

	mov	DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@@

; 304  : 		++optind;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
$LN34@getopt_int:

; 305  : 	}
; 306  : 	/* dump back option letter */
; 307  : 	return optchar;

	mov	eax, DWORD PTR _optchar$[ebp]
$LN1@getopt_int:

; 308  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_getopt_internal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
;	COMDAT _getopt_long
_TEXT	SEGMENT
_match$1 = -68						; size = 4
_i$2 = -56						; size = 4
_current_argv_len$3 = -44				; size = 4
_has_equal$4 = -32					; size = 4
_current_argv$5 = -20					; size = 4
_retval$ = -8						; size = 4
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long PROC					; COMDAT

; 356  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __24B24885_getopt@c
	call	@__CheckForDebuggerJustMyCode@4

; 357  : 	int retval;
; 358  : 
; 359  : 	_DIAGASSERT(nargv != NULL);
; 360  : 	_DIAGASSERT(options != NULL);
; 361  : 	_DIAGASSERT(long_options != NULL);
; 362  : 	/* idx may be NULL */
; 363  : 
; 364  : 	progname = nargv[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR _progname, eax

; 365  : 
; 366  : 	if ((retval = getopt_internal(nargc, nargv, options)) == -2) {

	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nargv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nargc$[ebp]
	push	edx
	call	_getopt_internal
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retval$[ebp], eax
	cmp	DWORD PTR _retval$[ebp], -2		; fffffffeH
	jne	$LN5@getopt_lon

; 367  : 		char *current_argv, *has_equal;
; 368  : 		size_t current_argv_len;
; 369  : 		int i, match;
; 370  : 
; 371  : 		current_argv = place;

	mov	eax, DWORD PTR _place
	mov	DWORD PTR _current_argv$5[ebp], eax

; 372  : 		match = -1;

	mov	DWORD PTR _match$1[ebp], -1

; 373  : 
; 374  : 		optind++;

	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax

; 375  : 		place = EMSG;

	mov	DWORD PTR _place, OFFSET ??_C@_00CNPNBAHC@@

; 376  : 
; 377  : 		if (*current_argv == '\0') {		/* found "--" */

	mov	eax, DWORD PTR _current_argv$5[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN6@getopt_lon

; 378  : 			/*
; 379  : 			 * We found an option (--), so if we skipped
; 380  : 			 * non-options, we have to permute.
; 381  : 			 */
; 382  : 			if (nonopt_end != -1) {

	cmp	DWORD PTR _nonopt_end, -1
	je	SHORT $LN7@getopt_lon

; 383  : 				permute_args(nonopt_start, nonopt_end,

	mov	eax, DWORD PTR _nargv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _optind
	push	ecx
	mov	edx, DWORD PTR _nonopt_end
	push	edx
	mov	eax, DWORD PTR _nonopt_start
	push	eax
	call	_permute_args
	add	esp, 16					; 00000010H

; 384  : 				    optind, nargv);
; 385  : 				optind -= nonopt_end - nonopt_start;

	mov	eax, DWORD PTR _nonopt_end
	sub	eax, DWORD PTR _nonopt_start
	mov	ecx, DWORD PTR _optind
	sub	ecx, eax
	mov	DWORD PTR _optind, ecx
$LN7@getopt_lon:

; 386  : 			}
; 387  : 			nonopt_start = nonopt_end = -1;

	mov	DWORD PTR _nonopt_end, -1
	mov	eax, DWORD PTR _nonopt_end
	mov	DWORD PTR _nonopt_start, eax

; 388  : 			return -1;

	or	eax, -1
	jmp	$LN1@getopt_lon
$LN6@getopt_lon:

; 389  : 		}
; 390  : 		if ((has_equal = strchr(current_argv, '=')) != NULL) {

	push	61					; 0000003dH
	mov	eax, DWORD PTR _current_argv$5[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _has_equal$4[ebp], eax
	cmp	DWORD PTR _has_equal$4[ebp], 0
	je	SHORT $LN8@getopt_lon

; 391  : 			/* argument found (--option=arg) */
; 392  : 			current_argv_len = has_equal - current_argv;

	mov	eax, DWORD PTR _has_equal$4[ebp]
	sub	eax, DWORD PTR _current_argv$5[ebp]
	mov	DWORD PTR _current_argv_len$3[ebp], eax

; 393  : 			has_equal++;

	mov	eax, DWORD PTR _has_equal$4[ebp]
	add	eax, 1
	mov	DWORD PTR _has_equal$4[ebp], eax

; 394  : 		} else

	jmp	SHORT $LN9@getopt_lon
$LN8@getopt_lon:

; 395  : 			current_argv_len = strlen(current_argv);

	mov	eax, DWORD PTR _current_argv$5[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _current_argv_len$3[ebp], eax
$LN9@getopt_lon:

; 396  : 	    
; 397  : 		for (i = 0; long_options[i].name; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@getopt_lon
$LN2@getopt_lon:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@getopt_lon:
	mov	eax, DWORD PTR _i$2[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax], 0
	je	$LN3@getopt_lon

; 398  : 			/* find matching long option */
; 399  : 			if (strncmp(current_argv, long_options[i].name,

	mov	esi, esp
	mov	eax, DWORD PTR _current_argv_len$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _long_options$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _current_argv$5[ebp]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN10@getopt_lon

; 400  : 			    current_argv_len))
; 401  : 				continue;

	jmp	SHORT $LN2@getopt_lon
$LN10@getopt_lon:

; 402  : 
; 403  : 			if (strlen(long_options[i].name) ==

	mov	eax, DWORD PTR _i$2[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, DWORD PTR _current_argv_len$3[ebp]
	jne	SHORT $LN11@getopt_lon

; 404  : 			    (unsigned)current_argv_len) {
; 405  : 				/* exact match */
; 406  : 				match = i;

	mov	eax, DWORD PTR _i$2[ebp]
	mov	DWORD PTR _match$1[ebp], eax

; 407  : 				break;

	jmp	SHORT $LN3@getopt_lon
$LN11@getopt_lon:

; 408  : 			}
; 409  : 			if (match == -1)		/* partial match */

	cmp	DWORD PTR _match$1[ebp], -1
	jne	SHORT $LN12@getopt_lon

; 410  : 				match = i;

	mov	eax, DWORD PTR _i$2[ebp]
	mov	DWORD PTR _match$1[ebp], eax
	jmp	SHORT $LN13@getopt_lon
$LN12@getopt_lon:

; 411  : 			else {
; 412  : 				/* ambiguous abbreviation */
; 413  : 				if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN14@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN15@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN16@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN14@getopt_lon
$LN16@getopt_lon:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN14@getopt_lon
$LN15@getopt_lon:

; 414  : 					xwarnx(ambig, (int)current_argv_len,

	mov	eax, DWORD PTR _current_argv$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _current_argv_len$3[ebp]
	push	ecx
	push	OFFSET _ambig
	call	_xwarnx
	add	esp, 12					; 0000000cH
$LN14@getopt_lon:

; 415  : 					     current_argv);
; 416  : 				optopt = 0;

	mov	DWORD PTR _optopt, 0

; 417  : 				return BADCH;

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_lon
$LN13@getopt_lon:

; 418  : 			}
; 419  : 		}

	jmp	$LN2@getopt_lon
$LN3@getopt_lon:

; 420  : 		if (match != -1) {			/* option found */

	cmp	DWORD PTR _match$1[ebp], -1
	je	$LN17@getopt_lon

; 421  : 		        if (long_options[match].has_arg == no_argument
; 422  : 			    && has_equal) {

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 0
	jne	$LN19@getopt_lon
	cmp	DWORD PTR _has_equal$4[ebp], 0
	je	$LN19@getopt_lon

; 423  : 				if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN20@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN21@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN22@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN20@getopt_lon
$LN22@getopt_lon:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN20@getopt_lon
$LN21@getopt_lon:

; 424  : 					xwarnx(noarg, (int)current_argv_len,

	mov	eax, DWORD PTR _current_argv$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _current_argv_len$3[ebp]
	push	ecx
	push	OFFSET _noarg
	call	_xwarnx
	add	esp, 12					; 0000000cH
$LN20@getopt_lon:

; 425  : 					     current_argv);
; 426  : 				/*
; 427  : 				 * XXX: GNU sets optopt to val regardless of
; 428  : 				 * flag
; 429  : 				 */
; 430  : 				if (long_options[match].flag == NULL)

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+8], 0
	jne	SHORT $LN23@getopt_lon

; 431  : 					optopt = long_options[match].val;

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _optopt, edx
	jmp	SHORT $LN24@getopt_lon
$LN23@getopt_lon:

; 432  : 				else
; 433  : 					optopt = 0;

	mov	DWORD PTR _optopt, 0
$LN24@getopt_lon:

; 434  : 				/* XXX: GNU returns '?' if options[0] != ':' */
; 435  : 				return BADARG;

	mov	eax, 58					; 0000003aH
	jmp	$LN1@getopt_lon
$LN19@getopt_lon:

; 436  : 			}
; 437  : 			if (long_options[match].has_arg == required_argument ||

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 1
	je	SHORT $LN26@getopt_lon
	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 2
	jne	SHORT $LN25@getopt_lon
$LN26@getopt_lon:

; 438  : 			    long_options[match].has_arg == optional_argument) {
; 439  : 				if (has_equal)

	cmp	DWORD PTR _has_equal$4[ebp], 0
	je	SHORT $LN27@getopt_lon

; 440  : 					optarg = has_equal;

	mov	eax, DWORD PTR _has_equal$4[ebp]
	mov	DWORD PTR _optarg, eax
	jmp	SHORT $LN25@getopt_lon
$LN27@getopt_lon:

; 441  : 				else if (long_options[match].has_arg ==

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 1
	jne	SHORT $LN25@getopt_lon

; 442  : 				    required_argument) {
; 443  : 					/*
; 444  : 					 * optional argument doesn't use
; 445  : 					 * next nargv
; 446  : 					 */
; 447  : 					optarg = nargv[optind++];

	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _optarg, edx
	mov	eax, DWORD PTR _optind
	add	eax, 1
	mov	DWORD PTR _optind, eax
$LN25@getopt_lon:

; 448  : 				}
; 449  : 			}
; 450  : 			if ((long_options[match].has_arg == required_argument)
; 451  : 			    && (optarg == NULL)) {

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 1
	jne	$LN30@getopt_lon
	cmp	DWORD PTR _optarg, 0
	jne	$LN30@getopt_lon

; 452  : 				/*
; 453  : 				 * Missing argument; leading ':'
; 454  : 				 * indicates no error should be generated
; 455  : 				 */
; 456  : 				if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN31@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN32@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN33@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN31@getopt_lon
$LN33@getopt_lon:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN31@getopt_lon
$LN32@getopt_lon:

; 457  : 					xwarnx(recargstring, current_argv);

	mov	eax, DWORD PTR _current_argv$5[ebp]
	push	eax
	push	OFFSET _recargstring
	call	_xwarnx
	add	esp, 8
$LN31@getopt_lon:

; 458  : 				/*
; 459  : 				 * XXX: GNU sets optopt to val regardless
; 460  : 				 * of flag
; 461  : 				 */
; 462  : 				if (long_options[match].flag == NULL)

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+8], 0
	jne	SHORT $LN34@getopt_lon

; 463  : 					optopt = long_options[match].val;

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _optopt, edx
	jmp	SHORT $LN35@getopt_lon
$LN34@getopt_lon:

; 464  : 				else
; 465  : 					optopt = 0;

	mov	DWORD PTR _optopt, 0
$LN35@getopt_lon:

; 466  : 				/* XXX: GNU returns '?' if options[0] != ':' */
; 467  : 				--optind;

	mov	eax, DWORD PTR _optind
	sub	eax, 1
	mov	DWORD PTR _optind, eax

; 468  : 				return BADARG;

	mov	eax, 58					; 0000003aH
	jmp	$LN1@getopt_lon
$LN30@getopt_lon:

; 469  : 			}
; 470  : 		} else {			/* unknown option */

	jmp	SHORT $LN18@getopt_lon
$LN17@getopt_lon:

; 471  : 			if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN36@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	jne	SHORT $LN37@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN38@getopt_lon
	mov	eax, DWORD PTR _options$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN36@getopt_lon
$LN38@getopt_lon:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN36@getopt_lon
$LN37@getopt_lon:

; 472  : 				xwarnx(illoptstring, current_argv);

	mov	eax, DWORD PTR _current_argv$5[ebp]
	push	eax
	push	OFFSET _illoptstring
	call	_xwarnx
	add	esp, 8
$LN36@getopt_lon:

; 473  : 			optopt = 0;

	mov	DWORD PTR _optopt, 0

; 474  : 			return BADCH;

	mov	eax, 63					; 0000003fH
	jmp	SHORT $LN1@getopt_lon
$LN18@getopt_lon:

; 475  : 		}
; 476  : 		if (long_options[match].flag) {

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+8], 0
	je	SHORT $LN39@getopt_lon

; 477  : 			*long_options[match].flag = long_options[match].val;

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _match$1[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _long_options$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+8]
	mov	edx, DWORD PTR _long_options$[ebp]
	mov	eax, DWORD PTR [edx+eax+12]
	mov	DWORD PTR [ecx], eax

; 478  : 			retval = 0;

	mov	DWORD PTR _retval$[ebp], 0

; 479  : 		} else 

	jmp	SHORT $LN40@getopt_lon
$LN39@getopt_lon:

; 480  : 			retval = long_options[match].val;

	mov	eax, DWORD PTR _match$1[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _retval$[ebp], edx
$LN40@getopt_lon:

; 481  : 		if (idx)

	cmp	DWORD PTR _idx$[ebp], 0
	je	SHORT $LN5@getopt_lon

; 482  : 			*idx = match;

	mov	eax, DWORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _match$1[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@getopt_lon:

; 483  : 	}
; 484  : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]
$LN1@getopt_lon:

; 485  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_getopt_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vfprintf PROC						; COMDAT

; 656  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 657  :         return _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H

; 658  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 644  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1850469A_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
