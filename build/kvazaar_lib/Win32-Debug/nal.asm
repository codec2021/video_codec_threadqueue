; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\nal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__E9BB758C_nal@c DB 01H
msvcjmc	ENDS
PUBLIC	_kvz_nal_write
PUBLIC	_kvz_image_checksum
PUBLIC	_kvz_image_md5
PUBLIC	__JustMyCode_Default
EXTRN	_kvz_bitstream_writebyte:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_kvz_array_checksum:DWORD
EXTRN	_kvz_array_md5:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\nal.c
;	COMDAT _kvz_image_md5
_TEXT	SEGMENT
_im$ = 8						; size = 4
_checksum_out$ = 12					; size = 4
_bitdepth$ = 16						; size = 1
_kvz_image_md5 PROC					; COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E9BB758C_nal@c
	call	@__CheckForDebuggerJustMyCode@4

; 96   :   kvz_array_md5(im->y, im->height, im->width, im->width, checksum_out[0], bitdepth);

	mov	esi, esp
	movzx	eax, BYTE PTR _bitdepth$[ebp]
	push	eax
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _checksum_out$[ebp]
	push	edx
	mov	eax, DWORD PTR _im$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _im$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _im$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _kvz_array_md5
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 97   : 
; 98   :   /* The number of chroma pixels is half that of luma. */
; 99   :   if (im->chroma_format != KVZ_CSP_400) {

	mov	eax, DWORD PTR _im$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN1@kvz_image_

; 100  :     kvz_array_md5(im->u, im->height >> 1, im->width >> 1, im->width >> 1, checksum_out[1], bitdepth);

	mov	esi, esp
	movzx	eax, BYTE PTR _bitdepth$[ebp]
	push	eax
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _checksum_out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+32]
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _im$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sar	edx, 1
	push	edx
	mov	eax, DWORD PTR _im$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sar	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _kvz_array_md5
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 101  :     kvz_array_md5(im->v, im->height >> 1, im->width >> 1, im->width >> 1, checksum_out[2], bitdepth);

	mov	esi, esp
	movzx	eax, BYTE PTR _bitdepth$[ebp]
	push	eax
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _checksum_out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+32]
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _im$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sar	edx, 1
	push	edx
	mov	eax, DWORD PTR _im$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sar	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR _kvz_array_md5
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@kvz_image_:

; 102  :   }
; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_image_md5 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\nal.c
;	COMDAT _kvz_image_checksum
_TEXT	SEGMENT
_im$ = 8						; size = 4
_checksum_out$ = 12					; size = 4
_bitdepth$ = 16						; size = 1
_kvz_image_checksum PROC				; COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E9BB758C_nal@c
	call	@__CheckForDebuggerJustMyCode@4

; 79   :   kvz_array_checksum(im->y, im->height, im->width, im->width, checksum_out[0], bitdepth);

	mov	esi, esp
	movzx	eax, BYTE PTR _bitdepth$[ebp]
	push	eax
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _checksum_out$[ebp]
	push	edx
	mov	eax, DWORD PTR _im$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _im$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _im$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _kvz_array_checksum
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 80   : 
; 81   :   /* The number of chroma pixels is half that of luma. */
; 82   :   if (im->chroma_format != KVZ_CSP_400) {

	mov	eax, DWORD PTR _im$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN1@kvz_image_

; 83   :     kvz_array_checksum(im->u, im->height >> 1, im->width >> 1, im->width >> 1, checksum_out[1], bitdepth);

	mov	esi, esp
	movzx	eax, BYTE PTR _bitdepth$[ebp]
	push	eax
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	ecx, DWORD PTR _checksum_out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+32]
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _im$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sar	edx, 1
	push	edx
	mov	eax, DWORD PTR _im$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sar	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _kvz_array_checksum
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 84   :     kvz_array_checksum(im->v, im->height >> 1, im->width >> 1, im->width >> 1, checksum_out[2], bitdepth);

	mov	esi, esp
	movzx	eax, BYTE PTR _bitdepth$[ebp]
	push	eax
	mov	ecx, 16					; 00000010H
	shl	ecx, 1
	add	ecx, DWORD PTR _checksum_out$[ebp]
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+32]
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _im$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sar	edx, 1
	push	edx
	mov	eax, DWORD PTR _im$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	sar	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _im$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR _kvz_array_checksum
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@kvz_image_:

; 85   :   }
; 86   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_image_checksum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\nal.c
;	COMDAT _kvz_nal_write
_TEXT	SEGMENT
_zero$ = -29						; size = 1
_start_code_prefix_one_3bytes$ = -17			; size = 1
_byte$ = -5						; size = 1
_bitstream$ = 8						; size = 4
_nal_type$ = 12						; size = 1
_temporal_id$ = 16					; size = 1
_long_start_code$ = 20					; size = 4
_kvz_nal_write PROC					; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __E9BB758C_nal@c
	call	@__CheckForDebuggerJustMyCode@4

; 45   :   uint8_t byte;
; 46   : 
; 47   :   // Some useful constants
; 48   :   const uint8_t start_code_prefix_one_3bytes = 0x01;

	mov	BYTE PTR _start_code_prefix_one_3bytes$[ebp], 1

; 49   :   const uint8_t zero = 0x00;

	mov	BYTE PTR _zero$[ebp], 0

; 50   : 
; 51   :   // zero_byte (0x00) shall be present in the byte stream NALU of VPS, SPS
; 52   :   // and PPS, or the first NALU of an access unit
; 53   :   if(long_start_code)

	cmp	DWORD PTR _long_start_code$[ebp], 0
	je	SHORT $LN2@kvz_nal_wr

; 54   :     kvz_bitstream_writebyte(bitstream, zero);

	movzx	eax, BYTE PTR _zero$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitstream$[ebp]
	push	ecx
	call	_kvz_bitstream_writebyte
	add	esp, 8
$LN2@kvz_nal_wr:

; 55   : 
; 56   :   // start_code_prefix_one_3bytes
; 57   :   kvz_bitstream_writebyte(bitstream, zero);

	movzx	eax, BYTE PTR _zero$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitstream$[ebp]
	push	ecx
	call	_kvz_bitstream_writebyte
	add	esp, 8

; 58   :   kvz_bitstream_writebyte(bitstream, zero);

	movzx	eax, BYTE PTR _zero$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitstream$[ebp]
	push	ecx
	call	_kvz_bitstream_writebyte
	add	esp, 8

; 59   :   kvz_bitstream_writebyte(bitstream, start_code_prefix_one_3bytes);

	movzx	eax, BYTE PTR _start_code_prefix_one_3bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitstream$[ebp]
	push	ecx
	call	_kvz_bitstream_writebyte
	add	esp, 8

; 60   : 
; 61   :   // Handle header bits with full bytes instead of using bitstream
; 62   :   // forbidden_zero_flag(1) + nal_unit_type(6) + 1bit of nuh_layer_id
; 63   :   byte = nal_type << 1;

	movzx	eax, BYTE PTR _nal_type$[ebp]
	shl	eax, 1
	mov	BYTE PTR _byte$[ebp], al

; 64   :   kvz_bitstream_writebyte(bitstream, byte);

	movzx	eax, BYTE PTR _byte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitstream$[ebp]
	push	ecx
	call	_kvz_bitstream_writebyte
	add	esp, 8

; 65   : 
; 66   :   // 5bits of nuh_layer_id + nuh_temporal_id_plus1(3)
; 67   :   byte = (temporal_id + 1) & 7;

	movzx	eax, BYTE PTR _temporal_id$[ebp]
	add	eax, 1
	and	eax, 7
	mov	BYTE PTR _byte$[ebp], al

; 68   :   kvz_bitstream_writebyte(bitstream, byte);

	movzx	eax, BYTE PTR _byte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitstream$[ebp]
	push	ecx
	call	_kvz_bitstream_writebyte
	add	esp, 8

; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_nal_write ENDP
_TEXT	ENDS
END
