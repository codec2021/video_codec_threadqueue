; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__6C65A336_cu@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__546CF5FC_crypto@h DB 01H
__6BE1C69C_encoderstate@h DB 01H
__451C3417_search_inter@c DB 01H
msvcjmc	ENDS
CONST	SEGMENT
_cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
_default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
_g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
_g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
_g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
_g_sig_last_scan_cg DD FLAT:_g_sig_last_scan_8x8
	DD	FLAT:_g_sig_last_scan_8x8+16
	DD	FLAT:_g_sig_last_scan_8x8+32
	DD	FLAT:_g_sig_last_scan_8x8
	DD	FLAT:_g_sig_last_scan_8x8+16
	DD	FLAT:_g_sig_last_scan_8x8+32
	DD	FLAT:_g_sig_last_scan_16x16
	DD	00H
	DD	00H
	DD	FLAT:_g_sig_last_scan_32x32
	DD	00H
	DD	00H
_g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
_g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+2
?small_hexbs@?1??early_terminate@@9@9 DD 00H		; `early_terminate'::`2'::small_hexbs
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
?large_hexbs@?1??hexagon_search@@9@9 DD 00H		; `hexagon_search'::`2'::large_hexbs
	DD	00H
	DD	01H
	DD	0fffffffeH
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	0ffffffffH
	DD	02H
	DD	0fffffffeH
	DD	00H
	DD	0ffffffffH
	DD	0fffffffeH
	DD	01H
	DD	0fffffffeH
	DD	02H
	DD	00H
?small_hexbs@?1??hexagon_search@@9@9 DD 00H		; `hexagon_search'::`2'::small_hexbs
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
?diamond@?1??diamond_search@@9@9 DD 00H			; `diamond_search'::`2'::diamond
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
?square@?1??search_frac@@9@9 DD 00H			; `search_frac'::`2'::square
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
?priorityList0@?1??search_pu_inter_bipred@@9@9 DB 00H	; `search_pu_inter_bipred'::`2'::priorityList0
	DB	01H
	DB	00H
	DB	02H
	DB	01H
	DB	02H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	02H
	DB	03H
?priorityList1@?1??search_pu_inter_bipred@@9@9 DB 01H	; `search_pu_inter_bipred'::`2'::priorityList1
	DB	00H
	DB	02H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	02H
CONST	ENDS
PUBLIC	_kvz_search_cu_inter
PUBLIC	_kvz_search_cu_smp
PUBLIC	_kvz_tz_pattern_search
PUBLIC	_kvz_tz_raster_search
PUBLIC	_kvz_cu_cost_inter_rd2
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??kvz_tz_pattern_search@@9@9	; `kvz_tz_pattern_search'::`1'::__LINE__Var
PUBLIC	??_C@_1HG@OHIPOECE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ ; `string'
PUBLIC	??_C@_1CC@GBDINMAN@?$AAp?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DM?$AA?5@ ; `string'
PUBLIC	?__LINE__Var@?0??search_pu_inter_ref@@9@9	; `search_pu_inter_ref'::`1'::__LINE__Var
PUBLIC	??_C@_1DG@NACHCKLO@?$AAL?$AAX?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?5?$AAL?$AAX?$AA_?$AAI?$AAD?$AAX@ ; `string'
PUBLIC	?__LINE__Var@?0??search_pu_inter@@9@9		; `search_pu_inter'::`1'::__LINE__Var
PUBLIC	??_C@_1JE@IKKFMGED@?$AAf?$AAr?$AAa?$AAc?$AAm?$AAv?$AA_?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA_?$AAt@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fee666666666666
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@7fee42d130773b76
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp___wassert:PROC
EXTRN	_abs:PROC
EXTRN	_kvz_image_calc_sad:PROC
EXTRN	_kvz_image_calc_satd:PROC
EXTRN	_kvz_cu_array_at_const:PROC
EXTRN	_kvz_inter_recon_cu:PROC
EXTRN	_kvz_inter_pred_pu:PROC
EXTRN	_kvz_inter_recon_bipred:PROC
EXTRN	_kvz_inter_get_mv_cand:PROC
EXTRN	_kvz_inter_get_merge_cand:PROC
EXTRN	_kvz_calc_mvd_cost_cabac:PROC
EXTRN	_kvz_get_mvd_coding_cost_cabac:PROC
EXTRN	_kvz_sort_modes:PROC
EXTRN	_kvz_cu_rd_cost_luma:PROC
EXTRN	_kvz_cu_rd_cost_chroma:PROC
EXTRN	_kvz_lcu_fill_trdepth:PROC
EXTRN	_kvz_quantize_lcu_residual:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtoui3:PROC
EXTRN	_memset:PROC
EXTRN	_kvz_part_mode_num_parts:BYTE
EXTRN	_kvz_part_mode_offsets:BYTE
EXTRN	_kvz_part_mode_sizes:BYTE
EXTRN	_kvz_filter_hpel_blocks_hor_ver_luma:DWORD
EXTRN	_kvz_filter_hpel_blocks_diag_luma:DWORD
EXTRN	_kvz_filter_qpel_blocks_hor_ver_luma:DWORD
EXTRN	_kvz_filter_qpel_blocks_diag_luma:DWORD
EXTRN	_kvz_get_extended_block:DWORD
EXTRN	_kvz_satd_any_size:DWORD
EXTRN	_kvz_satd_any_size_quad:DWORD
EXTRN	_kvz_get_optimized_sad:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@7fee42d130773b76
CONST	SEGMENT
__real@7fee42d130773b76 DQ 07fee42d130773b76r	; 1.7e+308
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+09
CONST	ENDS
;	COMDAT __real@3fee666666666666
CONST	SEGMENT
__real@3fee666666666666 DQ 03fee666666666666r	; 0.95
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1JE@IKKFMGED@?$AAf?$AAr?$AAa?$AAc?$AAm?$AAv?$AA_?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA_?$AAt@
CONST	SEGMENT
??_C@_1JE@IKKFMGED@?$AAf?$AAr?$AAa?$AAc?$AAm?$AAv?$AA_?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA_?$AAt@ DB 'f'
	DB	00H, 'r', 00H, 'a', 00H, 'c', 00H, 'm', 00H, 'v', 00H, '_', 00H
	DB	'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'i', 00H, 'n', 00H, '_'
	DB	00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '(', 00H, '&', 00H
	DB	'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, ',', 00H, ' ', 00H, 'c'
	DB	00H, 'u', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'u', 00H, '-', 00H
	DB	'>', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '.'
	DB	00H, 'm', 00H, 'v', 00H, '[', 00H, '0', 00H, ']', 00H, '[', 00H
	DB	'0', 00H, ']', 00H, ',', 00H, ' ', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, '_', 00H, 'c', 00H, 'u', 00H, '-', 00H, '>', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'm', 00H, 'v'
	DB	00H, '[', 00H, '0', 00H, ']', 00H, '[', 00H, '1', 00H, ']', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??search_pu_inter@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??search_pu_inter@@9@9 DD 0660H		; `search_pu_inter'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DG@NACHCKLO@?$AAL?$AAX?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?5?$AAL?$AAX?$AA_?$AAI?$AAD?$AAX@
CONST	SEGMENT
??_C@_1DG@NACHCKLO@?$AAL?$AAX?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?5?$AAL?$AAX?$AA_?$AAI?$AAD?$AAX@ DB 'L'
	DB	00H, 'X', 00H, '_', 00H, 'i', 00H, 'd', 00H, 'x', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 'L', 00H, 'X', 00H, '_', 00H, 'I', 00H, 'D'
	DB	00H, 'X', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'X', 00H, '_', 00H
	DB	'P', 00H, 'L', 00H, 'U', 00H, 'S', 00H, '_', 00H, '1', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??search_pu_inter_ref@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??search_pu_inter_ref@@9@9 DD 04c6H	; `search_pu_inter_ref'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CC@GBDINMAN@?$AAp?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DM?$AA?5@
CONST	SEGMENT
??_C@_1CC@GBDINMAN@?$AAp?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DM?$AA?5@ DB 'p'
	DB	00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, '4', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1HG@OHIPOECE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
CONST	SEGMENT
??_C@_1HG@OHIPOECE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ DB 'F'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c', 00H, '_'
	DB	00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H, '_', 00H
	DB	'2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k', 00H, 'v'
	DB	00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H, '-', 00H
	DB	'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H, 'e', 00H
	DB	'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '_', 00H, 'i', 00H, 'n'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_tz_pattern_search@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_tz_pattern_search@@9@9 DD 01e8H	; `kvz_tz_pattern_search'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _kvz_cu_cost_inter_rd2
_TEXT	SEGMENT
tv220 = -236						; size = 8
tv92 = -236						; size = 4
tv226 = -232						; size = 4
tv90 = -232						; size = 4
tv75 = -232						; size = 4
_reconstruct_chroma$ = -29				; size = 1
_tr_depth$ = -20					; size = 4
_cur_cu$ = -8						; size = 4
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_depth$ = 20						; size = 4
_lcu$ = 24						; size = 4
_inter_cost$ = 28					; size = 4
_inter_bitcost$ = 32					; size = 4
_kvz_cu_cost_inter_rd2 PROC				; COMDAT

; 1950 :   uint32_t *inter_bitcost){

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 1951 : 
; 1952 :   cu_info_t *cur_cu = LCU_GET_CU_AT_PX(lcu, SUB_SCU(x), SUB_SCU(y));

	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 63					; 0000003fH
	sar	eax, 2
	mov	ecx, DWORD PTR _y$[ebp]
	and	ecx, 63					; 0000003fH
	sar	ecx, 2
	imul	edx, ecx, 17
	lea	eax, DWORD PTR [eax+edx+18]
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _lcu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+24976]
	mov	DWORD PTR _cur_cu$[ebp], eax

; 1953 :   int tr_depth = MAX(1, depth);

	cmp	DWORD PTR _depth$[ebp], 1
	jge	SHORT $LN5@kvz_cu_cos
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN6@kvz_cu_cos
$LN5@kvz_cu_cos:
	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR tv75[ebp], eax
$LN6@kvz_cu_cos:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _tr_depth$[ebp], ecx

; 1954 :   if (cur_cu->part_size != SIZE_2Nx2N) {

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax]
	shr	cl, 5
	and	cl, 7
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@kvz_cu_cos

; 1955 :     tr_depth = depth + 1;

	mov	eax, DWORD PTR _depth$[ebp]
	add	eax, 1
	mov	DWORD PTR _tr_depth$[ebp], eax
$LN2@kvz_cu_cos:

; 1956 :   }
; 1957 :   kvz_lcu_fill_trdepth(lcu, x, y, depth, tr_depth);

	mov	eax, DWORD PTR _tr_depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcu$[ebp]
	push	ecx
	call	_kvz_lcu_fill_trdepth
	add	esp, 20					; 00000014H

; 1958 : 
; 1959 :   const bool reconstruct_chroma = state->encoder_control->chroma_format != KVZ_CSP_400;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+2536], 0
	je	SHORT $LN7@kvz_cu_cos
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN8@kvz_cu_cos
$LN7@kvz_cu_cos:
	mov	DWORD PTR tv90[ebp], 0
$LN8@kvz_cu_cos:
	cmp	DWORD PTR tv90[ebp], 0
	jne	SHORT $LN9@kvz_cu_cos
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $LN10@kvz_cu_cos
$LN9@kvz_cu_cos:
	mov	DWORD PTR tv92[ebp], 1
$LN10@kvz_cu_cos:
	mov	dl, BYTE PTR tv92[ebp]
	mov	BYTE PTR _reconstruct_chroma$[ebp], dl

; 1960 :   kvz_inter_recon_cu(state, lcu, x, y, CU_WIDTH_FROM_DEPTH(depth), true, reconstruct_chroma);

	movzx	eax, BYTE PTR _reconstruct_chroma$[ebp]
	push	eax
	push	1
	mov	edx, 64					; 00000040H
	mov	ecx, DWORD PTR _depth$[ebp]
	sar	edx, cl
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcu$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_inter_recon_cu
	add	esp, 28					; 0000001cH

; 1961 :   kvz_quantize_lcu_residual(state, true, reconstruct_chroma,

	push	0
	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	push	0
	movzx	ecx, BYTE PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _reconstruct_chroma$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_kvz_quantize_lcu_residual
	add	esp, 36					; 00000024H

; 1962 :     x, y, depth,
; 1963 :     NULL,
; 1964 :     lcu,
; 1965 :     false);
; 1966 : 
; 1967 :   *inter_cost = kvz_cu_rd_cost_luma(state, SUB_SCU(x), SUB_SCU(y), depth, cur_cu, lcu);

	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	and	eax, 63					; 0000003fH
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 63					; 0000003fH
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_kvz_cu_rd_cost_luma
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR _inter_cost$[ebp]
	fstp	QWORD PTR [eax]

; 1968 :   if (reconstruct_chroma) {

	movzx	eax, BYTE PTR _reconstruct_chroma$[ebp]
	test	eax, eax
	je	SHORT $LN3@kvz_cu_cos

; 1969 :     *inter_cost += kvz_cu_rd_cost_chroma(state, SUB_SCU(x), SUB_SCU(y), depth, cur_cu, lcu);

	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	and	eax, 63					; 0000003fH
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 63					; 0000003fH
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_kvz_cu_rd_cost_chroma
	add	esp, 24					; 00000018H
	fstp	QWORD PTR tv220[ebp]
	mov	eax, DWORD PTR _inter_cost$[ebp]
	movsd	xmm0, QWORD PTR tv220[ebp]
	addsd	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR _inter_cost$[ebp]
	movsd	QWORD PTR [ecx], xmm0
$LN3@kvz_cu_cos:

; 1970 :   }
; 1971 : 
; 1972 :   *inter_cost += *inter_bitcost * state->lambda;

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv226[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv226[ebp]
	mov	edx, DWORD PTR tv226[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _state$[ebp]
	mulsd	xmm0, QWORD PTR [eax+296]
	mov	ecx, DWORD PTR _inter_cost$[ebp]
	addsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _inter_cost$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 1973 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_cu_cost_inter_rd2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _search_pu_inter
_TEXT	SEGMENT
tv619 = -1108						; size = 4
tv407 = -1108						; size = 4
tv149 = -1108						; size = 4
tv143 = -1108						; size = 4
tv1768 = -1104						; size = 4
tv1653 = -1104						; size = 4
tv1645 = -1104						; size = 4
tv1406 = -1104						; size = 4
tv617 = -1104						; size = 4
tv528 = -1104						; size = 4
tv405 = -1104						; size = 4
tv401 = -1104						; size = 4
tv171 = -1104						; size = 4
tv147 = -1104						; size = 4
tv141 = -1104						; size = 4
_merge_idx$1 = -712					; size = 4
_cu_mv_cand$2 = -700					; size = 4
_reflist$3 = -688					; size = 4
_merge_idx$4 = -676					; size = 4
_extra_bits$5 = -664					; size = 4
_mv_ref_coded$6 = -652					; size = 2
_bitcost$7 = -640					; size = 8
_cost$8 = -624						; size = 4
_src$9 = -612						; size = 4
_rec$10 = -600						; size = 4
_mv$11 = -588						; size = 8
_merge_cand$12 = -572					; size = 4
_ref_LX$13 = -560					; size = 4
_ref$14 = -548						; size = 4
_can_use_bipred$ = -533					; size = 1
_ref_idx$15 = -524					; size = 4
_unipreds$ = -512					; size = 40
_best_cost_LX$ = -464					; size = 16
_merge_idx$16 = -440					; size = 4
_merge_rdo_idx$17 = -428				; size = 4
_has_chroma$ = -413					; size = 1
_is_duplicate$18 = -401					; size = 1
_cur_cand$19 = -392					; size = 4
_merge_idx$20 = -380					; size = 4
_num_rdo_cands$ = -368					; size = 4
_i$21 = -356						; size = 4
_mrg_costs$ = -344					; size = 40
_mrg_cands$ = -296					; size = 5
_info$ = -280						; size = 128
_cur_cu$ = -144						; size = 4
_y_local$ = -132					; size = 4
_x_local$ = -120					; size = 4
_merge_b1$ = -105					; size = 1
_merge_a1$ = -93					; size = 1
_height$ = -84						; size = 4
_width$ = -72						; size = 4
_y$ = -60						; size = 4
_x$ = -48						; size = 4
_width_cu$ = -36					; size = 4
_frame$ = -24						; size = 4
_cfg$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_state$ = 8						; size = 4
_x_cu$ = 12						; size = 4
_y_cu$ = 16						; size = 4
_depth$ = 20						; size = 4
_part_mode$ = 24					; size = 4
_i_pu$ = 28						; size = 4
_lcu$ = 32						; size = 4
_inter_cost$ = 36					; size = 4
_inter_bitcost$ = 40					; size = 4
_search_pu_inter PROC					; COMDAT

; 1632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1108				; 00000454H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1108]
	mov	ecx, 277				; 00000115H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 1633 :   *inter_cost = MAX_INT;

	mov	eax, DWORD PTR _inter_cost$[ebp]
	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	movsd	QWORD PTR [eax], xmm0

; 1634 :   *inter_bitcost = MAX_INT;

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [eax], 2147483647		; 7fffffffH

; 1635 : 
; 1636 :   const kvz_config *cfg = &state->encoder_control->cfg;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _cfg$[ebp], ecx

; 1637 :   const videoframe_t * const frame = state->tile->frame;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _frame$[ebp], edx

; 1638 :   const int width_cu  = LCU_WIDTH >> depth;

	mov	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _depth$[ebp]
	sar	eax, cl
	mov	DWORD PTR _width_cu$[ebp], eax

; 1639 :   const int x         = PU_GET_X(part_mode, width_cu, x_cu, i_pu);

	mov	eax, DWORD PTR _i_pu$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _part_mode$[ebp]
	lea	edx, DWORD PTR _kvz_part_mode_offsets[eax+ecx*8]
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	eax, BYTE PTR [edx+ecx]
	imul	eax, DWORD PTR _width_cu$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, DWORD PTR _x_cu$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 1640 :   const int y         = PU_GET_Y(part_mode, width_cu, y_cu, i_pu);

	mov	eax, DWORD PTR _i_pu$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _part_mode$[ebp]
	lea	edx, DWORD PTR _kvz_part_mode_offsets[eax+ecx*8]
	mov	eax, 1
	shl	eax, 0
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR _width_cu$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, DWORD PTR _y_cu$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 1641 :   const int width     = PU_GET_W(part_mode, width_cu, i_pu);

	mov	eax, DWORD PTR _i_pu$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _part_mode$[ebp]
	lea	edx, DWORD PTR _kvz_part_mode_sizes[eax+ecx*8]
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	eax, BYTE PTR [edx+ecx]
	imul	eax, DWORD PTR _width_cu$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _width$[ebp], eax

; 1642 :   const int height    = PU_GET_H(part_mode, width_cu, i_pu);

	mov	eax, DWORD PTR _i_pu$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _part_mode$[ebp]
	lea	edx, DWORD PTR _kvz_part_mode_sizes[eax+ecx*8]
	mov	eax, 1
	shl	eax, 0
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR _width_cu$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _height$[ebp], eax

; 1643 : 
; 1644 :   // Merge candidate A1 may not be used for the second PU of Nx2N, nLx2N and
; 1645 :   // nRx2N partitions.
; 1646 :   const bool merge_a1 = i_pu == 0 || width >= height;

	cmp	DWORD PTR _i_pu$[ebp], 0
	je	SHORT $LN52@search_pu_
	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jge	SHORT $LN52@search_pu_
	mov	DWORD PTR tv141[ebp], 0
	jmp	SHORT $LN53@search_pu_
$LN52@search_pu_:
	mov	DWORD PTR tv141[ebp], 1
$LN53@search_pu_:
	cmp	DWORD PTR tv141[ebp], 0
	jne	SHORT $LN54@search_pu_
	mov	DWORD PTR tv143[ebp], 0
	jmp	SHORT $LN55@search_pu_
$LN54@search_pu_:
	mov	DWORD PTR tv143[ebp], 1
$LN55@search_pu_:
	mov	cl, BYTE PTR tv143[ebp]
	mov	BYTE PTR _merge_a1$[ebp], cl

; 1647 :   // Merge candidate B1 may not be used for the second PU of 2NxN, 2NxnU and
; 1648 :   // 2NxnD partitions.
; 1649 :   const bool merge_b1 = i_pu == 0 || width <= height;

	cmp	DWORD PTR _i_pu$[ebp], 0
	je	SHORT $LN56@search_pu_
	mov	eax, DWORD PTR _width$[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jle	SHORT $LN56@search_pu_
	mov	DWORD PTR tv147[ebp], 0
	jmp	SHORT $LN57@search_pu_
$LN56@search_pu_:
	mov	DWORD PTR tv147[ebp], 1
$LN57@search_pu_:
	cmp	DWORD PTR tv147[ebp], 0
	jne	SHORT $LN58@search_pu_
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN59@search_pu_
$LN58@search_pu_:
	mov	DWORD PTR tv149[ebp], 1
$LN59@search_pu_:
	mov	cl, BYTE PTR tv149[ebp]
	mov	BYTE PTR _merge_b1$[ebp], cl

; 1650 : 
; 1651 :   const int x_local   = SUB_SCU(x);

	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _x_local$[ebp], eax

; 1652 :   const int y_local   = SUB_SCU(y);

	mov	eax, DWORD PTR _y$[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _y_local$[ebp], eax

; 1653 :   cu_info_t *cur_cu   = LCU_GET_CU_AT_PX(lcu, x_local, y_local);

	mov	eax, DWORD PTR _x_local$[ebp]
	sar	eax, 2
	mov	ecx, DWORD PTR _y_local$[ebp]
	sar	ecx, 2
	imul	edx, ecx, 17
	lea	eax, DWORD PTR [eax+edx+18]
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _lcu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+24976]
	mov	DWORD PTR _cur_cu$[ebp], eax

; 1654 : 
; 1655 :   inter_search_info_t info = {

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR _info$[ebp], eax
	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _info$[ebp+4], ecx
	mov	DWORD PTR _info$[ebp+8], 0
	mov	DWORD PTR _info$[ebp+12], 0
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _info$[ebp+16], eax
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _info$[ebp+20], eax
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _info$[ebp+24], eax
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _info$[ebp+28], eax
	xor	eax, eax
	mov	DWORD PTR _info$[ebp+32], eax
	mov	DWORD PTR _info$[ebp+36], eax
	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _info$[ebp+40]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _info$[ebp+100], 0
	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2332]
	test	ecx, ecx
	je	SHORT $LN60@search_pu_
	mov	DWORD PTR tv171[ebp], OFFSET _kvz_calc_mvd_cost_cabac
	jmp	SHORT $LN61@search_pu_
$LN60@search_pu_:
	mov	DWORD PTR tv171[ebp], OFFSET _calc_mvd_cost
$LN61@search_pu_:
	mov	edx, DWORD PTR tv171[ebp]
	mov	DWORD PTR _info$[ebp+104], edx
	mov	DWORD PTR _info$[ebp+108], 0
	mov	DWORD PTR _info$[ebp+112], 0
	mov	DWORD PTR _info$[ebp+116], 0
	mov	DWORD PTR _info$[ebp+120], 0
	mov	esi, esp
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	DWORD PTR _kvz_get_optimized_sad
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _info$[ebp+124], eax

; 1656 :     .state          = state,
; 1657 :     .pic            = frame->source,
; 1658 :     .origin         = { x, y },
; 1659 :     .width          = width,
; 1660 :     .height         = height,
; 1661 :     .mvd_cost_func  = cfg->mv_rdo ? kvz_calc_mvd_cost_cabac : calc_mvd_cost,
; 1662 :     .optimized_sad  = kvz_get_optimized_sad(width),
; 1663 :   };
; 1664 : 
; 1665 :   // Search for merge mode candidates
; 1666 :   info.num_merge_cand = kvz_inter_get_merge_cand(

	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	lea	ecx, DWORD PTR _info$[ebp+40]
	push	ecx
	movzx	edx, BYTE PTR _merge_b1$[ebp]
	push	edx
	movzx	eax, BYTE PTR _merge_a1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_kvz_inter_get_merge_cand
	add	esp, 36					; 00000024H
	movzx	eax, al
	mov	DWORD PTR _info$[ebp+100], eax
$LN4@search_pu_:

; 1667 :       state,
; 1668 :       x, y,
; 1669 :       width, height,
; 1670 :       merge_a1, merge_b1,
; 1671 :       info.merge_cand,
; 1672 :       lcu
; 1673 :   );
; 1674 : 
; 1675 :   // Default to candidate 0
; 1676 :   CU_SET_MV_CAND(cur_cu, 0, 0);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN29@search_pu_
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	and	cl, 248					; 000000f8H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+18], cl
	jmp	SHORT $LN30@search_pu_
$LN29@search_pu_:
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	and	cl, 199					; 000000c7H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+18], cl
$LN30@search_pu_:
	xor	eax, eax
	jne	SHORT $LN4@search_pu_
$LN3@search_pu_:

; 1677 :   CU_SET_MV_CAND(cur_cu, 1, 0);

	xor	eax, eax
	je	SHORT $LN31@search_pu_
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	and	cl, 248					; 000000f8H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+18], cl
	jmp	SHORT $LN32@search_pu_
$LN31@search_pu_:
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	and	cl, 199					; 000000c7H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+18], cl
$LN32@search_pu_:
	xor	eax, eax
	jne	SHORT $LN3@search_pu_

; 1678 : 
; 1679 :   // Merge Analysis starts here
; 1680 :   int8_t mrg_cands[MRG_MAX_NUM_CANDS];
; 1681 :   double mrg_costs[MRG_MAX_NUM_CANDS];
; 1682 :   for (int i = 0; i < MRG_MAX_NUM_CANDS; ++i) {

	mov	DWORD PTR _i$21[ebp], 0
	jmp	SHORT $LN10@search_pu_
$LN8@search_pu_:
	mov	eax, DWORD PTR _i$21[ebp]
	add	eax, 1
	mov	DWORD PTR _i$21[ebp], eax
$LN10@search_pu_:
	cmp	DWORD PTR _i$21[ebp], 5
	jge	SHORT $LN9@search_pu_

; 1683 :     mrg_cands[i] = -1;

	mov	eax, DWORD PTR _i$21[ebp]
	mov	BYTE PTR _mrg_cands$[ebp+eax], -1

; 1684 :     mrg_costs[i] = MAX_DOUBLE;

	mov	eax, DWORD PTR _i$21[ebp]
	movsd	xmm0, QWORD PTR __real@7fee42d130773b76
	movsd	QWORD PTR _mrg_costs$[ebp+eax*8], xmm0

; 1685 :   }

	jmp	SHORT $LN8@search_pu_
$LN9@search_pu_:

; 1686 : 
; 1687 :   int num_rdo_cands = 0;

	mov	DWORD PTR _num_rdo_cands$[ebp], 0

; 1688 : 
; 1689 :   // Check motion vector constraints and perform rough search
; 1690 :   for (int merge_idx = 0; merge_idx < info.num_merge_cand; ++merge_idx) {

	mov	DWORD PTR _merge_idx$20[ebp], 0
	jmp	SHORT $LN13@search_pu_
$LN11@search_pu_:
	mov	eax, DWORD PTR _merge_idx$20[ebp]
	add	eax, 1
	mov	DWORD PTR _merge_idx$20[ebp], eax
$LN13@search_pu_:
	mov	eax, DWORD PTR _merge_idx$20[ebp]
	cmp	eax, DWORD PTR _info$[ebp+100]
	jge	$LN12@search_pu_

; 1691 : 
; 1692 :     inter_merge_cand_t *cur_cand = &info.merge_cand[merge_idx];

	imul	eax, DWORD PTR _merge_idx$20[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	DWORD PTR _cur_cand$19[ebp], ecx

; 1693 :     cur_cu->inter.mv_dir = cur_cand->dir;

	mov	eax, DWORD PTR _cur_cand$19[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 3
	shl	cl, 6
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	al, BYTE PTR [edx+18]
	and	al, 63					; 0000003fH
	or	al, cl
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [ecx+18], al

; 1694 :     cur_cu->inter.mv_ref[0] = cur_cand->ref[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	esi, DWORD PTR _cur_cand$19[ebp]
	mov	cl, BYTE PTR [esi+ecx+1]
	mov	BYTE PTR [edx+eax+16], cl

; 1695 :     cur_cu->inter.mv_ref[1] = cur_cand->ref[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	esi, DWORD PTR _cur_cand$19[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx+16], al

; 1696 :     cur_cu->inter.mv[0][0] = cur_cand->mv[0][0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur_cand$19[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1697 :     cur_cu->inter.mv[0][1] = cur_cand->mv[0][1];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur_cand$19[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [esi+edx+8]
	mov	esi, 2
	shl	esi, 0
	mov	ax, WORD PTR [eax+ecx]
	mov	WORD PTR [edx+esi], ax

; 1698 :     cur_cu->inter.mv[1][0] = cur_cand->mv[1][0];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cur_cand$19[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, 4
	shl	eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [esi+eax+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	cx, WORD PTR [edx+ecx]
	mov	WORD PTR [eax+esi], cx

; 1699 :     cur_cu->inter.mv[1][1] = cur_cand->mv[1][1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cur_cand$19[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+8]
	mov	esi, 2
	shl	esi, 0
	mov	dx, WORD PTR [edx+eax]
	mov	WORD PTR [ecx+esi], dx

; 1700 : 
; 1701 :     // If bipred is not enabled, do not try candidates with mv_dir == 3.
; 1702 :     // Bipred is also forbidden for 4x8 and 8x4 blocks by the standard. 
; 1703 :     if (cur_cu->inter.mv_dir == 3 && !state->encoder_control->cfg.bipred) continue;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	shr	cl, 6
	and	cl, 3
	movzx	edx, cl
	cmp	edx, 3
	jne	SHORT $LN33@search_pu_
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+92], 0
	jne	SHORT $LN33@search_pu_
	jmp	$LN11@search_pu_
$LN33@search_pu_:

; 1704 :     if (cur_cu->inter.mv_dir == 3 && !(width + height > 12)) continue;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	shr	cl, 6
	and	cl, 3
	movzx	edx, cl
	cmp	edx, 3
	jne	SHORT $LN34@search_pu_
	mov	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _height$[ebp]
	cmp	eax, 12					; 0000000cH
	jg	SHORT $LN34@search_pu_
	jmp	$LN11@search_pu_
$LN34@search_pu_:

; 1705 : 
; 1706 :     bool is_duplicate = merge_candidate_in_list(info.merge_cand, cur_cand,

	mov	eax, DWORD PTR _num_rdo_cands$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mrg_cands$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur_cand$19[ebp]
	push	edx
	lea	eax, DWORD PTR _info$[ebp+40]
	push	eax
	call	_merge_candidate_in_list
	add	esp, 16					; 00000010H
	mov	BYTE PTR _is_duplicate$18[ebp], al

; 1707 :       mrg_cands, 
; 1708 :       num_rdo_cands);
; 1709 : 
; 1710 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1711 :     // Don't add duplicates to list
; 1712 :     if (!fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]) ||
; 1713 :         !fracmv_within_tile(&info, cur_cu->inter.mv[1][0], cur_cu->inter.mv[1][1]) ||

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	push	eax
	lea	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN36@search_pu_
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [eax+edx+8]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	push	ecx
	lea	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN36@search_pu_
	movzx	eax, BYTE PTR _is_duplicate$18[ebp]
	test	eax, eax
	je	SHORT $LN35@search_pu_
$LN36@search_pu_:

; 1714 :         is_duplicate)
; 1715 :     {
; 1716 :       continue;

	jmp	$LN11@search_pu_
$LN35@search_pu_:

; 1717 :     }
; 1718 : 
; 1719 :     kvz_inter_pred_pu(state, lcu, x_cu, y_cu, width_cu, true, false, i_pu);

	mov	eax, DWORD PTR _i_pu$[ebp]
	push	eax
	push	0
	push	1
	mov	ecx, DWORD PTR _width_cu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y_cu$[ebp]
	push	edx
	mov	eax, DWORD PTR _x_cu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_kvz_inter_pred_pu
	add	esp, 32					; 00000020H

; 1720 :     mrg_costs[num_rdo_cands] = kvz_satd_any_size(width, height,

	mov	esi, esp
	push	64					; 00000040H
	mov	eax, DWORD PTR _y_local$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _x_local$[ebp]
	mov	ecx, DWORD PTR _lcu$[ebp]
	lea	edx, DWORD PTR [ecx+eax+392]
	push	edx
	push	64					; 00000040H
	mov	eax, DWORD PTR _y_local$[ebp]
	shl	eax, 6
	add	eax, DWORD PTR _x_local$[ebp]
	mov	ecx, DWORD PTR _lcu$[ebp]
	lea	edx, DWORD PTR [ecx+eax+6540]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	DWORD PTR _kvz_satd_any_size
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv1406[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1406[ebp]
	mov	edx, DWORD PTR tv1406[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _num_rdo_cands$[ebp]
	movsd	QWORD PTR _mrg_costs$[ebp+eax*8], xmm0

; 1721 :       lcu->rec.y + y_local * LCU_WIDTH + x_local, LCU_WIDTH,
; 1722 :       lcu->ref.y + y_local * LCU_WIDTH + x_local, LCU_WIDTH);
; 1723 :     
; 1724 :     // Add cost of coding the merge index
; 1725 :     mrg_costs[num_rdo_cands] += merge_idx * info.state->lambda_sqrt;

	cvtsi2sd xmm0, DWORD PTR _merge_idx$20[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mulsd	xmm0, QWORD PTR [eax+304]
	mov	ecx, DWORD PTR _num_rdo_cands$[ebp]
	addsd	xmm0, QWORD PTR _mrg_costs$[ebp+ecx*8]
	mov	edx, DWORD PTR _num_rdo_cands$[ebp]
	movsd	QWORD PTR _mrg_costs$[ebp+edx*8], xmm0

; 1726 : 
; 1727 :     mrg_cands[num_rdo_cands] = merge_idx;

	mov	eax, DWORD PTR _num_rdo_cands$[ebp]
	mov	cl, BYTE PTR _merge_idx$20[ebp]
	mov	BYTE PTR _mrg_cands$[ebp+eax], cl

; 1728 :     num_rdo_cands++;

	mov	eax, DWORD PTR _num_rdo_cands$[ebp]
	add	eax, 1
	mov	DWORD PTR _num_rdo_cands$[ebp], eax

; 1729 :   }

	jmp	$LN11@search_pu_
$LN12@search_pu_:

; 1730 : 
; 1731 :   // Sort candidates by cost
; 1732 :   kvz_sort_modes(mrg_cands, mrg_costs, num_rdo_cands);

	movzx	eax, BYTE PTR _num_rdo_cands$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mrg_costs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mrg_cands$[ebp]
	push	edx
	call	_kvz_sort_modes
	add	esp, 12					; 0000000cH

; 1733 : 
; 1734 :   // Limit by availability
; 1735 :   // TODO: Do not limit to just 1
; 1736 :   num_rdo_cands = MIN(1, num_rdo_cands);

	cmp	DWORD PTR _num_rdo_cands$[ebp], 1
	jle	SHORT $LN62@search_pu_
	mov	DWORD PTR tv401[ebp], 1
	jmp	SHORT $LN63@search_pu_
$LN62@search_pu_:
	mov	eax, DWORD PTR _num_rdo_cands$[ebp]
	mov	DWORD PTR tv401[ebp], eax
$LN63@search_pu_:
	mov	ecx, DWORD PTR tv401[ebp]
	mov	DWORD PTR _num_rdo_cands$[ebp], ecx

; 1737 :     
; 1738 :   // Early Skip Mode Decision
; 1739 :   bool has_chroma = state->encoder_control->chroma_format != KVZ_CSP_400;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+2536], 0
	je	SHORT $LN64@search_pu_
	mov	DWORD PTR tv405[ebp], 1
	jmp	SHORT $LN65@search_pu_
$LN64@search_pu_:
	mov	DWORD PTR tv405[ebp], 0
$LN65@search_pu_:
	cmp	DWORD PTR tv405[ebp], 0
	jne	SHORT $LN66@search_pu_
	mov	DWORD PTR tv407[ebp], 0
	jmp	SHORT $LN67@search_pu_
$LN66@search_pu_:
	mov	DWORD PTR tv407[ebp], 1
$LN67@search_pu_:
	mov	dl, BYTE PTR tv407[ebp]
	mov	BYTE PTR _has_chroma$[ebp], dl

; 1740 :   if (cfg->early_skip && cur_cu->part_size == SIZE_2Nx2N) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2442]
	test	ecx, ecx
	je	$LN15@search_pu_
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax]
	shr	cl, 5
	and	cl, 7
	movzx	edx, cl
	test	edx, edx
	jne	$LN15@search_pu_

; 1741 :     for (int merge_rdo_idx = 0; merge_rdo_idx < num_rdo_cands; ++merge_rdo_idx) {

	mov	DWORD PTR _merge_rdo_idx$17[ebp], 0
	jmp	SHORT $LN16@search_pu_
$LN14@search_pu_:
	mov	eax, DWORD PTR _merge_rdo_idx$17[ebp]
	add	eax, 1
	mov	DWORD PTR _merge_rdo_idx$17[ebp], eax
$LN16@search_pu_:
	mov	eax, DWORD PTR _merge_rdo_idx$17[ebp]
	cmp	eax, DWORD PTR _num_rdo_cands$[ebp]
	jge	$LN15@search_pu_

; 1742 : 
; 1743 :       // Reconstruct blocks with merge candidate.
; 1744 :       // Check luma CBF. Then, check chroma CBFs if luma CBF is not set
; 1745 :       // and chroma exists.
; 1746 :       // Early terminate if merge candidate with zero CBF is found.
; 1747 :       int merge_idx = mrg_cands[merge_rdo_idx];

	mov	eax, DWORD PTR _merge_rdo_idx$17[ebp]
	movsx	ecx, BYTE PTR _mrg_cands$[ebp+eax]
	mov	DWORD PTR _merge_idx$16[ebp], ecx

; 1748 :       cur_cu->inter.mv_dir = info.merge_cand[merge_idx].dir;

	imul	eax, DWORD PTR _merge_idx$16[ebp], 12
	mov	cl, BYTE PTR _info$[ebp+eax+40]
	and	cl, 3
	shl	cl, 6
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	al, BYTE PTR [edx+18]
	and	al, 63					; 0000003fH
	or	al, cl
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [ecx+18], al

; 1749 :       cur_cu->inter.mv_ref[0] = info.merge_cand[merge_idx].ref[0];

	imul	eax, DWORD PTR _merge_idx$16[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, 1
	imul	edx, edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	mov	al, BYTE PTR [ecx+eax+1]
	mov	BYTE PTR [esi+edx+16], al

; 1750 :       cur_cu->inter.mv_ref[1] = info.merge_cand[merge_idx].ref[1];

	imul	eax, DWORD PTR _merge_idx$16[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	shl	eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [ecx+edx+1]
	mov	BYTE PTR [esi+eax+16], cl

; 1751 :       cur_cu->inter.mv[0][0] = info.merge_cand[merge_idx].mv[0][0];

	imul	eax, DWORD PTR _merge_idx$16[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [esi+edx+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	ax, WORD PTR [ecx+eax]
	mov	WORD PTR [edx+esi], ax

; 1752 :       cur_cu->inter.mv[0][1] = info.merge_cand[merge_idx].mv[0][1];

	imul	eax, DWORD PTR _merge_idx$16[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	shl	edx, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [esi+eax+8]
	mov	esi, 2
	shl	esi, 0
	mov	cx, WORD PTR [ecx+edx]
	mov	WORD PTR [eax+esi], cx

; 1753 :       cur_cu->inter.mv[1][0] = info.merge_cand[merge_idx].mv[1][0];

	imul	eax, DWORD PTR _merge_idx$16[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1754 :       cur_cu->inter.mv[1][1] = info.merge_cand[merge_idx].mv[1][1];

	imul	eax, DWORD PTR _merge_idx$16[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [esi+edx+8]
	mov	esi, 2
	shl	esi, 0
	mov	ax, WORD PTR [eax+ecx]
	mov	WORD PTR [edx+esi], ax

; 1755 :       kvz_lcu_fill_trdepth(lcu, x, y, depth, MAX(1, depth));

	cmp	DWORD PTR _depth$[ebp], 1
	jge	SHORT $LN68@search_pu_
	mov	DWORD PTR tv528[ebp], 1
	jmp	SHORT $LN69@search_pu_
$LN68@search_pu_:
	mov	eax, DWORD PTR _depth$[ebp]
	mov	DWORD PTR tv528[ebp], eax
$LN69@search_pu_:
	mov	ecx, DWORD PTR tv528[ebp]
	push	ecx
	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcu$[ebp]
	push	edx
	call	_kvz_lcu_fill_trdepth
	add	esp, 20					; 00000014H

; 1756 :       kvz_inter_recon_cu(state, lcu, x, y, width, true, false);

	push	0
	push	1
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_kvz_inter_recon_cu
	add	esp, 28					; 0000001cH

; 1757 :       kvz_quantize_lcu_residual(state, true, false, x, y, depth, cur_cu, lcu, true);

	push	1
	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	push	1
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_kvz_quantize_lcu_residual
	add	esp, 36					; 00000024H

; 1758 : 
; 1759 :       if (cbf_is_set(cur_cu->cbf, depth, COLOR_Y)) {

	push	0
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	push	edx
	call	_cbf_is_set
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN38@search_pu_

; 1760 :         continue;

	jmp	$LN14@search_pu_

; 1761 :       }

	jmp	$LN41@search_pu_
$LN38@search_pu_:

; 1762 :       else if (has_chroma) {

	movzx	eax, BYTE PTR _has_chroma$[ebp]
	test	eax, eax
	je	$LN41@search_pu_

; 1763 :         kvz_inter_recon_cu(state, lcu, x, y, width, false, has_chroma);

	movzx	eax, BYTE PTR _has_chroma$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_kvz_inter_recon_cu
	add	esp, 28					; 0000001cH

; 1764 :         kvz_quantize_lcu_residual(state, false, has_chroma, x, y, depth, cur_cu, lcu, true);

	push	1
	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _has_chroma$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_quantize_lcu_residual
	add	esp, 36					; 00000024H

; 1765 :         if (!cbf_is_set_any(cur_cu->cbf, depth)) {

	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	push	edx
	call	_cbf_is_set_any
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN41@search_pu_

; 1766 :           cur_cu->type = CU_INTER;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 252					; 000000fcH
	or	cl, 2
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx], cl

; 1767 :           cur_cu->merge_idx = merge_idx;

	mov	al, BYTE PTR _merge_idx$16[ebp]
	and	al, 7
	shl	al, 5
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	and	dl, 31					; 0000001fH
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+1], dl

; 1768 :           cur_cu->skipped = true;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+1]
	or	cl, 8
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+1], cl

; 1769 :           *inter_cost = 0.0;  // TODO: Check this

	mov	eax, DWORD PTR _inter_cost$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax], xmm0

; 1770 :           *inter_bitcost = merge_idx; // TODO: Check this

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	mov	ecx, DWORD PTR _merge_idx$16[ebp]
	mov	DWORD PTR [eax], ecx

; 1771 :           return;

	jmp	$LN74@search_pu_
$LN41@search_pu_:

; 1772 :         }
; 1773 :       }
; 1774 :     }

	jmp	$LN14@search_pu_
$LN15@search_pu_:

; 1775 :   }
; 1776 : 
; 1777 :   // AMVP search starts here
; 1778 : 
; 1779 :   // Store unipred information of L0 and L1 for biprediction
; 1780 :   // Best cost will be left at MAX_DOUBLE if no valid CU is found
; 1781 :   double best_cost_LX[2] = { MAX_DOUBLE, MAX_DOUBLE };

	movsd	xmm0, QWORD PTR __real@7fee42d130773b76
	movsd	QWORD PTR _best_cost_LX$[ebp], xmm0
	movsd	xmm0, QWORD PTR __real@7fee42d130773b76
	movsd	QWORD PTR _best_cost_LX$[ebp+8], xmm0

; 1782 :   cu_info_t unipreds[2];
; 1783 : 
; 1784 :   for (int ref_idx = 0; ref_idx < state->frame->ref->used_size; ref_idx++) {

	mov	DWORD PTR _ref_idx$15[ebp], 0
	jmp	SHORT $LN19@search_pu_
$LN17@search_pu_:
	mov	eax, DWORD PTR _ref_idx$15[ebp]
	add	eax, 1
	mov	DWORD PTR _ref_idx$15[ebp], eax
$LN19@search_pu_:
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _ref_idx$15[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jae	SHORT $LN18@search_pu_

; 1785 :     info.ref_idx = ref_idx;

	mov	eax, DWORD PTR _ref_idx$15[ebp]
	mov	DWORD PTR _info$[ebp+12], eax

; 1786 :     info.ref = state->frame->ref->images[ref_idx];

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ref_idx$15[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _info$[ebp+8], edx

; 1787 : 
; 1788 :     search_pu_inter_ref(&info, depth, lcu, cur_cu, inter_cost, inter_bitcost, best_cost_LX, unipreds);

	lea	eax, DWORD PTR _unipreds$[ebp]
	push	eax
	lea	ecx, DWORD PTR _best_cost_LX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inter_bitcost$[ebp]
	push	edx
	mov	eax, DWORD PTR _inter_cost$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcu$[ebp]
	push	edx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_search_pu_inter_ref
	add	esp, 32					; 00000020H

; 1789 :   }

	jmp	SHORT $LN17@search_pu_
$LN18@search_pu_:

; 1790 : 
; 1791 :   // Search bi-pred positions
; 1792 :   bool can_use_bipred = state->frame->slicetype == KVZ_SLICE_B

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	DWORD PTR [ecx+84], 0
	jne	SHORT $LN70@search_pu_
	mov	edx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN70@search_pu_
	mov	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _height$[ebp]
	cmp	eax, 16					; 00000010H
	jl	SHORT $LN70@search_pu_
	mov	DWORD PTR tv617[ebp], 1
	jmp	SHORT $LN71@search_pu_
$LN70@search_pu_:
	mov	DWORD PTR tv617[ebp], 0
$LN71@search_pu_:
	cmp	DWORD PTR tv617[ebp], 0
	jne	SHORT $LN72@search_pu_
	mov	DWORD PTR tv619[ebp], 0
	jmp	SHORT $LN73@search_pu_
$LN72@search_pu_:
	mov	DWORD PTR tv619[ebp], 1
$LN73@search_pu_:
	mov	cl, BYTE PTR tv619[ebp]
	mov	BYTE PTR _can_use_bipred$[ebp], cl

; 1793 :     && cfg->bipred
; 1794 :     && width + height >= 16; // 4x8 and 8x4 PBs are restricted to unipred
; 1795 : 
; 1796 :   if (can_use_bipred) {

	movzx	eax, BYTE PTR _can_use_bipred$[ebp]
	test	eax, eax
	je	$LN48@search_pu_

; 1797 : 
; 1798 :     // Try biprediction from valid acquired unipreds.
; 1799 :     if (best_cost_LX[0] != MAX_DOUBLE && best_cost_LX[1] != MAX_DOUBLE) {

	mov	eax, 8
	imul	ecx, eax, 0
	movsd	xmm0, QWORD PTR _best_cost_LX$[ebp+ecx]
	ucomisd	xmm0, QWORD PTR __real@7fee42d130773b76
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN44@search_pu_
	mov	eax, 8
	shl	eax, 0
	movsd	xmm0, QWORD PTR _best_cost_LX$[ebp+eax]
	ucomisd	xmm0, QWORD PTR __real@7fee42d130773b76
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN44@search_pu_

; 1800 : 
; 1801 :       // TODO: logic is copy paste from search_pu_inter_bipred.
; 1802 :       // Get rid of duplicate code asap.
; 1803 :       const image_list_t *const ref = info.state->frame->ref;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _ref$14[ebp], edx

; 1804 :       uint8_t(*ref_LX)[16] = info.state->frame->ref_LX;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 45					; 0000002dH
	mov	DWORD PTR _ref_LX$13[ebp], ecx

; 1805 : 
; 1806 :       inter_merge_cand_t *merge_cand = info.merge_cand;

	lea	eax, DWORD PTR _info$[ebp+40]
	mov	DWORD PTR _merge_cand$12[ebp], eax

; 1807 : 
; 1808 :       int16_t mv[2][2];
; 1809 :       mv[0][0] = unipreds[0].inter.mv[0][0];

	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _unipreds$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+8]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	lea	eax, DWORD PTR _mv$11[ebp+eax]
	mov	esi, 2
	imul	esi, esi, 0
	mov	cx, WORD PTR [edx+ecx]
	mov	WORD PTR [eax+esi], cx

; 1810 :       mv[0][1] = unipreds[0].inter.mv[0][1];

	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _unipreds$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+8]
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	lea	ecx, DWORD PTR _mv$11[ebp+ecx]
	mov	esi, 2
	shl	esi, 0
	mov	dx, WORD PTR [edx+eax]
	mov	WORD PTR [ecx+esi], dx

; 1811 :       mv[1][0] = unipreds[1].inter.mv[1][0];

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _unipreds$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+8]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, 4
	shl	ecx, 0
	lea	ecx, DWORD PTR _mv$11[ebp+ecx]
	mov	esi, 2
	imul	esi, esi, 0
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1812 :       mv[1][1] = unipreds[1].inter.mv[1][1];

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _unipreds$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+8]
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	lea	edx, DWORD PTR _mv$11[ebp+edx]
	mov	esi, 2
	shl	esi, 0
	mov	ax, WORD PTR [eax+ecx]
	mov	WORD PTR [edx+esi], ax

; 1813 : 
; 1814 :       kvz_inter_recon_bipred(info.state,

	push	0
	push	1
	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mv$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _ref_LX$13[ebp]
	mov	ecx, 20					; 00000014H
	shl	ecx, 0
	lea	edx, DWORD PTR _unipreds$[ebp+ecx]
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR [edx+ecx+16]
	movzx	eax, BYTE PTR [eax+edx]
	mov	ecx, DWORD PTR _ref$14[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _ref_LX$13[ebp]
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	eax, DWORD PTR _unipreds$[ebp+ecx]
	mov	ecx, 1
	imul	ecx, ecx, 0
	movzx	eax, BYTE PTR [eax+ecx+16]
	movzx	ecx, BYTE PTR [edx+eax]
	mov	edx, DWORD PTR _ref$14[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_kvz_inter_recon_bipred
	add	esp, 44					; 0000002cH

; 1815 :         ref->images[ref_LX[0][unipreds[0].inter.mv_ref[0]]],
; 1816 :         ref->images[ref_LX[1][unipreds[1].inter.mv_ref[1]]],
; 1817 :         x, y,
; 1818 :         width,
; 1819 :         height,
; 1820 :         mv,
; 1821 :         lcu,
; 1822 :         true,
; 1823 :         false);
; 1824 : 
; 1825 :       const kvz_pixel *rec = &lcu->rec.y[SUB_SCU(y) * LCU_WIDTH + SUB_SCU(x)];

	mov	eax, DWORD PTR _y$[ebp]
	and	eax, 63					; 0000003fH
	shl	eax, 6
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, DWORD PTR _lcu$[ebp]
	lea	edx, DWORD PTR [ecx+eax+6540]
	mov	DWORD PTR _rec$10[ebp], edx

; 1826 :       const kvz_pixel *src = &lcu->ref.y[SUB_SCU(y) * LCU_WIDTH + SUB_SCU(x)];

	mov	eax, DWORD PTR _y$[ebp]
	and	eax, 63					; 0000003fH
	shl	eax, 6
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, DWORD PTR _lcu$[ebp]
	lea	edx, DWORD PTR [ecx+eax+392]
	mov	DWORD PTR _src$9[ebp], edx

; 1827 :       uint32_t cost =

	mov	esi, esp
	push	64					; 00000040H
	mov	eax, DWORD PTR _src$9[ebp]
	push	eax
	push	64					; 00000040H
	mov	ecx, DWORD PTR _rec$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	DWORD PTR _kvz_satd_any_size
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cost$8[ebp], eax

; 1828 :         kvz_satd_any_size(width, height, rec, LCU_WIDTH, src, LCU_WIDTH);
; 1829 : 
; 1830 :       uint32_t bitcost[2] = { 0, 0 };

	mov	DWORD PTR _bitcost$7[ebp], 0
	mov	DWORD PTR _bitcost$7[ebp+4], 0

; 1831 : 
; 1832 :       cost += info.mvd_cost_func(info.state,

	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _bitcost$7[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _info$[ebp+32]
	push	eax
	push	0
	mov	ecx, 20					; 00000014H
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _unipreds$[ebp+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+8]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	push	edx
	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _unipreds$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+8]
	mov	eax, 2
	imul	ecx, eax, 0
	movsx	edx, WORD PTR [edx+ecx]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	DWORD PTR _info$[ebp+104]
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, DWORD PTR _cost$8[ebp]
	mov	DWORD PTR _cost$8[ebp], eax

; 1833 :         unipreds[0].inter.mv[0][0],
; 1834 :         unipreds[0].inter.mv[0][1],
; 1835 :         0,
; 1836 :         info.mv_cand,
; 1837 :         NULL, 0, 0,
; 1838 :         &bitcost[0]);
; 1839 :       cost += info.mvd_cost_func(info.state,

	mov	eax, 4
	shl	eax, 0
	lea	ecx, DWORD PTR _bitcost$7[ebp+eax]
	mov	esi, esp
	push	ecx
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _info$[ebp+32]
	push	edx
	push	0
	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _unipreds$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+8]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	push	edx
	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _unipreds$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+8]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	DWORD PTR _info$[ebp+104]
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, DWORD PTR _cost$8[ebp]
	mov	DWORD PTR _cost$8[ebp], eax

; 1840 :         unipreds[1].inter.mv[1][0],
; 1841 :         unipreds[1].inter.mv[1][1],
; 1842 :         0,
; 1843 :         info.mv_cand,
; 1844 :         NULL, 0, 0,
; 1845 :         &bitcost[1]);
; 1846 : 
; 1847 :       const uint8_t mv_ref_coded[2] = {

	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _unipreds$[ebp+ecx]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR [edx+ecx+16]
	mov	BYTE PTR _mv_ref_coded$6[ebp], dl
	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _unipreds$[ebp+eax]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [ecx+edx+16]
	mov	BYTE PTR _mv_ref_coded$6[ebp+1], al

; 1848 :         unipreds[0].inter.mv_ref[0],
; 1849 :         unipreds[1].inter.mv_ref[1]
; 1850 :       };
; 1851 :       const int extra_bits = mv_ref_coded[0] + mv_ref_coded[1] + 2 /* mv dir cost */;

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _mv_ref_coded$6[ebp+ecx]
	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _mv_ref_coded$6[ebp+eax]
	lea	edx, DWORD PTR [edx+ecx+2]
	mov	DWORD PTR _extra_bits$5[ebp], edx

; 1852 :       cost += info.state->lambda_sqrt * extra_bits + 0.5;

	cvtsi2sd xmm0, DWORD PTR _extra_bits$5[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mulsd	xmm0, QWORD PTR [eax+304]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	ecx, DWORD PTR _cost$8[ebp]
	mov	DWORD PTR tv1645[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv1645[ebp]
	mov	edx, DWORD PTR tv1645[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	call	__dtoui3
	mov	DWORD PTR _cost$8[ebp], eax

; 1853 : 
; 1854 :       if (cost < *inter_cost) {

	mov	eax, DWORD PTR _cost$8[ebp]
	mov	DWORD PTR tv1653[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1653[ebp]
	mov	ecx, DWORD PTR tv1653[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _inter_cost$[ebp]
	movsd	xmm1, QWORD PTR [edx]
	comisd	xmm1, xmm0
	jbe	$LN44@search_pu_

; 1855 :         cur_cu->inter.mv_dir = 3;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	or	cl, 192					; 000000c0H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+18], cl

; 1856 : 
; 1857 :         cur_cu->inter.mv_ref[0] = unipreds[0].inter.mv_ref[0];

	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _unipreds$[ebp+ecx]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, 1
	imul	eax, eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [edx+ecx+16]
	mov	BYTE PTR [esi+eax+16], cl

; 1858 :         cur_cu->inter.mv_ref[1] = unipreds[1].inter.mv_ref[1];

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _unipreds$[ebp+eax]
	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	shl	eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [ecx+edx+16]
	mov	BYTE PTR [esi+eax+16], cl

; 1859 : 
; 1860 :         cur_cu->inter.mv[0][0] = unipreds[0].inter.mv[0][0];

	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _unipreds$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+8]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [esi+eax+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	cx, WORD PTR [edx+ecx]
	mov	WORD PTR [eax+esi], cx

; 1861 :         cur_cu->inter.mv[0][1] = unipreds[0].inter.mv[0][1];

	mov	eax, 20					; 00000014H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _unipreds$[ebp+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+8]
	mov	eax, 2
	shl	eax, 0
	mov	ecx, 4
	imul	ecx, ecx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+8]
	mov	esi, 2
	shl	esi, 0
	mov	dx, WORD PTR [edx+eax]
	mov	WORD PTR [ecx+esi], dx

; 1862 :         cur_cu->inter.mv[1][0] = unipreds[1].inter.mv[1][0];

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _unipreds$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+8]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1863 :         cur_cu->inter.mv[1][1] = unipreds[1].inter.mv[1][1];

	mov	eax, 20					; 00000014H
	shl	eax, 0
	lea	ecx, DWORD PTR _unipreds$[ebp+eax]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+8]
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [esi+edx+8]
	mov	esi, 2
	shl	esi, 0
	mov	ax, WORD PTR [eax+ecx]
	mov	WORD PTR [edx+esi], ax

; 1864 :         cur_cu->merged = 0;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+1]
	and	cl, 239					; 000000efH
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+1], cl

; 1865 : 
; 1866 :         // Check every candidate to find a match
; 1867 :         for (int merge_idx = 0; merge_idx < info.num_merge_cand; merge_idx++) {

	mov	DWORD PTR _merge_idx$4[ebp], 0
	jmp	SHORT $LN22@search_pu_
$LN20@search_pu_:
	mov	eax, DWORD PTR _merge_idx$4[ebp]
	add	eax, 1
	mov	DWORD PTR _merge_idx$4[ebp], eax
$LN22@search_pu_:
	mov	eax, DWORD PTR _merge_idx$4[ebp]
	cmp	eax, DWORD PTR _info$[ebp+100]
	jge	$LN21@search_pu_

; 1868 :           if (merge_cand[merge_idx].mv[0][0] == cur_cu->inter.mv[0][0] &&
; 1869 :             merge_cand[merge_idx].mv[0][1] == cur_cu->inter.mv[0][1] &&
; 1870 :             merge_cand[merge_idx].mv[1][0] == cur_cu->inter.mv[1][0] &&
; 1871 :             merge_cand[merge_idx].mv[1][1] == cur_cu->inter.mv[1][1] &&
; 1872 :             merge_cand[merge_idx].ref[0] == cur_cu->inter.mv_ref[0] &&

	imul	eax, DWORD PTR _merge_idx$4[ebp], 12
	add	eax, DWORD PTR _merge_cand$12[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	ecx, 2
	imul	ecx, ecx, 0
	movsx	edx, WORD PTR [edx+ecx]
	cmp	eax, edx
	jne	$LN45@search_pu_
	imul	eax, DWORD PTR _merge_idx$4[ebp], 12
	add	eax, DWORD PTR _merge_cand$12[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+4]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [ecx+eax]
	cmp	edx, ecx
	jne	$LN45@search_pu_
	imul	eax, DWORD PTR _merge_idx$4[ebp], 12
	add	eax, DWORD PTR _merge_cand$12[ebp]
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+4]
	mov	eax, 2
	imul	ecx, eax, 0
	movsx	edx, WORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [ecx+eax+8]
	mov	ecx, 2
	imul	ecx, ecx, 0
	movsx	eax, WORD PTR [eax+ecx]
	cmp	edx, eax
	jne	$LN45@search_pu_
	imul	eax, DWORD PTR _merge_idx$4[ebp], 12
	add	eax, DWORD PTR _merge_cand$12[ebp]
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+4]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [eax+edx+8]
	mov	eax, 2
	shl	eax, 0
	movsx	edx, WORD PTR [edx+eax]
	cmp	ecx, edx
	jne	$LN45@search_pu_
	imul	eax, DWORD PTR _merge_idx$4[ebp], 12
	add	eax, DWORD PTR _merge_cand$12[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR [eax+edx+1]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	movzx	edx, BYTE PTR [ecx+edx+16]
	cmp	eax, edx
	jne	SHORT $LN45@search_pu_
	imul	eax, DWORD PTR _merge_idx$4[ebp], 12
	add	eax, DWORD PTR _merge_cand$12[ebp]
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR [eax+ecx+1]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+16]
	cmp	edx, eax
	jne	SHORT $LN45@search_pu_

; 1873 :             merge_cand[merge_idx].ref[1] == cur_cu->inter.mv_ref[1])
; 1874 :           {
; 1875 :             cur_cu->merged = 1;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+1]
	or	cl, 16					; 00000010H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+1], cl

; 1876 :             cur_cu->merge_idx = merge_idx;

	mov	al, BYTE PTR _merge_idx$4[ebp]
	and	al, 7
	shl	al, 5
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	and	dl, 31					; 0000001fH
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+1], dl

; 1877 :             break;

	jmp	SHORT $LN21@search_pu_
$LN45@search_pu_:

; 1878 :           }
; 1879 :         }

	jmp	$LN20@search_pu_
$LN21@search_pu_:

; 1880 : 
; 1881 :         // Each motion vector has its own candidate
; 1882 :         for (int reflist = 0; reflist < 2; reflist++) {

	mov	DWORD PTR _reflist$3[ebp], 0
	jmp	SHORT $LN25@search_pu_
$LN23@search_pu_:
	mov	eax, DWORD PTR _reflist$3[ebp]
	add	eax, 1
	mov	DWORD PTR _reflist$3[ebp], eax
$LN25@search_pu_:
	cmp	DWORD PTR _reflist$3[ebp], 2
	jge	$LN24@search_pu_

; 1883 :           kvz_inter_get_mv_cand(info.state, x, y, width, height, info.mv_cand, cur_cu, lcu, reflist);

	movzx	eax, BYTE PTR _reflist$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur_cu$[ebp]
	push	edx
	lea	eax, DWORD PTR _info$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_kvz_inter_get_mv_cand
	add	esp, 36					; 00000024H

; 1884 :           int cu_mv_cand = select_mv_cand(

	push	0
	mov	eax, DWORD PTR _reflist$3[ebp]
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+8]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	push	ecx
	mov	edx, DWORD PTR _reflist$3[ebp]
	mov	eax, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	push	ecx
	lea	edx, DWORD PTR _info$[ebp+32]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_select_mv_cand
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cu_mv_cand$2[ebp], eax
$LN28@search_pu_:

; 1885 :             info.state,
; 1886 :             info.mv_cand,
; 1887 :             cur_cu->inter.mv[reflist][0],
; 1888 :             cur_cu->inter.mv[reflist][1],
; 1889 :             NULL);
; 1890 :           CU_SET_MV_CAND(cur_cu, reflist, cu_mv_cand);

	cmp	DWORD PTR _reflist$3[ebp], 0
	jne	SHORT $LN46@search_pu_
	mov	al, BYTE PTR _cu_mv_cand$2[ebp]
	and	al, 7
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+18]
	and	dl, 248					; 000000f8H
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+18], dl
	jmp	SHORT $LN47@search_pu_
$LN46@search_pu_:
	mov	al, BYTE PTR _cu_mv_cand$2[ebp]
	and	al, 7
	shl	al, 3
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+18]
	and	dl, 199					; 000000c7H
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+18], dl
$LN47@search_pu_:
	xor	eax, eax
	jne	SHORT $LN28@search_pu_

; 1891 :         }

	jmp	$LN23@search_pu_
$LN24@search_pu_:

; 1892 : 
; 1893 :         *inter_cost = cost;

	mov	eax, DWORD PTR _cost$8[ebp]
	mov	DWORD PTR tv1768[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1768[ebp]
	mov	ecx, DWORD PTR tv1768[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _inter_cost$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 1894 :         *inter_bitcost = bitcost[0] + bitcost[1] + extra_bits;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _bitcost$7[ebp+ecx]
	add	eax, DWORD PTR _bitcost$7[ebp+edx]
	add	eax, DWORD PTR _extra_bits$5[ebp]
	mov	ecx, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [ecx], eax
$LN44@search_pu_:

; 1895 :       }
; 1896 :     }
; 1897 : 
; 1898 :     // TODO: this probably should have a separate command line option
; 1899 :     if (cfg->rdo == 3) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+64], 3
	jne	SHORT $LN48@search_pu_

; 1900 :       search_pu_inter_bipred(&info, depth, lcu, cur_cu, inter_cost, inter_bitcost);

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inter_cost$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur_cu$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_search_pu_inter_bipred
	add	esp, 24					; 00000018H
$LN48@search_pu_:

; 1901 :     }
; 1902 :   }
; 1903 : 
; 1904 :   // Compare best merge cost to amvp cost
; 1905 :   if (mrg_costs[0] < *inter_cost) {

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _inter_cost$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	comisd	xmm0, QWORD PTR _mrg_costs$[ebp+ecx]
	jbe	$LN49@search_pu_

; 1906 :     *inter_cost = mrg_costs[0];

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _inter_cost$[ebp]
	movsd	xmm0, QWORD PTR _mrg_costs$[ebp+ecx]
	movsd	QWORD PTR [edx], xmm0

; 1907 :     *inter_bitcost = 0; // TODO: Check this

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [eax], 0

; 1908 :     int merge_idx = mrg_cands[0];

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _mrg_cands$[ebp+ecx]
	mov	DWORD PTR _merge_idx$1[ebp], edx

; 1909 :     cur_cu->type = CU_INTER;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 252					; 000000fcH
	or	cl, 2
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx], cl

; 1910 :     cur_cu->merge_idx = merge_idx;

	mov	al, BYTE PTR _merge_idx$1[ebp]
	and	al, 7
	shl	al, 5
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	and	dl, 31					; 0000001fH
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+1], dl

; 1911 :     cur_cu->inter.mv_dir = info.merge_cand[merge_idx].dir;

	imul	eax, DWORD PTR _merge_idx$1[ebp], 12
	mov	cl, BYTE PTR _info$[ebp+eax+40]
	and	cl, 3
	shl	cl, 6
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	al, BYTE PTR [edx+18]
	and	al, 63					; 0000003fH
	or	al, cl
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [ecx+18], al

; 1912 :     cur_cu->inter.mv_ref[0] = info.merge_cand[merge_idx].ref[0];

	imul	eax, DWORD PTR _merge_idx$1[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, 1
	imul	edx, edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	mov	al, BYTE PTR [ecx+eax+1]
	mov	BYTE PTR [esi+edx+16], al

; 1913 :     cur_cu->inter.mv_ref[1] = info.merge_cand[merge_idx].ref[1];

	imul	eax, DWORD PTR _merge_idx$1[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	shl	eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [ecx+edx+1]
	mov	BYTE PTR [esi+eax+16], cl

; 1914 :     cur_cu->inter.mv[0][0] = info.merge_cand[merge_idx].mv[0][0];

	imul	eax, DWORD PTR _merge_idx$1[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [esi+edx+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	ax, WORD PTR [ecx+eax]
	mov	WORD PTR [edx+esi], ax

; 1915 :     cur_cu->inter.mv[0][1] = info.merge_cand[merge_idx].mv[0][1];

	imul	eax, DWORD PTR _merge_idx$1[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	shl	edx, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [esi+eax+8]
	mov	esi, 2
	shl	esi, 0
	mov	cx, WORD PTR [ecx+edx]
	mov	WORD PTR [eax+esi], cx

; 1916 :     cur_cu->inter.mv[1][0] = info.merge_cand[merge_idx].mv[1][0];

	imul	eax, DWORD PTR _merge_idx$1[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1917 :     cur_cu->inter.mv[1][1] = info.merge_cand[merge_idx].mv[1][1];

	imul	eax, DWORD PTR _merge_idx$1[ebp], 12
	lea	ecx, DWORD PTR _info$[ebp+eax+40]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [esi+edx+8]
	mov	esi, 2
	shl	esi, 0
	mov	ax, WORD PTR [eax+ecx]
	mov	WORD PTR [edx+esi], ax

; 1918 :     cur_cu->merged = true;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+1]
	or	cl, 16					; 00000010H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+1], cl

; 1919 :     cur_cu->skipped = false;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+1]
	and	cl, 247					; 000000f7H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+1], cl
$LN49@search_pu_:

; 1920 :   }
; 1921 : 
; 1922 :   if (*inter_cost < INT_MAX && cur_cu->inter.mv_dir == 1) {

	mov	eax, DWORD PTR _inter_cost$[ebp]
	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	comisd	xmm0, QWORD PTR [eax]
	jbe	$LN74@search_pu_
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	shr	cl, 6
	and	cl, 3
	movzx	edx, cl
	cmp	edx, 1
	jne	SHORT $LN74@search_pu_

; 1923 :     assert(fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]));

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	push	eax
	lea	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN74@search_pu_
	mov	eax, DWORD PTR ?__LINE__Var@?0??search_pu_inter@@9@9
	add	eax, 291				; 00000123H
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1HG@OHIPOECE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1JE@IKKFMGED@?$AAf?$AAr?$AAa?$AAc?$AAm?$AAv?$AA_?$AAw?$AAi?$AAt?$AAh?$AAi?$AAn?$AA_?$AAt@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN74@search_pu_:

; 1924 :   }
; 1925 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN84@search_pu_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1108				; 00000454H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN84@search_pu_:
	DD	8
	DD	$LN83@search_pu_
$LN83@search_pu_:
	DD	-280					; fffffee8H
	DD	128					; 00000080H
	DD	$LN75@search_pu_
	DD	-296					; fffffed8H
	DD	5
	DD	$LN76@search_pu_
	DD	-344					; fffffea8H
	DD	40					; 00000028H
	DD	$LN77@search_pu_
	DD	-464					; fffffe30H
	DD	16					; 00000010H
	DD	$LN78@search_pu_
	DD	-512					; fffffe00H
	DD	40					; 00000028H
	DD	$LN79@search_pu_
	DD	-588					; fffffdb4H
	DD	8
	DD	$LN80@search_pu_
	DD	-640					; fffffd80H
	DD	8
	DD	$LN81@search_pu_
	DD	-652					; fffffd74H
	DD	2
	DD	$LN82@search_pu_
$LN82@search_pu_:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN81@search_pu_:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN80@search_pu_:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
$LN79@search_pu_:
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	105					; 00000069H
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN78@search_pu_:
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	88					; 00000058H
	DB	0
$LN77@search_pu_:
	DB	109					; 0000006dH
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN76@search_pu_:
	DB	109					; 0000006dH
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN75@search_pu_:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
_search_pu_inter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _merge_candidate_in_list
_TEXT	SEGMENT
tv182 = -236						; size = 4
tv180 = -232						; size = 4
_list_cand$1 = -32					; size = 4
_i$2 = -20						; size = 4
_found$ = -5						; size = 1
_all_cands$ = 8						; size = 4
_cand_to_add$ = 12					; size = 4
_added_idx_list$ = 16					; size = 4
_list_size$ = 20					; size = 4
_merge_candidate_in_list PROC				; COMDAT

; 1593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 1594 :   bool found = false;

	mov	BYTE PTR _found$[ebp], 0

; 1595 :   for (int i = 0; i < list_size && !found; ++i) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@merge_cand
$LN2@merge_cand:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@merge_cand:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _list_size$[ebp]
	jge	$LN3@merge_cand
	movzx	eax, BYTE PTR _found$[ebp]
	test	eax, eax
	jne	$LN3@merge_cand

; 1596 :     inter_merge_cand_t * list_cand = &all_cands[added_idx_list[i]];

	mov	eax, DWORD PTR _added_idx_list$[ebp]
	add	eax, DWORD PTR _i$2[ebp]
	movsx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 12
	add	edx, DWORD PTR _all_cands$[ebp]
	mov	DWORD PTR _list_cand$1[ebp], edx

; 1597 : 
; 1598 :     found = cand_to_add->dir == list_cand->dir &&

	mov	eax, DWORD PTR _cand_to_add$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _list_cand$1[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	$LN6@merge_cand
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cand_to_add$[ebp]
	movzx	ecx, BYTE PTR [eax+edx+1]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _list_cand$1[ebp]
	movzx	eax, BYTE PTR [edx+eax+1]
	cmp	ecx, eax
	jne	$LN6@merge_cand
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cand_to_add$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _list_cand$1[ebp]
	lea	eax, DWORD PTR [edx+eax+4]
	mov	edx, 2
	imul	edx, edx, 0
	movsx	eax, WORD PTR [eax+edx]
	cmp	ecx, eax
	jne	$LN6@merge_cand
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cand_to_add$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _list_cand$1[ebp]
	lea	edx, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [edx+ecx]
	cmp	eax, edx
	jne	$LN6@merge_cand
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cand_to_add$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+1]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _list_cand$1[ebp]
	movzx	eax, BYTE PTR [ecx+eax+1]
	cmp	edx, eax
	jne	$LN6@merge_cand
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _cand_to_add$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _list_cand$1[ebp]
	lea	ecx, DWORD PTR [edx+ecx+4]
	mov	edx, 2
	imul	edx, edx, 0
	movsx	ecx, WORD PTR [ecx+edx]
	cmp	eax, ecx
	jne	SHORT $LN6@merge_cand
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cand_to_add$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _list_cand$1[ebp]
	lea	ecx, DWORD PTR [edx+ecx+4]
	mov	edx, 2
	shl	edx, 0
	movsx	ecx, WORD PTR [ecx+edx]
	cmp	eax, ecx
	jne	SHORT $LN6@merge_cand
	mov	DWORD PTR tv180[ebp], 1
	jmp	SHORT $LN7@merge_cand
$LN6@merge_cand:
	mov	DWORD PTR tv180[ebp], 0
$LN7@merge_cand:
	cmp	DWORD PTR tv180[ebp], 0
	jne	SHORT $LN8@merge_cand
	mov	DWORD PTR tv182[ebp], 0
	jmp	SHORT $LN9@merge_cand
$LN8@merge_cand:
	mov	DWORD PTR tv182[ebp], 1
$LN9@merge_cand:
	mov	dl, BYTE PTR tv182[ebp]
	mov	BYTE PTR _found$[ebp], dl

; 1599 :         cand_to_add->ref[0] == list_cand->ref[0] &&
; 1600 :         cand_to_add->mv[0][0] == list_cand->mv[0][0] &&
; 1601 :         cand_to_add->mv[0][1] == list_cand->mv[0][1] &&
; 1602 :         cand_to_add->ref[1] == list_cand->ref[1] &&
; 1603 :         cand_to_add->mv[1][0] == list_cand->mv[1][0] &&
; 1604 :         cand_to_add->mv[1][1] == list_cand->mv[1][1];
; 1605 :   }

	jmp	$LN2@merge_cand
$LN3@merge_cand:

; 1606 : 
; 1607 :   return found;

	mov	al, BYTE PTR _found$[ebp]

; 1608 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_merge_candidate_in_list ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _search_pu_inter_bipred
_TEXT	SEGMENT
tv985 = -472						; size = 4
tv873 = -472						; size = 4
tv865 = -472						; size = 4
tv86 = -472						; size = 4
_cu_mv_cand$1 = -272					; size = 4
_reflist$2 = -260					; size = 4
_merge_idx$3 = -248					; size = 4
_extra_bits$4 = -236					; size = 4
_mv_ref_coded$5 = -224					; size = 2
_bitcost$6 = -212					; size = 8
_cost$7 = -196						; size = 4
_src$8 = -184						; size = 4
_rec$9 = -172						; size = 4
_mv$10 = -160						; size = 8
_j$11 = -141						; size = 1
_i$12 = -129						; size = 1
_idx$13 = -120						; size = 4
_merge_cand$ = -108					; size = 4
_num_cand_pairs$ = -96					; size = 4
_height$ = -84						; size = 4
_width$ = -72						; size = 4
_y$ = -60						; size = 4
_x$ = -48						; size = 4
_frame$ = -36						; size = 4
_ref_LX$ = -24						; size = 4
_ref$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_depth$ = 12						; size = 4
_lcu$ = 16						; size = 4
_cur_cu$ = 20						; size = 4
_inter_cost$ = 24					; size = 4
_inter_bitcost$ = 28					; size = 4
_search_pu_inter_bipred PROC				; COMDAT

; 1450 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 472				; 000001d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-472]
	mov	ecx, 118				; 00000076H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 1451 :   const image_list_t *const ref = info->state->frame->ref;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _ref$[ebp], eax

; 1452 :   uint8_t (*ref_LX)[16] = info->state->frame->ref_LX;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, 45					; 0000002dH
	mov	DWORD PTR _ref_LX$[ebp], edx

; 1453 :   const videoframe_t * const frame = info->state->tile->frame;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _frame$[ebp], eax

; 1454 :   const int x         = info->origin.x;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _x$[ebp], ecx

; 1455 :   const int y         = info->origin.y;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _y$[ebp], ecx

; 1456 :   const int width     = info->width;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _width$[ebp], ecx

; 1457 :   const int height    = info->height;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _height$[ebp], ecx

; 1458 : 
; 1459 :   static const uint8_t priorityList0[] = { 0, 1, 0, 2, 1, 2, 0, 3, 1, 3, 2, 3 };
; 1460 :   static const uint8_t priorityList1[] = { 1, 0, 2, 0, 2, 1, 3, 0, 3, 1, 3, 2 };
; 1461 :   const unsigned num_cand_pairs =

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	sub	ecx, 1
	mov	edx, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [edx+100]
	cmp	ecx, 12					; 0000000cH
	jge	SHORT $LN26@search_pu_
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	sub	ecx, 1
	mov	edx, DWORD PTR _info$[ebp]
	imul	ecx, DWORD PTR [edx+100]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN27@search_pu_
$LN26@search_pu_:
	mov	DWORD PTR tv86[ebp], 12			; 0000000cH
$LN27@search_pu_:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR _num_cand_pairs$[ebp], eax

; 1462 :     MIN(info->num_merge_cand * (info->num_merge_cand - 1), 12);
; 1463 : 
; 1464 :   inter_merge_cand_t *merge_cand = info->merge_cand;

	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _merge_cand$[ebp], eax

; 1465 : 
; 1466 :   for (int32_t idx = 0; idx < num_cand_pairs; idx++) {

	mov	DWORD PTR _idx$13[ebp], 0
	jmp	SHORT $LN4@search_pu_
$LN2@search_pu_:
	mov	eax, DWORD PTR _idx$13[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$13[ebp], eax
$LN4@search_pu_:
	mov	eax, DWORD PTR _idx$13[ebp]
	cmp	eax, DWORD PTR _num_cand_pairs$[ebp]
	jae	$LN3@search_pu_

; 1467 :     uint8_t i = priorityList0[idx];

	mov	eax, DWORD PTR _idx$13[ebp]
	mov	cl, BYTE PTR ?priorityList0@?1??search_pu_inter_bipred@@9@9[eax]
	mov	BYTE PTR _i$12[ebp], cl

; 1468 :     uint8_t j = priorityList1[idx];

	mov	eax, DWORD PTR _idx$13[ebp]
	mov	cl, BYTE PTR ?priorityList1@?1??search_pu_inter_bipred@@9@9[eax]
	mov	BYTE PTR _j$11[ebp], cl

; 1469 :     if (i >= info->num_merge_cand || j >= info->num_merge_cand) break;

	movzx	eax, BYTE PTR _i$12[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	eax, DWORD PTR [ecx+100]
	jge	SHORT $LN15@search_pu_
	movzx	eax, BYTE PTR _j$11[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	eax, DWORD PTR [ecx+100]
	jl	SHORT $LN14@search_pu_
$LN15@search_pu_:
	jmp	$LN3@search_pu_
$LN14@search_pu_:

; 1470 : 
; 1471 :     // Find one L0 and L1 candidate according to the priority list
; 1472 :     if (!(merge_cand[i].dir & 0x1) || !(merge_cand[j].dir & 0x2)) continue;

	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _merge_cand$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 1
	je	SHORT $LN17@search_pu_
	movzx	eax, BYTE PTR _j$11[ebp]
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _merge_cand$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 2
	jne	SHORT $LN16@search_pu_
$LN17@search_pu_:
	jmp	$LN2@search_pu_
$LN16@search_pu_:

; 1473 : 
; 1474 :     if (ref_LX[0][merge_cand[i].ref[0]] == ref_LX[1][merge_cand[j].ref[1]] &&
; 1475 :         merge_cand[i].mv[0][0] == merge_cand[j].mv[1][0] &&

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _ref_LX$[ebp]
	movzx	edx, BYTE PTR _i$12[ebp]
	imul	eax, edx, 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	edx, 1
	imul	edx, edx, 0
	movzx	eax, BYTE PTR [eax+edx+1]
	movzx	ecx, BYTE PTR [ecx+eax]
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	edx, DWORD PTR _ref_LX$[ebp]
	movzx	eax, BYTE PTR _j$11[ebp]
	imul	eax, eax, 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	esi, 1
	shl	esi, 0
	movzx	eax, BYTE PTR [eax+esi+1]
	movzx	edx, BYTE PTR [edx+eax]
	cmp	ecx, edx
	jne	$LN18@search_pu_
	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	movzx	edx, BYTE PTR _j$11[ebp]
	imul	eax, edx, 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [eax+edx+4]
	mov	edx, 2
	imul	edx, edx, 0
	movsx	eax, WORD PTR [eax+edx]
	cmp	ecx, eax
	jne	SHORT $LN18@search_pu_
	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	movzx	ecx, BYTE PTR _j$11[ebp]
	imul	edx, ecx, 12
	add	edx, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR [edx+ecx+4]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [edx+ecx]
	cmp	eax, edx
	jne	SHORT $LN18@search_pu_

; 1476 :         merge_cand[i].mv[0][1] == merge_cand[j].mv[1][1])
; 1477 :     {
; 1478 :       continue;

	jmp	$LN2@search_pu_
$LN18@search_pu_:

; 1479 :     }
; 1480 : 
; 1481 :     int16_t mv[2][2];
; 1482 :     mv[0][0] = merge_cand[i].mv[0][0];

	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	lea	edx, DWORD PTR _mv$10[ebp+edx]
	mov	esi, 2
	imul	esi, esi, 0
	mov	ax, WORD PTR [ecx+eax]
	mov	WORD PTR [edx+esi], ax

; 1483 :     mv[0][1] = merge_cand[i].mv[0][1];

	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	shl	edx, 0
	mov	eax, 4
	imul	eax, eax, 0
	lea	eax, DWORD PTR _mv$10[ebp+eax]
	mov	esi, 2
	shl	esi, 0
	mov	cx, WORD PTR [ecx+edx]
	mov	WORD PTR [eax+esi], cx

; 1484 :     mv[1][0] = merge_cand[j].mv[1][0];

	movzx	eax, BYTE PTR _j$11[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, 4
	shl	ecx, 0
	lea	ecx, DWORD PTR _mv$10[ebp+ecx]
	mov	esi, 2
	imul	esi, esi, 0
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1485 :     mv[1][1] = merge_cand[j].mv[1][1];

	movzx	eax, BYTE PTR _j$11[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	lea	edx, DWORD PTR _mv$10[ebp+edx]
	mov	esi, 2
	shl	esi, 0
	mov	ax, WORD PTR [eax+ecx]
	mov	WORD PTR [edx+esi], ax

; 1486 : 
; 1487 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1488 :     if (!fracmv_within_tile(info, mv[0][0], mv[0][1]) ||

	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _mv$10[ebp+ecx]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _mv$10[ebp+eax]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@search_pu_
	mov	eax, 4
	shl	eax, 0
	lea	ecx, DWORD PTR _mv$10[ebp+eax]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR _mv$10[ebp+ecx]
	mov	eax, 2
	imul	ecx, eax, 0
	movsx	edx, WORD PTR [edx+ecx]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@search_pu_
$LN20@search_pu_:

; 1489 :         !fracmv_within_tile(info, mv[1][0], mv[1][1]))
; 1490 :     {
; 1491 :       continue;

	jmp	$LN2@search_pu_
$LN19@search_pu_:

; 1492 :     }
; 1493 : 
; 1494 :     kvz_inter_recon_bipred(info->state,

	push	0
	push	1
	mov	eax, DWORD PTR _lcu$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mv$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _ref_LX$[ebp]
	movzx	ecx, BYTE PTR _j$11[ebp]
	imul	edx, ecx, 12
	add	edx, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR [edx+ecx+1]
	movzx	eax, BYTE PTR [eax+edx]
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	edx, DWORD PTR _ref_LX$[ebp]
	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	eax, 1
	imul	eax, eax, 0
	movzx	ecx, BYTE PTR [ecx+eax+1]
	movzx	edx, BYTE PTR [edx+ecx]
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_kvz_inter_recon_bipred
	add	esp, 44					; 0000002cH

; 1495 :                            ref->images[ref_LX[0][merge_cand[i].ref[0]]],
; 1496 :                            ref->images[ref_LX[1][merge_cand[j].ref[1]]],
; 1497 :                            x, y,
; 1498 :                            width,
; 1499 :                            height,
; 1500 :                            mv,
; 1501 :                            lcu,
; 1502 :                            true,
; 1503 :                            false);
; 1504 : 
; 1505 :     const kvz_pixel *rec = &lcu->rec.y[SUB_SCU(y) * LCU_WIDTH + SUB_SCU(x)];

	mov	eax, DWORD PTR _y$[ebp]
	and	eax, 63					; 0000003fH
	shl	eax, 6
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, DWORD PTR _lcu$[ebp]
	lea	edx, DWORD PTR [ecx+eax+6540]
	mov	DWORD PTR _rec$9[ebp], edx

; 1506 :     const kvz_pixel *src = &frame->source->y[x + y * frame->source->width];

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _frame$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _y$[ebp]
	imul	edx, DWORD PTR [eax+32]
	add	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	add	eax, edx
	mov	DWORD PTR _src$8[ebp], eax

; 1507 :     uint32_t cost =

	mov	eax, DWORD PTR _frame$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _src$8[ebp]
	push	eax
	push	64					; 00000040H
	mov	ecx, DWORD PTR _rec$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	DWORD PTR _kvz_satd_any_size
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cost$7[ebp], eax

; 1508 :       kvz_satd_any_size(width, height, rec, LCU_WIDTH, src, frame->source->width);
; 1509 : 
; 1510 :     uint32_t bitcost[2] = { 0, 0 };

	mov	DWORD PTR _bitcost$6[ebp], 0
	mov	DWORD PTR _bitcost$6[ebp+4], 0

; 1511 : 
; 1512 :     cost += info->mvd_cost_func(info->state,

	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _bitcost$6[ebp+ecx]
	mov	esi, esp
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	push	0
	movzx	ecx, BYTE PTR _i$12[ebp]
	imul	edx, ecx, 12
	add	edx, DWORD PTR _merge_cand$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+4]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	push	ecx
	movzx	edx, BYTE PTR _i$12[ebp]
	imul	eax, edx, 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	call	ecx
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, DWORD PTR _cost$7[ebp]
	mov	DWORD PTR _cost$7[ebp], eax

; 1513 :                                merge_cand[i].mv[0][0],
; 1514 :                                merge_cand[i].mv[0][1],
; 1515 :                                0,
; 1516 :                                info->mv_cand,
; 1517 :                                NULL, 0, 0,
; 1518 :                                &bitcost[0]);
; 1519 :     cost += info->mvd_cost_func(info->state,

	mov	eax, 4
	shl	eax, 0
	lea	ecx, DWORD PTR _bitcost$6[ebp+eax]
	mov	esi, esp
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	push	0
	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	push	edx
	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	call	ecx
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, DWORD PTR _cost$7[ebp]
	mov	DWORD PTR _cost$7[ebp], eax

; 1520 :                                merge_cand[i].mv[1][0],
; 1521 :                                merge_cand[i].mv[1][1],
; 1522 :                                0,
; 1523 :                                info->mv_cand,
; 1524 :                                NULL, 0, 0,
; 1525 :                                &bitcost[1]);
; 1526 : 
; 1527 :     const uint8_t mv_ref_coded[2] = {

	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR [ecx+eax+1]
	mov	BYTE PTR _mv_ref_coded$5[ebp], cl
	movzx	eax, BYTE PTR _j$11[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 1
	shl	edx, 0
	mov	al, BYTE PTR [ecx+edx+1]
	mov	BYTE PTR _mv_ref_coded$5[ebp+1], al

; 1528 :       merge_cand[i].ref[0],
; 1529 :       merge_cand[j].ref[1]
; 1530 :     };
; 1531 :     const int extra_bits = mv_ref_coded[0] + mv_ref_coded[1] + 2 /* mv dir cost */;

	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR _mv_ref_coded$5[ebp+ecx]
	mov	eax, 1
	shl	eax, 0
	movzx	ecx, BYTE PTR _mv_ref_coded$5[ebp+eax]
	lea	edx, DWORD PTR [edx+ecx+2]
	mov	DWORD PTR _extra_bits$4[ebp], edx

; 1532 :     cost += info->state->lambda_sqrt * extra_bits + 0.5;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	cvtsi2sd xmm0, DWORD PTR _extra_bits$4[ebp]
	mulsd	xmm0, QWORD PTR [ecx+304]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR _cost$7[ebp]
	mov	DWORD PTR tv865[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv865[ebp]
	mov	eax, DWORD PTR tv865[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	call	__dtoui3
	mov	DWORD PTR _cost$7[ebp], eax

; 1533 : 
; 1534 :     if (cost < *inter_cost) {

	mov	eax, DWORD PTR _cost$7[ebp]
	mov	DWORD PTR tv873[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv873[ebp]
	mov	ecx, DWORD PTR tv873[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _inter_cost$[ebp]
	movsd	xmm1, QWORD PTR [edx]
	comisd	xmm1, xmm0
	jbe	$LN21@search_pu_

; 1535 :       cur_cu->inter.mv_dir = 3;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	or	cl, 192					; 000000c0H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+18], cl

; 1536 : 
; 1537 :       cur_cu->inter.mv_ref[0] = merge_cand[i].ref[0];

	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, 1
	imul	edx, edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	mov	al, BYTE PTR [ecx+eax+1]
	mov	BYTE PTR [esi+edx+16], al

; 1538 :       cur_cu->inter.mv_ref[1] = merge_cand[j].ref[1];

	movzx	eax, BYTE PTR _j$11[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	shl	eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [ecx+edx+1]
	mov	BYTE PTR [esi+eax+16], cl

; 1539 : 
; 1540 :       cur_cu->inter.mv[0][0] = merge_cand[i].mv[0][0];

	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, 4
	imul	edx, edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [esi+edx+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	ax, WORD PTR [ecx+eax]
	mov	WORD PTR [edx+esi], ax

; 1541 :       cur_cu->inter.mv[0][1] = merge_cand[i].mv[0][1];

	movzx	eax, BYTE PTR _i$12[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR [ecx+eax+4]
	mov	edx, 2
	shl	edx, 0
	mov	eax, 4
	imul	eax, eax, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [esi+eax+8]
	mov	esi, 2
	shl	esi, 0
	mov	cx, WORD PTR [ecx+edx]
	mov	WORD PTR [eax+esi], cx

; 1542 :       cur_cu->inter.mv[1][0] = merge_cand[j].mv[1][0];

	movzx	eax, BYTE PTR _j$11[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, 4
	shl	ecx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [esi+ecx+8]
	mov	esi, 2
	imul	esi, esi, 0
	mov	dx, WORD PTR [eax+edx]
	mov	WORD PTR [ecx+esi], dx

; 1543 :       cur_cu->inter.mv[1][1] = merge_cand[j].mv[1][1];

	movzx	eax, BYTE PTR _j$11[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	mov	edx, 4
	shl	edx, 0
	lea	eax, DWORD PTR [ecx+edx+4]
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, 4
	shl	edx, 0
	mov	esi, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [esi+edx+8]
	mov	esi, 2
	shl	esi, 0
	mov	ax, WORD PTR [eax+ecx]
	mov	WORD PTR [edx+esi], ax

; 1544 :       cur_cu->merged = 0;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+1]
	and	cl, 239					; 000000efH
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+1], cl

; 1545 : 
; 1546 :       // Check every candidate to find a match
; 1547 :       for (int merge_idx = 0; merge_idx < info->num_merge_cand; merge_idx++) {

	mov	DWORD PTR _merge_idx$3[ebp], 0
	jmp	SHORT $LN7@search_pu_
$LN5@search_pu_:
	mov	eax, DWORD PTR _merge_idx$3[ebp]
	add	eax, 1
	mov	DWORD PTR _merge_idx$3[ebp], eax
$LN7@search_pu_:
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _merge_idx$3[ebp]
	cmp	ecx, DWORD PTR [eax+100]
	jge	$LN6@search_pu_

; 1548 :         if (merge_cand[merge_idx].mv[0][0] == cur_cu->inter.mv[0][0] &&
; 1549 :             merge_cand[merge_idx].mv[0][1] == cur_cu->inter.mv[0][1] &&
; 1550 :             merge_cand[merge_idx].mv[1][0] == cur_cu->inter.mv[1][0] &&
; 1551 :             merge_cand[merge_idx].mv[1][1] == cur_cu->inter.mv[1][1] &&
; 1552 :             merge_cand[merge_idx].ref[0] == cur_cu->inter.mv_ref[0] &&

	imul	eax, DWORD PTR _merge_idx$3[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+4]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	ecx, 2
	imul	ecx, ecx, 0
	movsx	edx, WORD PTR [edx+ecx]
	cmp	eax, edx
	jne	$LN22@search_pu_
	imul	eax, DWORD PTR _merge_idx$3[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR [eax+edx+4]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [ecx+eax]
	cmp	edx, ecx
	jne	$LN22@search_pu_
	imul	eax, DWORD PTR _merge_idx$3[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+4]
	mov	eax, 2
	imul	ecx, eax, 0
	movsx	edx, WORD PTR [edx+ecx]
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	eax, DWORD PTR [ecx+eax+8]
	mov	ecx, 2
	imul	ecx, ecx, 0
	movsx	eax, WORD PTR [eax+ecx]
	cmp	edx, eax
	jne	$LN22@search_pu_
	imul	eax, DWORD PTR _merge_idx$3[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	lea	edx, DWORD PTR [eax+ecx+4]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [eax+edx+8]
	mov	eax, 2
	shl	eax, 0
	movsx	edx, WORD PTR [edx+eax]
	cmp	ecx, edx
	jne	$LN22@search_pu_
	imul	eax, DWORD PTR _merge_idx$3[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR [eax+edx+1]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	movzx	edx, BYTE PTR [ecx+edx+16]
	cmp	eax, edx
	jne	SHORT $LN22@search_pu_
	imul	eax, DWORD PTR _merge_idx$3[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR [eax+ecx+1]
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+16]
	cmp	edx, eax
	jne	SHORT $LN22@search_pu_

; 1553 :             merge_cand[merge_idx].ref[1] == cur_cu->inter.mv_ref[1])
; 1554 :         {
; 1555 :           cur_cu->merged = 1;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+1]
	or	cl, 16					; 00000010H
	mov	edx, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [edx+1], cl

; 1556 :           cur_cu->merge_idx = merge_idx;

	mov	al, BYTE PTR _merge_idx$3[ebp]
	and	al, 7
	shl	al, 5
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	and	dl, 31					; 0000001fH
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+1], dl

; 1557 :           break;

	jmp	SHORT $LN6@search_pu_
$LN22@search_pu_:

; 1558 :         }
; 1559 :       }

	jmp	$LN5@search_pu_
$LN6@search_pu_:

; 1560 : 
; 1561 :       // Each motion vector has its own candidate
; 1562 :       for (int reflist = 0; reflist < 2; reflist++) {

	mov	DWORD PTR _reflist$2[ebp], 0
	jmp	SHORT $LN10@search_pu_
$LN8@search_pu_:
	mov	eax, DWORD PTR _reflist$2[ebp]
	add	eax, 1
	mov	DWORD PTR _reflist$2[ebp], eax
$LN10@search_pu_:
	cmp	DWORD PTR _reflist$2[ebp], 2
	jge	$LN9@search_pu_

; 1563 :         kvz_inter_get_mv_cand(info->state, x, y, width, height, info->mv_cand, cur_cu, lcu, reflist);

	movzx	eax, BYTE PTR _reflist$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur_cu$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_kvz_inter_get_mv_cand
	add	esp, 36					; 00000024H

; 1564 :         int cu_mv_cand = select_mv_cand(

	push	0
	mov	eax, DWORD PTR _reflist$2[ebp]
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+8]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	push	ecx
	mov	edx, DWORD PTR _reflist$2[ebp]
	mov	eax, DWORD PTR _cur_cu$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+8]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_select_mv_cand
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cu_mv_cand$1[ebp], eax
$LN13@search_pu_:

; 1565 :             info->state,
; 1566 :             info->mv_cand,
; 1567 :             cur_cu->inter.mv[reflist][0],
; 1568 :             cur_cu->inter.mv[reflist][1],
; 1569 :             NULL);
; 1570 :         CU_SET_MV_CAND(cur_cu, reflist, cu_mv_cand);

	cmp	DWORD PTR _reflist$2[ebp], 0
	jne	SHORT $LN23@search_pu_
	mov	al, BYTE PTR _cu_mv_cand$1[ebp]
	and	al, 7
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+18]
	and	dl, 248					; 000000f8H
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+18], dl
	jmp	SHORT $LN24@search_pu_
$LN23@search_pu_:
	mov	al, BYTE PTR _cu_mv_cand$1[ebp]
	and	al, 7
	shl	al, 3
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+18]
	and	dl, 199					; 000000c7H
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+18], dl
$LN24@search_pu_:
	xor	eax, eax
	jne	SHORT $LN13@search_pu_

; 1571 :       }

	jmp	$LN8@search_pu_
$LN9@search_pu_:

; 1572 : 
; 1573 :       *inter_cost = cost;

	mov	eax, DWORD PTR _cost$7[ebp]
	mov	DWORD PTR tv985[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv985[ebp]
	mov	ecx, DWORD PTR tv985[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _inter_cost$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 1574 :       *inter_bitcost = bitcost[0] + bitcost[1] + extra_bits;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _bitcost$6[ebp+ecx]
	add	eax, DWORD PTR _bitcost$6[ebp+edx]
	add	eax, DWORD PTR _extra_bits$4[ebp]
	mov	ecx, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [ecx], eax
$LN21@search_pu_:

; 1575 :     }
; 1576 :   }

	jmp	$LN2@search_pu_
$LN3@search_pu_:

; 1577 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@search_pu_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 472				; 000001d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@search_pu_:
	DD	3
	DD	$LN31@search_pu_
$LN31@search_pu_:
	DD	-160					; ffffff60H
	DD	8
	DD	$LN28@search_pu_
	DD	-212					; ffffff2cH
	DD	8
	DD	$LN29@search_pu_
	DD	-224					; ffffff20H
	DD	2
	DD	$LN30@search_pu_
$LN30@search_pu_:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN29@search_pu_:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN28@search_pu_:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
_search_pu_inter_bipred ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _search_pu_inter_ref
_TEXT	SEGMENT
tv1085 = -444						; size = 4
tv1054 = -444						; size = 4
tv1043 = -444						; size = 4
tv1004 = -444						; size = 4
tv941 = -444						; size = 4
tv375 = -444						; size = 4
tv370 = -444						; size = 4
tv92 = -444						; size = 4
_valid_mv$1 = -241					; size = 1
_mv_ref_coded$2 = -229					; size = 1
_cu_mv_cand$ = -220					; size = 4
_merge_idx$ = -208					; size = 4
_merged$ = -196						; size = 4
_search_range$ = -184					; size = 4
_neighbor_poc_index$3 = -169				; size = 1
_i$4 = -160						; size = 4
_col_list$5 = -148					; size = 4
_mv_previous$6 = -136					; size = 8
_ref_cu$ = -120						; size = 4
_ref_array$ = -108					; size = 4
_mid_y$ = -96						; size = 4
_mid_x$ = -84						; size = 4
_mv$ = -72						; size = 8
_temp_ref_idx$ = -53					; size = 1
_LX_IDX_MAX_PLUS_1$ = -41				; size = 1
_LX_idx$ = -29						; size = 1
_ref_list$ = -17					; size = 1
_cfg$ = -8						; size = 4
_info$ = 8						; size = 4
_depth$ = 12						; size = 4
_lcu$ = 16						; size = 4
_cur_cu$ = 20						; size = 4
_inter_cost$ = 24					; size = 4
_inter_bitcost$ = 28					; size = 4
_best_LX_cost$ = 32					; size = 4
_unipred_LX$ = 36					; size = 4
_search_pu_inter_ref PROC				; COMDAT

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 111				; 0000006fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 1223 :   const kvz_config *cfg = &info->state->encoder_control->cfg;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cfg$[ebp], edx

; 1224 : 
; 1225 :   // which list, L0 or L1, ref_idx is in and in what index
; 1226 :   int8_t ref_list = -1;

	mov	BYTE PTR _ref_list$[ebp], -1

; 1227 :   // the index of the ref_idx in L0 or L1 list
; 1228 :   int8_t LX_idx;
; 1229 :   // max value of LX_idx plus one
; 1230 :   const int8_t LX_IDX_MAX_PLUS_1 = MAX(info->state->frame->ref_LX_size[0],

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	edx, BYTE PTR [edx+ecx+77]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, 1
	shl	ecx, 0
	movzx	eax, BYTE PTR [eax+ecx+77]
	cmp	edx, eax
	jle	SHORT $LN52@search_pu_
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, 1
	imul	edx, ecx, 0
	movzx	eax, BYTE PTR [eax+edx+77]
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN53@search_pu_
$LN52@search_pu_:
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR [eax+ecx+77]
	mov	DWORD PTR tv92[ebp], edx
$LN53@search_pu_:
	mov	al, BYTE PTR tv92[ebp]
	mov	BYTE PTR _LX_IDX_MAX_PLUS_1$[ebp], al

; 1231 :     info->state->frame->ref_LX_size[1]);
; 1232 : 
; 1233 :   for (LX_idx = 0; LX_idx < LX_IDX_MAX_PLUS_1; LX_idx++)

	mov	BYTE PTR _LX_idx$[ebp], 0
	jmp	SHORT $LN4@search_pu_
$LN2@search_pu_:
	mov	al, BYTE PTR _LX_idx$[ebp]
	add	al, 1
	mov	BYTE PTR _LX_idx$[ebp], al
$LN4@search_pu_:
	movsx	eax, BYTE PTR _LX_idx$[ebp]
	movsx	ecx, BYTE PTR _LX_IDX_MAX_PLUS_1$[ebp]
	cmp	eax, ecx
	jge	$LN3@search_pu_

; 1234 :   {
; 1235 :     // check if ref_idx is in L0
; 1236 :     if (LX_idx < info->state->frame->ref_LX_size[0] &&

	movsx	eax, BYTE PTR _LX_idx$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, 1
	imul	edx, edx, 0
	movzx	ecx, BYTE PTR [ecx+edx+77]
	cmp	eax, ecx
	jge	SHORT $LN21@search_pu_
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+45]
	movsx	eax, BYTE PTR _LX_idx$[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	mov	edx, DWORD PTR _info$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jne	SHORT $LN21@search_pu_

; 1237 :       info->state->frame->ref_LX[0][LX_idx] == info->ref_idx) {
; 1238 :       ref_list = 0;

	mov	BYTE PTR _ref_list$[ebp], 0

; 1239 :       break;

	jmp	SHORT $LN3@search_pu_
$LN21@search_pu_:

; 1240 :     }
; 1241 : 
; 1242 :     // check if ref_idx is in L1
; 1243 :     if (LX_idx < info->state->frame->ref_LX_size[1] &&

	movsx	eax, BYTE PTR _LX_idx$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, 1
	shl	edx, 0
	movzx	ecx, BYTE PTR [ecx+edx+77]
	cmp	eax, ecx
	jge	SHORT $LN22@search_pu_
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, 16					; 00000010H
	shl	eax, 0
	lea	ecx, DWORD PTR [edx+eax+45]
	movsx	edx, BYTE PTR _LX_idx$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jne	SHORT $LN22@search_pu_

; 1244 :       info->state->frame->ref_LX[1][LX_idx] == info->ref_idx) {
; 1245 :       ref_list = 1;

	mov	BYTE PTR _ref_list$[ebp], 1

; 1246 :       break;

	jmp	SHORT $LN3@search_pu_
$LN22@search_pu_:

; 1247 :     }
; 1248 :   }

	jmp	$LN2@search_pu_
$LN3@search_pu_:

; 1249 :   // ref_idx has to be found in either L0 or L1
; 1250 :   assert(LX_idx < LX_IDX_MAX_PLUS_1);

	movsx	eax, BYTE PTR _LX_idx$[ebp]
	movsx	ecx, BYTE PTR _LX_IDX_MAX_PLUS_1$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN54@search_pu_
	mov	edx, DWORD PTR ?__LINE__Var@?0??search_pu_inter_ref@@9@9
	add	edx, 28					; 0000001cH
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1HG@OHIPOECE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1DG@NACHCKLO@?$AAL?$AAX?$AA_?$AAi?$AAd?$AAx?$AA?5?$AA?$DM?$AA?5?$AAL?$AAX?$AA_?$AAI?$AAD?$AAX@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN54@search_pu_:

; 1251 : 
; 1252 :   // store temp values to be stored back later
; 1253 :   int8_t temp_ref_idx = cur_cu->inter.mv_ref[ref_list];

	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+eax+16]
	mov	BYTE PTR _temp_ref_idx$[ebp], dl

; 1254 : 
; 1255 :   // Get MV candidates
; 1256 :   cur_cu->inter.mv_ref[ref_list] = LX_idx;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR _LX_idx$[ebp]
	mov	BYTE PTR [ecx+eax+16], dl

; 1257 : 
; 1258 :   kvz_inter_get_mv_cand(info->state,

	movzx	eax, BYTE PTR _ref_list$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur_cu$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_kvz_inter_get_mv_cand
	add	esp, 36					; 00000024H

; 1259 :     info->origin.x,
; 1260 :     info->origin.y,
; 1261 :     info->width,
; 1262 :     info->height,
; 1263 :     info->mv_cand,
; 1264 :     cur_cu,
; 1265 :     lcu,
; 1266 :     ref_list);
; 1267 : 
; 1268 :   // store old values back
; 1269 :   cur_cu->inter.mv_ref[ref_list] = temp_ref_idx;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR _temp_ref_idx$[ebp]
	mov	BYTE PTR [ecx+eax+16], dl

; 1270 : 
; 1271 :   vector2d_t mv = { 0, 0 };

	mov	DWORD PTR _mv$[ebp], 0
	mov	DWORD PTR _mv$[ebp+4], 0

; 1272 : 
; 1273 :   // Take starting point for MV search from previous frame.
; 1274 :   // When temporal motion vector candidates are added, there is probably
; 1275 :   // no point to this anymore, but for now it helps.
; 1276 :   const int mid_x = info->state->tile->offset_x + info->origin.x + (info->width >> 1);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _info$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	sar	ecx, 1
	add	eax, ecx
	mov	DWORD PTR _mid_x$[ebp], eax

; 1277 :   const int mid_y = info->state->tile->offset_y + info->origin.y + (info->height >> 1);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _info$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	sar	ecx, 1
	add	eax, ecx
	mov	DWORD PTR _mid_y$[ebp], eax

; 1278 :   const cu_array_t* ref_array = info->state->frame->ref->cu_arrays[info->ref_idx];

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _ref_array$[ebp], ecx

; 1279 :   const cu_info_t* ref_cu = kvz_cu_array_at_const(ref_array, mid_x, mid_y);

	mov	eax, DWORD PTR _mid_y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mid_x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ref_array$[ebp]
	push	edx
	call	_kvz_cu_array_at_const
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ref_cu$[ebp], eax

; 1280 :   if (ref_cu->type == CU_INTER) {

	mov	eax, DWORD PTR _ref_cu$[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 3
	movzx	edx, cl
	cmp	edx, 2
	jne	$LN29@search_pu_

; 1281 :     vector2d_t mv_previous = { 0, 0 };

	mov	DWORD PTR _mv_previous$6[ebp], 0
	mov	DWORD PTR _mv_previous$6[ebp+4], 0

; 1282 :     if (ref_cu->inter.mv_dir & 1) {

	mov	eax, DWORD PTR _ref_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	shr	cl, 6
	and	cl, 3
	movzx	edx, cl
	and	edx, 1
	je	SHORT $LN24@search_pu_

; 1283 :       mv_previous.x = ref_cu->inter.mv[0][0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ref_cu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	mov	DWORD PTR _mv_previous$6[ebp], eax

; 1284 :       mv_previous.y = ref_cu->inter.mv[0][1];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ref_cu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	mov	DWORD PTR _mv_previous$6[ebp+4], edx

; 1285 :     }

	jmp	SHORT $LN25@search_pu_
$LN24@search_pu_:

; 1286 :     else {
; 1287 :       mv_previous.x = ref_cu->inter.mv[1][0];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ref_cu$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	eax, 2
	imul	ecx, eax, 0
	movsx	edx, WORD PTR [edx+ecx]
	mov	DWORD PTR _mv_previous$6[ebp], edx

; 1288 :       mv_previous.y = ref_cu->inter.mv[1][1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _ref_cu$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	mov	DWORD PTR _mv_previous$6[ebp+4], ecx
$LN25@search_pu_:

; 1289 :     }
; 1290 :     // Apply mv scaling if neighbor poc is available
; 1291 :     if (info->state->frame->ref_LX_size[ref_list] > 0) {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	movsx	eax, BYTE PTR _ref_list$[ebp]
	movzx	ecx, BYTE PTR [edx+eax+77]
	test	ecx, ecx
	jle	$LN26@search_pu_

; 1292 :       // When there are reference pictures from the future (POC > current POC)
; 1293 :       // in L0 or L1, the primary list for the colocated PU is the inverse of
; 1294 :       // collocated_from_l0_flag. Otherwise it is equal to reflist.
; 1295 :       //
; 1296 :       // Kvazaar always sets collocated_from_l0_flag so the list is L1 when
; 1297 :       // there are future references.
; 1298 :       int col_list = ref_list;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	DWORD PTR _col_list$5[ebp], eax

; 1299 :       for (int i = 0; i < info->state->frame->ref->used_size; i++) {

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN7@search_pu_
$LN5@search_pu_:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN7@search_pu_:
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$4[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $LN6@search_pu_

; 1300 :         if (info->state->frame->ref->pocs[i] > info->state->frame->poc) {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	cmp	ecx, DWORD PTR [edx+12]
	jle	SHORT $LN27@search_pu_

; 1301 :           col_list = 1;

	mov	DWORD PTR _col_list$5[ebp], 1

; 1302 :           break;

	jmp	SHORT $LN6@search_pu_
$LN27@search_pu_:

; 1303 :         }
; 1304 :       }

	jmp	SHORT $LN5@search_pu_
$LN6@search_pu_:

; 1305 :       if ((ref_cu->inter.mv_dir & (col_list + 1)) == 0) {

	mov	eax, DWORD PTR _ref_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	shr	cl, 6
	and	cl, 3
	movzx	edx, cl
	mov	eax, DWORD PTR _col_list$5[ebp]
	add	eax, 1
	and	edx, eax
	jne	SHORT $LN28@search_pu_

; 1306 :         // Use the other list if the colocated PU does not have a MV for the
; 1307 :         // primary list.
; 1308 :         col_list = 1 - col_list;

	mov	eax, 1
	sub	eax, DWORD PTR _col_list$5[ebp]
	mov	DWORD PTR _col_list$5[ebp], eax
$LN28@search_pu_:

; 1309 :       }
; 1310 : 
; 1311 :       uint8_t neighbor_poc_index = info->state->frame->ref_LX[ref_list][LX_idx];

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	movsx	eax, BYTE PTR _ref_list$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR [edx+eax+45]
	movsx	edx, BYTE PTR _LX_idx$[ebp]
	mov	al, BYTE PTR [ecx+edx]
	mov	BYTE PTR _neighbor_poc_index$3[ebp], al

; 1312 :       // Scaling takes current POC, reference POC, neighbor POC and neighbor reference POC as argument
; 1313 :       apply_mv_scaling(

	lea	eax, DWORD PTR _mv_previous$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+40]
	movzx	edx, BYTE PTR _neighbor_poc_index$3[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [edx+40]
	movzx	edx, BYTE PTR _neighbor_poc_index$3[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR [eax+12]
	add	eax, edx
	mov	edx, DWORD PTR _col_list$5[ebp]
	shl	edx, 4
	add	eax, edx
	mov	edx, DWORD PTR _ref_cu$[ebp]
	add	edx, DWORD PTR _col_list$5[ebp]
	movzx	edx, BYTE PTR [edx+16]
	movzx	eax, BYTE PTR [eax+edx]
	mov	ecx, DWORD PTR [ecx+eax*4+80]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+40]
	movzx	eax, BYTE PTR _neighbor_poc_index$3[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+20]
	movsx	edx, BYTE PTR _ref_list$[ebp]
	shl	edx, 4
	lea	ecx, DWORD PTR [ecx+edx+45]
	movsx	edx, BYTE PTR _LX_idx$[ebp]
	movzx	ecx, BYTE PTR [ecx+edx]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_apply_mv_scaling
	add	esp, 20					; 00000014H
$LN26@search_pu_:

; 1314 :         info->state->frame->poc,
; 1315 :         info->state->frame->ref->pocs[info->state->frame->ref_LX[ref_list][LX_idx]],
; 1316 :         info->state->frame->ref->pocs[neighbor_poc_index],
; 1317 :         info->state->frame->ref->images[neighbor_poc_index]->ref_pocs[
; 1318 :           info->state->frame->ref->ref_LXs[neighbor_poc_index]
; 1319 :           [col_list]
; 1320 :           [ref_cu->inter.mv_ref[col_list]]
; 1321 :         ],
; 1322 :         &mv_previous
; 1323 :       );
; 1324 :     }
; 1325 : 
; 1326 :     // Check if the mv is valid after scaling
; 1327 :     if (fracmv_within_tile(info, mv_previous.x, mv_previous.y)) {

	mov	eax, DWORD PTR _mv_previous$6[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mv_previous$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@search_pu_

; 1328 :       mv = mv_previous;

	mov	eax, DWORD PTR _mv_previous$6[ebp]
	mov	DWORD PTR _mv$[ebp], eax
	mov	ecx, DWORD PTR _mv_previous$6[ebp+4]
	mov	DWORD PTR _mv$[ebp+4], ecx
$LN29@search_pu_:

; 1329 :     }
; 1330 :   }
; 1331 : 
; 1332 :   int search_range = 32;

	mov	DWORD PTR _search_range$[ebp], 32	; 00000020H

; 1333 :   switch (cfg->ime_algorithm) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR tv370[ebp], ecx
	mov	edx, DWORD PTR tv370[ebp]
	sub	edx, 3
	mov	DWORD PTR tv370[ebp], edx
	cmp	DWORD PTR tv370[ebp], 3
	ja	SHORT $LN34@search_pu_
	mov	eax, DWORD PTR tv370[ebp]
	jmp	DWORD PTR $LN55@search_pu_[eax*4]
$LN30@search_pu_:

; 1334 :     case KVZ_IME_FULL64: search_range = 64; break;

	mov	DWORD PTR _search_range$[ebp], 64	; 00000040H
	jmp	SHORT $LN8@search_pu_
$LN31@search_pu_:

; 1335 :     case KVZ_IME_FULL32: search_range = 32; break;

	mov	DWORD PTR _search_range$[ebp], 32	; 00000020H
	jmp	SHORT $LN8@search_pu_
$LN32@search_pu_:

; 1336 :     case KVZ_IME_FULL16: search_range = 16; break;

	mov	DWORD PTR _search_range$[ebp], 16	; 00000010H
	jmp	SHORT $LN8@search_pu_
$LN33@search_pu_:

; 1337 :     case KVZ_IME_FULL8: search_range = 8; break;

	mov	DWORD PTR _search_range$[ebp], 8
$LN34@search_pu_:
$LN8@search_pu_:

; 1338 :     default: break;
; 1339 :   }
; 1340 : 
; 1341 :   info->best_cost = UINT32_MAX;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+116], -1

; 1342 : 
; 1343 :   switch (cfg->ime_algorithm) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR tv375[ebp], ecx
	mov	edx, DWORD PTR tv375[ebp]
	sub	edx, 1
	mov	DWORD PTR tv375[ebp], edx
	cmp	DWORD PTR tv375[ebp], 6
	ja	SHORT $LN38@search_pu_
	mov	eax, DWORD PTR tv375[ebp]
	jmp	DWORD PTR $LN56@search_pu_[eax*4]
$LN35@search_pu_:

; 1344 :     case KVZ_IME_TZ:
; 1345 :       tz_search(info, mv);

	mov	eax, DWORD PTR _mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_tz_search
	add	esp, 12					; 0000000cH

; 1346 :       break;

	jmp	SHORT $LN10@search_pu_
$LN36@search_pu_:

; 1347 : 
; 1348 :     case KVZ_IME_FULL64:
; 1349 :     case KVZ_IME_FULL32:
; 1350 :     case KVZ_IME_FULL16:
; 1351 :     case KVZ_IME_FULL8:
; 1352 :     case KVZ_IME_FULL:
; 1353 :       search_mv_full(info, search_range, mv);

	mov	eax, DWORD PTR _mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _search_range$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_search_mv_full
	add	esp, 16					; 00000010H

; 1354 :       break;

	jmp	SHORT $LN10@search_pu_
$LN37@search_pu_:

; 1355 : 
; 1356 :     case KVZ_IME_DIA:
; 1357 :       diamond_search(info, mv, info->state->encoder_control->cfg.me_max_steps);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+2424]
	push	eax
	mov	ecx, DWORD PTR _mv$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _mv$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_diamond_search
	add	esp, 16					; 00000010H

; 1358 :       break;

	jmp	SHORT $LN10@search_pu_
$LN38@search_pu_:

; 1359 : 
; 1360 :     default:
; 1361 :       hexagon_search(info, mv, info->state->encoder_control->cfg.me_max_steps);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+2424]
	push	eax
	mov	ecx, DWORD PTR _mv$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _mv$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_hexagon_search
	add	esp, 16					; 00000010H
$LN10@search_pu_:

; 1362 :       break;
; 1363 :   }
; 1364 : 
; 1365 :   if (cfg->fme_level > 0 && info->best_cost < *inter_cost) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jle	SHORT $LN39@search_pu_
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR tv941[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv941[ebp]
	mov	edx, DWORD PTR tv941[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _inter_cost$[ebp]
	movsd	xmm1, QWORD PTR [eax]
	comisd	xmm1, xmm0
	jbe	SHORT $LN39@search_pu_

; 1366 :     search_frac(info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_search_frac
	add	esp, 4
	jmp	$LN41@search_pu_
$LN39@search_pu_:

; 1367 : 
; 1368 :   } else if (info->best_cost < UINT32_MAX) {

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+116], -1
	jae	$LN41@search_pu_

; 1369 :     // Recalculate inter cost with SATD.
; 1370 :     info->best_cost = kvz_image_calc_satd(

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _info$[ebp]
	add	ecx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [eax+112]
	sar	edx, 2
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _info$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [edx+108]
	sar	ecx, 2
	add	eax, ecx
	push	eax
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_kvz_image_calc_satd
	add	esp, 32					; 00000020H
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+116], eax

; 1371 :         info->state->tile->frame->source,
; 1372 :         info->ref,
; 1373 :         info->origin.x,
; 1374 :         info->origin.y,
; 1375 :         info->state->tile->offset_x + info->origin.x + (info->best_mv.x >> 2),
; 1376 :         info->state->tile->offset_y + info->origin.y + (info->best_mv.y >> 2),
; 1377 :         info->width,
; 1378 :         info->height);
; 1379 :     info->best_cost += info->best_bitcost * (int)(info->state->lambda_sqrt + 0.5);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsd	xmm0, QWORD PTR [ecx+304]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _info$[ebp]
	imul	edx, DWORD PTR [eax+120]
	mov	ecx, DWORD PTR _info$[ebp]
	add	edx, DWORD PTR [ecx+116]
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+116], edx
$LN41@search_pu_:

; 1380 :   }
; 1381 : 
; 1382 :   mv = info->best_mv;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+112]
	mov	DWORD PTR _mv$[ebp], ecx
	mov	DWORD PTR _mv$[ebp+4], edx

; 1383 : 
; 1384 :   int merged = 0;

	mov	DWORD PTR _merged$[ebp], 0

; 1385 :   int merge_idx = 0;

	mov	DWORD PTR _merge_idx$[ebp], 0

; 1386 :   // Check every candidate to find a match
; 1387 :   for (merge_idx = 0; merge_idx < info->num_merge_cand; merge_idx++) {

	mov	DWORD PTR _merge_idx$[ebp], 0
	jmp	SHORT $LN14@search_pu_
$LN12@search_pu_:
	mov	eax, DWORD PTR _merge_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _merge_idx$[ebp], eax
$LN14@search_pu_:
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _merge_idx$[ebp]
	cmp	ecx, DWORD PTR [eax+100]
	jge	$LN13@search_pu_

; 1388 :     if (info->merge_cand[merge_idx].dir != 3 &&
; 1389 :         info->merge_cand[merge_idx].mv[info->merge_cand[merge_idx].dir - 1][0] == mv.x &&
; 1390 :         info->merge_cand[merge_idx].mv[info->merge_cand[merge_idx].dir - 1][1] == mv.y &&

	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+40]
	cmp	edx, 3
	je	$LN42@search_pu_
	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	cmp	ecx, DWORD PTR _mv$[ebp]
	jne	$LN42@search_pu_
	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	cmp	eax, DWORD PTR _mv$[ebp+4]
	jne	SHORT $LN42@search_pu_
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	sub	eax, 1
	shl	eax, 4
	lea	ecx, DWORD PTR [edx+eax+45]
	imul	edx, DWORD PTR _merge_idx$[ebp], 12
	mov	eax, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [eax+edx+40]
	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	esi, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [esi+eax+40]
	movzx	edx, BYTE PTR [edx+eax]
	movzx	eax, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jne	SHORT $LN42@search_pu_

; 1391 :         (uint32_t)info->state->frame->ref_LX[info->merge_cand[merge_idx].dir - 1][
; 1392 :         info->merge_cand[merge_idx].ref[info->merge_cand[merge_idx].dir - 1]] == info->ref_idx)
; 1393 :     {
; 1394 :       merged = 1;

	mov	DWORD PTR _merged$[ebp], 1

; 1395 :       break;

	jmp	SHORT $LN13@search_pu_
$LN42@search_pu_:

; 1396 :     }
; 1397 :   }

	jmp	$LN12@search_pu_
$LN13@search_pu_:

; 1398 : 
; 1399 :   // Only check when candidates are different
; 1400 :   int cu_mv_cand = 0;

	mov	DWORD PTR _cu_mv_cand$[ebp], 0

; 1401 :   if (!merged) {

	cmp	DWORD PTR _merged$[ebp], 0
	jne	SHORT $LN43@search_pu_

; 1402 :     cu_mv_cand =

	push	0
	mov	eax, DWORD PTR _mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_select_mv_cand
	add	esp, 20					; 00000014H
	mov	DWORD PTR _cu_mv_cand$[ebp], eax
$LN43@search_pu_:

; 1403 :       select_mv_cand(info->state, info->mv_cand, mv.x, mv.y, NULL);
; 1404 :   }
; 1405 : 
; 1406 :   if (info->best_cost < *inter_cost) {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR tv1004[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1004[ebp]
	mov	edx, DWORD PTR tv1004[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _inter_cost$[ebp]
	movsd	xmm1, QWORD PTR [eax]
	comisd	xmm1, xmm0
	jbe	$LN44@search_pu_

; 1407 :     // Map reference index to L0/L1 pictures
; 1408 :     cur_cu->inter.mv_dir = ref_list+1;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	add	eax, 1
	and	al, 3
	shl	al, 6
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+18]
	and	dl, 63					; 0000003fH
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+18], dl

; 1409 :     uint8_t mv_ref_coded = LX_idx;

	mov	al, BYTE PTR _LX_idx$[ebp]
	mov	BYTE PTR _mv_ref_coded$2[ebp], al

; 1410 : 
; 1411 :     cur_cu->merged                  = merged;

	mov	al, BYTE PTR _merged$[ebp]
	and	al, 1
	shl	al, 4
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	and	dl, 239					; 000000efH
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+1], dl

; 1412 :     cur_cu->merge_idx               = merge_idx;

	mov	al, BYTE PTR _merge_idx$[ebp]
	and	al, 7
	shl	al, 5
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	and	dl, 31					; 0000001fH
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+1], dl

; 1413 :     cur_cu->inter.mv_ref[ref_list]  = LX_idx;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR _LX_idx$[ebp]
	mov	BYTE PTR [ecx+eax+16], dl

; 1414 :     cur_cu->inter.mv[ref_list][0]   = (int16_t)mv.x;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+8]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	ax, WORD PTR _mv$[ebp]
	mov	WORD PTR [edx+ecx], ax

; 1415 :     cur_cu->inter.mv[ref_list][1]   = (int16_t)mv.y;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+8]
	mov	eax, 2
	shl	eax, 0
	mov	cx, WORD PTR _mv$[ebp+4]
	mov	WORD PTR [edx+eax], cx
$LN17@search_pu_:

; 1416 : 
; 1417 :     CU_SET_MV_CAND(cur_cu, ref_list, cu_mv_cand);

	movsx	eax, BYTE PTR _ref_list$[ebp]
	test	eax, eax
	jne	SHORT $LN45@search_pu_
	mov	al, BYTE PTR _cu_mv_cand$[ebp]
	and	al, 7
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+18]
	and	dl, 248					; 000000f8H
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+18], dl
	jmp	SHORT $LN46@search_pu_
$LN45@search_pu_:
	mov	al, BYTE PTR _cu_mv_cand$[ebp]
	and	al, 7
	shl	al, 3
	mov	ecx, DWORD PTR _cur_cu$[ebp]
	mov	dl, BYTE PTR [ecx+18]
	and	dl, 199					; 000000c7H
	or	dl, al
	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	BYTE PTR [eax+18], dl
$LN46@search_pu_:
	xor	eax, eax
	jne	SHORT $LN17@search_pu_

; 1418 : 
; 1419 :     *inter_cost = info->best_cost;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR tv1043[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1043[ebp]
	mov	edx, DWORD PTR tv1043[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _inter_cost$[ebp]
	movsd	QWORD PTR [eax], xmm0

; 1420 :     *inter_bitcost = info->best_bitcost + cur_cu->inter.mv_dir - 1 + mv_ref_coded;

	mov	eax, DWORD PTR _cur_cu$[ebp]
	mov	cl, BYTE PTR [eax+18]
	shr	cl, 6
	and	cl, 3
	movzx	edx, cl
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	add	ecx, edx
	movzx	edx, BYTE PTR _mv_ref_coded$2[ebp]
	lea	eax, DWORD PTR [ecx+edx-1]
	mov	ecx, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [ecx], eax
$LN44@search_pu_:

; 1421 :   }
; 1422 : 
; 1423 : 
; 1424 :   // Update best unipreds for biprediction
; 1425 :   if (info->best_cost < best_LX_cost[ref_list]) {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR tv1054[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv1054[ebp]
	mov	edx, DWORD PTR tv1054[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	ecx, DWORD PTR _best_LX_cost$[ebp]
	movsd	xmm1, QWORD PTR [ecx+eax*8]
	comisd	xmm1, xmm0
	jbe	$LN48@search_pu_

; 1426 :     bool valid_mv = fracmv_within_tile(info, mv.x, mv.y);

	mov	eax, DWORD PTR _mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _valid_mv$1[ebp], al

; 1427 :     if (valid_mv) {

	movzx	eax, BYTE PTR _valid_mv$1[ebp]
	test	eax, eax
	je	$LN48@search_pu_

; 1428 :       // Map reference index to L0/L1 pictures
; 1429 :       unipred_LX[ref_list].inter.mv_dir = ref_list + 1;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	add	eax, 1
	movsx	ecx, BYTE PTR _ref_list$[ebp]
	imul	edx, ecx, 20
	and	al, 3
	shl	al, 6
	mov	ecx, DWORD PTR _unipred_LX$[ebp]
	mov	dl, BYTE PTR [ecx+edx+18]
	and	dl, 63					; 0000003fH
	or	dl, al
	movsx	eax, BYTE PTR _ref_list$[ebp]
	imul	ecx, eax, 20
	mov	eax, DWORD PTR _unipred_LX$[ebp]
	mov	BYTE PTR [eax+ecx+18], dl

; 1430 :       unipred_LX[ref_list].inter.mv_ref[ref_list] = LX_idx;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	imul	ecx, eax, 20
	add	ecx, DWORD PTR _unipred_LX$[ebp]
	movsx	edx, BYTE PTR _ref_list$[ebp]
	mov	al, BYTE PTR _LX_idx$[ebp]
	mov	BYTE PTR [ecx+edx+16], al

; 1431 :       unipred_LX[ref_list].inter.mv[ref_list][0] = (int16_t)mv.x;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	imul	ecx, eax, 20
	add	ecx, DWORD PTR _unipred_LX$[ebp]
	movsx	edx, BYTE PTR _ref_list$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4+8]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	cx, WORD PTR _mv$[ebp]
	mov	WORD PTR [eax+edx], cx

; 1432 :       unipred_LX[ref_list].inter.mv[ref_list][1] = (int16_t)mv.y;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	imul	ecx, eax, 20
	add	ecx, DWORD PTR _unipred_LX$[ebp]
	movsx	edx, BYTE PTR _ref_list$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4+8]
	mov	ecx, 2
	shl	ecx, 0
	mov	dx, WORD PTR _mv$[ebp+4]
	mov	WORD PTR [eax+ecx], dx
$LN20@search_pu_:

; 1433 : 
; 1434 :       CU_SET_MV_CAND(&unipred_LX[ref_list], ref_list, cu_mv_cand);

	movsx	eax, BYTE PTR _ref_list$[ebp]
	test	eax, eax
	jne	SHORT $LN49@search_pu_
	movsx	eax, BYTE PTR _ref_list$[ebp]
	imul	ecx, eax, 20
	mov	dl, BYTE PTR _cu_mv_cand$[ebp]
	and	dl, 7
	mov	eax, DWORD PTR _unipred_LX$[ebp]
	mov	cl, BYTE PTR [eax+ecx+18]
	and	cl, 248					; 000000f8H
	or	cl, dl
	movsx	edx, BYTE PTR _ref_list$[ebp]
	imul	eax, edx, 20
	mov	edx, DWORD PTR _unipred_LX$[ebp]
	mov	BYTE PTR [edx+eax+18], cl
	jmp	SHORT $LN50@search_pu_
$LN49@search_pu_:
	movsx	eax, BYTE PTR _ref_list$[ebp]
	imul	ecx, eax, 20
	mov	dl, BYTE PTR _cu_mv_cand$[ebp]
	and	dl, 7
	shl	dl, 3
	mov	eax, DWORD PTR _unipred_LX$[ebp]
	mov	cl, BYTE PTR [eax+ecx+18]
	and	cl, 199					; 000000c7H
	or	cl, dl
	movsx	edx, BYTE PTR _ref_list$[ebp]
	imul	eax, edx, 20
	mov	edx, DWORD PTR _unipred_LX$[ebp]
	mov	BYTE PTR [edx+eax+18], cl
$LN50@search_pu_:
	xor	eax, eax
	jne	SHORT $LN20@search_pu_

; 1435 : 
; 1436 :       best_LX_cost[ref_list] = info->best_cost;

	movsx	eax, BYTE PTR _ref_list$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR tv1085[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv1085[ebp]
	mov	ecx, DWORD PTR tv1085[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _best_LX_cost$[ebp]
	movsd	QWORD PTR [edx+eax*8], xmm0
$LN48@search_pu_:

; 1437 :     }
; 1438 :   }
; 1439 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN60@search_pu_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN60@search_pu_:
	DD	2
	DD	$LN59@search_pu_
$LN59@search_pu_:
	DD	-72					; ffffffb8H
	DD	8
	DD	$LN57@search_pu_
	DD	-136					; ffffff78H
	DD	8
	DD	$LN58@search_pu_
$LN58@search_pu_:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
$LN57@search_pu_:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
	npad	1
$LN55@search_pu_:
	DD	$LN33@search_pu_
	DD	$LN32@search_pu_
	DD	$LN31@search_pu_
	DD	$LN30@search_pu_
$LN56@search_pu_:
	DD	$LN35@search_pu_
	DD	$LN36@search_pu_
	DD	$LN36@search_pu_
	DD	$LN36@search_pu_
	DD	$LN36@search_pu_
	DD	$LN36@search_pu_
	DD	$LN37@search_pu_
_search_pu_inter_ref ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _apply_mv_scaling
_TEXT	SEGMENT
tv148 = -240						; size = 4
tv78 = -240						; size = 4
tv72 = -240						; size = 4
tv149 = -236						; size = 4
tv79 = -236						; size = 4
tv73 = -236						; size = 4
tv129 = -232						; size = 4
tv75 = -232						; size = 4
tv69 = -232						; size = 4
_scale$ = -32						; size = 4
_diff_neighbor$ = -20					; size = 4
_diff_current$ = -8					; size = 4
_current_poc$ = 8					; size = 4
_current_ref_poc$ = 12					; size = 4
_neighbor_poc$ = 16					; size = 4
_neighbor_ref_poc$ = 20					; size = 4
_mv_cand$ = 24						; size = 4
_apply_mv_scaling PROC					; COMDAT

; 1194 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 1195 :   int32_t diff_current = current_poc - current_ref_poc;

	mov	eax, DWORD PTR _current_poc$[ebp]
	sub	eax, DWORD PTR _current_ref_poc$[ebp]
	mov	DWORD PTR _diff_current$[ebp], eax

; 1196 :   int32_t diff_neighbor = neighbor_poc - neighbor_ref_poc;

	mov	eax, DWORD PTR _neighbor_poc$[ebp]
	sub	eax, DWORD PTR _neighbor_ref_poc$[ebp]
	mov	DWORD PTR _diff_neighbor$[ebp], eax

; 1197 : 
; 1198 :   if (diff_current == diff_neighbor) return;

	mov	eax, DWORD PTR _diff_current$[ebp]
	cmp	eax, DWORD PTR _diff_neighbor$[ebp]
	jne	SHORT $LN2@apply_mv_s
	jmp	$LN1@apply_mv_s
$LN2@apply_mv_s:

; 1199 :   if (diff_neighbor == 0) return;

	cmp	DWORD PTR _diff_neighbor$[ebp], 0
	jne	SHORT $LN3@apply_mv_s
	jmp	$LN1@apply_mv_s
$LN3@apply_mv_s:

; 1200 : 
; 1201 :   diff_current = CLIP(-128, 127, diff_current);

	cmp	DWORD PTR _diff_current$[ebp], 127	; 0000007fH
	jle	SHORT $LN5@apply_mv_s
	mov	DWORD PTR tv69[ebp], 127		; 0000007fH
	jmp	SHORT $LN6@apply_mv_s
$LN5@apply_mv_s:
	mov	eax, DWORD PTR _diff_current$[ebp]
	mov	DWORD PTR tv69[ebp], eax
$LN6@apply_mv_s:
	cmp	DWORD PTR tv69[ebp], -128		; ffffff80H
	jge	SHORT $LN9@apply_mv_s
	mov	DWORD PTR tv73[ebp], -128		; ffffff80H
	jmp	SHORT $LN10@apply_mv_s
$LN9@apply_mv_s:
	cmp	DWORD PTR _diff_current$[ebp], 127	; 0000007fH
	jle	SHORT $LN7@apply_mv_s
	mov	DWORD PTR tv72[ebp], 127		; 0000007fH
	jmp	SHORT $LN8@apply_mv_s
$LN7@apply_mv_s:
	mov	ecx, DWORD PTR _diff_current$[ebp]
	mov	DWORD PTR tv72[ebp], ecx
$LN8@apply_mv_s:
	mov	edx, DWORD PTR tv72[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN10@apply_mv_s:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR _diff_current$[ebp], eax

; 1202 :   diff_neighbor = CLIP(-128, 127, diff_neighbor);

	cmp	DWORD PTR _diff_neighbor$[ebp], 127	; 0000007fH
	jle	SHORT $LN11@apply_mv_s
	mov	DWORD PTR tv75[ebp], 127		; 0000007fH
	jmp	SHORT $LN12@apply_mv_s
$LN11@apply_mv_s:
	mov	eax, DWORD PTR _diff_neighbor$[ebp]
	mov	DWORD PTR tv75[ebp], eax
$LN12@apply_mv_s:
	cmp	DWORD PTR tv75[ebp], -128		; ffffff80H
	jge	SHORT $LN15@apply_mv_s
	mov	DWORD PTR tv79[ebp], -128		; ffffff80H
	jmp	SHORT $LN16@apply_mv_s
$LN15@apply_mv_s:
	cmp	DWORD PTR _diff_neighbor$[ebp], 127	; 0000007fH
	jle	SHORT $LN13@apply_mv_s
	mov	DWORD PTR tv78[ebp], 127		; 0000007fH
	jmp	SHORT $LN14@apply_mv_s
$LN13@apply_mv_s:
	mov	ecx, DWORD PTR _diff_neighbor$[ebp]
	mov	DWORD PTR tv78[ebp], ecx
$LN14@apply_mv_s:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR tv79[ebp], edx
$LN16@apply_mv_s:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR _diff_neighbor$[ebp], eax

; 1203 : 
; 1204 :   int scale = CLIP(-4096, 4095,

	mov	eax, DWORD PTR _diff_neighbor$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	sar	eax, 1
	add	eax, 16384				; 00004000H
	cdq
	idiv	DWORD PTR _diff_neighbor$[ebp]
	imul	eax, DWORD PTR _diff_current$[ebp]
	add	eax, 32					; 00000020H
	sar	eax, 6
	cmp	eax, 4095				; 00000fffH
	jle	SHORT $LN17@apply_mv_s
	mov	DWORD PTR tv129[ebp], 4095		; 00000fffH
	jmp	SHORT $LN18@apply_mv_s
$LN17@apply_mv_s:
	mov	ecx, DWORD PTR _diff_neighbor$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	sar	eax, 1
	add	eax, 16384				; 00004000H
	cdq
	idiv	DWORD PTR _diff_neighbor$[ebp]
	imul	eax, DWORD PTR _diff_current$[ebp]
	add	eax, 32					; 00000020H
	sar	eax, 6
	mov	DWORD PTR tv129[ebp], eax
$LN18@apply_mv_s:
	cmp	DWORD PTR tv129[ebp], -4096		; fffff000H
	jge	SHORT $LN21@apply_mv_s
	mov	DWORD PTR tv149[ebp], -4096		; fffff000H
	jmp	SHORT $LN22@apply_mv_s
$LN21@apply_mv_s:
	mov	edx, DWORD PTR _diff_neighbor$[ebp]
	push	edx
	call	_abs
	add	esp, 4
	sar	eax, 1
	add	eax, 16384				; 00004000H
	cdq
	idiv	DWORD PTR _diff_neighbor$[ebp]
	imul	eax, DWORD PTR _diff_current$[ebp]
	add	eax, 32					; 00000020H
	sar	eax, 6
	cmp	eax, 4095				; 00000fffH
	jle	SHORT $LN19@apply_mv_s
	mov	DWORD PTR tv148[ebp], 4095		; 00000fffH
	jmp	SHORT $LN20@apply_mv_s
$LN19@apply_mv_s:
	mov	eax, DWORD PTR _diff_neighbor$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	sar	eax, 1
	add	eax, 16384				; 00004000H
	cdq
	idiv	DWORD PTR _diff_neighbor$[ebp]
	imul	eax, DWORD PTR _diff_current$[ebp]
	add	eax, 32					; 00000020H
	sar	eax, 6
	mov	DWORD PTR tv148[ebp], eax
$LN20@apply_mv_s:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR tv149[ebp], ecx
$LN22@apply_mv_s:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR _scale$[ebp], edx

; 1205 :     (diff_current * ((0x4000 + (abs(diff_neighbor) >> 1)) / diff_neighbor) + 32) >> 6);
; 1206 : 
; 1207 :   mv_cand->x = get_scaled_mv(mv_cand->x, scale);

	mov	eax, DWORD PTR _scale$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv_cand$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_get_scaled_mv
	add	esp, 8
	cwde
	mov	ecx, DWORD PTR _mv_cand$[ebp]
	mov	DWORD PTR [ecx], eax

; 1208 :   mv_cand->y = get_scaled_mv(mv_cand->y, scale);

	mov	eax, DWORD PTR _scale$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv_cand$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	push	edx
	call	_get_scaled_mv
	add	esp, 8
	cwde
	mov	ecx, DWORD PTR _mv_cand$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN1@apply_mv_s:

; 1209 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_apply_mv_scaling ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _get_scaled_mv
_TEXT	SEGMENT
tv87 = -232						; size = 4
tv90 = -228						; size = 4
tv81 = -224						; size = 4
tv91 = -220						; size = 4
tv74 = -216						; size = 4
tv77 = -212						; size = 4
tv68 = -208						; size = 4
_scaled$ = -8						; size = 4
_mv$ = 8						; size = 2
_scale$ = 12						; size = 4
_get_scaled_mv PROC					; COMDAT

; 1176 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 1177 :   int32_t scaled = scale * mv;

	movsx	eax, WORD PTR _mv$[ebp]
	imul	eax, DWORD PTR _scale$[ebp]
	mov	DWORD PTR _scaled$[ebp], eax

; 1178 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	cmp	DWORD PTR _scaled$[ebp], 0
	jge	SHORT $LN3@get_scaled
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@get_scaled
$LN3@get_scaled:
	mov	DWORD PTR tv68[ebp], 0
$LN4@get_scaled:
	mov	eax, DWORD PTR tv68[ebp]
	mov	ecx, DWORD PTR _scaled$[ebp]
	lea	edx, DWORD PTR [ecx+eax+127]
	sar	edx, 8
	cmp	edx, 32767				; 00007fffH
	jle	SHORT $LN7@get_scaled
	mov	DWORD PTR tv77[ebp], 32767		; 00007fffH
	jmp	SHORT $LN8@get_scaled
$LN7@get_scaled:
	cmp	DWORD PTR _scaled$[ebp], 0
	jge	SHORT $LN5@get_scaled
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN6@get_scaled
$LN5@get_scaled:
	mov	DWORD PTR tv74[ebp], 0
$LN6@get_scaled:
	mov	eax, DWORD PTR tv74[ebp]
	mov	ecx, DWORD PTR _scaled$[ebp]
	lea	edx, DWORD PTR [ecx+eax+127]
	sar	edx, 8
	mov	DWORD PTR tv77[ebp], edx
$LN8@get_scaled:
	cmp	DWORD PTR tv77[ebp], -32768		; ffff8000H
	jge	SHORT $LN15@get_scaled
	mov	DWORD PTR tv91[ebp], -32768		; ffff8000H
	jmp	SHORT $LN16@get_scaled
$LN15@get_scaled:
	cmp	DWORD PTR _scaled$[ebp], 0
	jge	SHORT $LN9@get_scaled
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN10@get_scaled
$LN9@get_scaled:
	mov	DWORD PTR tv81[ebp], 0
$LN10@get_scaled:
	mov	eax, DWORD PTR tv81[ebp]
	mov	ecx, DWORD PTR _scaled$[ebp]
	lea	edx, DWORD PTR [ecx+eax+127]
	sar	edx, 8
	cmp	edx, 32767				; 00007fffH
	jle	SHORT $LN13@get_scaled
	mov	DWORD PTR tv90[ebp], 32767		; 00007fffH
	jmp	SHORT $LN14@get_scaled
$LN13@get_scaled:
	cmp	DWORD PTR _scaled$[ebp], 0
	jge	SHORT $LN11@get_scaled
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN12@get_scaled
$LN11@get_scaled:
	mov	DWORD PTR tv87[ebp], 0
$LN12@get_scaled:
	mov	eax, DWORD PTR tv87[ebp]
	mov	ecx, DWORD PTR _scaled$[ebp]
	lea	edx, DWORD PTR [ecx+eax+127]
	sar	edx, 8
	mov	DWORD PTR tv90[ebp], edx
$LN14@get_scaled:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv91[ebp], eax
$LN16@get_scaled:
	mov	ax, WORD PTR tv91[ebp]

; 1179 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_get_scaled_mv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _search_frac
_TEXT	SEGMENT
tv397 = -70556						; size = 4
tv250 = -70556						; size = 4
_j$1 = -69012						; size = 4
_j$2 = -69000						; size = 4
_filtered_pos$3 = -68988				; size = 16
_j$4 = -68964						; size = 4
_within_tile$5 = -68952					; size = 4
_pattern$6 = -68940					; size = 16
_mv_shift$7 = -68916					; size = 4
_step$8 = -68904					; size = 4
_i$ = -68892						; size = 4
_filter_steps$ = -68880					; size = 16
_tmp_stride$ = -68856					; size = 4
_tmp_pic$ = -68844					; size = 4
_epol_args$ = -68832					; size = 68
_ext_s$ = -68748					; size = 4
_ext_origin$ = -68736					; size = 4
_ext$ = -68724						; size = 4
_ext_buffer$ = -68712					; size = 5184
_sample_off_y$ = -63517					; size = 1
_sample_off_x$ = -63505					; size = 1
_fme_level$ = -63496					; size = 4
_state$ = -63484					; size = 4
_internal_height$ = -63472				; size = 4
_internal_width$ = -63460				; size = 4
_height$ = -63448					; size = 4
_width$ = -63436					; size = 4
_orig$ = -63424						; size = 8
_pic$ = -63408						; size = 4
_ref$ = -63396						; size = 4
_hor_first_cols$ = -63384				; size = 720
_intermediate$ = -62656					; size = 46080
_filtered$ = -16512					; size = 16384
_costs$ = -100						; size = 16
_best_index$ = -76					; size = 4
_bitcosts$ = -64					; size = 16
_best_bitcost$ = -40					; size = 4
_best_cost$ = -28					; size = 4
_mv$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_search_frac PROC					; COMDAT

; 986  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -64				; ffffffc0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	mov	eax, 70584				; 000113b8H
	call	__chkstk
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-70584]
	mov	ecx, 17646				; 000044eeH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 987  :   // Map indexes to relative coordinates in the following way:
; 988  :   // 5 3 6
; 989  :   // 1 0 2
; 990  :   // 7 4 8
; 991  :   static const vector2d_t square[9] = {
; 992  :       {  0,  0 },  { -1,  0 },  {  1,  0 },
; 993  :       {  0, -1 },  {  0,  1 },  { -1, -1 },
; 994  :       {  1, -1 },  { -1,  1 },  {  1,  1 }
; 995  :   };
; 996  : 
; 997  :   // Set mv to pixel precision
; 998  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR [eax+108]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp], ecx
	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR [eax+112]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp+4], ecx

; 999  : 
; 1000 :   unsigned best_cost = UINT32_MAX;

	mov	DWORD PTR _best_cost$[ebp], -1

; 1001 :   uint32_t best_bitcost = 0;

	mov	DWORD PTR _best_bitcost$[ebp], 0

; 1002 :   uint32_t bitcosts[4] = { 0 };

	xor	eax, eax
	mov	DWORD PTR _bitcosts$[ebp], eax
	mov	DWORD PTR _bitcosts$[ebp+4], eax
	mov	DWORD PTR _bitcosts$[ebp+8], eax
	mov	DWORD PTR _bitcosts$[ebp+12], eax

; 1003 :   unsigned best_index = 0;

	mov	DWORD PTR _best_index$[ebp], 0

; 1004 : 
; 1005 :   unsigned costs[4] = { 0 };

	xor	eax, eax
	mov	DWORD PTR _costs$[ebp], eax
	mov	DWORD PTR _costs$[ebp+4], eax
	mov	DWORD PTR _costs$[ebp+8], eax
	mov	DWORD PTR _costs$[ebp+12], eax

; 1006 : 
; 1007 :   ALIGNED(64) kvz_pixel filtered[4][LCU_LUMA_SIZE];
; 1008 : 
; 1009 :   // Storage buffers for intermediate horizontally filtered results.
; 1010 :   // Have the first columns in contiguous memory for vectorization.
; 1011 :   ALIGNED(64) int16_t intermediate[5][KVZ_IPOL_MAX_IM_SIZE_LUMA_SIMD];
; 1012 :   int16_t hor_first_cols[5][KVZ_EXT_BLOCK_W_LUMA + 1];
; 1013 : 
; 1014 :   const kvz_picture *ref = info->ref;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ref$[ebp], ecx

; 1015 :   const kvz_picture *pic = info->pic;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pic$[ebp], ecx

; 1016 :   vector2d_t orig = info->origin;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _orig$[ebp], ecx
	mov	DWORD PTR _orig$[ebp+4], edx

; 1017 :   const int width = info->width;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _width$[ebp], ecx

; 1018 :   const int height = info->height;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _height$[ebp], ecx

; 1019 :   const int internal_width  = ((width  + 7) >> 3) << 3; // Round up to closest 8

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 7
	sar	eax, 3
	shl	eax, 3
	mov	DWORD PTR _internal_width$[ebp], eax

; 1020 :   const int internal_height = ((height + 7) >> 3) << 3;

	mov	eax, DWORD PTR _height$[ebp]
	add	eax, 7
	sar	eax, 3
	shl	eax, 3
	mov	DWORD PTR _internal_height$[ebp], eax

; 1021 : 
; 1022 :   const encoder_state_t *state = info->state;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _state$[ebp], ecx

; 1023 :   int fme_level = state->encoder_control->cfg.fme_level;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _fme_level$[ebp], edx

; 1024 :   int8_t sample_off_x = 0;

	mov	BYTE PTR _sample_off_x$[ebp], 0

; 1025 :   int8_t sample_off_y = 0;

	mov	BYTE PTR _sample_off_y$[ebp], 0

; 1026 : 
; 1027 :   // Space for (possibly) extrapolated pixels and the part from the picture
; 1028 :   // One extra row and column compared to normal interpolation and some extra for AVX2.
; 1029 :   // The extrapolation function will set the pointers and stride.
; 1030 :   kvz_pixel ext_buffer[KVZ_FME_MAX_INPUT_SIZE_SIMD];
; 1031 :   kvz_pixel *ext = NULL;

	mov	DWORD PTR _ext$[ebp], 0

; 1032 :   kvz_pixel *ext_origin = NULL;

	mov	DWORD PTR _ext_origin$[ebp], 0

; 1033 :   int ext_s = 0;

	mov	DWORD PTR _ext_s$[ebp], 0

; 1034 :   kvz_epol_args epol_args = {

	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _epol_args$[ebp], ecx
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _epol_args$[ebp+4], ecx
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _epol_args$[ebp+8], ecx
	mov	eax, DWORD PTR _ref$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _epol_args$[ebp+12], ecx
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _orig$[ebp]
	mov	eax, DWORD PTR _mv$[ebp]
	lea	ecx, DWORD PTR [edx+eax-1]
	mov	DWORD PTR _epol_args$[ebp+16], ecx
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR _orig$[ebp+4]
	mov	eax, DWORD PTR _mv$[ebp+4]
	lea	ecx, DWORD PTR [edx+eax-1]
	mov	DWORD PTR _epol_args$[ebp+20], ecx
	mov	eax, DWORD PTR _internal_width$[ebp]
	add	eax, 1
	mov	DWORD PTR _epol_args$[ebp+24], eax
	mov	eax, DWORD PTR _internal_height$[ebp]
	add	eax, 1
	mov	DWORD PTR _epol_args$[ebp+28], eax
	mov	DWORD PTR _epol_args$[ebp+32], 3
	mov	DWORD PTR _epol_args$[ebp+36], 4
	mov	DWORD PTR _epol_args$[ebp+40], 3
	mov	DWORD PTR _epol_args$[ebp+44], 4
	mov	DWORD PTR _epol_args$[ebp+48], 0
	mov	DWORD PTR _epol_args$[ebp+52], 0
	mov	DWORD PTR _epol_args$[ebp+56], 0
	mov	DWORD PTR _epol_args$[ebp+60], 0
	mov	DWORD PTR _epol_args$[ebp+64], 0

; 1035 :     .src = ref->y,
; 1036 :     .src_w = ref->width,
; 1037 :     .src_h = ref->height,
; 1038 :     .src_s = ref->stride,
; 1039 :     .blk_x = state->tile->offset_x + orig.x + mv.x - 1,
; 1040 :     .blk_y = state->tile->offset_y + orig.y + mv.y - 1,
; 1041 :     .blk_w = internal_width + 1,  // TODO: real width
; 1042 :     .blk_h = internal_height + 1, // TODO: real height
; 1043 :     .pad_l = KVZ_LUMA_FILTER_OFFSET,
; 1044 :     .pad_r = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 1045 :     .pad_t = KVZ_LUMA_FILTER_OFFSET,
; 1046 :     .pad_b = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 1047 :     .pad_b_simd = 0 // AVX2 padding unnecessary because of blk_h
; 1048 :   };
; 1049 : 
; 1050 :   // Initialize separately. Gets rid of warning
; 1051 :   // about using nonstandard extension.
; 1052 :   epol_args.buf = ext_buffer;

	lea	eax, DWORD PTR _ext_buffer$[ebp]
	mov	DWORD PTR _epol_args$[ebp+52], eax

; 1053 :   epol_args.ext = &ext;

	lea	eax, DWORD PTR _ext$[ebp]
	mov	DWORD PTR _epol_args$[ebp+56], eax

; 1054 :   epol_args.ext_origin = &ext_origin;

	lea	eax, DWORD PTR _ext_origin$[ebp]
	mov	DWORD PTR _epol_args$[ebp+60], eax

; 1055 :   epol_args.ext_s = &ext_s;

	lea	eax, DWORD PTR _ext_s$[ebp]
	mov	DWORD PTR _epol_args$[ebp+64], eax

; 1056 : 
; 1057 :   kvz_get_extended_block(&epol_args);

	mov	esi, esp
	lea	eax, DWORD PTR _epol_args$[ebp]
	push	eax
	call	DWORD PTR _kvz_get_extended_block
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1058 : 
; 1059 :   kvz_pixel *tmp_pic = pic->y + orig.y * pic->stride + orig.x;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR _orig$[ebp+4]
	imul	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _pic$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, ecx
	add	eax, DWORD PTR _orig$[ebp]
	mov	DWORD PTR _tmp_pic$[ebp], eax

; 1060 :   int tmp_stride = pic->stride;

	mov	eax, DWORD PTR _pic$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _tmp_stride$[ebp], ecx

; 1061 :                   
; 1062 :   // Search integer position
; 1063 :   costs[0] = kvz_satd_any_size(width, height,

	mov	esi, esp
	mov	eax, DWORD PTR _ext_s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ext_s$[ebp]
	mov	edx, DWORD PTR _ext_origin$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	mov	ecx, DWORD PTR _tmp_stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmp_pic$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	DWORD PTR _kvz_satd_any_size
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, 4
	imul	ecx, edx, 0
	mov	DWORD PTR _costs$[ebp+ecx], eax

; 1064 :     tmp_pic, tmp_stride,
; 1065 :     ext_origin + ext_s + 1, ext_s);
; 1066 : 
; 1067 :   costs[0] += info->mvd_cost_func(state,

	mov	eax, 4
	imul	esi, eax, 0
	mov	ecx, 4
	imul	edx, ecx, 0
	lea	eax, DWORD PTR _bitcosts$[ebp+edx]
	mov	edi, esp
	push	eax
	mov	ecx, DWORD PTR _info$[ebx]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _info$[ebx]
	movzx	ecx, WORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _info$[ebx]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _info$[ebx]
	add	eax, 32					; 00000020H
	push	eax
	push	2
	mov	ecx, DWORD PTR _mv$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _mv$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$[ebx]
	mov	edx, DWORD PTR [ecx+104]
	call	edx
	add	esp, 36					; 00000024H
	cmp	edi, esp
	call	__RTC_CheckEsp
	add	eax, DWORD PTR _costs$[ebp+esi]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	DWORD PTR _costs$[ebp+edx], eax

; 1068 :                                   mv.x, mv.y, 2,
; 1069 :                                   info->mv_cand,
; 1070 :                                   info->merge_cand,
; 1071 :                                   info->num_merge_cand,
; 1072 :                                   info->ref_idx,
; 1073 :                                   &bitcosts[0]);
; 1074 :   best_cost = costs[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _costs$[ebp+ecx]
	mov	DWORD PTR _best_cost$[ebp], edx

; 1075 :   best_bitcost = bitcosts[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _bitcosts$[ebp+ecx]
	mov	DWORD PTR _best_bitcost$[ebp], edx

; 1076 :   
; 1077 :   //Set mv to half-pixel precision
; 1078 :   mv.x *= 2;

	mov	eax, DWORD PTR _mv$[ebp]
	shl	eax, 1
	mov	DWORD PTR _mv$[ebp], eax

; 1079 :   mv.y *= 2;

	mov	eax, DWORD PTR _mv$[ebp+4]
	shl	eax, 1
	mov	DWORD PTR _mv$[ebp+4], eax

; 1080 : 
; 1081 :   ipol_blocks_func * filter_steps[4] = {

	mov	eax, DWORD PTR _kvz_filter_hpel_blocks_hor_ver_luma
	mov	DWORD PTR _filter_steps$[ebp], eax
	mov	eax, DWORD PTR _kvz_filter_hpel_blocks_diag_luma
	mov	DWORD PTR _filter_steps$[ebp+4], eax
	mov	eax, DWORD PTR _kvz_filter_qpel_blocks_hor_ver_luma
	mov	DWORD PTR _filter_steps$[ebp+8], eax
	mov	eax, DWORD PTR _kvz_filter_qpel_blocks_diag_luma
	mov	DWORD PTR _filter_steps$[ebp+12], eax

; 1082 :     kvz_filter_hpel_blocks_hor_ver_luma,
; 1083 :     kvz_filter_hpel_blocks_diag_luma,
; 1084 :     kvz_filter_qpel_blocks_hor_ver_luma,
; 1085 :     kvz_filter_qpel_blocks_diag_luma,
; 1086 :   };
; 1087 : 
; 1088 :   // Search halfpel positions around best integer mv
; 1089 :   int i = 1;

	mov	DWORD PTR _i$[ebp], 1

; 1090 :   for (int step = 0; step < fme_level; ++step){

	mov	DWORD PTR _step$8[ebp], 0
	jmp	SHORT $LN4@search_fra
$LN2@search_fra:
	mov	eax, DWORD PTR _step$8[ebp]
	add	eax, 1
	mov	DWORD PTR _step$8[ebp], eax
$LN4@search_fra:
	mov	eax, DWORD PTR _step$8[ebp]
	cmp	eax, DWORD PTR _fme_level$[ebp]
	jge	$LN3@search_fra

; 1091 : 
; 1092 :     const int mv_shift = (step < 2) ? 1 : 0;

	cmp	DWORD PTR _step$8[ebp], 2
	jge	SHORT $LN20@search_fra
	mov	DWORD PTR tv250[ebp], 1
	jmp	SHORT $LN21@search_fra
$LN20@search_fra:
	mov	DWORD PTR tv250[ebp], 0
$LN21@search_fra:
	mov	eax, DWORD PTR tv250[ebp]
	mov	DWORD PTR _mv_shift$7[ebp], eax

; 1093 : 
; 1094 :     filter_steps[step](state->encoder_control,

	mov	esi, esp
	movzx	eax, BYTE PTR _sample_off_y$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _sample_off_x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _hor_first_cols$[ebp]
	push	edx
	movzx	eax, BYTE PTR _fme_level$[ebp]
	push	eax
	lea	ecx, DWORD PTR _intermediate$[ebp]
	push	ecx
	lea	edx, DWORD PTR _filtered$[ebp]
	push	edx
	mov	eax, DWORD PTR _internal_height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _internal_width$[ebp]
	push	ecx
	movzx	edx, WORD PTR _ext_s$[ebp]
	push	edx
	mov	eax, DWORD PTR _ext_origin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _step$8[ebp]
	mov	ecx, DWORD PTR _filter_steps$[ebp+eax*4]
	call	ecx
	add	esp, 44					; 0000002cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1095 :       ext_origin,
; 1096 :       ext_s,
; 1097 :       internal_width,
; 1098 :       internal_height,
; 1099 :       filtered,
; 1100 :       intermediate,
; 1101 :       fme_level,
; 1102 :       hor_first_cols,
; 1103 :       sample_off_x,
; 1104 :       sample_off_y);
; 1105 :           
; 1106 :     const vector2d_t *pattern[4] = { &square[i], &square[i + 1], &square[i + 2], &square[i + 3] };

	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR ?square@?1??search_frac@@9@9[eax*8]
	mov	DWORD PTR _pattern$6[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR ?square@?1??search_frac@@9@9[eax*8+8]
	mov	DWORD PTR _pattern$6[ebp+4], ecx
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR ?square@?1??search_frac@@9@9[eax*8+16]
	mov	DWORD PTR _pattern$6[ebp+8], ecx
	mov	eax, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR ?square@?1??search_frac@@9@9[eax*8+24]
	mov	DWORD PTR _pattern$6[ebp+12], ecx

; 1107 : 
; 1108 :     int8_t within_tile[4];
; 1109 :     for (int j = 0; j < 4; j++) {

	mov	DWORD PTR _j$4[ebp], 0
	jmp	SHORT $LN7@search_fra
$LN5@search_fra:
	mov	eax, DWORD PTR _j$4[ebp]
	add	eax, 1
	mov	DWORD PTR _j$4[ebp], eax
$LN7@search_fra:
	cmp	DWORD PTR _j$4[ebp], 4
	jge	SHORT $LN6@search_fra

; 1110 :       within_tile[j] =

	mov	eax, DWORD PTR _j$4[ebp]
	mov	ecx, DWORD PTR _pattern$6[ebp+eax*4]
	mov	edx, DWORD PTR _mv$[ebp+4]
	add	edx, DWORD PTR [ecx+4]
	mov	eax, 1
	mov	ecx, DWORD PTR _mv_shift$7[ebp]
	shl	eax, cl
	imul	edx, eax
	push	edx
	mov	ecx, DWORD PTR _j$4[ebp]
	mov	edx, DWORD PTR _pattern$6[ebp+ecx*4]
	mov	eax, DWORD PTR _mv$[ebp]
	add	eax, DWORD PTR [edx]
	mov	edx, 1
	mov	ecx, DWORD PTR _mv_shift$7[ebp]
	shl	edx, cl
	imul	eax, edx
	push	eax
	mov	eax, DWORD PTR _info$[ebx]
	push	eax
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _j$4[ebp]
	mov	BYTE PTR _within_tile$5[ebp+ecx], al

; 1111 :         fracmv_within_tile(info, (mv.x + pattern[j]->x) * (1 << mv_shift), (mv.y + pattern[j]->y) * (1 << mv_shift));
; 1112 :     };

	jmp	SHORT $LN5@search_fra
$LN6@search_fra:

; 1113 : 
; 1114 :     kvz_pixel *filtered_pos[4] = { 0 };

	xor	eax, eax
	mov	DWORD PTR _filtered_pos$3[ebp], eax
	mov	DWORD PTR _filtered_pos$3[ebp+4], eax
	mov	DWORD PTR _filtered_pos$3[ebp+8], eax
	mov	DWORD PTR _filtered_pos$3[ebp+12], eax

; 1115 :     filtered_pos[0] = &filtered[0][0];

	mov	eax, 4096				; 00001000H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _filtered$[ebp+ecx]
	mov	eax, 1
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	DWORD PTR _filtered_pos$3[ebp+ecx], edx

; 1116 :     filtered_pos[1] = &filtered[1][0];

	mov	eax, 4096				; 00001000H
	shl	eax, 0
	lea	ecx, DWORD PTR _filtered$[ebp+eax]
	mov	edx, 1
	imul	eax, edx, 0
	add	ecx, eax
	mov	edx, 4
	shl	edx, 0
	mov	DWORD PTR _filtered_pos$3[ebp+edx], ecx

; 1117 :     filtered_pos[2] = &filtered[2][0];

	mov	eax, 4096				; 00001000H
	shl	eax, 1
	lea	ecx, DWORD PTR _filtered$[ebp+eax]
	mov	edx, 1
	imul	eax, edx, 0
	add	ecx, eax
	mov	edx, 4
	shl	edx, 1
	mov	DWORD PTR _filtered_pos$3[ebp+edx], ecx

; 1118 :     filtered_pos[3] = &filtered[3][0];

	mov	eax, 4096				; 00001000H
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _filtered$[ebp+ecx]
	mov	eax, 1
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	DWORD PTR _filtered_pos$3[ebp+ecx], edx

; 1119 : 
; 1120 :     kvz_satd_any_size_quad(width, height, (const kvz_pixel **)filtered_pos, LCU_WIDTH, tmp_pic, tmp_stride, 4, costs, within_tile);

	mov	esi, esp
	lea	eax, DWORD PTR _within_tile$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _costs$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _tmp_stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp_pic$[ebp]
	push	eax
	push	64					; 00000040H
	lea	ecx, DWORD PTR _filtered_pos$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	DWORD PTR _kvz_satd_any_size_quad
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1121 : 
; 1122 :     for (int j = 0; j < 4; j++) {

	mov	DWORD PTR _j$2[ebp], 0
	jmp	SHORT $LN10@search_fra
$LN8@search_fra:
	mov	eax, DWORD PTR _j$2[ebp]
	add	eax, 1
	mov	DWORD PTR _j$2[ebp], eax
$LN10@search_fra:
	cmp	DWORD PTR _j$2[ebp], 4
	jge	$LN9@search_fra

; 1123 :       if (within_tile[j]) {

	mov	eax, DWORD PTR _j$2[ebp]
	movsx	ecx, BYTE PTR _within_tile$5[ebp+eax]
	test	ecx, ecx
	je	$LN14@search_fra

; 1124 :         costs[j] += info->mvd_cost_func(

	mov	eax, DWORD PTR _j$2[ebp]
	lea	ecx, DWORD PTR _bitcosts$[ebp+eax*4]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _info$[ebx]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _info$[ebx]
	movzx	edx, WORD PTR [ecx+100]
	push	edx
	mov	eax, DWORD PTR _info$[ebx]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _info$[ebx]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _mv_shift$7[ebp]
	push	edx
	mov	eax, DWORD PTR _j$2[ebp]
	mov	ecx, DWORD PTR _pattern$6[ebp+eax*4]
	mov	edx, DWORD PTR _mv$[ebp+4]
	add	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _j$2[ebp]
	mov	ecx, DWORD PTR _pattern$6[ebp+eax*4]
	mov	edx, DWORD PTR _mv$[ebp]
	add	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$[ebx]
	mov	edx, DWORD PTR [ecx+104]
	call	edx
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _j$2[ebp]
	add	eax, DWORD PTR _costs$[ebp+ecx*4]
	mov	edx, DWORD PTR _j$2[ebp]
	mov	DWORD PTR _costs$[ebp+edx*4], eax
$LN14@search_fra:

; 1125 :             state,
; 1126 :             mv.x + pattern[j]->x,
; 1127 :             mv.y + pattern[j]->y,
; 1128 :             mv_shift,
; 1129 :             info->mv_cand,
; 1130 :             info->merge_cand,
; 1131 :             info->num_merge_cand,
; 1132 :             info->ref_idx,
; 1133 :             &bitcosts[j]
; 1134 :         );
; 1135 :       }
; 1136 :     }

	jmp	$LN8@search_fra
$LN9@search_fra:

; 1137 : 
; 1138 :     for (int j = 0; j < 4; ++j) {

	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN13@search_fra
$LN11@search_fra:
	mov	eax, DWORD PTR _j$1[ebp]
	add	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN13@search_fra:
	cmp	DWORD PTR _j$1[ebp], 4
	jge	SHORT $LN12@search_fra

; 1139 :       if (within_tile[j] && costs[j] < best_cost) {

	mov	eax, DWORD PTR _j$1[ebp]
	movsx	ecx, BYTE PTR _within_tile$5[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN15@search_fra
	mov	eax, DWORD PTR _j$1[ebp]
	mov	ecx, DWORD PTR _costs$[ebp+eax*4]
	cmp	ecx, DWORD PTR _best_cost$[ebp]
	jae	SHORT $LN15@search_fra

; 1140 :         best_cost = costs[j];

	mov	eax, DWORD PTR _j$1[ebp]
	mov	ecx, DWORD PTR _costs$[ebp+eax*4]
	mov	DWORD PTR _best_cost$[ebp], ecx

; 1141 :         best_bitcost = bitcosts[j];

	mov	eax, DWORD PTR _j$1[ebp]
	mov	ecx, DWORD PTR _bitcosts$[ebp+eax*4]
	mov	DWORD PTR _best_bitcost$[ebp], ecx

; 1142 :         best_index = i + j;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _j$1[ebp]
	mov	DWORD PTR _best_index$[ebp], eax
$LN15@search_fra:

; 1143 :       }
; 1144 :     }

	jmp	SHORT $LN11@search_fra
$LN12@search_fra:

; 1145 : 
; 1146 :     i += 4;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 4
	mov	DWORD PTR _i$[ebp], eax

; 1147 : 
; 1148 :     // Update mv for the best position on current precision
; 1149 :     if (step == 1 || step == fme_level - 1) {

	cmp	DWORD PTR _step$8[ebp], 1
	je	SHORT $LN17@search_fra
	mov	eax, DWORD PTR _fme_level$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _step$8[ebp], eax
	jne	$LN16@search_fra
$LN17@search_fra:

; 1150 :       // Move search to best_index
; 1151 :       mv.x += square[best_index].x;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, DWORD PTR ?square@?1??search_frac@@9@9[eax*8]
	mov	DWORD PTR _mv$[ebp], ecx

; 1152 :       mv.y += square[best_index].y;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?square@?1??search_frac@@9@9[eax*8+4]
	mov	DWORD PTR _mv$[ebp+4], ecx

; 1153 : 
; 1154 :       // On last hpel step...
; 1155 :       if (step == MIN(fme_level - 1, 1)) {

	mov	eax, DWORD PTR _fme_level$[ebp]
	sub	eax, 1
	cmp	eax, 1
	jge	SHORT $LN22@search_fra
	mov	ecx, DWORD PTR _fme_level$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv397[ebp], ecx
	jmp	SHORT $LN23@search_fra
$LN22@search_fra:
	mov	DWORD PTR tv397[ebp], 1
$LN23@search_fra:
	mov	edx, DWORD PTR _step$8[ebp]
	cmp	edx, DWORD PTR tv397[ebp]
	jne	SHORT $LN16@search_fra

; 1156 :         //Set mv to quarterpel precision
; 1157 :         mv.x *= 2;

	mov	eax, DWORD PTR _mv$[ebp]
	shl	eax, 1
	mov	DWORD PTR _mv$[ebp], eax

; 1158 :         mv.y *= 2;

	mov	eax, DWORD PTR _mv$[ebp+4]
	shl	eax, 1
	mov	DWORD PTR _mv$[ebp+4], eax

; 1159 :         sample_off_x = square[best_index].x;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	cl, BYTE PTR ?square@?1??search_frac@@9@9[eax*8]
	mov	BYTE PTR _sample_off_x$[ebp], cl

; 1160 :         sample_off_y = square[best_index].y;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	cl, BYTE PTR ?square@?1??search_frac@@9@9[eax*8+4]
	mov	BYTE PTR _sample_off_y$[ebp], cl

; 1161 :         best_index = 0;

	mov	DWORD PTR _best_index$[ebp], 0

; 1162 :         i = 1;

	mov	DWORD PTR _i$[ebp], 1
$LN16@search_fra:

; 1163 :       }
; 1164 :     }
; 1165 :   }

	jmp	$LN2@search_fra
$LN3@search_fra:

; 1166 : 
; 1167 :   info->best_mv = mv;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR _mv$[ebp]
	mov	DWORD PTR [eax+108], ecx
	mov	edx, DWORD PTR _mv$[ebp+4]
	mov	DWORD PTR [eax+112], edx

; 1168 :   info->best_cost = best_cost;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR _best_cost$[ebp]
	mov	DWORD PTR [eax+116], ecx

; 1169 :   info->best_bitcost = best_bitcost;

	mov	eax, DWORD PTR _info$[ebx]
	mov	ecx, DWORD PTR _best_bitcost$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 1170 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN41@search_fra
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
	npad	3
$LN41@search_fra:
	DD	16					; 00000010H
	DD	$LN40@search_fra
$LN40@search_fra:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN24@search_fra
	DD	-64					; ffffffc0H
	DD	16					; 00000010H
	DD	$LN25@search_fra
	DD	-100					; ffffff9cH
	DD	16					; 00000010H
	DD	$LN26@search_fra
	DD	-16512					; ffffbf80H
	DD	16384					; 00004000H
	DD	$LN27@search_fra
	DD	-62656					; ffff0b40H
	DD	46080					; 0000b400H
	DD	$LN28@search_fra
	DD	-63384					; ffff0868H
	DD	720					; 000002d0H
	DD	$LN29@search_fra
	DD	-63424					; ffff0840H
	DD	8
	DD	$LN30@search_fra
	DD	-68712					; fffef398H
	DD	5184					; 00001440H
	DD	$LN31@search_fra
	DD	-68724					; fffef38cH
	DD	4
	DD	$LN32@search_fra
	DD	-68736					; fffef380H
	DD	4
	DD	$LN33@search_fra
	DD	-68748					; fffef374H
	DD	4
	DD	$LN34@search_fra
	DD	-68832					; fffef320H
	DD	68					; 00000044H
	DD	$LN35@search_fra
	DD	-68880					; fffef2f0H
	DD	16					; 00000010H
	DD	$LN36@search_fra
	DD	-68940					; fffef2b4H
	DD	16					; 00000010H
	DD	$LN37@search_fra
	DD	-68952					; fffef2a8H
	DD	4
	DD	$LN38@search_fra
	DD	-68988					; fffef284H
	DD	16					; 00000010H
	DD	$LN39@search_fra
$LN39@search_fra:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
$LN38@search_fra:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN37@search_fra:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	0
$LN36@search_fra:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	0
$LN35@search_fra:
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN34@search_fra:
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	0
$LN33@search_fra:
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
$LN32@search_fra:
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
$LN31@search_fra:
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN30@search_fra:
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
$LN29@search_fra:
	DB	104					; 00000068H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	115					; 00000073H
	DB	0
$LN28@search_fra:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$LN27@search_fra:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN26@search_fra:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN25@search_fra:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN24@search_fra:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
_search_frac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _search_mv_full
_TEXT	SEGMENT
_yy$1 = -176						; size = 4
_xx$2 = -164						; size = 4
_j$3 = -152						; size = 4
_already_tested$4 = -137				; size = 1
_x$5 = -128						; size = 4
_y$6 = -116						; size = 4
_max_mv$7 = -104					; size = 8
_min_mv$8 = -88						; size = 8
_mv$9 = -72						; size = 8
_i$10 = -56						; size = 4
_x$11 = -44						; size = 4
_y$12 = -32						; size = 4
_x$13 = -20						; size = 4
_y$14 = -8						; size = 4
_info$ = 8						; size = 4
_search_range$ = 12					; size = 4
_extra_mv$ = 16						; size = 8
_search_mv_full PROC					; COMDAT

; 909  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 93					; 0000005dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 910  :   // Search around the 0-vector.
; 911  :   for (int y = -search_range; y <= search_range; y++) {

	mov	eax, DWORD PTR _search_range$[ebp]
	neg	eax
	mov	DWORD PTR _y$14[ebp], eax
	jmp	SHORT $LN4@search_mv_
$LN2@search_mv_:
	mov	eax, DWORD PTR _y$14[ebp]
	add	eax, 1
	mov	DWORD PTR _y$14[ebp], eax
$LN4@search_mv_:
	mov	eax, DWORD PTR _y$14[ebp]
	cmp	eax, DWORD PTR _search_range$[ebp]
	jg	SHORT $LN3@search_mv_

; 912  :     for (int x = -search_range; x <= search_range; x++) {

	mov	eax, DWORD PTR _search_range$[ebp]
	neg	eax
	mov	DWORD PTR _x$13[ebp], eax
	jmp	SHORT $LN7@search_mv_
$LN5@search_mv_:
	mov	eax, DWORD PTR _x$13[ebp]
	add	eax, 1
	mov	DWORD PTR _x$13[ebp], eax
$LN7@search_mv_:
	mov	eax, DWORD PTR _x$13[ebp]
	cmp	eax, DWORD PTR _search_range$[ebp]
	jg	SHORT $LN6@search_mv_

; 913  :       check_mv_cost(info, x, y);

	mov	eax, DWORD PTR _y$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH

; 914  :     }

	jmp	SHORT $LN5@search_mv_
$LN6@search_mv_:

; 915  :   }

	jmp	SHORT $LN2@search_mv_
$LN3@search_mv_:

; 916  : 
; 917  :   // Change to integer precision.
; 918  :   extra_mv.x >>= 2;

	mov	eax, DWORD PTR _extra_mv$[ebp]
	sar	eax, 2
	mov	DWORD PTR _extra_mv$[ebp], eax

; 919  :   extra_mv.y >>= 2;

	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	sar	eax, 2
	mov	DWORD PTR _extra_mv$[ebp+4], eax

; 920  : 
; 921  :   // Check around extra_mv if it's not one of the merge candidates.
; 922  :   if (!mv_in_merge(info, extra_mv)) {

	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _extra_mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_mv_in_merge
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN26@search_mv_

; 923  :     for (int y = -search_range; y <= search_range; y++) {

	mov	eax, DWORD PTR _search_range$[ebp]
	neg	eax
	mov	DWORD PTR _y$12[ebp], eax
	jmp	SHORT $LN10@search_mv_
$LN8@search_mv_:
	mov	eax, DWORD PTR _y$12[ebp]
	add	eax, 1
	mov	DWORD PTR _y$12[ebp], eax
$LN10@search_mv_:
	mov	eax, DWORD PTR _y$12[ebp]
	cmp	eax, DWORD PTR _search_range$[ebp]
	jg	SHORT $LN26@search_mv_

; 924  :       for (int x = -search_range; x <= search_range; x++) {

	mov	eax, DWORD PTR _search_range$[ebp]
	neg	eax
	mov	DWORD PTR _x$11[ebp], eax
	jmp	SHORT $LN13@search_mv_
$LN11@search_mv_:
	mov	eax, DWORD PTR _x$11[ebp]
	add	eax, 1
	mov	DWORD PTR _x$11[ebp], eax
$LN13@search_mv_:
	mov	eax, DWORD PTR _x$11[ebp]
	cmp	eax, DWORD PTR _search_range$[ebp]
	jg	SHORT $LN12@search_mv_

; 925  :         check_mv_cost(info, extra_mv.x + x, extra_mv.y + y);

	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	add	eax, DWORD PTR _y$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _extra_mv$[ebp]
	add	ecx, DWORD PTR _x$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH

; 926  :       }

	jmp	SHORT $LN11@search_mv_
$LN12@search_mv_:

; 927  :     }

	jmp	SHORT $LN8@search_mv_
$LN26@search_mv_:

; 928  :   }
; 929  : 
; 930  :   // Select starting point from among merge candidates. These should include
; 931  :   // both mv_cand vectors and (0, 0).
; 932  :   for (int i = 0; i < info->num_merge_cand; ++i) {

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN16@search_mv_
$LN14@search_mv_:
	mov	eax, DWORD PTR _i$10[ebp]
	add	eax, 1
	mov	DWORD PTR _i$10[ebp], eax
$LN16@search_mv_:
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _i$10[ebp]
	cmp	ecx, DWORD PTR [eax+100]
	jge	$LN1@search_mv_

; 933  :     if (info->merge_cand[i].dir == 3) continue;

	imul	eax, DWORD PTR _i$10[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+40]
	cmp	edx, 3
	jne	SHORT $LN27@search_mv_
	jmp	SHORT $LN14@search_mv_
$LN27@search_mv_:

; 934  : 
; 935  :     vector2d_t mv = {

	imul	eax, DWORD PTR _i$10[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _i$10[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	sar	ecx, 2
	mov	DWORD PTR _mv$9[ebp], ecx
	imul	eax, DWORD PTR _i$10[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _i$10[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	sar	eax, 2
	mov	DWORD PTR _mv$9[ebp+4], eax

; 936  :       .x = info->merge_cand[i].mv[info->merge_cand[i].dir - 1][0] >> 2,
; 937  :       .y = info->merge_cand[i].mv[info->merge_cand[i].dir - 1][1] >> 2,
; 938  :     };
; 939  : 
; 940  :     // Ignore 0-vector because it has already been checked.
; 941  :     if (mv.x == 0 && mv.y == 0) continue;

	cmp	DWORD PTR _mv$9[ebp], 0
	jne	SHORT $LN28@search_mv_
	cmp	DWORD PTR _mv$9[ebp+4], 0
	jne	SHORT $LN28@search_mv_
	jmp	$LN14@search_mv_
$LN28@search_mv_:

; 942  : 
; 943  :     vector2d_t min_mv = { mv.x - search_range, mv.y - search_range };

	mov	eax, DWORD PTR _mv$9[ebp]
	sub	eax, DWORD PTR _search_range$[ebp]
	mov	DWORD PTR _min_mv$8[ebp], eax
	mov	eax, DWORD PTR _mv$9[ebp+4]
	sub	eax, DWORD PTR _search_range$[ebp]
	mov	DWORD PTR _min_mv$8[ebp+4], eax

; 944  :     vector2d_t max_mv = { mv.x + search_range, mv.y + search_range };

	mov	eax, DWORD PTR _mv$9[ebp]
	add	eax, DWORD PTR _search_range$[ebp]
	mov	DWORD PTR _max_mv$7[ebp], eax
	mov	eax, DWORD PTR _mv$9[ebp+4]
	add	eax, DWORD PTR _search_range$[ebp]
	mov	DWORD PTR _max_mv$7[ebp+4], eax

; 945  : 
; 946  :     for (int y = min_mv.y; y <= max_mv.y; ++y) {

	mov	eax, DWORD PTR _min_mv$8[ebp+4]
	mov	DWORD PTR _y$6[ebp], eax
	jmp	SHORT $LN19@search_mv_
$LN17@search_mv_:
	mov	eax, DWORD PTR _y$6[ebp]
	add	eax, 1
	mov	DWORD PTR _y$6[ebp], eax
$LN19@search_mv_:
	mov	eax, DWORD PTR _y$6[ebp]
	cmp	eax, DWORD PTR _max_mv$7[ebp+4]
	jg	$LN18@search_mv_

; 947  :       for (int x = min_mv.x; x <= max_mv.x; ++x) {

	mov	eax, DWORD PTR _min_mv$8[ebp]
	mov	DWORD PTR _x$5[ebp], eax
	jmp	SHORT $LN22@search_mv_
$LN20@search_mv_:
	mov	eax, DWORD PTR _x$5[ebp]
	add	eax, 1
	mov	DWORD PTR _x$5[ebp], eax
$LN22@search_mv_:
	mov	eax, DWORD PTR _x$5[ebp]
	cmp	eax, DWORD PTR _max_mv$7[ebp]
	jg	$LN21@search_mv_

; 948  :         if (!intmv_within_tile(info, x, y)) {

	mov	eax, DWORD PTR _y$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_intmv_within_tile
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN29@search_mv_

; 949  :           continue;

	jmp	SHORT $LN20@search_mv_
$LN29@search_mv_:

; 950  :         }
; 951  : 
; 952  :         // Avoid calculating the same points over and over again.
; 953  :         bool already_tested = false;

	mov	BYTE PTR _already_tested$4[ebp], 0

; 954  :         for (int j = -1; j < i; ++j) {

	mov	DWORD PTR _j$3[ebp], -1
	jmp	SHORT $LN25@search_mv_
$LN23@search_mv_:
	mov	eax, DWORD PTR _j$3[ebp]
	add	eax, 1
	mov	DWORD PTR _j$3[ebp], eax
$LN25@search_mv_:
	mov	eax, DWORD PTR _j$3[ebp]
	cmp	eax, DWORD PTR _i$10[ebp]
	jge	$LN24@search_mv_

; 955  :           int xx = 0;

	mov	DWORD PTR _xx$2[ebp], 0

; 956  :           int yy = 0;

	mov	DWORD PTR _yy$1[ebp], 0

; 957  :           if (j >= 0) {

	cmp	DWORD PTR _j$3[ebp], 0
	jl	$LN30@search_mv_

; 958  :             if (info->merge_cand[j].dir == 3) continue;

	imul	eax, DWORD PTR _j$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+40]
	cmp	edx, 3
	jne	SHORT $LN31@search_mv_
	jmp	SHORT $LN23@search_mv_
$LN31@search_mv_:

; 959  :             xx = info->merge_cand[j].mv[info->merge_cand[j].dir - 1][0] >> 2;

	imul	eax, DWORD PTR _j$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _j$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	sar	ecx, 2
	mov	DWORD PTR _xx$2[ebp], ecx

; 960  :             yy = info->merge_cand[j].mv[info->merge_cand[j].dir - 1][1] >> 2;

	imul	eax, DWORD PTR _j$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _j$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	sar	eax, 2
	mov	DWORD PTR _yy$1[ebp], eax
$LN30@search_mv_:

; 961  :           }
; 962  :           if (x >= xx - search_range && x <= xx + search_range &&
; 963  :               y >= yy - search_range && y <= yy + search_range)

	mov	eax, DWORD PTR _xx$2[ebp]
	sub	eax, DWORD PTR _search_range$[ebp]
	cmp	DWORD PTR _x$5[ebp], eax
	jl	SHORT $LN32@search_mv_
	mov	eax, DWORD PTR _xx$2[ebp]
	add	eax, DWORD PTR _search_range$[ebp]
	cmp	DWORD PTR _x$5[ebp], eax
	jg	SHORT $LN32@search_mv_
	mov	eax, DWORD PTR _yy$1[ebp]
	sub	eax, DWORD PTR _search_range$[ebp]
	cmp	DWORD PTR _y$6[ebp], eax
	jl	SHORT $LN32@search_mv_
	mov	eax, DWORD PTR _yy$1[ebp]
	add	eax, DWORD PTR _search_range$[ebp]
	cmp	DWORD PTR _y$6[ebp], eax
	jg	SHORT $LN32@search_mv_

; 964  :           {
; 965  :             already_tested = true;

	mov	BYTE PTR _already_tested$4[ebp], 1

; 966  :             x = xx + search_range;

	mov	eax, DWORD PTR _xx$2[ebp]
	add	eax, DWORD PTR _search_range$[ebp]
	mov	DWORD PTR _x$5[ebp], eax

; 967  :             break;

	jmp	SHORT $LN24@search_mv_
$LN32@search_mv_:

; 968  :           }
; 969  :         }

	jmp	$LN23@search_mv_
$LN24@search_mv_:

; 970  :         if (already_tested) continue;

	movzx	eax, BYTE PTR _already_tested$4[ebp]
	test	eax, eax
	je	SHORT $LN33@search_mv_
	jmp	$LN20@search_mv_
$LN33@search_mv_:

; 971  : 
; 972  :         check_mv_cost(info, x, y);

	mov	eax, DWORD PTR _y$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH

; 973  :       }

	jmp	$LN20@search_mv_
$LN21@search_mv_:

; 974  :     }

	jmp	$LN17@search_mv_
$LN18@search_mv_:

; 975  :   }

	jmp	$LN14@search_mv_
$LN1@search_mv_:

; 976  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN39@search_mv_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN39@search_mv_:
	DD	3
	DD	$LN38@search_mv_
$LN38@search_mv_:
	DD	-72					; ffffffb8H
	DD	8
	DD	$LN35@search_mv_
	DD	-88					; ffffffa8H
	DD	8
	DD	$LN36@search_mv_
	DD	-104					; ffffff98H
	DD	8
	DD	$LN37@search_mv_
$LN37@search_mv_:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
$LN36@search_mv_:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
$LN35@search_mv_:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
_search_mv_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _diamond_search
_TEXT	SEGMENT
_i$1 = -72						; size = 4
_better_found$ = -57					; size = 1
_from_dir$ = -48					; size = 4
_i$2 = -36						; size = 4
_best_index$ = -24					; size = 4
_mv$ = -12						; size = 8
_info$ = 8						; size = 4
_extra_mv$ = 12						; size = 8
_steps$ = 20						; size = 4
_diamond_search PROC					; COMDAT

; 817  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 818  :   enum diapos {
; 819  :     DIA_UP = 0,
; 820  :     DIA_RIGHT = 1,
; 821  :     DIA_LEFT = 2,
; 822  :     DIA_DOWN = 3,
; 823  :     DIA_CENTER = 4,
; 824  :   };
; 825  : 
; 826  :   // a diamond shape with the center included
; 827  :   //   0
; 828  :   // 2 4 1
; 829  :   //   3
; 830  :   static const vector2d_t diamond[5] = {
; 831  :     {0, -1}, {1, 0}, {0, 1}, {-1, 0},
; 832  :     {0, 0}
; 833  :   };
; 834  : 
; 835  :   info->best_cost = UINT32_MAX;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+116], -1

; 836  : 
; 837  :   // Select starting point from among merge candidates. These should
; 838  :   // include both mv_cand vectors and (0, 0).
; 839  :   select_starting_point(info, extra_mv);

	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _extra_mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_select_starting_point
	add	esp, 12					; 0000000cH

; 840  : 
; 841  :   // Check if we should stop search
; 842  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+2356], 0
	je	SHORT $LN11@diamond_se
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_early_terminate
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@diamond_se

; 843  :     early_terminate(info))
; 844  :   {
; 845  :     return;

	jmp	$LN1@diamond_se
$LN11@diamond_se:

; 846  :   }
; 847  :   
; 848  :   // current motion vector
; 849  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp], ecx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp+4], ecx

; 850  : 
; 851  :   // current best index
; 852  :   enum diapos best_index = DIA_CENTER;

	mov	DWORD PTR _best_index$[ebp], 4

; 853  : 
; 854  :   // initial search of the points of the diamond
; 855  :   for (int i = 0; i < 5; ++i) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@diamond_se
$LN2@diamond_se:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@diamond_se:
	cmp	DWORD PTR _i$2[ebp], 5
	jge	SHORT $LN3@diamond_se

; 856  :     if (check_mv_cost(info, mv.x + diamond[i].x, mv.y + diamond[i].y)) {

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?diamond@?1??diamond_search@@9@9[eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _mv$[ebp]
	add	eax, DWORD PTR ?diamond@?1??diamond_search@@9@9[edx*8]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@diamond_se

; 857  :       best_index = i;

	mov	eax, DWORD PTR _i$2[ebp]
	mov	DWORD PTR _best_index$[ebp], eax
$LN12@diamond_se:

; 858  :     }
; 859  :   }

	jmp	SHORT $LN2@diamond_se
$LN3@diamond_se:

; 860  : 
; 861  :   if (best_index == DIA_CENTER) {

	cmp	DWORD PTR _best_index$[ebp], 4
	jne	SHORT $LN13@diamond_se

; 862  :     // the center point was the best in initial check
; 863  :     return;

	jmp	$LN1@diamond_se
$LN13@diamond_se:

; 864  :   }
; 865  : 
; 866  :   // Move the center to the best match.
; 867  :   mv.x += diamond[best_index].x;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, DWORD PTR ?diamond@?1??diamond_search@@9@9[eax*8]
	mov	DWORD PTR _mv$[ebp], ecx

; 868  :   mv.y += diamond[best_index].y;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?diamond@?1??diamond_search@@9@9[eax*8+4]
	mov	DWORD PTR _mv$[ebp+4], ecx

; 869  : 
; 870  :   // the arrival direction, the index of the diamond member that will be excluded
; 871  :   enum diapos from_dir = DIA_CENTER;

	mov	DWORD PTR _from_dir$[ebp], 4
$LN7@diamond_se:

; 872  : 
; 873  :   // whether we found a better candidate this iteration
; 874  :   uint8_t better_found;
; 875  : 
; 876  :   do {
; 877  :     better_found = 0;

	mov	BYTE PTR _better_found$[ebp], 0

; 878  :     // decrement count if enabled
; 879  :     if (steps > 0) steps -= 1;

	cmp	DWORD PTR _steps$[ebp], 0
	jbe	SHORT $LN14@diamond_se
	mov	eax, DWORD PTR _steps$[ebp]
	sub	eax, 1
	mov	DWORD PTR _steps$[ebp], eax
$LN14@diamond_se:

; 880  : 
; 881  :     // search the points of the diamond
; 882  :     for (int i = 0; i < 4; ++i) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN10@diamond_se
$LN8@diamond_se:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN10@diamond_se:
	cmp	DWORD PTR _i$1[ebp], 4
	jge	SHORT $LN9@diamond_se

; 883  :       // this is where we came from so it's checked already
; 884  :       if (i == from_dir) continue;

	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _from_dir$[ebp]
	jne	SHORT $LN15@diamond_se
	jmp	SHORT $LN8@diamond_se
$LN15@diamond_se:

; 885  : 
; 886  :       if (check_mv_cost(info, mv.x + diamond[i].x, mv.y + diamond[i].y)) {

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?diamond@?1??diamond_search@@9@9[eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _mv$[ebp]
	add	eax, DWORD PTR ?diamond@?1??diamond_search@@9@9[edx*8]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN16@diamond_se

; 887  :         best_index = i;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	DWORD PTR _best_index$[ebp], eax

; 888  :         better_found = 1;

	mov	BYTE PTR _better_found$[ebp], 1
$LN16@diamond_se:

; 889  :       }
; 890  :     }

	jmp	SHORT $LN8@diamond_se
$LN9@diamond_se:

; 891  : 
; 892  :     if (better_found) {

	movzx	eax, BYTE PTR _better_found$[ebp]
	test	eax, eax
	je	SHORT $LN5@diamond_se

; 893  :       // Move the center to the best match.
; 894  :       mv.x += diamond[best_index].x;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, DWORD PTR ?diamond@?1??diamond_search@@9@9[eax*8]
	mov	DWORD PTR _mv$[ebp], ecx

; 895  :       mv.y += diamond[best_index].y;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?diamond@?1??diamond_search@@9@9[eax*8+4]
	mov	DWORD PTR _mv$[ebp+4], ecx

; 896  : 
; 897  :       // record where we came from to the next iteration
; 898  :       // the xor operation flips the orientation
; 899  :       from_dir = best_index ^ 0x3;

	mov	eax, DWORD PTR _best_index$[ebp]
	xor	eax, 3
	mov	DWORD PTR _from_dir$[ebp], eax
$LN5@diamond_se:

; 900  :     }
; 901  :   } while (better_found && steps != 0);

	movzx	eax, BYTE PTR _better_found$[ebp]
	test	eax, eax
	je	SHORT $LN1@diamond_se
	cmp	DWORD PTR _steps$[ebp], 0
	jne	$LN7@diamond_se
$LN1@diamond_se:

; 902  :   // and we're done
; 903  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@diamond_se
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN22@diamond_se:
	DD	1
	DD	$LN21@diamond_se
$LN21@diamond_se:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN20@diamond_se
$LN20@diamond_se:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
_diamond_search ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _hexagon_search
_TEXT	SEGMENT
_i$1 = -88						; size = 4
_offset$2 = -76						; size = 8
_i$3 = -60						; size = 4
_start$4 = -48						; size = 4
_i$5 = -36						; size = 4
_best_index$ = -24					; size = 4
_mv$ = -12						; size = 8
_info$ = 8						; size = 4
_extra_mv$ = 12						; size = 8
_steps$ = 20						; size = 4
_hexagon_search PROC					; COMDAT

; 711  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 712  :   // The start of the hexagonal pattern has been repeated at the end so that
; 713  :   // the indices between 1-6 can be used as the start of a 3-point list of new
; 714  :   // points to search.
; 715  :   //   6--1,7
; 716  :   //  /     \    =)
; 717  :   // 5   0  2,8
; 718  :   //  \     /
; 719  :   //   4---3
; 720  :   static const vector2d_t large_hexbs[9] = {
; 721  :       { 0, 0 },
; 722  :       { 1, -2 }, { 2, 0 }, { 1, 2 }, { -1, 2 }, { -2, 0 }, { -1, -2 },
; 723  :       { 1, -2 }, { 2, 0 }
; 724  :   };
; 725  :   // This is used as the last step of the hexagon search.
; 726  :   //   1
; 727  :   // 2 0 3
; 728  :   //   4
; 729  :   static const vector2d_t small_hexbs[9] = {
; 730  :       { 0, 0 },
; 731  :       { 0, -1 }, { -1, 0 }, { 1, 0 }, { 0, 1 },
; 732  :       { -1, -1 }, { 1, -1 }, { -1, 1 }, { 1, 1 }
; 733  :   };
; 734  : 
; 735  :   info->best_cost = UINT32_MAX;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+116], -1

; 736  : 
; 737  :   // Select starting point from among merge candidates. These should
; 738  :   // include both mv_cand vectors and (0, 0).
; 739  :   select_starting_point(info, extra_mv);

	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _extra_mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_select_starting_point
	add	esp, 12					; 0000000cH

; 740  : 
; 741  :   // Check if we should stop search
; 742  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+2356], 0
	je	SHORT $LN13@hexagon_se
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_early_terminate
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@hexagon_se

; 743  :       early_terminate(info))
; 744  :   {
; 745  :     return;

	jmp	$LN1@hexagon_se
$LN13@hexagon_se:

; 746  :   }
; 747  : 
; 748  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp], ecx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp+4], ecx

; 749  : 
; 750  :   // Current best index, either to merge_cands, large_hexbs or small_hexbs.
; 751  :   int best_index = 0;

	mov	DWORD PTR _best_index$[ebp], 0

; 752  : 
; 753  :   // Search the initial 7 points of the hexagon.
; 754  :   for (int i = 1; i < 7; ++i) {

	mov	DWORD PTR _i$5[ebp], 1
	jmp	SHORT $LN4@hexagon_se
$LN2@hexagon_se:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN4@hexagon_se:
	cmp	DWORD PTR _i$5[ebp], 7
	jge	SHORT $LN5@hexagon_se

; 755  :     if (check_mv_cost(info, mv.x + large_hexbs[i].x, mv.y + large_hexbs[i].y)) {

	mov	eax, DWORD PTR _i$5[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?large_hexbs@?1??hexagon_search@@9@9[eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _i$5[ebp]
	mov	eax, DWORD PTR _mv$[ebp]
	add	eax, DWORD PTR ?large_hexbs@?1??hexagon_search@@9@9[edx*8]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@hexagon_se

; 756  :       best_index = i;

	mov	eax, DWORD PTR _i$5[ebp]
	mov	DWORD PTR _best_index$[ebp], eax
$LN14@hexagon_se:

; 757  :     }
; 758  :   }

	jmp	SHORT $LN2@hexagon_se
$LN5@hexagon_se:

; 759  : 
; 760  :   // Iteratively search the 3 new points around the best match, until the best
; 761  :   // match is in the center.
; 762  :   while (best_index != 0 && steps != 0) {

	cmp	DWORD PTR _best_index$[ebp], 0
	je	$LN6@hexagon_se
	cmp	DWORD PTR _steps$[ebp], 0
	je	$LN6@hexagon_se

; 763  :     // decrement count if enabled
; 764  :     if (steps > 0) steps -= 1;

	cmp	DWORD PTR _steps$[ebp], 0
	jbe	SHORT $LN15@hexagon_se
	mov	eax, DWORD PTR _steps$[ebp]
	sub	eax, 1
	mov	DWORD PTR _steps$[ebp], eax
$LN15@hexagon_se:

; 765  : 
; 766  :     // Starting point of the 3 offsets to be searched.
; 767  :     unsigned start;
; 768  :     if (best_index == 1) {

	cmp	DWORD PTR _best_index$[ebp], 1
	jne	SHORT $LN16@hexagon_se

; 769  :       start = 6;

	mov	DWORD PTR _start$4[ebp], 6
	jmp	SHORT $LN17@hexagon_se
$LN16@hexagon_se:

; 770  :     } else if (best_index == 8) {

	cmp	DWORD PTR _best_index$[ebp], 8
	jne	SHORT $LN18@hexagon_se

; 771  :       start = 1;

	mov	DWORD PTR _start$4[ebp], 1

; 772  :     } else {

	jmp	SHORT $LN17@hexagon_se
$LN18@hexagon_se:

; 773  :       start = best_index - 1;

	mov	eax, DWORD PTR _best_index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _start$4[ebp], eax
$LN17@hexagon_se:

; 774  :     }
; 775  : 
; 776  :     // Move the center to the best match.
; 777  :     mv.x += large_hexbs[best_index].x;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, DWORD PTR ?large_hexbs@?1??hexagon_search@@9@9[eax*8]
	mov	DWORD PTR _mv$[ebp], ecx

; 778  :     mv.y += large_hexbs[best_index].y;

	mov	eax, DWORD PTR _best_index$[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?large_hexbs@?1??hexagon_search@@9@9[eax*8+4]
	mov	DWORD PTR _mv$[ebp+4], ecx

; 779  :     best_index = 0;

	mov	DWORD PTR _best_index$[ebp], 0

; 780  : 
; 781  :     // Iterate through the next 3 points.
; 782  :     for (int i = 0; i < 3; ++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN9@hexagon_se
$LN7@hexagon_se:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN9@hexagon_se:
	cmp	DWORD PTR _i$3[ebp], 3
	jge	SHORT $LN8@hexagon_se

; 783  :       vector2d_t offset = large_hexbs[start + i];

	mov	eax, DWORD PTR _start$4[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR ?large_hexbs@?1??hexagon_search@@9@9[eax*8]
	mov	edx, DWORD PTR ?large_hexbs@?1??hexagon_search@@9@9[eax*8+4]
	mov	DWORD PTR _offset$2[ebp], ecx
	mov	DWORD PTR _offset$2[ebp+4], edx

; 784  :       if (check_mv_cost(info, mv.x + offset.x, mv.y + offset.y)) {

	mov	eax, DWORD PTR _mv$[ebp+4]
	add	eax, DWORD PTR _offset$2[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, DWORD PTR _offset$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@hexagon_se

; 785  :         best_index = start + i;

	mov	eax, DWORD PTR _start$4[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	mov	DWORD PTR _best_index$[ebp], eax
$LN20@hexagon_se:

; 786  :       }
; 787  :     }

	jmp	SHORT $LN7@hexagon_se
$LN8@hexagon_se:

; 788  :   }

	jmp	$LN5@hexagon_se
$LN6@hexagon_se:

; 789  : 
; 790  :   // Move the center to the best match.
; 791  :   //mv.x += large_hexbs[best_index].x;
; 792  :   //mv.y += large_hexbs[best_index].y;
; 793  : 
; 794  :   // Do the final step of the search with a small pattern.
; 795  :   for (int i = 1; i < 9; ++i) {

	mov	DWORD PTR _i$1[ebp], 1
	jmp	SHORT $LN12@hexagon_se
$LN10@hexagon_se:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN12@hexagon_se:
	cmp	DWORD PTR _i$1[ebp], 9
	jge	SHORT $LN1@hexagon_se

; 796  :     check_mv_cost(info, mv.x + small_hexbs[i].x, mv.y + small_hexbs[i].y);

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?small_hexbs@?1??hexagon_search@@9@9[eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _mv$[ebp]
	add	eax, DWORD PTR ?small_hexbs@?1??hexagon_search@@9@9[edx*8]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH

; 797  :   }

	jmp	SHORT $LN10@hexagon_se
$LN1@hexagon_se:

; 798  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@hexagon_se
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN25@hexagon_se:
	DD	2
	DD	$LN24@hexagon_se
$LN24@hexagon_se:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN22@hexagon_se
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN23@hexagon_se
$LN23@hexagon_se:
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN22@hexagon_se:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
_hexagon_search ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _tz_search
_TEXT	SEGMENT
_iDist$1 = -168						; size = 4
_iDist$2 = -156						; size = 4
_iDist$3 = -144						; size = 4
_iDist$4 = -132						; size = 4
_rounds_without_improvement$ = -120			; size = 4
_start$ = -108						; size = 8
_best_dist$ = -92					; size = 4
_use_star_refinement$ = -77				; size = 1
_use_raster_refinement$ = -65				; size = 1
_use_raster_scan$ = -53					; size = 1
_step4_type$ = -44					; size = 4
_step2_type$ = -32					; size = 4
_iRaster$ = -20						; size = 4
_iSearchRange$ = -8					; size = 4
_info$ = 8						; size = 4
_extra_mv$ = 12						; size = 8
_tz_search PROC						; COMDAT

; 616  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-364]
	mov	ecx, 91					; 0000005bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 617  :   //TZ parameters
; 618  :   const int iSearchRange = 96;  // search range for each stage

	mov	DWORD PTR _iSearchRange$[ebp], 96	; 00000060H

; 619  :   const int iRaster = 5;  // search distance limit and downsampling factor for step 3

	mov	DWORD PTR _iRaster$[ebp], 5

; 620  :   const unsigned step2_type = 0;  // search patterns for steps 2 and 4

	mov	DWORD PTR _step2_type$[ebp], 0

; 621  :   const unsigned step4_type = 0;

	mov	DWORD PTR _step4_type$[ebp], 0

; 622  :   const bool use_raster_scan = false;  // enable step 3

	mov	BYTE PTR _use_raster_scan$[ebp], 0

; 623  :   const bool use_raster_refinement = false;  // enable step 4 mode 1

	mov	BYTE PTR _use_raster_refinement$[ebp], 0

; 624  :   const bool use_star_refinement = true;   // enable step 4 mode 2 (only one mode will be executed)

	mov	BYTE PTR _use_star_refinement$[ebp], 1

; 625  : 
; 626  :   int best_dist = 0;

	mov	DWORD PTR _best_dist$[ebp], 0

; 627  :   info->best_cost = UINT32_MAX;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+116], -1

; 628  : 
; 629  :   // Select starting point from among merge candidates. These should
; 630  :   // include both mv_cand vectors and (0, 0).
; 631  :   select_starting_point(info, extra_mv);

	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _extra_mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_select_starting_point
	add	esp, 12					; 0000000cH

; 632  : 
; 633  :   // Check if we should stop search
; 634  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+2356], 0
	je	SHORT $LN16@tz_search
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_early_terminate
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@tz_search

; 635  :       early_terminate(info))
; 636  :   {
; 637  :     return;

	jmp	$LN1@tz_search
$LN16@tz_search:

; 638  :   }
; 639  : 
; 640  :   vector2d_t start = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sar	ecx, 2
	mov	DWORD PTR _start$[ebp], ecx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	sar	ecx, 2
	mov	DWORD PTR _start$[ebp+4], ecx

; 641  : 
; 642  :   // step 2, grid search
; 643  :   int rounds_without_improvement = 0;

	mov	DWORD PTR _rounds_without_improvement$[ebp], 0

; 644  :   for (int iDist = 1; iDist <= iSearchRange; iDist *= 2) {

	mov	DWORD PTR _iDist$4[ebp], 1
	jmp	SHORT $LN4@tz_search
$LN2@tz_search:
	mov	eax, DWORD PTR _iDist$4[ebp]
	shl	eax, 1
	mov	DWORD PTR _iDist$4[ebp], eax
$LN4@tz_search:
	mov	eax, DWORD PTR _iDist$4[ebp]
	cmp	eax, DWORD PTR _iSearchRange$[ebp]
	jg	SHORT $LN3@tz_search

; 645  :     kvz_tz_pattern_search(info, step2_type, iDist, start, &best_dist);

	lea	eax, DWORD PTR _best_dist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDist$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _step2_type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_kvz_tz_pattern_search
	add	esp, 24					; 00000018H

; 646  : 
; 647  :     // Break the loop if the last three rounds didn't produce a better MV.
; 648  :     if (best_dist != iDist) rounds_without_improvement++;

	mov	eax, DWORD PTR _best_dist$[ebp]
	cmp	eax, DWORD PTR _iDist$4[ebp]
	je	SHORT $LN17@tz_search
	mov	eax, DWORD PTR _rounds_without_improvement$[ebp]
	add	eax, 1
	mov	DWORD PTR _rounds_without_improvement$[ebp], eax
$LN17@tz_search:

; 649  :     if (rounds_without_improvement >= 3) break;

	cmp	DWORD PTR _rounds_without_improvement$[ebp], 3
	jl	SHORT $LN18@tz_search
	jmp	SHORT $LN3@tz_search
$LN18@tz_search:

; 650  :   }

	jmp	SHORT $LN2@tz_search
$LN3@tz_search:

; 651  : 
; 652  :   if (start.x != 0 || start.y != 0) {

	cmp	DWORD PTR _start$[ebp], 0
	jne	SHORT $LN20@tz_search
	cmp	DWORD PTR _start$[ebp+4], 0
	je	$LN19@tz_search
$LN20@tz_search:

; 653  :     // repeat step 2 starting from the zero MV
; 654  :     start.x = 0;

	mov	DWORD PTR _start$[ebp], 0

; 655  :     start.y = 0;

	mov	DWORD PTR _start$[ebp+4], 0

; 656  :     rounds_without_improvement = 0;

	mov	DWORD PTR _rounds_without_improvement$[ebp], 0

; 657  :     for (int iDist = 1; iDist <= iSearchRange/2; iDist *= 2) {

	mov	DWORD PTR _iDist$3[ebp], 1
	jmp	SHORT $LN7@tz_search
$LN5@tz_search:
	mov	eax, DWORD PTR _iDist$3[ebp]
	shl	eax, 1
	mov	DWORD PTR _iDist$3[ebp], eax
$LN7@tz_search:
	mov	eax, DWORD PTR _iSearchRange$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _iDist$3[ebp], eax
	jg	SHORT $LN19@tz_search

; 658  :       kvz_tz_pattern_search(info, step2_type, iDist, start, &best_dist);

	lea	eax, DWORD PTR _best_dist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDist$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _step2_type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_kvz_tz_pattern_search
	add	esp, 24					; 00000018H

; 659  : 
; 660  :       if (best_dist != iDist) rounds_without_improvement++;

	mov	eax, DWORD PTR _best_dist$[ebp]
	cmp	eax, DWORD PTR _iDist$3[ebp]
	je	SHORT $LN21@tz_search
	mov	eax, DWORD PTR _rounds_without_improvement$[ebp]
	add	eax, 1
	mov	DWORD PTR _rounds_without_improvement$[ebp], eax
$LN21@tz_search:

; 661  :       if (rounds_without_improvement >= 3) break;

	cmp	DWORD PTR _rounds_without_improvement$[ebp], 3
	jl	SHORT $LN22@tz_search
	jmp	SHORT $LN19@tz_search
$LN22@tz_search:

; 662  :     }

	jmp	SHORT $LN5@tz_search
$LN19@tz_search:

; 663  :   }
; 664  : 
; 665  :   //step 3, raster scan
; 666  :   if (use_raster_scan && best_dist > iRaster) {

	movzx	eax, BYTE PTR _use_raster_scan$[ebp]
	test	eax, eax
	je	SHORT $LN23@tz_search
	mov	eax, DWORD PTR _best_dist$[ebp]
	cmp	eax, DWORD PTR _iRaster$[ebp]
	jle	SHORT $LN23@tz_search

; 667  :     best_dist = iRaster;

	mov	eax, DWORD PTR _iRaster$[ebp]
	mov	DWORD PTR _best_dist$[ebp], eax

; 668  :     kvz_tz_raster_search(info, iSearchRange, iRaster);

	mov	eax, DWORD PTR _iRaster$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSearchRange$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_kvz_tz_raster_search
	add	esp, 12					; 0000000cH
$LN23@tz_search:

; 669  :   }
; 670  : 
; 671  :   //step 4
; 672  : 
; 673  :   //raster refinement
; 674  :   if (use_raster_refinement && best_dist > 0) {

	movzx	eax, BYTE PTR _use_raster_refinement$[ebp]
	test	eax, eax
	je	SHORT $LN11@tz_search
	cmp	DWORD PTR _best_dist$[ebp], 0
	jle	SHORT $LN11@tz_search

; 675  :     for (int iDist = best_dist >> 1; iDist > 0; iDist >>= 1) {

	mov	eax, DWORD PTR _best_dist$[ebp]
	sar	eax, 1
	mov	DWORD PTR _iDist$2[ebp], eax
	jmp	SHORT $LN10@tz_search
$LN8@tz_search:
	mov	eax, DWORD PTR _iDist$2[ebp]
	sar	eax, 1
	mov	DWORD PTR _iDist$2[ebp], eax
$LN10@tz_search:
	cmp	DWORD PTR _iDist$2[ebp], 0
	jle	SHORT $LN11@tz_search

; 676  :       start.x = info->best_mv.x >> 2;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sar	ecx, 2
	mov	DWORD PTR _start$[ebp], ecx

; 677  :       start.y = info->best_mv.y >> 2;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	sar	ecx, 2
	mov	DWORD PTR _start$[ebp+4], ecx

; 678  :       kvz_tz_pattern_search(info, step4_type, iDist, start, &best_dist);

	lea	eax, DWORD PTR _best_dist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDist$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _step4_type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_kvz_tz_pattern_search
	add	esp, 24					; 00000018H

; 679  :     }

	jmp	SHORT $LN8@tz_search
$LN11@tz_search:

; 680  :   }
; 681  : 
; 682  :   //star refinement (repeat step 2 for the current starting point)
; 683  :   while (use_star_refinement && best_dist > 0) {

	movzx	eax, BYTE PTR _use_star_refinement$[ebp]
	test	eax, eax
	je	SHORT $LN1@tz_search
	cmp	DWORD PTR _best_dist$[ebp], 0
	jle	SHORT $LN1@tz_search

; 684  :     best_dist = 0;

	mov	DWORD PTR _best_dist$[ebp], 0

; 685  :     start.x = info->best_mv.x >> 2;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sar	ecx, 2
	mov	DWORD PTR _start$[ebp], ecx

; 686  :     start.y = info->best_mv.y >> 2;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	sar	ecx, 2
	mov	DWORD PTR _start$[ebp+4], ecx

; 687  :     for (int iDist = 1; iDist <= iSearchRange; iDist *= 2) {

	mov	DWORD PTR _iDist$1[ebp], 1
	jmp	SHORT $LN15@tz_search
$LN13@tz_search:
	mov	eax, DWORD PTR _iDist$1[ebp]
	shl	eax, 1
	mov	DWORD PTR _iDist$1[ebp], eax
$LN15@tz_search:
	mov	eax, DWORD PTR _iDist$1[ebp]
	cmp	eax, DWORD PTR _iSearchRange$[ebp]
	jg	SHORT $LN14@tz_search

; 688  :       kvz_tz_pattern_search(info, step4_type, iDist, start, &best_dist);

	lea	eax, DWORD PTR _best_dist$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDist$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _step4_type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_kvz_tz_pattern_search
	add	esp, 24					; 00000018H

; 689  :     }

	jmp	SHORT $LN13@tz_search
$LN14@tz_search:

; 690  :   }

	jmp	SHORT $LN11@tz_search
$LN1@tz_search:

; 691  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@tz_search
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 364				; 0000016cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN29@tz_search:
	DD	2
	DD	$LN28@tz_search
$LN28@tz_search:
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN26@tz_search
	DD	-108					; ffffff94H
	DD	8
	DD	$LN27@tz_search
$LN27@tz_search:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$LN26@tz_search:
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_tz_search ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _kvz_tz_raster_search
_TEXT	SEGMENT
_x$1 = -36						; size = 4
_y$2 = -24						; size = 4
_mv$ = -12						; size = 8
_info$ = 8						; size = 4
_iSearchRange$ = 12					; size = 4
_iRaster$ = 16						; size = 4
_kvz_tz_raster_search PROC				; COMDAT

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 604  :   const vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp], ecx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp+4], ecx

; 605  : 
; 606  :   //compute SAD values for every point in the iRaster downsampled version of the current search area
; 607  :   for (int y = iSearchRange; y >= -iSearchRange; y -= iRaster) {

	mov	eax, DWORD PTR _iSearchRange$[ebp]
	mov	DWORD PTR _y$2[ebp], eax
	jmp	SHORT $LN4@kvz_tz_ras
$LN2@kvz_tz_ras:
	mov	eax, DWORD PTR _y$2[ebp]
	sub	eax, DWORD PTR _iRaster$[ebp]
	mov	DWORD PTR _y$2[ebp], eax
$LN4@kvz_tz_ras:
	mov	eax, DWORD PTR _iSearchRange$[ebp]
	neg	eax
	cmp	DWORD PTR _y$2[ebp], eax
	jl	SHORT $LN1@kvz_tz_ras

; 608  :     for (int x = -iSearchRange; x <= iSearchRange; x += iRaster) {

	mov	eax, DWORD PTR _iSearchRange$[ebp]
	neg	eax
	mov	DWORD PTR _x$1[ebp], eax
	jmp	SHORT $LN7@kvz_tz_ras
$LN5@kvz_tz_ras:
	mov	eax, DWORD PTR _x$1[ebp]
	add	eax, DWORD PTR _iRaster$[ebp]
	mov	DWORD PTR _x$1[ebp], eax
$LN7@kvz_tz_ras:
	mov	eax, DWORD PTR _x$1[ebp]
	cmp	eax, DWORD PTR _iSearchRange$[ebp]
	jg	SHORT $LN6@kvz_tz_ras

; 609  :       check_mv_cost(info, mv.x + x, mv.y + y);

	mov	eax, DWORD PTR _mv$[ebp+4]
	add	eax, DWORD PTR _y$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, DWORD PTR _x$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH

; 610  :     }

	jmp	SHORT $LN5@kvz_tz_ras
$LN6@kvz_tz_ras:

; 611  :   }

	jmp	SHORT $LN2@kvz_tz_ras
$LN1@kvz_tz_ras:

; 612  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@kvz_tz_ras
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@kvz_tz_ras:
	DD	1
	DD	$LN10@kvz_tz_ras
$LN10@kvz_tz_ras:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN9@kvz_tz_ras
$LN9@kvz_tz_ras:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
_kvz_tz_raster_search ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _kvz_tz_pattern_search
_TEXT	SEGMENT
tv215 = -540						; size = 4
tv211 = -540						; size = 4
_y$1 = -340						; size = 4
_x$2 = -328						; size = 4
_offset$3 = -316					; size = 8
_i$4 = -300						; size = 4
_best_index$ = -288					; size = 4
_n_points$ = -276					; size = 4
_pattern$ = -264					; size = 256
__$ArrayPad$ = -4					; size = 4
_info$ = 8						; size = 4
_pattern_type$ = 12					; size = 4
_iDist$ = 16						; size = 4
_mv$ = 20						; size = 8
_best_dist$ = 28					; size = 4
_kvz_tz_pattern_search PROC				; COMDAT

; 488  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 540				; 0000021cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-540]
	mov	ecx, 135				; 00000087H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 489  :   assert(pattern_type < 4);

	cmp	DWORD PTR _pattern_type$[ebp], 4
	jb	SHORT $LN20@kvz_tz_pat
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_tz_pattern_search@@9@9
	add	eax, 1
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1HG@OHIPOECE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1CC@GBDINMAN@?$AAp?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DM?$AA?5@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN20@kvz_tz_pat:

; 490  : 
; 491  :   //implemented search patterns
; 492  :   const vector2d_t pattern[4][8] = {

	mov	DWORD PTR _pattern$[ebp], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+4], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+8], eax
	mov	DWORD PTR _pattern$[ebp+12], 0
	mov	DWORD PTR _pattern$[ebp+16], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+20], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+24], eax
	mov	DWORD PTR _pattern$[ebp+28], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+32], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+36], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+40], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+44], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+48], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+52], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+56], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+60], eax
	mov	DWORD PTR _pattern$[ebp+64], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+68], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+72], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+76], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+80], eax
	mov	DWORD PTR _pattern$[ebp+84], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+88], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+92], eax
	mov	DWORD PTR _pattern$[ebp+96], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+100], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+104], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+108], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+112], eax
	mov	DWORD PTR _pattern$[ebp+116], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+120], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+124], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+128], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+132], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+136], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+140], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+144], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+148], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+152], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+156], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+160], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+164], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+168], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+172], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+176], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+180], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+184], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+188], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+192], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+196], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+200], eax
	mov	DWORD PTR _pattern$[ebp+204], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+208], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+212], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+216], eax
	mov	DWORD PTR _pattern$[ebp+220], 0
	mov	eax, DWORD PTR _iDist$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+224], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR _pattern$[ebp+228], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _pattern$[ebp+232], eax
	mov	eax, DWORD PTR _iDist$[ebp]
	neg	eax
	mov	DWORD PTR _pattern$[ebp+236], eax
	mov	DWORD PTR _pattern$[ebp+240], 0
	mov	DWORD PTR _pattern$[ebp+244], 0
	mov	DWORD PTR _pattern$[ebp+248], 0
	mov	DWORD PTR _pattern$[ebp+252], 0

; 493  :       //diamond (8 points)
; 494  :       //[ ][ ][ ][ ][1][ ][ ][ ][ ]
; 495  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 496  :       //[ ][ ][8][ ][ ][ ][5][ ][ ]
; 497  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 498  :       //[4][ ][ ][ ][o][ ][ ][ ][2]
; 499  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 500  :       //[ ][ ][7][ ][ ][ ][6][ ][ ]
; 501  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 502  :       //[ ][ ][ ][ ][3][ ][ ][ ][ ]
; 503  :       {
; 504  :         { 0, iDist }, { iDist, 0 }, { 0, -iDist }, { -iDist, 0 },
; 505  :         { iDist / 2, iDist / 2 }, { iDist / 2, -iDist / 2 }, { -iDist / 2, -iDist / 2 }, { -iDist / 2, iDist / 2 }
; 506  :       },
; 507  : 
; 508  :       //square (8 points)
; 509  :       //[8][ ][ ][ ][1][ ][ ][ ][2]
; 510  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 511  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 512  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 513  :       //[7][ ][ ][ ][o][ ][ ][ ][3]
; 514  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 515  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 516  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 517  :       //[6][ ][ ][ ][5][ ][ ][ ][4]
; 518  :       {
; 519  :         { 0, iDist }, { iDist, iDist }, { iDist, 0 }, { iDist, -iDist }, { 0, -iDist },
; 520  :         { -iDist, -iDist }, { -iDist, 0 }, { -iDist, iDist }
; 521  :       },
; 522  : 
; 523  :       //octagon (8 points)
; 524  :       //[ ][ ][5][ ][ ][ ][1][ ][ ]
; 525  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 526  :       //[ ][ ][ ][ ][ ][ ][ ][ ][2]
; 527  :       //[4][ ][ ][ ][ ][ ][ ][ ][ ]
; 528  :       //[ ][ ][ ][ ][o][ ][ ][ ][ ]
; 529  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 530  :       //[8][ ][ ][ ][ ][ ][ ][ ][6]
; 531  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 532  :       //[ ][ ][7][ ][ ][ ][3][ ][ ]
; 533  :       {
; 534  :         { iDist / 2, iDist }, { iDist, iDist / 2 }, { iDist / 2, -iDist }, { -iDist, iDist / 2 },
; 535  :         { -iDist / 2, iDist }, { iDist, -iDist / 2 }, { -iDist / 2, -iDist }, { -iDist, -iDist / 2 }
; 536  :       },
; 537  : 
; 538  :       //hexagon (6 points)
; 539  :       //[ ][ ][5][ ][ ][ ][1][ ][ ]
; 540  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 541  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 542  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 543  :       //[4][ ][ ][ ][o][ ][ ][ ][2]
; 544  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 545  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 546  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 547  :       //[ ][ ][6][ ][ ][ ][3][ ][ ]
; 548  :       {
; 549  :         { iDist / 2, iDist }, { iDist, 0 }, { iDist / 2, -iDist }, { -iDist, 0 },
; 550  :         { iDist / 2, iDist }, { -iDist / 2, -iDist }, { 0, 0 }, { 0, 0 }
; 551  :       }
; 552  :   };
; 553  : 
; 554  :   // Set the number of points to be checked.
; 555  :   int n_points;
; 556  :   if (iDist == 1) {

	cmp	DWORD PTR _iDist$[ebp], 1
	jne	SHORT $LN9@kvz_tz_pat

; 557  :     switch (pattern_type) {

	mov	eax, DWORD PTR _pattern_type$[ebp]
	mov	DWORD PTR tv211[ebp], eax
	cmp	DWORD PTR tv211[ebp], 0
	je	SHORT $LN11@kvz_tz_pat
	cmp	DWORD PTR tv211[ebp], 2
	je	SHORT $LN12@kvz_tz_pat
	cmp	DWORD PTR tv211[ebp], 3
	je	SHORT $LN13@kvz_tz_pat
	jmp	SHORT $LN14@kvz_tz_pat
$LN11@kvz_tz_pat:

; 558  :       case 0:
; 559  :         n_points = 4;

	mov	DWORD PTR _n_points$[ebp], 4

; 560  :         break;

	jmp	SHORT $LN2@kvz_tz_pat
$LN12@kvz_tz_pat:

; 561  :       case 2:
; 562  :         n_points = 4;

	mov	DWORD PTR _n_points$[ebp], 4

; 563  :         break;

	jmp	SHORT $LN2@kvz_tz_pat
$LN13@kvz_tz_pat:

; 564  :       case 3:
; 565  :         n_points = 4;

	mov	DWORD PTR _n_points$[ebp], 4

; 566  :         break;

	jmp	SHORT $LN2@kvz_tz_pat
$LN14@kvz_tz_pat:

; 567  :       default:
; 568  :         n_points = 8;

	mov	DWORD PTR _n_points$[ebp], 8
$LN2@kvz_tz_pat:

; 569  :         break;
; 570  :     };
; 571  :   } else {

	jmp	SHORT $LN10@kvz_tz_pat
$LN9@kvz_tz_pat:

; 572  :     switch (pattern_type) {

	mov	eax, DWORD PTR _pattern_type$[ebp]
	mov	DWORD PTR tv215[ebp], eax
	cmp	DWORD PTR tv215[ebp], 3
	je	SHORT $LN15@kvz_tz_pat
	jmp	SHORT $LN16@kvz_tz_pat
$LN15@kvz_tz_pat:

; 573  :       case 3:
; 574  :         n_points = 6;

	mov	DWORD PTR _n_points$[ebp], 6

; 575  :         break;

	jmp	SHORT $LN10@kvz_tz_pat
$LN16@kvz_tz_pat:

; 576  :       default:
; 577  :         n_points = 8;

	mov	DWORD PTR _n_points$[ebp], 8
$LN10@kvz_tz_pat:

; 578  :         break;
; 579  :     };
; 580  :   }
; 581  : 
; 582  :   // Compute SAD values for all chosen points.
; 583  :   int best_index = -1;

	mov	DWORD PTR _best_index$[ebp], -1

; 584  :   for (int i = 0; i < n_points; i++) {

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN8@kvz_tz_pat
$LN6@kvz_tz_pat:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN8@kvz_tz_pat:
	mov	eax, DWORD PTR _i$4[ebp]
	cmp	eax, DWORD PTR _n_points$[ebp]
	jge	SHORT $LN7@kvz_tz_pat

; 585  :     vector2d_t offset = pattern[pattern_type][i];

	mov	eax, DWORD PTR _pattern_type$[ebp]
	shl	eax, 6
	lea	ecx, DWORD PTR _pattern$[ebp+eax]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _offset$3[ebp], eax
	mov	DWORD PTR _offset$3[ebp+4], ecx

; 586  :     int x = mv.x + offset.x;

	mov	eax, DWORD PTR _mv$[ebp]
	add	eax, DWORD PTR _offset$3[ebp]
	mov	DWORD PTR _x$2[ebp], eax

; 587  :     int y = mv.y + offset.y;

	mov	eax, DWORD PTR _mv$[ebp+4]
	add	eax, DWORD PTR _offset$3[ebp+4]
	mov	DWORD PTR _y$1[ebp], eax

; 588  : 
; 589  :     if (check_mv_cost(info, x, y)) {

	mov	eax, DWORD PTR _y$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@kvz_tz_pat

; 590  :       best_index = i;

	mov	eax, DWORD PTR _i$4[ebp]
	mov	DWORD PTR _best_index$[ebp], eax
$LN17@kvz_tz_pat:

; 591  :     }
; 592  :   }

	jmp	$LN6@kvz_tz_pat
$LN7@kvz_tz_pat:

; 593  : 
; 594  :   if (best_index >= 0) {

	cmp	DWORD PTR _best_index$[ebp], 0
	jl	SHORT $LN1@kvz_tz_pat

; 595  :     *best_dist = iDist;

	mov	eax, DWORD PTR _best_dist$[ebp]
	mov	ecx, DWORD PTR _iDist$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@kvz_tz_pat:

; 596  :   }
; 597  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@kvz_tz_pat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 540				; 0000021cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@kvz_tz_pat:
	DD	2
	DD	$LN23@kvz_tz_pat
$LN23@kvz_tz_pat:
	DD	-264					; fffffef8H
	DD	256					; 00000100H
	DD	$LN21@kvz_tz_pat
	DD	-316					; fffffec4H
	DD	8
	DD	$LN22@kvz_tz_pat
$LN22@kvz_tz_pat:
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN21@kvz_tz_pat:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	0
_kvz_tz_pattern_search ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _early_terminate
_TEXT	SEGMENT
tv183 = -312						; size = 4
tv161 = -312						; size = 4
tv155 = -312						; size = 4
_y$1 = -112						; size = 4
_x$2 = -100						; size = 4
_i$3 = -88						; size = 4
_best_index$4 = -76					; size = 4
_threshold$5 = -64					; size = 8
_k$6 = -48						; size = 4
_last_index$ = -36					; size = 4
_first_index$ = -24					; size = 4
_mv$ = -12						; size = 8
_info$ = 8						; size = 4
_early_terminate PROC					; COMDAT

; 436  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-312]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 437  :   static const vector2d_t small_hexbs[7] = {
; 438  :       { 0, -1 }, { -1, 0 }, { 0, 1 }, { 1, 0 },
; 439  :       { 0, -1 }, { -1, 0 }, { 0, 0 },
; 440  :   };
; 441  : 
; 442  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp], ecx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	sar	ecx, 2
	mov	DWORD PTR _mv$[ebp+4], ecx

; 443  : 
; 444  :   int first_index = 0;

	mov	DWORD PTR _first_index$[ebp], 0

; 445  :   int last_index = 3;

	mov	DWORD PTR _last_index$[ebp], 3

; 446  : 
; 447  :   for (int k = 0; k < 2; ++k) {

	mov	DWORD PTR _k$6[ebp], 0
	jmp	SHORT $LN4@early_term
$LN2@early_term:
	mov	eax, DWORD PTR _k$6[ebp]
	add	eax, 1
	mov	DWORD PTR _k$6[ebp], eax
$LN4@early_term:
	cmp	DWORD PTR _k$6[ebp], 2
	jge	$LN3@early_term

; 448  :     double threshold;
; 449  :     if (info->state->encoder_control->cfg.me_early_termination ==

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+2356], 2
	jne	SHORT $LN8@early_term

; 450  :         KVZ_ME_EARLY_TERMINATION_SENSITIVE)
; 451  :     {
; 452  :       threshold = info->best_cost * 0.95;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR tv155[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv155[ebp]
	mov	edx, DWORD PTR tv155[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mulsd	xmm0, QWORD PTR __real@3fee666666666666
	movsd	QWORD PTR _threshold$5[ebp], xmm0

; 453  :     } else {

	jmp	SHORT $LN9@early_term
$LN8@early_term:

; 454  :       threshold = info->best_cost;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR tv161[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv161[ebp]
	mov	edx, DWORD PTR tv161[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR _threshold$5[ebp], xmm0
$LN9@early_term:

; 455  :     }
; 456  : 
; 457  :     int best_index = 6;

	mov	DWORD PTR _best_index$4[ebp], 6

; 458  :     for (int i = first_index; i <= last_index; i++) {

	mov	eax, DWORD PTR _first_index$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@early_term
$LN5@early_term:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@early_term:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _last_index$[ebp]
	jg	SHORT $LN6@early_term

; 459  :       int x = mv.x + small_hexbs[i].x;

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, DWORD PTR ?small_hexbs@?1??early_terminate@@9@9[eax*8]
	mov	DWORD PTR _x$2[ebp], ecx

; 460  :       int y = mv.y + small_hexbs[i].y;

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?small_hexbs@?1??early_terminate@@9@9[eax*8+4]
	mov	DWORD PTR _y$1[ebp], ecx

; 461  : 
; 462  :       if (check_mv_cost(info, x, y)) {

	mov	eax, DWORD PTR _y$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@early_term

; 463  :         best_index = i;

	mov	eax, DWORD PTR _i$3[ebp]
	mov	DWORD PTR _best_index$4[ebp], eax
$LN10@early_term:

; 464  :       }
; 465  :     }

	jmp	SHORT $LN5@early_term
$LN6@early_term:

; 466  : 
; 467  :     // Adjust the movement vector
; 468  :     mv.x += small_hexbs[best_index].x;

	mov	eax, DWORD PTR _best_index$4[ebp]
	mov	ecx, DWORD PTR _mv$[ebp]
	add	ecx, DWORD PTR ?small_hexbs@?1??early_terminate@@9@9[eax*8]
	mov	DWORD PTR _mv$[ebp], ecx

; 469  :     mv.y += small_hexbs[best_index].y;

	mov	eax, DWORD PTR _best_index$4[ebp]
	mov	ecx, DWORD PTR _mv$[ebp+4]
	add	ecx, DWORD PTR ?small_hexbs@?1??early_terminate@@9@9[eax*8+4]
	mov	DWORD PTR _mv$[ebp+4], ecx

; 470  : 
; 471  :     // If best match is not better than threshold, we stop the search.
; 472  :     if (info->best_cost >= threshold) {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR tv183[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv183[ebp]
	mov	edx, DWORD PTR tv183[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	comisd	xmm0, QWORD PTR _threshold$5[ebp]
	jb	SHORT $LN11@early_term

; 473  :       return true;

	mov	al, 1
	jmp	SHORT $LN1@early_term
$LN11@early_term:

; 474  :     }
; 475  : 
; 476  :     first_index = (best_index + 3) % 4;

	mov	eax, DWORD PTR _best_index$4[ebp]
	add	eax, 3
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN16@early_term
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN16@early_term:
	mov	DWORD PTR _first_index$[ebp], eax

; 477  :     last_index = first_index + 2;

	mov	eax, DWORD PTR _first_index$[ebp]
	add	eax, 2
	mov	DWORD PTR _last_index$[ebp], eax

; 478  :   }

	jmp	$LN2@early_term
$LN3@early_term:

; 479  :   return false;

	xor	al, al
$LN1@early_term:

; 480  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@early_term
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 312				; 00000138H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@early_term:
	DD	1
	DD	$LN14@early_term
$LN14@early_term:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN13@early_term
$LN13@early_term:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
_early_terminate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _calc_mvd_cost
_TEXT	SEGMENT
_mvd_cost$1 = -44					; size = 4
_merged$ = -29						; size = 1
_merge_idx$ = -20					; size = 4
_temp_bitcost$ = -8					; size = 4
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_mv_shift$ = 20						; size = 4
_mv_cand$ = 24						; size = 4
_merge_cand$ = 28					; size = 4
_num_cand$ = 32						; size = 2
_ref_idx$ = 36						; size = 4
_bitcost$ = 40						; size = 4
_calc_mvd_cost PROC					; COMDAT

; 402  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 403  :   uint32_t temp_bitcost = 0;

	mov	DWORD PTR _temp_bitcost$[ebp], 0

; 404  :   uint32_t merge_idx;
; 405  :   int8_t merged      = 0;

	mov	BYTE PTR _merged$[ebp], 0

; 406  : 
; 407  :   x *= 1 << mv_shift;

	mov	eax, 1
	mov	ecx, DWORD PTR _mv_shift$[ebp]
	shl	eax, cl
	imul	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 408  :   y *= 1 << mv_shift;

	mov	eax, 1
	mov	ecx, DWORD PTR _mv_shift$[ebp]
	shl	eax, cl
	imul	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 409  : 
; 410  :   // Check every candidate to find a match
; 411  :   for(merge_idx = 0; merge_idx < (uint32_t)num_cand; merge_idx++) {

	mov	DWORD PTR _merge_idx$[ebp], 0
	jmp	SHORT $LN4@calc_mvd_c
$LN2@calc_mvd_c:
	mov	eax, DWORD PTR _merge_idx$[ebp]
	add	eax, 1
	mov	DWORD PTR _merge_idx$[ebp], eax
$LN4@calc_mvd_c:
	movsx	eax, WORD PTR _num_cand$[ebp]
	cmp	DWORD PTR _merge_idx$[ebp], eax
	jae	$LN3@calc_mvd_c

; 412  :     if (merge_cand[merge_idx].dir == 3) continue;

	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	mov	ecx, DWORD PTR _merge_cand$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 3
	jne	SHORT $LN5@calc_mvd_c
	jmp	SHORT $LN2@calc_mvd_c
$LN5@calc_mvd_c:

; 413  :     if (merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][0] == x &&
; 414  :         merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][1] == y &&

	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	imul	ecx, DWORD PTR _merge_idx$[ebp], 12
	mov	edx, DWORD PTR _merge_cand$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, 2
	imul	ecx, eax, 0
	movsx	edx, WORD PTR [edx+ecx]
	cmp	edx, DWORD PTR _x$[ebp]
	jne	SHORT $LN6@calc_mvd_c
	imul	eax, DWORD PTR _merge_idx$[ebp], 12
	add	eax, DWORD PTR _merge_cand$[ebp]
	imul	ecx, DWORD PTR _merge_idx$[ebp], 12
	mov	edx, DWORD PTR _merge_cand$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, 2
	shl	eax, 0
	movsx	ecx, WORD PTR [edx+eax]
	cmp	ecx, DWORD PTR _y$[ebp]
	jne	SHORT $LN6@calc_mvd_c
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	edx, DWORD PTR _merge_idx$[ebp], 12
	mov	eax, DWORD PTR _merge_cand$[ebp]
	movzx	edx, BYTE PTR [eax+edx]
	sub	edx, 1
	shl	edx, 4
	lea	eax, DWORD PTR [ecx+edx+45]
	imul	ecx, DWORD PTR _merge_idx$[ebp], 12
	add	ecx, DWORD PTR _merge_cand$[ebp]
	imul	edx, DWORD PTR _merge_idx$[ebp], 12
	mov	esi, DWORD PTR _merge_cand$[ebp]
	movzx	edx, BYTE PTR [esi+edx]
	movzx	ecx, BYTE PTR [ecx+edx]
	movzx	edx, BYTE PTR [eax+ecx]
	cmp	edx, DWORD PTR _ref_idx$[ebp]
	jne	SHORT $LN6@calc_mvd_c

; 415  :         state->frame->ref_LX[merge_cand[merge_idx].dir - 1][
; 416  :           merge_cand[merge_idx].ref[merge_cand[merge_idx].dir - 1]
; 417  :         ] == ref_idx) {
; 418  :       temp_bitcost += merge_idx;

	mov	eax, DWORD PTR _temp_bitcost$[ebp]
	add	eax, DWORD PTR _merge_idx$[ebp]
	mov	DWORD PTR _temp_bitcost$[ebp], eax

; 419  :       merged = 1;

	mov	BYTE PTR _merged$[ebp], 1

; 420  :       break;

	jmp	SHORT $LN3@calc_mvd_c
$LN6@calc_mvd_c:

; 421  :     }
; 422  :   }

	jmp	$LN2@calc_mvd_c
$LN3@calc_mvd_c:

; 423  : 
; 424  :   // Check mvd cost only if mv is not merged
; 425  :   if (!merged) {

	movsx	eax, BYTE PTR _merged$[ebp]
	test	eax, eax
	jne	SHORT $LN7@calc_mvd_c

; 426  :     uint32_t mvd_cost = 0;

	mov	DWORD PTR _mvd_cost$1[ebp], 0

; 427  :     select_mv_cand(state, mv_cand, x, y, &mvd_cost);

	lea	eax, DWORD PTR _mvd_cost$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _mv_cand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_select_mv_cand
	add	esp, 20					; 00000014H

; 428  :     temp_bitcost += mvd_cost;

	mov	eax, DWORD PTR _temp_bitcost$[ebp]
	add	eax, DWORD PTR _mvd_cost$1[ebp]
	mov	DWORD PTR _temp_bitcost$[ebp], eax
$LN7@calc_mvd_c:

; 429  :   }
; 430  :   *bitcost = temp_bitcost;

	mov	eax, DWORD PTR _bitcost$[ebp]
	mov	ecx, DWORD PTR _temp_bitcost$[ebp]
	mov	DWORD PTR [eax], ecx

; 431  :   return temp_bitcost*(int32_t)(state->lambda_sqrt + 0.5);

	mov	eax, DWORD PTR _state$[ebp]
	movsd	xmm0, QWORD PTR [eax+304]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si ecx, xmm0
	mov	eax, ecx
	imul	eax, DWORD PTR _temp_bitcost$[ebp]

; 432  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@calc_mvd_c
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN11@calc_mvd_c:
	DD	1
	DD	$LN10@calc_mvd_c
$LN10@calc_mvd_c:
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN9@calc_mvd_c
$LN9@calc_mvd_c:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	100					; 00000064H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_calc_mvd_cost ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _select_mv_cand
_TEXT	SEGMENT
tv88 = -248						; size = 4
tv171 = -244						; size = 4
tv169 = -244						; size = 4
tv86 = -244						; size = 4
_cand2_cost$ = -44					; size = 4
_cand1_cost$ = -32					; size = 4
_mvd_coding_cost$ = -20					; size = 4
_same_cand$ = -5					; size = 1
_state$ = 8						; size = 4
_mv_cand$ = 12						; size = 4
_mv_x$ = 16						; size = 4
_mv_y$ = 20						; size = 4
_cost_out$ = 24						; size = 4
_select_mv_cand PROC					; COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 352  :   const bool same_cand =

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _mv_cand$[ebp]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	mov	edx, 4
	shl	edx, 0
	add	edx, DWORD PTR _mv_cand$[ebp]
	mov	eax, 2
	imul	eax, eax, 0
	movsx	edx, WORD PTR [edx+eax]
	cmp	ecx, edx
	jne	SHORT $LN9@select_mv_
	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _mv_cand$[ebp]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	mov	ecx, 4
	shl	ecx, 0
	add	ecx, DWORD PTR _mv_cand$[ebp]
	mov	edx, 2
	shl	edx, 0
	movsx	ecx, WORD PTR [ecx+edx]
	cmp	eax, ecx
	jne	SHORT $LN9@select_mv_
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN10@select_mv_
$LN9@select_mv_:
	mov	DWORD PTR tv86[ebp], 0
$LN10@select_mv_:
	cmp	DWORD PTR tv86[ebp], 0
	jne	SHORT $LN11@select_mv_
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN12@select_mv_
$LN11@select_mv_:
	mov	DWORD PTR tv88[ebp], 1
$LN12@select_mv_:
	mov	dl, BYTE PTR tv88[ebp]
	mov	BYTE PTR _same_cand$[ebp], dl

; 353  :     (mv_cand[0][0] == mv_cand[1][0] && mv_cand[0][1] == mv_cand[1][1]);
; 354  : 
; 355  :   if (same_cand && !cost_out) {

	movzx	eax, BYTE PTR _same_cand$[ebp]
	test	eax, eax
	je	SHORT $LN2@select_mv_
	cmp	DWORD PTR _cost_out$[ebp], 0
	jne	SHORT $LN2@select_mv_

; 356  :     // Pick the first one if both candidates are the same.
; 357  :     return 0;

	xor	eax, eax
	jmp	$LN1@select_mv_
$LN2@select_mv_:

; 358  :   }
; 359  : 
; 360  :   uint32_t (*mvd_coding_cost)(const encoder_state_t * const state,
; 361  :                               const cabac_data_t*,
; 362  :                               int32_t, int32_t);
; 363  :   if (state->encoder_control->cfg.mv_rdo) {

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+2332]
	test	edx, edx
	je	SHORT $LN3@select_mv_

; 364  :     mvd_coding_cost = kvz_get_mvd_coding_cost_cabac;

	mov	DWORD PTR _mvd_coding_cost$[ebp], OFFSET _kvz_get_mvd_coding_cost_cabac

; 365  :   } else {

	jmp	SHORT $LN4@select_mv_
$LN3@select_mv_:

; 366  :     mvd_coding_cost = get_mvd_coding_cost;

	mov	DWORD PTR _mvd_coding_cost$[ebp], OFFSET _get_mvd_coding_cost
$LN4@select_mv_:

; 367  :   }
; 368  : 
; 369  :   uint32_t cand1_cost = mvd_coding_cost(

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _mv_cand$[ebp]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _mv_y$[ebp]
	sub	ecx, eax
	mov	esi, esp
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _mv_cand$[ebp]
	mov	ecx, 2
	imul	edx, ecx, 0
	movsx	eax, WORD PTR [eax+edx]
	mov	ecx, DWORD PTR _mv_x$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	DWORD PTR _mvd_coding_cost$[ebp]
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cand1_cost$[ebp], eax

; 370  :       state, &state->cabac,
; 371  :       mv_x - mv_cand[0][0],
; 372  :       mv_y - mv_cand[0][1]);
; 373  : 
; 374  :   uint32_t cand2_cost;
; 375  :   if (same_cand) {

	movzx	eax, BYTE PTR _same_cand$[ebp]
	test	eax, eax
	je	SHORT $LN5@select_mv_

; 376  :     cand2_cost = cand1_cost;

	mov	eax, DWORD PTR _cand1_cost$[ebp]
	mov	DWORD PTR _cand2_cost$[ebp], eax

; 377  :   } else {

	jmp	SHORT $LN6@select_mv_
$LN5@select_mv_:

; 378  :     cand2_cost = mvd_coding_cost(

	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _mv_cand$[ebp]
	mov	ecx, 2
	shl	ecx, 0
	movsx	edx, WORD PTR [eax+ecx]
	mov	eax, DWORD PTR _mv_y$[ebp]
	sub	eax, edx
	mov	esi, esp
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	add	ecx, DWORD PTR _mv_cand$[ebp]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	mov	edx, DWORD PTR _mv_x$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	DWORD PTR _mvd_coding_cost$[ebp]
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cand2_cost$[ebp], eax
$LN6@select_mv_:

; 379  :       state, &state->cabac,
; 380  :       mv_x - mv_cand[1][0],
; 381  :       mv_y - mv_cand[1][1]);
; 382  :   }
; 383  : 
; 384  :   if (cost_out) {

	cmp	DWORD PTR _cost_out$[ebp], 0
	je	SHORT $LN7@select_mv_

; 385  :     *cost_out = MIN(cand1_cost, cand2_cost);

	mov	eax, DWORD PTR _cand1_cost$[ebp]
	cmp	eax, DWORD PTR _cand2_cost$[ebp]
	jae	SHORT $LN13@select_mv_
	mov	ecx, DWORD PTR _cand1_cost$[ebp]
	mov	DWORD PTR tv169[ebp], ecx
	jmp	SHORT $LN14@select_mv_
$LN13@select_mv_:
	mov	edx, DWORD PTR _cand2_cost$[ebp]
	mov	DWORD PTR tv169[ebp], edx
$LN14@select_mv_:
	mov	eax, DWORD PTR _cost_out$[ebp]
	mov	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@select_mv_:

; 386  :   }
; 387  : 
; 388  :   // Pick the second candidate if it has lower cost.
; 389  :   return cand2_cost < cand1_cost ? 1 : 0;

	mov	eax, DWORD PTR _cand2_cost$[ebp]
	cmp	eax, DWORD PTR _cand1_cost$[ebp]
	jae	SHORT $LN15@select_mv_
	mov	DWORD PTR tv171[ebp], 1
	jmp	SHORT $LN16@select_mv_
$LN15@select_mv_:
	mov	DWORD PTR tv171[ebp], 0
$LN16@select_mv_:
	mov	eax, DWORD PTR tv171[ebp]
$LN1@select_mv_:

; 390  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_select_mv_cand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _get_mvd_coding_cost
_TEXT	SEGMENT
_abs_mvd$ = -24						; size = 8
_bitcost$ = -8						; size = 4
_state$ = 8						; size = 4
_cabac$ = 12						; size = 4
_mvd_hor$ = 16						; size = 4
_mvd_ver$ = 20						; size = 4
_get_mvd_coding_cost PROC				; COMDAT

; 334  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 335  :   unsigned bitcost = 0;

	mov	DWORD PTR _bitcost$[ebp], 0

; 336  :   const vector2d_t abs_mvd = { abs(mvd_hor), abs(mvd_ver) };

	mov	eax, DWORD PTR _mvd_hor$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _abs_mvd$[ebp], eax
	mov	eax, DWORD PTR _mvd_ver$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _abs_mvd$[ebp+4], eax

; 337  : 
; 338  :   bitcost += get_ep_ex_golomb_bitcost(abs_mvd.x) << CTX_FRAC_BITS;

	mov	eax, DWORD PTR _abs_mvd$[ebp]
	push	eax
	call	_get_ep_ex_golomb_bitcost
	add	esp, 4
	shl	eax, 15					; 0000000fH
	add	eax, DWORD PTR _bitcost$[ebp]
	mov	DWORD PTR _bitcost$[ebp], eax

; 339  :   bitcost += get_ep_ex_golomb_bitcost(abs_mvd.y) << CTX_FRAC_BITS;

	mov	eax, DWORD PTR _abs_mvd$[ebp+4]
	push	eax
	call	_get_ep_ex_golomb_bitcost
	add	esp, 4
	shl	eax, 15					; 0000000fH
	add	eax, DWORD PTR _bitcost$[ebp]
	mov	DWORD PTR _bitcost$[ebp], eax

; 340  : 
; 341  :   // Round and shift back to integer bits.
; 342  :   return (bitcost + CTX_FRAC_HALF_BIT) >> CTX_FRAC_BITS;

	mov	eax, DWORD PTR _bitcost$[ebp]
	add	eax, 16384				; 00004000H
	shr	eax, 15					; 0000000fH

; 343  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@get_mvd_co
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@get_mvd_co:
	DD	1
	DD	$LN4@get_mvd_co
$LN4@get_mvd_co:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN3@get_mvd_co
$LN3@get_mvd_co:
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	100					; 00000064H
	DB	0
_get_mvd_coding_cost ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _select_starting_point
_TEXT	SEGMENT
_y$1 = -32						; size = 4
_x$2 = -20						; size = 4
_i$3 = -8						; size = 4
_info$ = 8						; size = 4
_extra_mv$ = 12						; size = 8
_select_starting_point PROC				; COMDAT

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 304  :   // Check the 0-vector, so we can ignore all 0-vectors in the merge cand list.
; 305  :   check_mv_cost(info, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_check_mv_cost
	add	esp, 12					; 0000000cH

; 306  : 
; 307  :   // Change to integer precision.
; 308  :   extra_mv.x >>= 2;

	mov	eax, DWORD PTR _extra_mv$[ebp]
	sar	eax, 2
	mov	DWORD PTR _extra_mv$[ebp], eax

; 309  :   extra_mv.y >>= 2;

	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	sar	eax, 2
	mov	DWORD PTR _extra_mv$[ebp+4], eax

; 310  : 
; 311  :   // Check mv_in if it's not one of the merge candidates.
; 312  :   if ((extra_mv.x != 0 || extra_mv.y != 0) && !mv_in_merge(info, extra_mv)) {

	cmp	DWORD PTR _extra_mv$[ebp], 0
	jne	SHORT $LN6@select_sta
	cmp	DWORD PTR _extra_mv$[ebp+4], 0
	je	SHORT $LN5@select_sta
$LN6@select_sta:
	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _extra_mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_mv_in_merge
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@select_sta

; 313  :     check_mv_cost(info, extra_mv.x, extra_mv.y);

	mov	eax, DWORD PTR _extra_mv$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _extra_mv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH
$LN5@select_sta:

; 314  :   }
; 315  : 
; 316  :   // Go through candidates
; 317  :   for (unsigned i = 0; i < info->num_merge_cand; ++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@select_sta
$LN2@select_sta:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@select_sta:
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax+100]
	jae	$LN1@select_sta

; 318  :     if (info->merge_cand[i].dir == 3) continue;

	imul	eax, DWORD PTR _i$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+40]
	cmp	edx, 3
	jne	SHORT $LN7@select_sta
	jmp	SHORT $LN2@select_sta
$LN7@select_sta:

; 319  : 
; 320  :     int x = (info->merge_cand[i].mv[info->merge_cand[i].dir - 1][0] + 2) >> 2;

	imul	eax, DWORD PTR _i$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _i$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	add	ecx, 2
	sar	ecx, 2
	mov	DWORD PTR _x$2[ebp], ecx

; 321  :     int y = (info->merge_cand[i].mv[info->merge_cand[i].dir - 1][1] + 2) >> 2;

	imul	eax, DWORD PTR _i$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _i$3[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	add	eax, 2
	sar	eax, 2
	mov	DWORD PTR _y$1[ebp], eax

; 322  : 
; 323  :     if (x == 0 && y == 0) continue;

	cmp	DWORD PTR _x$2[ebp], 0
	jne	SHORT $LN8@select_sta
	cmp	DWORD PTR _y$1[ebp], 0
	jne	SHORT $LN8@select_sta
	jmp	$LN2@select_sta
$LN8@select_sta:

; 324  : 
; 325  :     check_mv_cost(info, x, y);

	mov	eax, DWORD PTR _y$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_check_mv_cost
	add	esp, 12					; 0000000cH

; 326  :   }

	jmp	$LN2@select_sta
$LN1@select_sta:

; 327  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_select_starting_point ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _mv_in_merge
_TEXT	SEGMENT
_merge_mv$1 = -24					; size = 8
_i$2 = -8						; size = 4
_info$ = 8						; size = 4
_mv$ = 12						; size = 8
_mv_in_merge PROC					; COMDAT

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 282  :   for (int i = 0; i < info->num_merge_cand; ++i) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@mv_in_merg
$LN2@mv_in_merg:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@mv_in_merg:
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax+100]
	jge	$LN3@mv_in_merg

; 283  :     if (info->merge_cand[i].dir == 3) continue;

	imul	eax, DWORD PTR _i$2[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+40]
	cmp	edx, 3
	jne	SHORT $LN5@mv_in_merg
	jmp	SHORT $LN2@mv_in_merg
$LN5@mv_in_merg:

; 284  :     const vector2d_t merge_mv = {

	imul	eax, DWORD PTR _i$2[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _i$2[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	imul	eax, edx, 0
	movsx	ecx, WORD PTR [ecx+eax]
	add	ecx, 2
	sar	ecx, 2
	mov	DWORD PTR _merge_mv$1[ebp], ecx
	imul	eax, DWORD PTR _i$2[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+40]
	imul	eax, DWORD PTR _i$2[ebp], 12
	mov	ecx, DWORD PTR _info$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+40]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, 2
	shl	edx, 0
	movsx	eax, WORD PTR [ecx+edx]
	add	eax, 2
	sar	eax, 2
	mov	DWORD PTR _merge_mv$1[ebp+4], eax

; 285  :       (info->merge_cand[i].mv[info->merge_cand[i].dir - 1][0] + 2) >> 2,
; 286  :       (info->merge_cand[i].mv[info->merge_cand[i].dir - 1][1] + 2) >> 2
; 287  :     };
; 288  :     if (merge_mv.x == mv.x && merge_mv.y == mv.y) {

	mov	eax, DWORD PTR _merge_mv$1[ebp]
	cmp	eax, DWORD PTR _mv$[ebp]
	jne	SHORT $LN6@mv_in_merg
	mov	eax, DWORD PTR _merge_mv$1[ebp+4]
	cmp	eax, DWORD PTR _mv$[ebp+4]
	jne	SHORT $LN6@mv_in_merg

; 289  :       return true;

	mov	al, 1
	jmp	SHORT $LN1@mv_in_merg
$LN6@mv_in_merg:

; 290  :     }
; 291  :   }

	jmp	$LN2@mv_in_merg
$LN3@mv_in_merg:

; 292  :   return false;

	xor	al, al
$LN1@mv_in_merg:

; 293  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@mv_in_merg
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@mv_in_merg:
	DD	1
	DD	$LN9@mv_in_merg
$LN9@mv_in_merg:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN8@mv_in_merg
$LN8@mv_in_merg:
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
_mv_in_merge ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _get_ep_ex_golomb_bitcost
_TEXT	SEGMENT
_bins$ = -8						; size = 4
_symbol$ = 8						; size = 4
_get_ep_ex_golomb_bitcost PROC				; COMDAT

; 256  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 257  :   // Calculate 2 * log2(symbol + 2)
; 258  : 
; 259  :   unsigned bins = 0;

	mov	DWORD PTR _bins$[ebp], 0

; 260  :   symbol += 2;

	mov	eax, DWORD PTR _symbol$[ebp]
	add	eax, 2
	mov	DWORD PTR _symbol$[ebp], eax

; 261  :   if (symbol >= 1 << 8) { bins += 16; symbol >>= 8; }

	cmp	DWORD PTR _symbol$[ebp], 256		; 00000100H
	jb	SHORT $LN2@get_ep_ex_
	mov	eax, DWORD PTR _bins$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _bins$[ebp], eax
	mov	eax, DWORD PTR _symbol$[ebp]
	shr	eax, 8
	mov	DWORD PTR _symbol$[ebp], eax
$LN2@get_ep_ex_:

; 262  :   if (symbol >= 1 << 4) { bins += 8; symbol >>= 4; }

	cmp	DWORD PTR _symbol$[ebp], 16		; 00000010H
	jb	SHORT $LN3@get_ep_ex_
	mov	eax, DWORD PTR _bins$[ebp]
	add	eax, 8
	mov	DWORD PTR _bins$[ebp], eax
	mov	eax, DWORD PTR _symbol$[ebp]
	shr	eax, 4
	mov	DWORD PTR _symbol$[ebp], eax
$LN3@get_ep_ex_:

; 263  :   if (symbol >= 1 << 2) { bins += 4; symbol >>= 2; }

	cmp	DWORD PTR _symbol$[ebp], 4
	jb	SHORT $LN4@get_ep_ex_
	mov	eax, DWORD PTR _bins$[ebp]
	add	eax, 4
	mov	DWORD PTR _bins$[ebp], eax
	mov	eax, DWORD PTR _symbol$[ebp]
	shr	eax, 2
	mov	DWORD PTR _symbol$[ebp], eax
$LN4@get_ep_ex_:

; 264  :   if (symbol >= 1 << 1) { bins += 2; }

	cmp	DWORD PTR _symbol$[ebp], 2
	jb	SHORT $LN5@get_ep_ex_
	mov	eax, DWORD PTR _bins$[ebp]
	add	eax, 2
	mov	DWORD PTR _bins$[ebp], eax
$LN5@get_ep_ex_:

; 265  : 
; 266  :   // TODO: It might be a good idea to put a small slope on this function to
; 267  :   // make sure any search function that follows the gradient heads towards
; 268  :   // a smaller MVD, but that would require fractinal costs and bits being
; 269  :   // used everywhere in inter search.
; 270  :   // return num_bins + 0.001 * symbol;
; 271  : 
; 272  :   return bins;

	mov	eax, DWORD PTR _bins$[ebp]

; 273  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_get_ep_ex_golomb_bitcost ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _check_mv_cost
_TEXT	SEGMENT
_cost$ = -20						; size = 4
_bitcost$ = -8						; size = 4
_info$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_check_mv_cost PROC					; COMDAT

; 215  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 216  :   if (!intmv_within_tile(info, x, y)) return false;

	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_intmv_within_tile
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@check_mv_c
	xor	al, al
	jmp	$LN1@check_mv_c
$LN2@check_mv_c:

; 217  : 
; 218  :   uint32_t bitcost = 0;

	mov	DWORD PTR _bitcost$[ebp], 0

; 219  :   uint32_t cost = kvz_image_calc_sad(

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _info$[ebp]
	add	eax, DWORD PTR [ecx+20]
	add	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _info$[ebp]
	add	edx, DWORD PTR [eax+16]
	add	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_kvz_image_calc_sad
	add	esp, 36					; 00000024H
	mov	DWORD PTR _cost$[ebp], eax

; 220  :       info->pic,
; 221  :       info->ref,
; 222  :       info->origin.x,
; 223  :       info->origin.y,
; 224  :       info->state->tile->offset_x + info->origin.x + x,
; 225  :       info->state->tile->offset_y + info->origin.y + y,
; 226  :       info->width,
; 227  :       info->height,
; 228  :       info->optimized_sad
; 229  :   );
; 230  : 
; 231  :   if (cost >= info->best_cost) return false;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _cost$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jb	SHORT $LN3@check_mv_c
	xor	al, al
	jmp	$LN1@check_mv_c
$LN3@check_mv_c:

; 232  : 
; 233  :   cost += info->mvd_cost_func(

	mov	esi, esp
	lea	eax, DWORD PTR _bitcost$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	movzx	ecx, WORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	push	2
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+104]
	call	eax
	add	esp, 36					; 00000024H
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, DWORD PTR _cost$[ebp]
	mov	DWORD PTR _cost$[ebp], eax

; 234  :       info->state,
; 235  :       x, y, 2,
; 236  :       info->mv_cand,
; 237  :       info->merge_cand,
; 238  :       info->num_merge_cand,
; 239  :       info->ref_idx,
; 240  :       &bitcost
; 241  :   );
; 242  : 
; 243  :   if (cost >= info->best_cost) return false;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _cost$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jb	SHORT $LN4@check_mv_c
	xor	al, al
	jmp	SHORT $LN1@check_mv_c
$LN4@check_mv_c:

; 244  : 
; 245  :   // Set to motion vector in quarter pixel precision.
; 246  :   info->best_mv.x = x * 4;

	mov	eax, DWORD PTR _x$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+108], eax

; 247  :   info->best_mv.y = y * 4;

	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 248  :   info->best_cost = cost;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _cost$[ebp]
	mov	DWORD PTR [eax+116], ecx

; 249  :   info->best_bitcost = bitcost;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _bitcost$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 250  : 
; 251  :   return true;

	mov	al, 1
$LN1@check_mv_c:

; 252  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@check_mv_c
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@check_mv_c:
	DD	1
	DD	$LN7@check_mv_c
$LN7@check_mv_c:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN6@check_mv_c
$LN6@check_mv_c:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_check_mv_cost ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _intmv_within_tile
_TEXT	SEGMENT
_info$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_intmv_within_tile PROC					; COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 199  :   return fracmv_within_tile(info, x * 4, y * 4);

	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	call	_fracmv_within_tile
	add	esp, 12					; 0000000cH

; 200  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_intmv_within_tile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _fracmv_within_tile
_TEXT	SEGMENT
tv193 = -332						; size = 4
tv80 = -332						; size = 4
tv72 = -332						; size = 4
tv191 = -328						; size = 4
tv78 = -328						; size = 4
tv70 = -328						; size = 4
_from_bottom$ = -128					; size = 4
_from_right$ = -116					; size = 4
_abs_mv$ = -104						; size = 8
_margin$ = -88						; size = 4
_mv_lcu$1 = -76						; size = 8
_orig_lcu$2 = -60					; size = 8
_margin$3 = -44						; size = 4
_is_frac_chroma$ = -29					; size = 1
_is_frac_luma$ = -17					; size = 1
_ctrl$ = -8						; size = 4
_info$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_fracmv_within_tile PROC				; COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-332]
	mov	ecx, 83					; 00000053H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _ctrl$[ebp], edx

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, DWORD PTR _x$[ebp]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN34@fracmv_wit
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN34@fracmv_wit:
	test	eax, eax
	jne	SHORT $LN17@fracmv_wit
	mov	ecx, DWORD PTR _y$[ebp]
	and	ecx, -2147483645			; 80000003H
	jns	SHORT $LN35@fracmv_wit
	dec	ecx
	or	ecx, -4					; fffffffcH
	inc	ecx
$LN35@fracmv_wit:
	test	ecx, ecx
	jne	SHORT $LN17@fracmv_wit
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN18@fracmv_wit
$LN17@fracmv_wit:
	mov	DWORD PTR tv70[ebp], 1
$LN18@fracmv_wit:
	cmp	DWORD PTR tv70[ebp], 0
	jne	SHORT $LN19@fracmv_wit
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN20@fracmv_wit
$LN19@fracmv_wit:
	mov	DWORD PTR tv72[ebp], 1
$LN20@fracmv_wit:
	mov	dl, BYTE PTR tv72[ebp]
	mov	BYTE PTR _is_frac_luma$[ebp], dl

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, DWORD PTR _x$[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN36@fracmv_wit
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN36@fracmv_wit:
	test	eax, eax
	jne	SHORT $LN21@fracmv_wit
	mov	ecx, DWORD PTR _y$[ebp]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN37@fracmv_wit
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN37@fracmv_wit:
	test	ecx, ecx
	jne	SHORT $LN21@fracmv_wit
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $LN22@fracmv_wit
$LN21@fracmv_wit:
	mov	DWORD PTR tv78[ebp], 1
$LN22@fracmv_wit:
	cmp	DWORD PTR tv78[ebp], 0
	jne	SHORT $LN23@fracmv_wit
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN24@fracmv_wit
$LN23@fracmv_wit:
	mov	DWORD PTR tv80[ebp], 1
$LN24@fracmv_wit:
	mov	dl, BYTE PTR tv80[ebp]
	mov	BYTE PTR _is_frac_chroma$[ebp], dl

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	mov	eax, DWORD PTR _ctrl$[ebp]
	cmp	DWORD PTR [eax+156], 0
	je	$LN2@fracmv_wit
	mov	eax, DWORD PTR _ctrl$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	$LN2@fracmv_wit

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;

	mov	DWORD PTR _margin$3[ebp], 0

; 118  :     if (is_frac_luma) {

	movzx	eax, BYTE PTR _is_frac_luma$[ebp]
	test	eax, eax
	je	SHORT $LN3@fracmv_wit

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	DWORD PTR _margin$3[ebp], 4
	jmp	SHORT $LN4@fracmv_wit
$LN3@fracmv_wit:

; 122  :     } else if (is_frac_chroma) {

	movzx	eax, BYTE PTR _is_frac_chroma$[ebp]
	test	eax, eax
	je	SHORT $LN4@fracmv_wit

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;

	mov	DWORD PTR _margin$3[ebp], 2
$LN4@fracmv_wit:

; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	mov	eax, DWORD PTR _ctrl$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN6@fracmv_wit

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	mov	eax, DWORD PTR _margin$3[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _margin$3[ebp], eax
	jmp	SHORT $LN7@fracmv_wit
$LN6@fracmv_wit:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	mov	eax, DWORD PTR _ctrl$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN7@fracmv_wit

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	mov	eax, DWORD PTR _margin$3[ebp]
	add	eax, 8
	mov	DWORD PTR _margin$3[ebp], eax
$LN7@fracmv_wit:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {

	mov	eax, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR _orig_lcu$2[ebp], eax
	mov	eax, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [eax+20]
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR _orig_lcu$2[ebp+4], eax

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _info$[ebp]
	add	ecx, DWORD PTR [edx+24]
	add	ecx, DWORD PTR _margin$3[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	sub	eax, DWORD PTR _orig_lcu$2[ebp]
	mov	DWORD PTR _mv_lcu$1[ebp], eax
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _info$[ebp]
	add	ecx, DWORD PTR [edx+28]
	add	ecx, DWORD PTR _margin$3[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
	cdq
	and	edx, 255				; 000000ffH
	add	eax, edx
	sar	eax, 8
	sub	eax, DWORD PTR _orig_lcu$2[ebp+4]
	mov	DWORD PTR _mv_lcu$1[ebp+4], eax

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	ecx, DWORD PTR _mv_lcu$1[ebp+4]
	cmp	ecx, DWORD PTR [eax+4600]
	jle	SHORT $LN9@fracmv_wit

; 151  :       return false;

	xor	al, al
	jmp	$LN1@fracmv_wit
$LN9@fracmv_wit:

; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	eax, DWORD PTR _mv_lcu$1[ebp]
	add	eax, DWORD PTR _mv_lcu$1[ebp+4]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx+4600]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	add	edx, DWORD PTR [ecx+4596]
	cmp	eax, edx
	jle	SHORT $LN2@fracmv_wit

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;

	xor	al, al
	jmp	$LN1@fracmv_wit
$LN2@fracmv_wit:

; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR _ctrl$[ebp]
	cmp	DWORD PTR [eax+2336], 0
	jne	SHORT $LN11@fracmv_wit

; 162  :     return true;

	mov	al, 1
	jmp	$LN1@fracmv_wit
$LN11@fracmv_wit:

; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	mov	DWORD PTR _margin$[ebp], 0

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	mov	eax, DWORD PTR _ctrl$[ebp]
	cmp	DWORD PTR [eax+2336], 4
	jne	SHORT $LN12@fracmv_wit

; 168  :     if (is_frac_luma) {

	movzx	eax, BYTE PTR _is_frac_luma$[ebp]
	test	eax, eax
	je	SHORT $LN13@fracmv_wit

; 169  :       margin = 4 << 2;

	mov	DWORD PTR _margin$[ebp], 16		; 00000010H
	jmp	SHORT $LN12@fracmv_wit
$LN13@fracmv_wit:

; 170  :     } else if (is_frac_chroma) {

	movzx	eax, BYTE PTR _is_frac_chroma$[ebp]
	test	eax, eax
	je	SHORT $LN12@fracmv_wit

; 171  :       margin = 2 << 2;

	mov	DWORD PTR _margin$[ebp], 8
$LN12@fracmv_wit:

; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _abs_mv$[ebp], eax
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _y$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _abs_mv$[ebp+4], eax

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 2
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	edx, DWORD PTR _abs_mv$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]
	sub	ecx, eax
	mov	DWORD PTR _from_right$[ebp], ecx

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 2
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	edx, DWORD PTR _abs_mv$[ebp+4]
	lea	eax, DWORD PTR [edx+eax*4]
	sub	ecx, eax
	mov	DWORD PTR _from_bottom$[ebp], ecx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	mov	eax, DWORD PTR _abs_mv$[ebp]
	cmp	eax, DWORD PTR _margin$[ebp]
	jl	SHORT $LN25@fracmv_wit
	mov	ecx, DWORD PTR _abs_mv$[ebp+4]
	cmp	ecx, DWORD PTR _margin$[ebp]
	jl	SHORT $LN25@fracmv_wit
	mov	edx, DWORD PTR _from_right$[ebp]
	cmp	edx, DWORD PTR _margin$[ebp]
	jl	SHORT $LN25@fracmv_wit
	mov	eax, DWORD PTR _from_bottom$[ebp]
	cmp	eax, DWORD PTR _margin$[ebp]
	jl	SHORT $LN25@fracmv_wit
	mov	DWORD PTR tv191[ebp], 1
	jmp	SHORT $LN26@fracmv_wit
$LN25@fracmv_wit:
	mov	DWORD PTR tv191[ebp], 0
$LN26@fracmv_wit:
	cmp	DWORD PTR tv191[ebp], 0
	jne	SHORT $LN27@fracmv_wit
	mov	DWORD PTR tv193[ebp], 0
	jmp	SHORT $LN28@fracmv_wit
$LN27@fracmv_wit:
	mov	DWORD PTR tv193[ebp], 1
$LN28@fracmv_wit:
	mov	al, BYTE PTR tv193[ebp]
$LN1@fracmv_wit:

; 188  :          abs_mv.y >= margin &&
; 189  :          from_right >= margin &&
; 190  :          from_bottom >= margin;
; 191  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN33@fracmv_wit
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN33@fracmv_wit:
	DD	3
	DD	$LN32@fracmv_wit
$LN32@fracmv_wit:
	DD	-60					; ffffffc4H
	DD	8
	DD	$LN29@fracmv_wit
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN30@fracmv_wit
	DD	-104					; ffffff98H
	DD	8
	DD	$LN31@fracmv_wit
$LN31@fracmv_wit:
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	0
$LN30@fracmv_wit:
	DB	109					; 0000006dH
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	0
$LN29@fracmv_wit:
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	0
_fracmv_within_tile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _kvz_search_cu_smp
_TEXT	SEGMENT
tv224 = -396						; size = 8
_smp_extra_bits$ = -192					; size = 4
_scu$1 = -180						; size = 4
_x$2 = -168						; size = 4
_y$3 = -156						; size = 4
_bitcost$4 = -144					; size = 4
_cost$5 = -132						; size = 8
_cur_pu$6 = -116					; size = 4
_height_pu$7 = -104					; size = 4
_width_pu$8 = -92					; size = 4
_y_pu$9 = -80						; size = 4
_x_pu$10 = -68						; size = 4
_i$11 = -56						; size = 4
_x_local$ = -44						; size = 4
_y_local$ = -32						; size = 4
_width$ = -20						; size = 4
_num_pu$ = -8						; size = 4
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_depth$ = 20						; size = 4
_part_mode$ = 24					; size = 4
_lcu$ = 28						; size = 4
_inter_cost$ = 32					; size = 4
_inter_bitcost$ = 36					; size = 4
_kvz_search_cu_smp PROC					; COMDAT

; 2036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-396]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 2037 :   const int num_pu  = kvz_part_mode_num_parts[part_mode];

	mov	eax, DWORD PTR _part_mode$[ebp]
	movzx	ecx, BYTE PTR _kvz_part_mode_num_parts[eax]
	mov	DWORD PTR _num_pu$[ebp], ecx

; 2038 :   const int width   = LCU_WIDTH >> depth;

	mov	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _depth$[ebp]
	sar	eax, cl
	mov	DWORD PTR _width$[ebp], eax

; 2039 :   const int y_local = SUB_SCU(y);

	mov	eax, DWORD PTR _y$[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _y_local$[ebp], eax

; 2040 :   const int x_local = SUB_SCU(x);

	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _x_local$[ebp], eax

; 2041 : 
; 2042 :   *inter_cost    = 0;

	mov	eax, DWORD PTR _inter_cost$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax], xmm0

; 2043 :   *inter_bitcost = 0;

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [eax], 0

; 2044 : 
; 2045 :   for (int i = 0; i < num_pu; ++i) {

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN4@kvz_search
$LN2@kvz_search:
	mov	eax, DWORD PTR _i$11[ebp]
	add	eax, 1
	mov	DWORD PTR _i$11[ebp], eax
$LN4@kvz_search:
	mov	eax, DWORD PTR _i$11[ebp]
	cmp	eax, DWORD PTR _num_pu$[ebp]
	jge	$LN3@kvz_search

; 2046 :     const int x_pu      = PU_GET_X(part_mode, width, x_local, i);

	mov	eax, DWORD PTR _i$11[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _part_mode$[ebp]
	lea	edx, DWORD PTR _kvz_part_mode_offsets[eax+ecx*8]
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	eax, BYTE PTR [edx+ecx]
	imul	eax, DWORD PTR _width$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, DWORD PTR _x_local$[ebp]
	mov	DWORD PTR _x_pu$10[ebp], eax

; 2047 :     const int y_pu      = PU_GET_Y(part_mode, width, y_local, i);

	mov	eax, DWORD PTR _i$11[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _part_mode$[ebp]
	lea	edx, DWORD PTR _kvz_part_mode_offsets[eax+ecx*8]
	mov	eax, 1
	shl	eax, 0
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR _width$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, DWORD PTR _y_local$[ebp]
	mov	DWORD PTR _y_pu$9[ebp], eax

; 2048 :     const int width_pu  = PU_GET_W(part_mode, width, i);

	mov	eax, DWORD PTR _i$11[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _part_mode$[ebp]
	lea	edx, DWORD PTR _kvz_part_mode_sizes[eax+ecx*8]
	mov	eax, 1
	imul	ecx, eax, 0
	movzx	eax, BYTE PTR [edx+ecx]
	imul	eax, DWORD PTR _width$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _width_pu$8[ebp], eax

; 2049 :     const int height_pu = PU_GET_H(part_mode, width, i);

	mov	eax, DWORD PTR _i$11[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _part_mode$[ebp]
	lea	edx, DWORD PTR _kvz_part_mode_sizes[eax+ecx*8]
	mov	eax, 1
	shl	eax, 0
	movzx	eax, BYTE PTR [edx+eax]
	imul	eax, DWORD PTR _width$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _height_pu$7[ebp], eax

; 2050 :     cu_info_t *cur_pu   = LCU_GET_CU_AT_PX(lcu, x_pu, y_pu);

	mov	eax, DWORD PTR _x_pu$10[ebp]
	sar	eax, 2
	mov	ecx, DWORD PTR _y_pu$9[ebp]
	sar	ecx, 2
	imul	edx, ecx, 17
	lea	eax, DWORD PTR [eax+edx+18]
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _lcu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+24976]
	mov	DWORD PTR _cur_pu$6[ebp], eax

; 2051 : 
; 2052 :     cur_pu->type      = CU_INTER;

	mov	eax, DWORD PTR _cur_pu$6[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 252					; 000000fcH
	or	cl, 2
	mov	edx, DWORD PTR _cur_pu$6[ebp]
	mov	BYTE PTR [edx], cl

; 2053 :     cur_pu->part_size = part_mode;

	mov	al, BYTE PTR _part_mode$[ebp]
	and	al, 7
	shl	al, 5
	mov	ecx, DWORD PTR _cur_pu$6[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 31					; 0000001fH
	or	dl, al
	mov	eax, DWORD PTR _cur_pu$6[ebp]
	mov	BYTE PTR [eax], dl

; 2054 :     cur_pu->depth     = depth;

	mov	al, BYTE PTR _depth$[ebp]
	and	al, 7
	shl	al, 2
	mov	ecx, DWORD PTR _cur_pu$6[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 227					; 000000e3H
	or	dl, al
	mov	eax, DWORD PTR _cur_pu$6[ebp]
	mov	BYTE PTR [eax], dl

; 2055 :     cur_pu->qp        = state->qp;

	mov	eax, DWORD PTR _cur_pu$6[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	dl, BYTE PTR [ecx+312]
	mov	BYTE PTR [eax+6], dl

; 2056 : 
; 2057 :     double cost      = MAX_INT;

	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	movsd	QWORD PTR _cost$5[ebp], xmm0

; 2058 :     uint32_t bitcost = MAX_INT;

	mov	DWORD PTR _bitcost$4[ebp], 2147483647	; 7fffffffH

; 2059 : 
; 2060 :     search_pu_inter(state, x, y, depth, part_mode, i, lcu, &cost, &bitcost);

	lea	eax, DWORD PTR _bitcost$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _cost$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcu$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _part_mode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_search_pu_inter
	add	esp, 36					; 00000024H

; 2061 : 
; 2062 :     if (cost >= MAX_INT) {

	movsd	xmm0, QWORD PTR _cost$5[ebp]
	comisd	xmm0, QWORD PTR __real@41dfffffffc00000
	jb	SHORT $LN11@kvz_search

; 2063 :       // Could not find any motion vector.
; 2064 :       *inter_cost    = MAX_INT;

	mov	eax, DWORD PTR _inter_cost$[ebp]
	movsd	xmm0, QWORD PTR __real@41dfffffffc00000
	movsd	QWORD PTR [eax], xmm0

; 2065 :       *inter_bitcost = MAX_INT;

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [eax], 2147483647		; 7fffffffH

; 2066 :       return;

	jmp	$LN1@kvz_search
$LN11@kvz_search:

; 2067 :     }
; 2068 : 
; 2069 :     *inter_cost    += cost;

	mov	eax, DWORD PTR _inter_cost$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	addsd	xmm0, QWORD PTR _cost$5[ebp]
	mov	ecx, DWORD PTR _inter_cost$[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 2070 :     *inter_bitcost += bitcost;

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _bitcost$4[ebp]
	mov	edx, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [edx], ecx

; 2071 : 
; 2072 :     for (int y = y_pu; y < y_pu + height_pu; y += SCU_WIDTH) {

	mov	eax, DWORD PTR _y_pu$9[ebp]
	mov	DWORD PTR _y$3[ebp], eax
	jmp	SHORT $LN7@kvz_search
$LN5@kvz_search:
	mov	eax, DWORD PTR _y$3[ebp]
	add	eax, 4
	mov	DWORD PTR _y$3[ebp], eax
$LN7@kvz_search:
	mov	eax, DWORD PTR _y_pu$9[ebp]
	add	eax, DWORD PTR _height_pu$7[ebp]
	cmp	DWORD PTR _y$3[ebp], eax
	jge	$LN6@kvz_search

; 2073 :       for (int x = x_pu; x < x_pu + width_pu; x += SCU_WIDTH) {

	mov	eax, DWORD PTR _x_pu$10[ebp]
	mov	DWORD PTR _x$2[ebp], eax
	jmp	SHORT $LN10@kvz_search
$LN8@kvz_search:
	mov	eax, DWORD PTR _x$2[ebp]
	add	eax, 4
	mov	DWORD PTR _x$2[ebp], eax
$LN10@kvz_search:
	mov	eax, DWORD PTR _x_pu$10[ebp]
	add	eax, DWORD PTR _width_pu$8[ebp]
	cmp	DWORD PTR _x$2[ebp], eax
	jge	SHORT $LN9@kvz_search

; 2074 :         cu_info_t *scu = LCU_GET_CU_AT_PX(lcu, x, y);

	mov	eax, DWORD PTR _x$2[ebp]
	sar	eax, 2
	mov	ecx, DWORD PTR _y$3[ebp]
	sar	ecx, 2
	imul	edx, ecx, 17
	lea	eax, DWORD PTR [eax+edx+18]
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _lcu$[ebp]
	lea	eax, DWORD PTR [edx+ecx+24976]
	mov	DWORD PTR _scu$1[ebp], eax

; 2075 :         scu->type = CU_INTER;

	mov	eax, DWORD PTR _scu$1[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 252					; 000000fcH
	or	cl, 2
	mov	edx, DWORD PTR _scu$1[ebp]
	mov	BYTE PTR [edx], cl

; 2076 :         scu->inter = cur_pu->inter;

	mov	eax, DWORD PTR _cur_pu$6[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _scu$1[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2077 :       }

	jmp	SHORT $LN8@kvz_search
$LN9@kvz_search:

; 2078 :     }

	jmp	$LN5@kvz_search
$LN6@kvz_search:

; 2079 :   }

	jmp	$LN2@kvz_search
$LN3@kvz_search:

; 2080 : 
; 2081 :   // Calculate more accurate cost when needed
; 2082 :   if (state->encoder_control->cfg.rdo >= 2) {

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+64], 2
	jl	SHORT $LN12@kvz_search

; 2083 :     kvz_cu_cost_inter_rd2(state,

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inter_cost$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcu$[ebp]
	push	edx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_cu_cost_inter_rd2
	add	esp, 28					; 0000001cH
$LN12@kvz_search:

; 2084 :       x, y, depth,
; 2085 :       lcu,
; 2086 :       inter_cost,
; 2087 :       inter_bitcost);
; 2088 :   }
; 2089 : 
; 2090 :   // Count bits spent for coding the partition mode.
; 2091 :   int smp_extra_bits = 1; // horizontal or vertical

	mov	DWORD PTR _smp_extra_bits$[ebp], 1

; 2092 :   if (state->encoder_control->cfg.amp_enable) {

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN14@kvz_search

; 2093 :     smp_extra_bits += 1; // symmetric or asymmetric

	mov	eax, DWORD PTR _smp_extra_bits$[ebp]
	add	eax, 1
	mov	DWORD PTR _smp_extra_bits$[ebp], eax

; 2094 :     if (part_mode != SIZE_2NxN && part_mode != SIZE_Nx2N) {

	cmp	DWORD PTR _part_mode$[ebp], 1
	je	SHORT $LN14@kvz_search
	cmp	DWORD PTR _part_mode$[ebp], 2
	je	SHORT $LN14@kvz_search

; 2095 :       smp_extra_bits += 1; // U,L or D,R

	mov	eax, DWORD PTR _smp_extra_bits$[ebp]
	add	eax, 1
	mov	DWORD PTR _smp_extra_bits$[ebp], eax
$LN14@kvz_search:

; 2096 :     }
; 2097 :   }
; 2098 :   // The transform is split for SMP and AMP blocks so we need more bits for
; 2099 :   // coding the CBF.
; 2100 :   smp_extra_bits += 6;

	mov	eax, DWORD PTR _smp_extra_bits$[ebp]
	add	eax, 6
	mov	DWORD PTR _smp_extra_bits$[ebp], eax

; 2101 : 
; 2102 :   *inter_cost += (state->encoder_control->cfg.rdo >= 2 ? state->lambda : state->lambda_sqrt) * smp_extra_bits;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+64], 2
	jl	SHORT $LN16@kvz_search
	mov	edx, DWORD PTR _state$[ebp]
	movsd	xmm0, QWORD PTR [edx+296]
	movsd	QWORD PTR tv224[ebp], xmm0
	jmp	SHORT $LN17@kvz_search
$LN16@kvz_search:
	mov	eax, DWORD PTR _state$[ebp]
	movsd	xmm0, QWORD PTR [eax+304]
	movsd	QWORD PTR tv224[ebp], xmm0
$LN17@kvz_search:
	cvtsi2sd xmm0, DWORD PTR _smp_extra_bits$[ebp]
	mulsd	xmm0, QWORD PTR tv224[ebp]
	mov	ecx, DWORD PTR _inter_cost$[ebp]
	addsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _inter_cost$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 2103 :   *inter_bitcost += smp_extra_bits;

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _smp_extra_bits$[ebp]
	mov	edx, DWORD PTR _inter_bitcost$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@kvz_search:

; 2104 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@kvz_search
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 396				; 0000018cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@kvz_search:
	DD	2
	DD	$LN20@kvz_search
$LN20@kvz_search:
	DD	-132					; ffffff7cH
	DD	8
	DD	$LN18@kvz_search
	DD	-144					; ffffff70H
	DD	4
	DD	$LN19@kvz_search
$LN19@kvz_search:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN18@kvz_search:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_kvz_search_cu_smp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
;	COMDAT _kvz_search_cu_inter
_TEXT	SEGMENT
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_depth$ = 20						; size = 4
_lcu$ = 24						; size = 4
_inter_cost$ = 28					; size = 4
_inter_bitcost$ = 32					; size = 4
_kvz_search_cu_inter PROC				; COMDAT

; 1995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __451C3417_search_inter@c
	call	@__CheckForDebuggerJustMyCode@4

; 1996 :   search_pu_inter(state,

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inter_cost$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcu$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_search_pu_inter
	add	esp, 36					; 00000024H

; 1997 :                   x, y, depth,
; 1998 :                   SIZE_2Nx2N, 0,
; 1999 :                   lcu,
; 2000 :                   inter_cost,
; 2001 :                   inter_bitcost);
; 2002 : 
; 2003 :   // Calculate more accurate cost when needed
; 2004 :   if (state->encoder_control->cfg.rdo >= 2) {

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+64], 2
	jl	SHORT $LN1@kvz_search

; 2005 :     kvz_cu_cost_inter_rd2(state,

	mov	eax, DWORD PTR _inter_bitcost$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inter_cost$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcu$[ebp]
	push	edx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_kvz_cu_cost_inter_rd2
	add	esp, 28					; 0000001cH
$LN1@kvz_search:

; 2006 :       x, y, depth,
; 2007 :       lcu,
; 2008 :       inter_cost,
; 2009 :       inter_bitcost);
; 2010 :   }
; 2011 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_search_cu_inter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
;	COMDAT _cbf_is_set_any
_TEXT	SEGMENT
tv79 = -196						; size = 4
_cbf$ = 8						; size = 2
_depth$ = 12						; size = 4
_cbf_is_set_any PROC					; COMDAT

; 525  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6C65A336_cu@h
	call	@__CheckForDebuggerJustMyCode@4

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	push	0
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	movzx	ecx, WORD PTR _cbf$[ebp]
	push	ecx
	call	_cbf_is_set
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@cbf_is_set
	push	1
	mov	edx, DWORD PTR _depth$[ebp]
	push	edx
	movzx	eax, WORD PTR _cbf$[ebp]
	push	eax
	call	_cbf_is_set
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@cbf_is_set
	push	2
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	movzx	edx, WORD PTR _cbf$[ebp]
	push	edx
	call	_cbf_is_set
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@cbf_is_set
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN4@cbf_is_set
$LN3@cbf_is_set:
	mov	DWORD PTR tv79[ebp], 1
$LN4@cbf_is_set:
	mov	eax, DWORD PTR tv79[ebp]

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_cbf_is_set_any ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
;	COMDAT _cbf_is_set
_TEXT	SEGMENT
tv72 = -196						; size = 4
_cbf$ = 8						; size = 2
_depth$ = 12						; size = 4
_plane$ = 16						; size = 4
_cbf_is_set PROC					; COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6C65A336_cu@h
	call	@__CheckForDebuggerJustMyCode@4

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR _cbf$[ebp]
	mov	ecx, DWORD PTR _depth$[ebp]
	movzx	edx, WORD PTR _cbf_masks[ecx*2]
	imul	ecx, DWORD PTR _plane$[ebp], 5
	shl	edx, cl
	and	eax, edx
	je	SHORT $LN3@cbf_is_set
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@cbf_is_set
$LN3@cbf_is_set:
	mov	DWORD PTR tv72[ebp], 0
$LN4@cbf_is_set:
	mov	eax, DWORD PTR tv72[ebp]

; 519  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_cbf_is_set ENDP
_TEXT	ENDS
END
