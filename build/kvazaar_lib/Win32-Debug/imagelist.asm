; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__6C65A336_cu@h DB 01H
__40DF0D2D_ctype@h DB 01H
__C5A167BB_basetsd@h DB 01H
__D24F4925_winnt@h DB 01H
__56CF70A3_processthreadsapi@h DB 01H
__4FC5969A_memoryapi@h DB 01H
__7D439CBC_winerror@h DB 01H
__41E0877F_winbase@h DB 01H
__08182E14_stralign@h DB 01H
__8FD04514_threads@h DB 01H
__BD904B23_imagelist@c DB 01H
msvcjmc	ENDS
CONST	SEGMENT
_cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_kvz_image_list_alloc
PUBLIC	_kvz_image_list_resize
PUBLIC	_kvz_image_list_destroy
PUBLIC	_kvz_image_list_add
PUBLIC	_kvz_image_list_rem
PUBLIC	_kvz_image_list_copy_contents
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??kvz_image_list_add@@9@9	; `kvz_image_list_add'::`1'::__LINE__Var
PUBLIC	??_C@_0DG@EODIENIF@Tried?5to?5add?5an?5unreferenced?5pi@ ; `string'
PUBLIC	??_C@_1HA@NPLFHGF@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0@				; `string'
PUBLIC	??_C@_0DH@MIHEGIK@Tried?5to?5add?5an?5unreferenced?5cu@ ; `string'
EXTRN	__imp___wassert:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_kvz_image_free:PROC
EXTRN	_kvz_cu_array_free:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DH@MIHEGIK@Tried?5to?5add?5an?5unreferenced?5cu@
CONST	SEGMENT
??_C@_0DH@MIHEGIK@Tried?5to?5add?5an?5unreferenced?5cu@ DB 'Tried to add '
	DB	'an unreferenced cu_array. This is a bug!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0@ DB '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@NPLFHGF@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
CONST	SEGMENT
??_C@_1HA@NPLFHGF@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ DB 'F'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c', 00H, '_'
	DB	00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H, '_', 00H
	DB	'2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k', 00H, 'v'
	DB	00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H, '-', 00H
	DB	'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'm', 00H
	DB	'a', 00H, 'g', 00H, 'e', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, '.', 00H, 'c', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EODIENIF@Tried?5to?5add?5an?5unreferenced?5pi@
CONST	SEGMENT
??_C@_0DG@EODIENIF@Tried?5to?5add?5an?5unreferenced?5pi@ DB 'Tried to add'
	DB	' an unreferenced picture. This is a bug!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_image_list_add@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_image_list_add@@9@9 DD 077H	; `kvz_image_list_add'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
;	COMDAT _kvz_image_list_copy_contents
_TEXT	SEGMENT
_i$ = -8						; size = 4
_target$ = 8						; size = 4
_source$ = 12						; size = 4
_kvz_image_list_copy_contents PROC			; COMDAT

; 213  : int kvz_image_list_copy_contents(image_list_t *target, image_list_t *source) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BD904B23_imagelist@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@kvz_image_:

; 214  :   int i;
; 215  :   while (target->used_size > 0) {

	mov	eax, DWORD PTR _target$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jbe	SHORT $LN3@kvz_image_

; 216  :     kvz_image_list_rem(target, 0);

	push	0
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	call	_kvz_image_list_rem
	add	esp, 8

; 217  :   }

	jmp	SHORT $LN2@kvz_image_
$LN3@kvz_image_:

; 218  :   
; 219  :   for (i = source->used_size - 1; i >= 0; --i) {

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN6@kvz_image_
$LN4@kvz_image_:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@kvz_image_:
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $LN5@kvz_image_

; 220  :     kvz_image_list_add(target, source->images[i], source->cu_arrays[i], source->pocs[i], source->ref_LXs[i]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _source$[ebp]
	add	eax, DWORD PTR [ecx+12]
	push	eax
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	call	_kvz_image_list_add
	add	esp, 20					; 00000014H

; 221  :   }

	jmp	SHORT $LN4@kvz_image_
$LN5@kvz_image_:

; 222  :   return 1;

	mov	eax, 1

; 223  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_image_list_copy_contents ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
;	COMDAT _kvz_image_list_rem
_TEXT	SEGMENT
_j$1 = -44						; size = 4
_j$2 = -32						; size = 4
_i$3 = -20						; size = 4
_j$4 = -8						; size = 4
_list$ = 8						; size = 4
_n$ = 12						; size = 4
_kvz_image_list_rem PROC				; COMDAT

; 167  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BD904B23_imagelist@c
	call	@__CheckForDebuggerJustMyCode@4

; 168  :   // Must be within list boundaries
; 169  :   if (n >= list->used_size)

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jb	SHORT $LN14@kvz_image_

; 170  :   {
; 171  :     return 0;

	xor	eax, eax
	jmp	$LN1@kvz_image_
$LN14@kvz_image_:

; 172  :   }
; 173  : 
; 174  :   kvz_image_free(list->images[n]);

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_kvz_image_free
	add	esp, 4

; 175  : 
; 176  :   kvz_cu_array_free(&list->cu_arrays[n]);

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _n$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_kvz_cu_array_free
	add	esp, 4

; 177  : 
; 178  :   // The last item is easy to remove
; 179  :   if (n == list->used_size - 1) {

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	cmp	DWORD PTR _n$[ebp], ecx
	jne	$LN15@kvz_image_

; 180  :     list->images[n] = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 181  :     list->cu_arrays[n] = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 182  :     list->pocs[n] = 0;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 183  :     for (int j = 0; j < 16; j++) {

	mov	DWORD PTR _j$4[ebp], 0
	jmp	SHORT $LN4@kvz_image_
$LN2@kvz_image_:
	mov	eax, DWORD PTR _j$4[ebp]
	add	eax, 1
	mov	DWORD PTR _j$4[ebp], eax
$LN4@kvz_image_:
	cmp	DWORD PTR _j$4[ebp], 16			; 00000010H
	jge	SHORT $LN3@kvz_image_

; 184  :       list->ref_LXs[n][0][j] = 0;

	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, DWORD PTR _j$4[ebp]
	mov	BYTE PTR [edx+eax], 0

; 185  :       list->ref_LXs[n][1][j] = 0;

	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, DWORD PTR _j$4[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 186  :     }

	jmp	SHORT $LN2@kvz_image_
$LN3@kvz_image_:

; 187  :     list->used_size--;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 188  :   } else {

	jmp	$LN16@kvz_image_
$LN15@kvz_image_:

; 189  :     int i = n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _i$3[ebp], eax

; 190  :     // Shift all following pics one backward in the list
; 191  :     for (i = n; i < list->used_size - 1; ++i) {

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@kvz_image_
$LN5@kvz_image_:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@kvz_image_:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	cmp	DWORD PTR _i$3[ebp], ecx
	jae	$LN6@kvz_image_

; 192  :       list->images[i] = list->images[i + 1];

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 193  :       list->cu_arrays[i] = list->cu_arrays[i + 1];

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 194  :       list->pocs[i] = list->pocs[i + 1];

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	esi, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+4]
	mov	DWORD PTR [eax+edx*4], ecx

; 195  :       for (int j = 0; j < 16; j++) {

	mov	DWORD PTR _j$2[ebp], 0
	jmp	SHORT $LN10@kvz_image_
$LN8@kvz_image_:
	mov	eax, DWORD PTR _j$2[ebp]
	add	eax, 1
	mov	DWORD PTR _j$2[ebp], eax
$LN10@kvz_image_:
	cmp	DWORD PTR _j$2[ebp], 16			; 00000010H
	jge	$LN9@kvz_image_

; 196  :         list->ref_LXs[i][0][j] = list->ref_LXs[i + 1][0][j];

	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, DWORD PTR _i$3[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	add	ecx, eax
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	ecx, eax
	mov	eax, DWORD PTR _j$2[ebp]
	mov	esi, DWORD PTR _j$2[ebp]
	mov	dl, BYTE PTR [edx+esi]
	mov	BYTE PTR [ecx+eax], dl

; 197  :         list->ref_LXs[i][1][j] = list->ref_LXs[i + 1][1][j];

	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, DWORD PTR _i$3[ebp]
	shl	ecx, 5
	mov	eax, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, ecx
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	eax, ecx
	mov	ecx, DWORD PTR _j$2[ebp]
	mov	esi, DWORD PTR _j$2[ebp]
	mov	dl, BYTE PTR [edx+esi]
	mov	BYTE PTR [eax+ecx], dl

; 198  :       }

	jmp	$LN8@kvz_image_
$LN9@kvz_image_:

; 199  :     }

	jmp	$LN5@kvz_image_
$LN6@kvz_image_:

; 200  :     list->images[list->used_size - 1] = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4-4], 0

; 201  :     list->cu_arrays[list->used_size - 1] = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx*4-4], 0

; 202  :     list->pocs[list->used_size - 1] = 0;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+ecx*4-4], 0

; 203  :     for (int j = 0; j < 16; j++) {

	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN13@kvz_image_
$LN11@kvz_image_:
	mov	eax, DWORD PTR _j$1[ebp]
	add	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN13@kvz_image_:
	cmp	DWORD PTR _j$1[ebp], 16			; 00000010H
	jge	SHORT $LN12@kvz_image_

; 204  :       list->ref_LXs[list->used_size - 1][0][j] = 0;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, ecx
	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	add	eax, edx
	mov	ecx, DWORD PTR _j$1[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 205  :       list->ref_LXs[list->used_size - 1][1][j] = 0;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, ecx
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	eax, ecx
	mov	edx, DWORD PTR _j$1[ebp]
	mov	BYTE PTR [eax+edx], 0

; 206  :     }

	jmp	SHORT $LN11@kvz_image_
$LN12@kvz_image_:

; 207  :     list->used_size--;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, 1
	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+20], ecx
$LN16@kvz_image_:

; 208  :   }
; 209  : 
; 210  :   return 1;

	mov	eax, 1
$LN1@kvz_image_:

; 211  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_image_list_rem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
;	COMDAT _kvz_image_list_add
_TEXT	SEGMENT
tv136 = -244						; size = 4
_j$1 = -44						; size = 4
_j$2 = -32						; size = 4
_new_size$3 = -20					; size = 4
_i$ = -8						; size = 4
_list$ = 8						; size = 4
_im$ = 12						; size = 4
_cua$ = 16						; size = 4
_poc$ = 20						; size = 4
_ref_LX$ = 24						; size = 4
_kvz_image_list_add PROC				; COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BD904B23_imagelist@c
	call	@__CheckForDebuggerJustMyCode@4

; 120  :   int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 121  :   if (KVZ_ATOMIC_INC(&(im->refcount)) == 1) {

	mov	eax, DWORD PTR _im$[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax], ecx
	inc	ecx
	cmp	ecx, 1
	jne	SHORT $LN11@kvz_image_

; 122  :     fprintf(stderr, "Tried to add an unreferenced picture. This is a bug!\n");

	push	OFFSET ??_C@_0DG@EODIENIF@Tried?5to?5add?5an?5unreferenced?5pi@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 123  :     assert(0); //Stop for debugging

	xor	eax, eax
	jne	SHORT $LN16@kvz_image_
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_image_list_add@@9@9
	add	ecx, 4
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1HA@NPLFHGF@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_13COJANIEC@?$AA0@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN16@kvz_image_:

; 124  :     return 0;

	xor	eax, eax
	jmp	$LN1@kvz_image_
$LN11@kvz_image_:

; 125  :   }
; 126  :   
; 127  :   if (KVZ_ATOMIC_INC(&(cua->refcount)) == 1) {

	mov	eax, DWORD PTR _cua$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax], ecx
	inc	ecx
	cmp	ecx, 1
	jne	SHORT $LN12@kvz_image_

; 128  :     fprintf(stderr, "Tried to add an unreferenced cu_array. This is a bug!\n");

	push	OFFSET ??_C@_0DH@MIHEGIK@Tried?5to?5add?5an?5unreferenced?5cu@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 129  :     assert(0); //Stop for debugging

	xor	eax, eax
	jne	SHORT $LN17@kvz_image_
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_image_list_add@@9@9
	add	ecx, 10					; 0000000aH
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1HA@NPLFHGF@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_13COJANIEC@?$AA0@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN17@kvz_image_:

; 130  :     return 0;

	xor	eax, eax
	jmp	$LN1@kvz_image_
$LN12@kvz_image_:

; 131  :   }
; 132  : 
; 133  :   if (list->size == list->used_size) {

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN13@kvz_image_

; 134  :     unsigned new_size = MAX(list->size + 1, list->size * 2);

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 1
	cmp	ecx, eax
	jbe	SHORT $LN18@kvz_image_
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	DWORD PTR tv136[ebp], edx
	jmp	SHORT $LN19@kvz_image_
$LN18@kvz_image_:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shl	ecx, 1
	mov	DWORD PTR tv136[ebp], ecx
$LN19@kvz_image_:
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR _new_size$3[ebp], edx

; 135  :     if (!kvz_image_list_resize(list, new_size)) return 0;

	mov	eax, DWORD PTR _new_size$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	call	_kvz_image_list_resize
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@kvz_image_
	xor	eax, eax
	jmp	$LN1@kvz_image_
$LN13@kvz_image_:

; 136  :   }
; 137  :   
; 138  :   for (i = list->used_size; i > 0; i--) {

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN4@kvz_image_
$LN2@kvz_image_:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@kvz_image_:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$LN3@kvz_image_

; 139  :     list->images[i] = list->images[i - 1];

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 140  :     list->cu_arrays[i] = list->cu_arrays[i - 1];

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 141  :     list->pocs[i] = list->pocs[i - 1];

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 142  :     for (int j = 0; j < 16; j++) {

	mov	DWORD PTR _j$2[ebp], 0
	jmp	SHORT $LN7@kvz_image_
$LN5@kvz_image_:
	mov	eax, DWORD PTR _j$2[ebp]
	add	eax, 1
	mov	DWORD PTR _j$2[ebp], eax
$LN7@kvz_image_:
	cmp	DWORD PTR _j$2[ebp], 16			; 00000010H
	jge	$LN6@kvz_image_

; 143  :       list->ref_LXs[i][0][j] = list->ref_LXs[i - 1][0][j];

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	add	ecx, eax
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	ecx, eax
	mov	eax, DWORD PTR _j$2[ebp]
	mov	esi, DWORD PTR _j$2[ebp]
	mov	dl, BYTE PTR [edx+esi]
	mov	BYTE PTR [ecx+eax], dl

; 144  :       list->ref_LXs[i][1][j] = list->ref_LXs[i - 1][1][j];

	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	eax, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, ecx
	mov	ecx, 16					; 00000010H
	shl	ecx, 0
	add	eax, ecx
	mov	ecx, DWORD PTR _j$2[ebp]
	mov	esi, DWORD PTR _j$2[ebp]
	mov	dl, BYTE PTR [edx+esi]
	mov	BYTE PTR [eax+ecx], dl

; 145  :     }

	jmp	$LN5@kvz_image_
$LN6@kvz_image_:

; 146  :   }

	jmp	$LN2@kvz_image_
$LN3@kvz_image_:

; 147  : 
; 148  :   list->images[0] = im;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _im$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 149  :   list->cu_arrays[0] = cua;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _cua$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 150  :   list->pocs[0] = poc;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _list$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _poc$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 151  :   for (int j = 0; j < 16; j++) {

	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN10@kvz_image_
$LN8@kvz_image_:
	mov	eax, DWORD PTR _j$1[ebp]
	add	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN10@kvz_image_:
	cmp	DWORD PTR _j$1[ebp], 16			; 00000010H
	jge	SHORT $LN9@kvz_image_

; 152  :     list->ref_LXs[0][0][j] = ref_LX[0][j];

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _ref_LX$[ebp]
	mov	edx, 32					; 00000020H
	imul	eax, edx, 0
	mov	edx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [edx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	add	edx, eax
	mov	eax, DWORD PTR _j$1[ebp]
	mov	esi, DWORD PTR _j$1[ebp]
	mov	cl, BYTE PTR [ecx+esi]
	mov	BYTE PTR [edx+eax], cl

; 153  :     list->ref_LXs[0][1][j] = ref_LX[1][j];

	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	eax, DWORD PTR _ref_LX$[ebp]
	mov	ecx, 32					; 00000020H
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	add	ecx, edx
	mov	edx, 16					; 00000010H
	shl	edx, 0
	add	ecx, edx
	mov	edx, DWORD PTR _j$1[ebp]
	mov	esi, DWORD PTR _j$1[ebp]
	mov	al, BYTE PTR [eax+esi]
	mov	BYTE PTR [ecx+edx], al

; 154  :   }

	jmp	SHORT $LN8@kvz_image_
$LN9@kvz_image_:

; 155  :   
; 156  :   list->used_size++;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 157  :   return 1;

	mov	eax, 1
$LN1@kvz_image_:

; 158  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_image_list_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
;	COMDAT _kvz_image_list_destroy
_TEXT	SEGMENT
_j$1 = -20						; size = 4
_i$ = -8						; size = 4
_list$ = 8						; size = 4
_kvz_image_list_destroy PROC				; COMDAT

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BD904B23_imagelist@c
	call	@__CheckForDebuggerJustMyCode@4

; 83   :   unsigned int i;
; 84   :   if (list->used_size > 0) {

	mov	eax, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jbe	$LN8@kvz_image_

; 85   :     for (i = 0; i < list->used_size; ++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@kvz_image_
$LN2@kvz_image_:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@kvz_image_:
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	$LN8@kvz_image_

; 86   :       kvz_image_free(list->images[i]);

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_kvz_image_free
	add	esp, 4

; 87   :       list->images[i] = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 88   :       kvz_cu_array_free(&list->cu_arrays[i]);

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_kvz_cu_array_free
	add	esp, 4

; 89   :       list->cu_arrays[i] = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 90   :       list->pocs[i] = 0;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 91   :       for (int j = 0; j < 16; j++) {

	mov	DWORD PTR _j$1[ebp], 0
	jmp	SHORT $LN7@kvz_image_
$LN5@kvz_image_:
	mov	eax, DWORD PTR _j$1[ebp]
	add	eax, 1
	mov	DWORD PTR _j$1[ebp], eax
$LN7@kvz_image_:
	cmp	DWORD PTR _j$1[ebp], 16			; 00000010H
	jge	SHORT $LN6@kvz_image_

; 92   :         list->ref_LXs[i][0][j] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	add	edx, ecx
	mov	eax, DWORD PTR _j$1[ebp]
	mov	BYTE PTR [edx+eax], 0

; 93   :         list->ref_LXs[i][1][j] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, eax
	mov	eax, 16					; 00000010H
	shl	eax, 0
	add	edx, eax
	mov	ecx, DWORD PTR _j$1[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 94   :       }

	jmp	SHORT $LN5@kvz_image_
$LN6@kvz_image_:

; 95   :     }

	jmp	$LN2@kvz_image_
$LN8@kvz_image_:

; 96   :   }
; 97   : 
; 98   :   if (list->size > 0) {

	mov	eax, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jbe	SHORT $LN9@kvz_image_

; 99   :     free(list->images);

	mov	esi, esp
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 100  :     free(list->cu_arrays);

	mov	esi, esp
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 101  :     free(list->pocs);

	mov	esi, esp
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 102  :     free(list->ref_LXs);

	mov	esi, esp
	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@kvz_image_:

; 103  :   }
; 104  :   list->images = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax], 0

; 105  :   list->cu_arrays = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+4], 0

; 106  :   list->pocs = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+8], 0

; 107  :   list->ref_LXs = NULL;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+12], 0

; 108  :   free(list);

	mov	esi, esp
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 109  :   return 1;

	mov	eax, 1

; 110  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_image_list_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
;	COMDAT _kvz_image_list_resize
_TEXT	SEGMENT
tv140 = -196						; size = 4
_list$ = 8						; size = 4
_size$ = 12						; size = 4
_kvz_image_list_resize PROC				; COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BD904B23_imagelist@c
	call	@__CheckForDebuggerJustMyCode@4

; 68   :   list->images = (kvz_picture**)realloc(list->images, sizeof(kvz_picture*) * size);

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx], eax

; 69   :   list->cu_arrays = (cu_array_t**)realloc(list->cu_arrays, sizeof(cu_array_t*) * size);

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 70   :   list->pocs = realloc(list->pocs, sizeof(int32_t) * size);

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 71   :   list->ref_LXs = realloc(list->ref_LXs, sizeof(*list->ref_LXs) * size);

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 5
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR __imp__realloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 72   :   list->size = size;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 73   :   return size == 0 || (list->images && list->cu_arrays && list->pocs);

	cmp	DWORD PTR _size$[ebp], 0
	je	SHORT $LN4@kvz_image_
	mov	eax, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@kvz_image_
	mov	ecx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN3@kvz_image_
	mov	edx, DWORD PTR _list$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN4@kvz_image_
$LN3@kvz_image_:
	mov	DWORD PTR tv140[ebp], 0
	jmp	SHORT $LN5@kvz_image_
$LN4@kvz_image_:
	mov	DWORD PTR tv140[ebp], 1
$LN5@kvz_image_:
	mov	eax, DWORD PTR tv140[ebp]

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_image_list_resize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
;	COMDAT _kvz_image_list_alloc
_TEXT	SEGMENT
_list$ = -8						; size = 4
_size$ = 8						; size = 4
_kvz_image_list_alloc PROC				; COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BD904B23_imagelist@c
	call	@__CheckForDebuggerJustMyCode@4

; 49   :   image_list_t *list = (image_list_t *)malloc(sizeof(image_list_t));

	mov	esi, esp
	push	24					; 00000018H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _list$[ebp], eax

; 50   :   list->size      = size;

	mov	eax, DWORD PTR _list$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 51   :   list->images    = malloc(sizeof(kvz_picture*)  * size);

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx], eax

; 52   :   list->cu_arrays = malloc(sizeof(cu_array_t*)   * size);

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 53   :   list->pocs      = malloc(sizeof(int32_t)       * size);

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 54   :   list->ref_LXs   = malloc(sizeof(*list->ref_LXs) * size);

	mov	eax, DWORD PTR _size$[ebp]
	shl	eax, 5
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _list$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 55   :   list->used_size = 0;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [eax+20], 0

; 56   : 
; 57   :   return list;

	mov	eax, DWORD PTR _list$[ebp]

; 58   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_image_list_alloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 644  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1850469A_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
