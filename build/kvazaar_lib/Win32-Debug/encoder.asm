; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@FIMIKDEG@array_checksum@		; `string'
PUBLIC	??_C@_09INHMEIKP@array_md5@			; `string'
PUBLIC	??_C@_07DDJKLCAH@reg_sad@			; `string'
PUBLIC	??_C@_07CCGEEBAL@sad_4x4@			; `string'
PUBLIC	??_C@_07MEAHLBLP@sad_8x8@			; `string'
PUBLIC	??_C@_09CIFGAEGF@sad_16x16@			; `string'
PUBLIC	??_C@_09PHPGBCME@sad_32x32@			; `string'
PUBLIC	??_C@_09HIOKBDLK@sad_64x64@			; `string'
PUBLIC	??_C@_08GDBJPAOD@satd_4x4@			; `string'
PUBLIC	??_C@_08IFHKAAFH@satd_8x8@			; `string'
PUBLIC	??_C@_0L@CJHLPOG@satd_16x16@			; `string'
PUBLIC	??_C@_0L@NNDHKJEH@satd_32x32@			; `string'
PUBLIC	??_C@_0L@FCCLKIDJ@satd_64x64@			; `string'
PUBLIC	??_C@_0O@FHJAMJMP@satd_any_size@		; `string'
PUBLIC	??_C@_0N@PBMCJFCI@sad_4x4_dual@			; `string'
PUBLIC	??_C@_0N@NAFGAMEI@sad_8x8_dual@			; `string'
PUBLIC	??_C@_0P@KGAKCNHP@sad_16x16_dual@		; `string'
PUBLIC	??_C@_0P@EBOHBHKK@sad_32x32_dual@		; `string'
PUBLIC	??_C@_0P@BGJOPAPB@sad_64x64_dual@		; `string'
PUBLIC	??_C@_0O@PJODLFIO@satd_4x4_dual@		; `string'
PUBLIC	??_C@_0O@NIHHCMOO@satd_8x8_dual@		; `string'
PUBLIC	??_C@_0BA@GFDJBOPJ@satd_16x16_dual@		; `string'
PUBLIC	??_C@_0BA@ICNECECM@satd_32x32_dual@		; `string'
PUBLIC	??_C@_0BA@NFKNMDHH@satd_64x64_dual@		; `string'
PUBLIC	??_C@_0BD@EFOGIBKC@satd_any_size_quad@		; `string'
PUBLIC	??_C@_0BA@BPDFDAFM@pixels_calc_ssd@		; `string'
PUBLIC	??_C@_0P@FIKELBGI@bipred_average@		; `string'
PUBLIC	??_C@_0BC@IMILIHON@get_optimized_sad@		; `string'
PUBLIC	??_C@_07OEMLCPNF@ver_sad@			; `string'
PUBLIC	??_C@_07CJIKFDIC@hor_sad@			; `string'
PUBLIC	??_C@_09GDPKBOJB@pixel_var@			; `string'
PUBLIC	??_C@_0BF@BJKPGPEP@fast_forward_dst_4x4@	; `string'
PUBLIC	??_C@_07MAFDGKIL@dct_4x4@			; `string'
PUBLIC	??_C@_07CGDAJKDP@dct_8x8@			; `string'
PUBLIC	??_C@_09LPGJIHFJ@dct_16x16@			; `string'
PUBLIC	??_C@_09GAMJJBPI@dct_32x32@			; `string'
PUBLIC	??_C@_0BF@LGIDMEOF@fast_inverse_dst_4x4@	; `string'
PUBLIC	??_C@_08LDLIJGLD@idct_4x4@			; `string'
PUBLIC	??_C@_08FFNLGGAH@idct_8x8@			; `string'
PUBLIC	??_C@_0L@BMPNPGHO@idct_16x16@			; `string'
PUBLIC	??_C@_0L@MDFNOANP@idct_32x32@			; `string'
PUBLIC	??_C@_0CA@KBMGLOML@filter_hpel_blocks_hor_ver_luma@ ; `string'
PUBLIC	??_C@_0BN@LGIFMJCD@filter_hpel_blocks_diag_luma@ ; `string'
PUBLIC	??_C@_0CA@HAFBJKBM@filter_qpel_blocks_hor_ver_luma@ ; `string'
PUBLIC	??_C@_0BN@LBBJMBKC@filter_qpel_blocks_diag_luma@ ; `string'
PUBLIC	??_C@_0BH@DGLFPIPB@sample_quarterpel_luma@	; `string'
PUBLIC	??_C@_0BF@HOLGGLNK@sample_octpel_chroma@	; `string'
PUBLIC	??_C@_0BK@LCPNGAOF@sample_quarterpel_luma_hi@	; `string'
PUBLIC	??_C@_0BI@EFIAEBMP@sample_octpel_chroma_hi@	; `string'
PUBLIC	??_C@_0BD@MPANGNDO@get_extended_block@		; `string'
PUBLIC	??_C@_05DFPBCFDJ@quant@				; `string'
PUBLIC	??_C@_0BC@MPMPMGJB@quantize_residual@		; `string'
PUBLIC	??_C@_07GMDOJGPA@dequant@			; `string'
PUBLIC	??_C@_0O@ECIHPEON@coeff_abs_sum@		; `string'
PUBLIC	??_C@_0BA@HMNKAKOO@fast_coeff_cost@		; `string'
PUBLIC	??_C@_0N@NMFCEONC@angular_pred@			; `string'
PUBLIC	??_C@_0BC@KPOCLILL@intra_pred_planar@		; `string'
PUBLIC	??_C@_0BH@EAOLFJGL@intra_pred_filtered_dc@	; `string'
PUBLIC	??_C@_0BF@LGILOHOJ@sao_edge_ddistortion@	; `string'
PUBLIC	??_C@_0BC@OCNKGNNI@calc_sao_edge_dir@		; `string'
PUBLIC	??_C@_0BG@IJPOOFFG@sao_reconstruct_color@	; `string'
PUBLIC	??_C@_0BF@HDNLAKN@sao_band_ddistortion@		; `string'
PUBLIC	??_C@_0BB@GDIDDFDB@encode_coeff_nxn@		; `string'
EXTRN	_kvz_array_checksum:DWORD
EXTRN	_kvz_array_md5:DWORD
EXTRN	_kvz_reg_sad:DWORD
EXTRN	_kvz_sad_4x4:DWORD
EXTRN	_kvz_sad_8x8:DWORD
EXTRN	_kvz_sad_16x16:DWORD
EXTRN	_kvz_sad_32x32:DWORD
EXTRN	_kvz_sad_64x64:DWORD
EXTRN	_kvz_satd_4x4:DWORD
EXTRN	_kvz_satd_8x8:DWORD
EXTRN	_kvz_satd_16x16:DWORD
EXTRN	_kvz_satd_32x32:DWORD
EXTRN	_kvz_satd_64x64:DWORD
EXTRN	_kvz_satd_any_size:DWORD
EXTRN	_kvz_sad_4x4_dual:DWORD
EXTRN	_kvz_sad_8x8_dual:DWORD
EXTRN	_kvz_sad_16x16_dual:DWORD
EXTRN	_kvz_sad_32x32_dual:DWORD
EXTRN	_kvz_sad_64x64_dual:DWORD
EXTRN	_kvz_satd_4x4_dual:DWORD
EXTRN	_kvz_satd_8x8_dual:DWORD
EXTRN	_kvz_satd_16x16_dual:DWORD
EXTRN	_kvz_satd_32x32_dual:DWORD
EXTRN	_kvz_satd_64x64_dual:DWORD
EXTRN	_kvz_satd_any_size_quad:DWORD
EXTRN	_kvz_pixels_calc_ssd:DWORD
EXTRN	_kvz_bipred_average:DWORD
EXTRN	_kvz_get_optimized_sad:DWORD
EXTRN	_kvz_ver_sad:DWORD
EXTRN	_kvz_hor_sad:DWORD
EXTRN	_kvz_pixel_var:DWORD
EXTRN	_kvz_fast_forward_dst_4x4:DWORD
EXTRN	_kvz_dct_4x4:DWORD
EXTRN	_kvz_dct_8x8:DWORD
EXTRN	_kvz_dct_16x16:DWORD
EXTRN	_kvz_dct_32x32:DWORD
EXTRN	_kvz_fast_inverse_dst_4x4:DWORD
EXTRN	_kvz_idct_4x4:DWORD
EXTRN	_kvz_idct_8x8:DWORD
EXTRN	_kvz_idct_16x16:DWORD
EXTRN	_kvz_idct_32x32:DWORD
EXTRN	_kvz_filter_hpel_blocks_hor_ver_luma:DWORD
EXTRN	_kvz_filter_hpel_blocks_diag_luma:DWORD
EXTRN	_kvz_filter_qpel_blocks_hor_ver_luma:DWORD
EXTRN	_kvz_filter_qpel_blocks_diag_luma:DWORD
EXTRN	_kvz_get_extended_block:DWORD
EXTRN	_kvz_sample_quarterpel_luma:DWORD
EXTRN	_kvz_sample_octpel_chroma:DWORD
EXTRN	_kvz_sample_quarterpel_luma_hi:DWORD
EXTRN	_kvz_sample_octpel_chroma_hi:DWORD
EXTRN	_kvz_quant:DWORD
EXTRN	_kvz_quantize_residual:DWORD
EXTRN	_kvz_dequant:DWORD
EXTRN	_kvz_coeff_abs_sum:DWORD
EXTRN	_kvz_fast_coeff_cost:DWORD
EXTRN	_kvz_angular_pred:DWORD
EXTRN	_kvz_intra_pred_planar:DWORD
EXTRN	_kvz_intra_pred_filtered_dc:DWORD
EXTRN	_kvz_sao_edge_ddistortion:DWORD
EXTRN	_kvz_calc_sao_edge_dir:DWORD
EXTRN	_kvz_sao_reconstruct_color:DWORD
EXTRN	_kvz_sao_band_ddistortion:DWORD
EXTRN	_kvz_encode_coeff_nxn:DWORD
msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__E2865EBA_corecrt_math@h DB 01H
__6C65A336_cu@h DB 01H
__546CF5FC_crypto@h DB 01H
__6BE1C69C_encoderstate@h DB 01H
__C4AC213E_kvz_math@h DB 01H
__747AF517_encoder@c DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_0BB@GDIDDFDB@encode_coeff_nxn@
CONST	SEGMENT
??_C@_0BB@GDIDDFDB@encode_coeff_nxn@ DB 'encode_coeff_nxn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HDNLAKN@sao_band_ddistortion@
CONST	SEGMENT
??_C@_0BF@HDNLAKN@sao_band_ddistortion@ DB 'sao_band_ddistortion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IJPOOFFG@sao_reconstruct_color@
CONST	SEGMENT
??_C@_0BG@IJPOOFFG@sao_reconstruct_color@ DB 'sao_reconstruct_color', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OCNKGNNI@calc_sao_edge_dir@
CONST	SEGMENT
??_C@_0BC@OCNKGNNI@calc_sao_edge_dir@ DB 'calc_sao_edge_dir', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LGILOHOJ@sao_edge_ddistortion@
CONST	SEGMENT
??_C@_0BF@LGILOHOJ@sao_edge_ddistortion@ DB 'sao_edge_ddistortion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EAOLFJGL@intra_pred_filtered_dc@
CONST	SEGMENT
??_C@_0BH@EAOLFJGL@intra_pred_filtered_dc@ DB 'intra_pred_filtered_dc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KPOCLILL@intra_pred_planar@
CONST	SEGMENT
??_C@_0BC@KPOCLILL@intra_pred_planar@ DB 'intra_pred_planar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NMFCEONC@angular_pred@
CONST	SEGMENT
??_C@_0N@NMFCEONC@angular_pred@ DB 'angular_pred', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HMNKAKOO@fast_coeff_cost@
CONST	SEGMENT
??_C@_0BA@HMNKAKOO@fast_coeff_cost@ DB 'fast_coeff_cost', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ECIHPEON@coeff_abs_sum@
CONST	SEGMENT
??_C@_0O@ECIHPEON@coeff_abs_sum@ DB 'coeff_abs_sum', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMDOJGPA@dequant@
CONST	SEGMENT
??_C@_07GMDOJGPA@dequant@ DB 'dequant', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MPMPMGJB@quantize_residual@
CONST	SEGMENT
??_C@_0BC@MPMPMGJB@quantize_residual@ DB 'quantize_residual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFPBCFDJ@quant@
CONST	SEGMENT
??_C@_05DFPBCFDJ@quant@ DB 'quant', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MPANGNDO@get_extended_block@
CONST	SEGMENT
??_C@_0BD@MPANGNDO@get_extended_block@ DB 'get_extended_block', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EFIAEBMP@sample_octpel_chroma_hi@
CONST	SEGMENT
??_C@_0BI@EFIAEBMP@sample_octpel_chroma_hi@ DB 'sample_octpel_chroma_hi', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LCPNGAOF@sample_quarterpel_luma_hi@
CONST	SEGMENT
??_C@_0BK@LCPNGAOF@sample_quarterpel_luma_hi@ DB 'sample_quarterpel_luma_'
	DB	'hi', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOLGGLNK@sample_octpel_chroma@
CONST	SEGMENT
??_C@_0BF@HOLGGLNK@sample_octpel_chroma@ DB 'sample_octpel_chroma', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DGLFPIPB@sample_quarterpel_luma@
CONST	SEGMENT
??_C@_0BH@DGLFPIPB@sample_quarterpel_luma@ DB 'sample_quarterpel_luma', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LBBJMBKC@filter_qpel_blocks_diag_luma@
CONST	SEGMENT
??_C@_0BN@LBBJMBKC@filter_qpel_blocks_diag_luma@ DB 'filter_qpel_blocks_d'
	DB	'iag_luma', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HAFBJKBM@filter_qpel_blocks_hor_ver_luma@
CONST	SEGMENT
??_C@_0CA@HAFBJKBM@filter_qpel_blocks_hor_ver_luma@ DB 'filter_qpel_block'
	DB	's_hor_ver_luma', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGIFMJCD@filter_hpel_blocks_diag_luma@
CONST	SEGMENT
??_C@_0BN@LGIFMJCD@filter_hpel_blocks_diag_luma@ DB 'filter_hpel_blocks_d'
	DB	'iag_luma', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KBMGLOML@filter_hpel_blocks_hor_ver_luma@
CONST	SEGMENT
??_C@_0CA@KBMGLOML@filter_hpel_blocks_hor_ver_luma@ DB 'filter_hpel_block'
	DB	's_hor_ver_luma', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MDFNOANP@idct_32x32@
CONST	SEGMENT
??_C@_0L@MDFNOANP@idct_32x32@ DB 'idct_32x32', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BMPNPGHO@idct_16x16@
CONST	SEGMENT
??_C@_0L@BMPNPGHO@idct_16x16@ DB 'idct_16x16', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFNLGGAH@idct_8x8@
CONST	SEGMENT
??_C@_08FFNLGGAH@idct_8x8@ DB 'idct_8x8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LDLIJGLD@idct_4x4@
CONST	SEGMENT
??_C@_08LDLIJGLD@idct_4x4@ DB 'idct_4x4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LGIDMEOF@fast_inverse_dst_4x4@
CONST	SEGMENT
??_C@_0BF@LGIDMEOF@fast_inverse_dst_4x4@ DB 'fast_inverse_dst_4x4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GAMJJBPI@dct_32x32@
CONST	SEGMENT
??_C@_09GAMJJBPI@dct_32x32@ DB 'dct_32x32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LPGJIHFJ@dct_16x16@
CONST	SEGMENT
??_C@_09LPGJIHFJ@dct_16x16@ DB 'dct_16x16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CGDAJKDP@dct_8x8@
CONST	SEGMENT
??_C@_07CGDAJKDP@dct_8x8@ DB 'dct_8x8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MAFDGKIL@dct_4x4@
CONST	SEGMENT
??_C@_07MAFDGKIL@dct_4x4@ DB 'dct_4x4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BJKPGPEP@fast_forward_dst_4x4@
CONST	SEGMENT
??_C@_0BF@BJKPGPEP@fast_forward_dst_4x4@ DB 'fast_forward_dst_4x4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDPKBOJB@pixel_var@
CONST	SEGMENT
??_C@_09GDPKBOJB@pixel_var@ DB 'pixel_var', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CJIKFDIC@hor_sad@
CONST	SEGMENT
??_C@_07CJIKFDIC@hor_sad@ DB 'hor_sad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OEMLCPNF@ver_sad@
CONST	SEGMENT
??_C@_07OEMLCPNF@ver_sad@ DB 'ver_sad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IMILIHON@get_optimized_sad@
CONST	SEGMENT
??_C@_0BC@IMILIHON@get_optimized_sad@ DB 'get_optimized_sad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FIKELBGI@bipred_average@
CONST	SEGMENT
??_C@_0P@FIKELBGI@bipred_average@ DB 'bipred_average', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BPDFDAFM@pixels_calc_ssd@
CONST	SEGMENT
??_C@_0BA@BPDFDAFM@pixels_calc_ssd@ DB 'pixels_calc_ssd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EFOGIBKC@satd_any_size_quad@
CONST	SEGMENT
??_C@_0BD@EFOGIBKC@satd_any_size_quad@ DB 'satd_any_size_quad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NFKNMDHH@satd_64x64_dual@
CONST	SEGMENT
??_C@_0BA@NFKNMDHH@satd_64x64_dual@ DB 'satd_64x64_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ICNECECM@satd_32x32_dual@
CONST	SEGMENT
??_C@_0BA@ICNECECM@satd_32x32_dual@ DB 'satd_32x32_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GFDJBOPJ@satd_16x16_dual@
CONST	SEGMENT
??_C@_0BA@GFDJBOPJ@satd_16x16_dual@ DB 'satd_16x16_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NIHHCMOO@satd_8x8_dual@
CONST	SEGMENT
??_C@_0O@NIHHCMOO@satd_8x8_dual@ DB 'satd_8x8_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PJODLFIO@satd_4x4_dual@
CONST	SEGMENT
??_C@_0O@PJODLFIO@satd_4x4_dual@ DB 'satd_4x4_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BGJOPAPB@sad_64x64_dual@
CONST	SEGMENT
??_C@_0P@BGJOPAPB@sad_64x64_dual@ DB 'sad_64x64_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EBOHBHKK@sad_32x32_dual@
CONST	SEGMENT
??_C@_0P@EBOHBHKK@sad_32x32_dual@ DB 'sad_32x32_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KGAKCNHP@sad_16x16_dual@
CONST	SEGMENT
??_C@_0P@KGAKCNHP@sad_16x16_dual@ DB 'sad_16x16_dual', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAFGAMEI@sad_8x8_dual@
CONST	SEGMENT
??_C@_0N@NAFGAMEI@sad_8x8_dual@ DB 'sad_8x8_dual', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PBMCJFCI@sad_4x4_dual@
CONST	SEGMENT
??_C@_0N@PBMCJFCI@sad_4x4_dual@ DB 'sad_4x4_dual', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHJAMJMP@satd_any_size@
CONST	SEGMENT
??_C@_0O@FHJAMJMP@satd_any_size@ DB 'satd_any_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FCCLKIDJ@satd_64x64@
CONST	SEGMENT
??_C@_0L@FCCLKIDJ@satd_64x64@ DB 'satd_64x64', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNDHKJEH@satd_32x32@
CONST	SEGMENT
??_C@_0L@NNDHKJEH@satd_32x32@ DB 'satd_32x32', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CJHLPOG@satd_16x16@
CONST	SEGMENT
??_C@_0L@CJHLPOG@satd_16x16@ DB 'satd_16x16', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IFHKAAFH@satd_8x8@
CONST	SEGMENT
??_C@_08IFHKAAFH@satd_8x8@ DB 'satd_8x8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDBJPAOD@satd_4x4@
CONST	SEGMENT
??_C@_08GDBJPAOD@satd_4x4@ DB 'satd_4x4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HIOKBDLK@sad_64x64@
CONST	SEGMENT
??_C@_09HIOKBDLK@sad_64x64@ DB 'sad_64x64', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHPGBCME@sad_32x32@
CONST	SEGMENT
??_C@_09PHPGBCME@sad_32x32@ DB 'sad_32x32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CIFGAEGF@sad_16x16@
CONST	SEGMENT
??_C@_09CIFGAEGF@sad_16x16@ DB 'sad_16x16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEAHLBLP@sad_8x8@
CONST	SEGMENT
??_C@_07MEAHLBLP@sad_8x8@ DB 'sad_8x8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CCGEEBAL@sad_4x4@
CONST	SEGMENT
??_C@_07CCGEEBAL@sad_4x4@ DB 'sad_4x4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDJKLCAH@reg_sad@
CONST	SEGMENT
??_C@_07DDJKLCAH@reg_sad@ DB 'reg_sad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09INHMEIKP@array_md5@
CONST	SEGMENT
??_C@_09INHMEIKP@array_md5@ DB 'array_md5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FIMIKDEG@array_checksum@
CONST	SEGMENT
??_C@_0P@FIMIKDEG@array_checksum@ DB 'array_checksum', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
_default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
_kvz_gop_lowdelay4 DQ 03ff0000000000000r	; 1
	DB	05H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	04H
	DB	01H
	DB	05H
	DB	09H
	DB	0dH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	02H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	02H
	DB	06H
	DB	0aH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	03H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	DB	0bH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	01H
	DB	04H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	04H
	DB	08H
	DB	0cH
	ORG $+2
	ORG $+12
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
_kvz_gop_ra8 DQ	03ff0000000000000r		; 1
	DB	00H
	DB	08H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	08H
	DB	0cH
	DB	010H
	ORG $+2
	ORG $+13
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DB	03H
	DB	04H
	DB	02H
	DB	01H
	DB	01H
	DB	04H
	ORG $+15
	DB	02H
	DB	04H
	DB	08H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	02H
	DB	03H
	DB	01H
	DB	02H
	DB	02H
	DB	06H
	ORG $+14
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	01H
	DB	04H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+13
	DB	01H
	DB	01H
	ORG $+2
	ORG $+15
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	03H
	DB	04H
	DB	00H
	DB	02H
	DB	01H
	DB	05H
	ORG $+14
	DB	02H
	DB	01H
	DB	03H
	ORG $+2
	ORG $+14
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	06H
	DB	03H
	DB	01H
	DB	01H
	DB	02H
	ORG $+15
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	05H
	DB	04H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	ORG $+14
	DB	02H
	DB	01H
	DB	05H
	ORG $+2
	ORG $+14
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	07H
	DB	04H
	DB	00H
	DB	01H
	DB	01H
	ORG $+15
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+2
	ORG $+13
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
_kvz_gop_ra16 DQ 03ff0000000000000r		; 1
	DB	01H
	DB	010H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	010H
	DB	018H
	DB	020H
	ORG $+2
	ORG $+13
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DB	01H
	DB	08H
	DB	02H
	DB	01H
	DB	01H
	DB	08H
	ORG $+15
	DB	02H
	DB	08H
	DB	010H
	ORG $+2
	ORG $+14
	DQ	0c0138a0902de00d2r		; -4.8848
	DQ	03fca617c1bda511ar		; 0.2061
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	04H
	DB	03H
	DB	01H
	DB	02H
	DB	04H
	DB	0cH
	ORG $+14
	DB	02H
	DB	04H
	DB	0cH
	ORG $+2
	ORG $+14
	DQ	0c016fd8adab9f55ar		; -5.7476
	DQ	03fcd42c3c9eecbfbr		; 0.2286
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	02H
	DB	04H
	DB	01H
	DB	03H
	DB	02H
	DB	06H
	DB	0eH
	ORG $+13
	DB	02H
	DB	02H
	DB	0aH
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	01H
	DB	05H
	DB	00H
	DB	04H
	DB	01H
	DB	03H
	DB	07H
	DB	0fH
	ORG $+12
	DB	01H
	DB	01H
	ORG $+2
	ORG $+15
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	03H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	05H
	DB	0dH
	ORG $+13
	DB	02H
	DB	01H
	DB	03H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	06H
	DB	04H
	DB	01H
	DB	02H
	DB	02H
	DB	0aH
	ORG $+14
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	05H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	0bH
	ORG $+13
	DB	02H
	DB	01H
	DB	05H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	07H
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	09H
	ORG $+14
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	0cH
	DB	03H
	DB	01H
	DB	01H
	DB	04H
	ORG $+15
	DB	02H
	DB	04H
	DB	0cH
	ORG $+2
	ORG $+14
	DQ	0c016fd8adab9f55ar		; -5.7476
	DQ	03fcd42c3c9eecbfbr		; 0.2286
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	0aH
	DB	04H
	DB	01H
	DB	02H
	DB	02H
	DB	06H
	ORG $+14
	DB	02H
	DB	02H
	DB	0aH
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	09H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+13
	DB	02H
	DB	01H
	DB	09H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0bH
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	05H
	ORG $+14
	DB	03H
	DB	01H
	DB	03H
	DB	0bH
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	0eH
	DB	04H
	DB	01H
	DB	01H
	DB	02H
	ORG $+15
	DB	03H
	DB	02H
	DB	06H
	DB	0eH
	ORG $+2
	ORG $+13
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0dH
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	ORG $+14
	DB	03H
	DB	01H
	DB	05H
	DB	0dH
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0fH
	DB	05H
	DB	00H
	DB	01H
	DB	01H
	ORG $+15
	DB	04H
	DB	01H
	DB	03H
	DB	07H
	DB	0fH
	ORG $+2
	ORG $+12
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
_cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+2
_g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
	ORG $+4
_g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
_g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
_g_sig_last_scan_cg DD FLAT:_g_sig_last_scan_8x8
	DD	FLAT:_g_sig_last_scan_8x8+16
	DD	FLAT:_g_sig_last_scan_8x8+32
	DD	FLAT:_g_sig_last_scan_8x8
	DD	FLAT:_g_sig_last_scan_8x8+16
	DD	FLAT:_g_sig_last_scan_8x8+32
	DD	FLAT:_g_sig_last_scan_16x16
	DD	00H
	DD	00H
	DD	FLAT:_g_sig_last_scan_32x32
	DD	00H
	DD	00H
_g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
_g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
_g_sao_edge_offsets DD 0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
_strategies_to_select DD FLAT:??_C@_0P@FIMIKDEG@array_checksum@
	DD	FLAT:_kvz_array_checksum
	DD	FLAT:??_C@_09INHMEIKP@array_md5@
	DD	FLAT:_kvz_array_md5
	DD	FLAT:??_C@_07DDJKLCAH@reg_sad@
	DD	FLAT:_kvz_reg_sad
	DD	FLAT:??_C@_07CCGEEBAL@sad_4x4@
	DD	FLAT:_kvz_sad_4x4
	DD	FLAT:??_C@_07MEAHLBLP@sad_8x8@
	DD	FLAT:_kvz_sad_8x8
	DD	FLAT:??_C@_09CIFGAEGF@sad_16x16@
	DD	FLAT:_kvz_sad_16x16
	DD	FLAT:??_C@_09PHPGBCME@sad_32x32@
	DD	FLAT:_kvz_sad_32x32
	DD	FLAT:??_C@_09HIOKBDLK@sad_64x64@
	DD	FLAT:_kvz_sad_64x64
	DD	FLAT:??_C@_08GDBJPAOD@satd_4x4@
	DD	FLAT:_kvz_satd_4x4
	DD	FLAT:??_C@_08IFHKAAFH@satd_8x8@
	DD	FLAT:_kvz_satd_8x8
	DD	FLAT:??_C@_0L@CJHLPOG@satd_16x16@
	DD	FLAT:_kvz_satd_16x16
	DD	FLAT:??_C@_0L@NNDHKJEH@satd_32x32@
	DD	FLAT:_kvz_satd_32x32
	DD	FLAT:??_C@_0L@FCCLKIDJ@satd_64x64@
	DD	FLAT:_kvz_satd_64x64
	DD	FLAT:??_C@_0O@FHJAMJMP@satd_any_size@
	DD	FLAT:_kvz_satd_any_size
	DD	FLAT:??_C@_0N@PBMCJFCI@sad_4x4_dual@
	DD	FLAT:_kvz_sad_4x4_dual
	DD	FLAT:??_C@_0N@NAFGAMEI@sad_8x8_dual@
	DD	FLAT:_kvz_sad_8x8_dual
	DD	FLAT:??_C@_0P@KGAKCNHP@sad_16x16_dual@
	DD	FLAT:_kvz_sad_16x16_dual
	DD	FLAT:??_C@_0P@EBOHBHKK@sad_32x32_dual@
	DD	FLAT:_kvz_sad_32x32_dual
	DD	FLAT:??_C@_0P@BGJOPAPB@sad_64x64_dual@
	DD	FLAT:_kvz_sad_64x64_dual
	DD	FLAT:??_C@_0O@PJODLFIO@satd_4x4_dual@
	DD	FLAT:_kvz_satd_4x4_dual
	DD	FLAT:??_C@_0O@NIHHCMOO@satd_8x8_dual@
	DD	FLAT:_kvz_satd_8x8_dual
	DD	FLAT:??_C@_0BA@GFDJBOPJ@satd_16x16_dual@
	DD	FLAT:_kvz_satd_16x16_dual
	DD	FLAT:??_C@_0BA@ICNECECM@satd_32x32_dual@
	DD	FLAT:_kvz_satd_32x32_dual
	DD	FLAT:??_C@_0BA@NFKNMDHH@satd_64x64_dual@
	DD	FLAT:_kvz_satd_64x64_dual
	DD	FLAT:??_C@_0BD@EFOGIBKC@satd_any_size_quad@
	DD	FLAT:_kvz_satd_any_size_quad
	DD	FLAT:??_C@_0BA@BPDFDAFM@pixels_calc_ssd@
	DD	FLAT:_kvz_pixels_calc_ssd
	DD	FLAT:??_C@_0P@FIKELBGI@bipred_average@
	DD	FLAT:_kvz_bipred_average
	DD	FLAT:??_C@_0BC@IMILIHON@get_optimized_sad@
	DD	FLAT:_kvz_get_optimized_sad
	DD	FLAT:??_C@_07OEMLCPNF@ver_sad@
	DD	FLAT:_kvz_ver_sad
	DD	FLAT:??_C@_07CJIKFDIC@hor_sad@
	DD	FLAT:_kvz_hor_sad
	DD	FLAT:??_C@_09GDPKBOJB@pixel_var@
	DD	FLAT:_kvz_pixel_var
	DD	FLAT:??_C@_0BF@BJKPGPEP@fast_forward_dst_4x4@
	DD	FLAT:_kvz_fast_forward_dst_4x4
	DD	FLAT:??_C@_07MAFDGKIL@dct_4x4@
	DD	FLAT:_kvz_dct_4x4
	DD	FLAT:??_C@_07CGDAJKDP@dct_8x8@
	DD	FLAT:_kvz_dct_8x8
	DD	FLAT:??_C@_09LPGJIHFJ@dct_16x16@
	DD	FLAT:_kvz_dct_16x16
	DD	FLAT:??_C@_09GAMJJBPI@dct_32x32@
	DD	FLAT:_kvz_dct_32x32
	DD	FLAT:??_C@_0BF@LGIDMEOF@fast_inverse_dst_4x4@
	DD	FLAT:_kvz_fast_inverse_dst_4x4
	DD	FLAT:??_C@_08LDLIJGLD@idct_4x4@
	DD	FLAT:_kvz_idct_4x4
	DD	FLAT:??_C@_08FFNLGGAH@idct_8x8@
	DD	FLAT:_kvz_idct_8x8
	DD	FLAT:??_C@_0L@BMPNPGHO@idct_16x16@
	DD	FLAT:_kvz_idct_16x16
	DD	FLAT:??_C@_0L@MDFNOANP@idct_32x32@
	DD	FLAT:_kvz_idct_32x32
	DD	FLAT:??_C@_0CA@KBMGLOML@filter_hpel_blocks_hor_ver_luma@
	DD	FLAT:_kvz_filter_hpel_blocks_hor_ver_luma
	DD	FLAT:??_C@_0BN@LGIFMJCD@filter_hpel_blocks_diag_luma@
	DD	FLAT:_kvz_filter_hpel_blocks_diag_luma
	DD	FLAT:??_C@_0CA@HAFBJKBM@filter_qpel_blocks_hor_ver_luma@
	DD	FLAT:_kvz_filter_qpel_blocks_hor_ver_luma
	DD	FLAT:??_C@_0BN@LBBJMBKC@filter_qpel_blocks_diag_luma@
	DD	FLAT:_kvz_filter_qpel_blocks_diag_luma
	DD	FLAT:??_C@_0BH@DGLFPIPB@sample_quarterpel_luma@
	DD	FLAT:_kvz_sample_quarterpel_luma
	DD	FLAT:??_C@_0BF@HOLGGLNK@sample_octpel_chroma@
	DD	FLAT:_kvz_sample_octpel_chroma
	DD	FLAT:??_C@_0BK@LCPNGAOF@sample_quarterpel_luma_hi@
	DD	FLAT:_kvz_sample_quarterpel_luma_hi
	DD	FLAT:??_C@_0BI@EFIAEBMP@sample_octpel_chroma_hi@
	DD	FLAT:_kvz_sample_octpel_chroma_hi
	DD	FLAT:??_C@_0BD@MPANGNDO@get_extended_block@
	DD	FLAT:_kvz_get_extended_block
	DD	FLAT:??_C@_05DFPBCFDJ@quant@
	DD	FLAT:_kvz_quant
	DD	FLAT:??_C@_0BC@MPMPMGJB@quantize_residual@
	DD	FLAT:_kvz_quantize_residual
	DD	FLAT:??_C@_07GMDOJGPA@dequant@
	DD	FLAT:_kvz_dequant
	DD	FLAT:??_C@_0O@ECIHPEON@coeff_abs_sum@
	DD	FLAT:_kvz_coeff_abs_sum
	DD	FLAT:??_C@_0BA@HMNKAKOO@fast_coeff_cost@
	DD	FLAT:_kvz_fast_coeff_cost
	DD	FLAT:??_C@_0N@NMFCEONC@angular_pred@
	DD	FLAT:_kvz_angular_pred
	DD	FLAT:??_C@_0BC@KPOCLILL@intra_pred_planar@
	DD	FLAT:_kvz_intra_pred_planar
	DD	FLAT:??_C@_0BH@EAOLFJGL@intra_pred_filtered_dc@
	DD	FLAT:_kvz_intra_pred_filtered_dc
	DD	FLAT:??_C@_0BF@LGILOHOJ@sao_edge_ddistortion@
	DD	FLAT:_kvz_sao_edge_ddistortion
	DD	FLAT:??_C@_0BC@OCNKGNNI@calc_sao_edge_dir@
	DD	FLAT:_kvz_calc_sao_edge_dir
	DD	FLAT:??_C@_0BG@IJPOOFFG@sao_reconstruct_color@
	DD	FLAT:_kvz_sao_reconstruct_color
	DD	FLAT:??_C@_0BF@HDNLAKN@sao_band_ddistortion@
	DD	FLAT:_kvz_sao_band_ddistortion
	DD	FLAT:??_C@_0BB@GDIDDFDB@encode_coeff_nxn@
	DD	FLAT:_kvz_encode_coeff_nxn
	DD	00H
	DD	00H
_ERP_AQP_STRENGTH DQ 04008000000000000r		; 3
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_kvz_encoder_control_init
PUBLIC	_kvz_encoder_control_free
PUBLIC	_kvz_encoder_control_input_init
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??kvz_math_floor_log2@@9@9	; `kvz_math_floor_log2'::`1'::__LINE__Var
PUBLIC	??_C@_1GO@JKKFCEKE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ ; `string'
PUBLIC	??_C@_1BE@NLJBPLFJ@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@ ; `string'
PUBLIC	?__LINE__Var@?0??kvz_math_ceil_log2@@9@9	; `kvz_math_ceil_log2'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??kvz_encoder_control_init@@9@9	; `kvz_encoder_control_init'::`1'::__LINE__Var
PUBLIC	??_C@_0CB@KLODPDKM@Config?5object?5must?5not?5be?5null?$CB@ ; `string'
PUBLIC	??_C@_0CF@HCNHEFAB@Failed?5to?5allocate?5encoder?5cont@ ; `string'
PUBLIC	??_C@_0BN@BAGGALEA@?9?9owf?$DNauto?5value?5set?5to?5?$CFd?4?6@ ; `string'
PUBLIC	??_C@_0CB@CBHENLKG@?9?9threads?$DNauto?5value?5set?5to?5?$CFd?4@ ; `string'
PUBLIC	??_C@_0CD@COALBNAK@Could?5not?5initialize?5threadqueu@ ; `string'
PUBLIC	??_C@_04KJMIOICK@?$AA?$AB?$AC?$AD@		; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BK@HJJLDGNG@Could?5not?5open?5CQM?5file?4?6@ ; `string'
PUBLIC	??_C@_0CH@FLHFJCEP@Could?5not?5open?5fast?5coeff?5table@ ; `string'
PUBLIC	??_C@_0DB@MHJCDLCN@Failed?5to?5parse?5fast?5coeff?5tabl@ ; `string'
PUBLIC	??_C@_0EA@HAMPPOPI@No?5output?5file?5defined?5for?5Fast@ ; `string'
PUBLIC	??_C@_0BJ@KNKDCEEJ@Too?5many?5tiles?5?$CIwidth?$CJ?$CB?6@ ; `string'
PUBLIC	??_C@_0BK@DJMPICPN@Too?5many?5tiles?5?$CIheight?$CJ?$CB?6@ ; `string'
PUBLIC	??_C@_1GM@LCDACKMB@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ ; `string'
PUBLIC	??_C@_1KK@KGMAGOM@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_1KK@DCBCFFMB@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_1KK@CPCODEGA@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_1KK@BHFAGHEN@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0DE@IGDIJFAB@Unsupported?5amount?5of?5layers?5?$CI?$CF@ ; `string'
PUBLIC	??_C@_0DO@IKPPGHLL@Rate?5control?3?5Using?5experimenta@ ; `string'
PUBLIC	??_C@_0CH@LJFEBHHN@Unsupported?5number?5of?5GOP?5layer@ ; `string'
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40013086567287c5
PUBLIC	__real@4008000000000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@400d404e27d9a26e
PUBLIC	__real@4010000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@401c000000000000
PUBLIC	__real@401d762e3b99e27e
PUBLIC	__real@4020000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@4028000000000000
PUBLIC	__real@402a0314e3dae3ef
PUBLIC	__real@402c000000000000
PUBLIC	__real@402e000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@4039000000000000
PUBLIC	__real@403e000000000000
PUBLIC	__real@bf8fd2e22cdec4ed
PUBLIC	__real@bfad8abad381f0fc
PUBLIC	__real@bfb5deeea9bfa22f
PUBLIC	__real@bfd7db625709bd73
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	__imp___wassert:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_kvz_scalinglist_init:PROC
EXTRN	_kvz_scalinglist_destroy:PROC
EXTRN	_kvz_scalinglist_parse:PROC
EXTRN	_kvz_scalinglist_process:PROC
EXTRN	_kvz_threadqueue_init:PROC
EXTRN	_kvz_threadqueue_free:PROC
EXTRN	_kvz_fast_coeff_table_parse:PROC
EXTRN	_kvz_fast_coeff_use_default_table:PROC
EXTRN	_cos:PROC
EXTRN	_pow:PROC
EXTRN	__imp__log2:PROC
EXTRN	__imp__round:PROC
EXTRN	_kvz_config_process_lp_gop:PROC
EXTRN	_kvz_config_validate:PROC
EXTRN	_kvz_init_rdcost_outfiles:PROC
EXTRN	_kvz_close_rdcost_outfiles:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__allshl:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__ltod3:PROC
EXTRN	_kvz_g_hardware_flags:BYTE
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bfd7db625709bd73
CONST	SEGMENT
__real@bfd7db625709bd73 DQ 0bfd7db625709bd73r	; -0.372765
CONST	ENDS
;	COMDAT __real@bfb5deeea9bfa22f
CONST	SEGMENT
__real@bfb5deeea9bfa22f DQ 0bfb5deeea9bfa22fr	; -0.0854329
CONST	ENDS
;	COMDAT __real@bfad8abad381f0fc
CONST	SEGMENT
__real@bfad8abad381f0fc DQ 0bfad8abad381f0fcr	; -0.057699
CONST	ENDS
;	COMDAT __real@bf8fd2e22cdec4ed
CONST	SEGMENT
__real@bf8fd2e22cdec4ed DQ 0bf8fd2e22cdec4edr	; -0.0155389
CONST	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@402e000000000000
CONST	SEGMENT
__real@402e000000000000 DQ 0402e000000000000r	; 15
CONST	ENDS
;	COMDAT __real@402c000000000000
CONST	SEGMENT
__real@402c000000000000 DQ 0402c000000000000r	; 14
CONST	ENDS
;	COMDAT __real@402a0314e3dae3ef
CONST	SEGMENT
__real@402a0314e3dae3ef DQ 0402a0314e3dae3efr	; 13.006
CONST	ENDS
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@401d762e3b99e27e
CONST	SEGMENT
__real@401d762e3b99e27e DQ 0401d762e3b99e27er	; 7.36541
CONST	ENDS
;	COMDAT __real@401c000000000000
CONST	SEGMENT
__real@401c000000000000 DQ 0401c000000000000r	; 7
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@400d404e27d9a26e
CONST	SEGMENT
__real@400d404e27d9a26e DQ 0400d404e27d9a26er	; 3.6564
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@40013086567287c5
CONST	SEGMENT
__real@40013086567287c5 DQ 040013086567287c5r	; 2.14869
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CH@LJFEBHHN@Unsupported?5number?5of?5GOP?5layer@
CONST	SEGMENT
??_C@_0CH@LJFEBHHN@Unsupported?5number?5of?5GOP?5layer@ DB 'Unsupported n'
	DB	'umber of GOP layers (%d)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@IKPPGHLL@Rate?5control?3?5Using?5experimenta@
CONST	SEGMENT
??_C@_0DO@IKPPGHLL@Rate?5control?3?5Using?5experimenta@ DB 'Rate control:'
	DB	' Using experimental weights for GOP layers (%d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IGDIJFAB@Unsupported?5amount?5of?5layers?5?$CI?$CF@
CONST	SEGMENT
??_C@_0DE@IGDIJFAB@Unsupported?5amount?5of?5layers?5?$CI?$CF@ DB 'Unsuppo'
	DB	'rted amount of layers (%d) for lowdelay GOP', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KK@BHFAGHEN@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@
CONST	SEGMENT
??_C@_1KK@BHFAGHEN@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@ DB 'W'
	DB	00H, 'I', 00H, 'T', 00H, 'H', 00H, 'I', 00H, 'N', 00H, '(', 00H
	DB	' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, '-', 00H, '>', 00H, 'c', 00H, 'f', 00H, 'g', 00H
	DB	'.', 00H, 'p', 00H, 'u', 00H, '_', 00H, 'd', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'h', 00H, '_', 00H, 'i', 00H, 'n', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, '.', 00H, 'm', 00H, 'a', 00H, 'x', 00H, '['
	DB	00H, 'i', 00H, ']', 00H, ',', 00H, ' ', 00H, 'P', 00H, 'U', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'H', 00H, '_'
	DB	00H, 'I', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H, '_', 00H
	DB	'M', 00H, 'I', 00H, 'N', 00H, ',', 00H, ' ', 00H, 'P', 00H, 'U'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'H', 00H
	DB	'_', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H, '_'
	DB	00H, 'M', 00H, 'A', 00H, 'X', 00H, ' ', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KK@CPCODEGA@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@
CONST	SEGMENT
??_C@_1KK@CPCODEGA@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@ DB 'W'
	DB	00H, 'I', 00H, 'T', 00H, 'H', 00H, 'I', 00H, 'N', 00H, '(', 00H
	DB	' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, '-', 00H, '>', 00H, 'c', 00H, 'f', 00H, 'g', 00H
	DB	'.', 00H, 'p', 00H, 'u', 00H, '_', 00H, 'd', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'h', 00H, '_', 00H, 'i', 00H, 'n', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, '.', 00H, 'm', 00H, 'i', 00H, 'n', 00H, '['
	DB	00H, 'i', 00H, ']', 00H, ',', 00H, ' ', 00H, 'P', 00H, 'U', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'H', 00H, '_'
	DB	00H, 'I', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H, '_', 00H
	DB	'M', 00H, 'I', 00H, 'N', 00H, ',', 00H, ' ', 00H, 'P', 00H, 'U'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'H', 00H
	DB	'_', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H, '_'
	DB	00H, 'M', 00H, 'A', 00H, 'X', 00H, ' ', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KK@DCBCFFMB@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@
CONST	SEGMENT
??_C@_1KK@DCBCFFMB@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@ DB 'W'
	DB	00H, 'I', 00H, 'T', 00H, 'H', 00H, 'I', 00H, 'N', 00H, '(', 00H
	DB	' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, '-', 00H, '>', 00H, 'c', 00H, 'f', 00H, 'g', 00H
	DB	'.', 00H, 'p', 00H, 'u', 00H, '_', 00H, 'd', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'h', 00H, '_', 00H, 'i', 00H, 'n', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'm', 00H, 'a', 00H, 'x', 00H, '['
	DB	00H, 'i', 00H, ']', 00H, ',', 00H, ' ', 00H, 'P', 00H, 'U', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'H', 00H, '_'
	DB	00H, 'I', 00H, 'N', 00H, 'T', 00H, 'E', 00H, 'R', 00H, '_', 00H
	DB	'M', 00H, 'I', 00H, 'N', 00H, ',', 00H, ' ', 00H, 'P', 00H, 'U'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'H', 00H
	DB	'_', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 'E', 00H, 'R', 00H, '_'
	DB	00H, 'M', 00H, 'A', 00H, 'X', 00H, ' ', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KK@KGMAGOM@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@
CONST	SEGMENT
??_C@_1KK@KGMAGOM@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@ DB 'W'
	DB	00H, 'I', 00H, 'T', 00H, 'H', 00H, 'I', 00H, 'N', 00H, '(', 00H
	DB	' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, '-', 00H, '>', 00H, 'c', 00H, 'f', 00H, 'g', 00H
	DB	'.', 00H, 'p', 00H, 'u', 00H, '_', 00H, 'd', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'h', 00H, '_', 00H, 'i', 00H, 'n', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, '.', 00H, 'm', 00H, 'i', 00H, 'n', 00H, '['
	DB	00H, 'i', 00H, ']', 00H, ',', 00H, ' ', 00H, 'P', 00H, 'U', 00H
	DB	'_', 00H, 'D', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'H', 00H, '_'
	DB	00H, 'I', 00H, 'N', 00H, 'T', 00H, 'E', 00H, 'R', 00H, '_', 00H
	DB	'M', 00H, 'I', 00H, 'N', 00H, ',', 00H, ' ', 00H, 'P', 00H, 'U'
	DB	00H, '_', 00H, 'D', 00H, 'E', 00H, 'P', 00H, 'T', 00H, 'H', 00H
	DB	'_', 00H, 'I', 00H, 'N', 00H, 'T', 00H, 'E', 00H, 'R', 00H, '_'
	DB	00H, 'M', 00H, 'A', 00H, 'X', 00H, ' ', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@LCDACKMB@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
CONST	SEGMENT
??_C@_1GM@LCDACKMB@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ DB 'F'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c', 00H, '_'
	DB	00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H, '_', 00H
	DB	'2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k', 00H, 'v'
	DB	00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H, '-', 00H
	DB	'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DJMPICPN@Too?5many?5tiles?5?$CIheight?$CJ?$CB?6@
CONST	SEGMENT
??_C@_0BK@DJMPICPN@Too?5many?5tiles?5?$CIheight?$CJ?$CB?6@ DB 'Too many t'
	DB	'iles (height)!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KNKDCEEJ@Too?5many?5tiles?5?$CIwidth?$CJ?$CB?6@
CONST	SEGMENT
??_C@_0BJ@KNKDCEEJ@Too?5many?5tiles?5?$CIwidth?$CJ?$CB?6@ DB 'Too many ti'
	DB	'les (width)!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HAMPPOPI@No?5output?5file?5defined?5for?5Fast@
CONST	SEGMENT
??_C@_0EA@HAMPPOPI@No?5output?5file?5defined?5for?5Fast@ DB 'No output fi'
	DB	'le defined for Fast RD sampling or accuracy check.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MHJCDLCN@Failed?5to?5parse?5fast?5coeff?5tabl@
CONST	SEGMENT
??_C@_0DB@MHJCDLCN@Failed?5to?5parse?5fast?5coeff?5tabl@ DB 'Failed to pa'
	DB	'rse fast coeff table, using default', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FLHFJCEP@Could?5not?5open?5fast?5coeff?5table@
CONST	SEGMENT
??_C@_0CH@FLHFJCEP@Could?5not?5open?5fast?5coeff?5table@ DB 'Could not op'
	DB	'en fast coeff table file.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HJJLDGNG@Could?5not?5open?5CQM?5file?4?6@
CONST	SEGMENT
??_C@_0BK@HJJLDGNG@Could?5not?5open?5CQM?5file?4?6@ DB 'Could not open CQ'
	DB	'M file.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04KJMIOICK@?$AA?$AB?$AC?$AD@
CONST	SEGMENT
??_C@_04KJMIOICK@?$AA?$AB?$AC?$AD@ DB 00H, 01H, 02H, 03H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@COALBNAK@Could?5not?5initialize?5threadqueu@
CONST	SEGMENT
??_C@_0CD@COALBNAK@Could?5not?5initialize?5threadqueu@ DB 'Could not init'
	DB	'ialize threadqueue.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBHENLKG@?9?9threads?$DNauto?5value?5set?5to?5?$CFd?4@
CONST	SEGMENT
??_C@_0CB@CBHENLKG@?9?9threads?$DNauto?5value?5set?5to?5?$CFd?4@ DB '--th'
	DB	'reads=auto value set to %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BAGGALEA@?9?9owf?$DNauto?5value?5set?5to?5?$CFd?4?6@
CONST	SEGMENT
??_C@_0BN@BAGGALEA@?9?9owf?$DNauto?5value?5set?5to?5?$CFd?4?6@ DB '--owf='
	DB	'auto value set to %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HCNHEFAB@Failed?5to?5allocate?5encoder?5cont@
CONST	SEGMENT
??_C@_0CF@HCNHEFAB@Failed?5to?5allocate?5encoder?5cont@ DB 'Failed to all'
	DB	'ocate encoder control.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KLODPDKM@Config?5object?5must?5not?5be?5null?$CB@
CONST	SEGMENT
??_C@_0CB@KLODPDKM@Config?5object?5must?5not?5be?5null?$CB@ DB 'Config ob'
	DB	'ject must not be null!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_encoder_control_init@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_encoder_control_init@@9@9 DD 0deH	; `kvz_encoder_control_init'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_math_ceil_log2@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_math_ceil_log2@@9@9 DD 03cH	; `kvz_math_ceil_log2'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BE@NLJBPLFJ@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BE@NLJBPLFJ@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@ DB 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@JKKFCEKE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
CONST	SEGMENT
??_C@_1GO@JKKFCEKE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ DB 'F'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c', 00H, '_'
	DB	00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H, '_', 00H
	DB	'2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k', 00H, 'v'
	DB	00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H, '-', 00H
	DB	'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'k', 00H, 'v', 00H
	DB	'z', 00H, '_', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'h', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??kvz_math_floor_log2@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??kvz_math_floor_log2@@9@9 DD 02cH	; `kvz_math_floor_log2'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
;	COMDAT _init_erp_aqp_roi
_TEXT	SEGMENT
tv249 = -372						; size = 8
tv186 = -368						; size = 4
tv281 = -364						; size = 8
tv237 = -364						; size = 8
tv220 = -364						; size = 8
tv187 = -364						; size = 4
tv169 = -360						; size = 4
tv90 = -360						; size = 4
tv66 = -360						; size = 4
_x$1 = -160						; size = 4
_y_roi$2 = -148						; size = 4
_qp_delta$3 = -133					; size = 1
_y$4 = -124						; size = 4
_lcu_weight$5 = -112					; size = 8
_lcu_height$6 = -96					; size = 4
_y_orig$7 = -84						; size = 4
_y_lcu$8 = -72						; size = 4
_y$9 = -60						; size = 4
_total_weight$ = -48					; size = 8
_frame_height$ = -32					; size = 4
_width$ = -20						; size = 4
_height$ = -8						; size = 4
_encoder$ = 8						; size = 4
_orig_roi$ = 12						; size = 4
_orig_width$ = 16					; size = 4
_orig_height$ = 20					; size = 4
_init_erp_aqp_roi PROC					; COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 93					; 0000005dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __747AF517_encoder@c
	call	@__CheckForDebuggerJustMyCode@4

; 170  :   // Update ROI with WS-PSNR delta QPs.
; 171  :   int height = encoder->in.height_in_lcu;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	mov	DWORD PTR _height$[ebp], ecx

; 172  :   int width  = orig_roi ? orig_width : 1;

	cmp	DWORD PTR _orig_roi$[ebp], 0
	je	SHORT $LN17@init_erp_a
	mov	eax, DWORD PTR _orig_width$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN18@init_erp_a
$LN17@init_erp_a:
	mov	DWORD PTR tv66[ebp], 1
$LN18@init_erp_a:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR _width$[ebp], ecx

; 173  : 
; 174  :   int frame_height = encoder->in.real_height;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2500]
	mov	DWORD PTR _frame_height$[ebp], ecx

; 175  : 
; 176  :   encoder->cfg.roi.width  = width;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax+2396], ecx

; 177  :   encoder->cfg.roi.height = height;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [eax+2400], ecx

; 178  :   encoder->cfg.roi.dqps   = calloc(width * height, sizeof(orig_roi[0]));

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [ecx+2404], eax

; 179  : 
; 180  :   double total_weight = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _total_weight$[ebp], xmm0

; 181  :   for (int y = 0; y < frame_height; y++) {

	mov	DWORD PTR _y$9[ebp], 0
	jmp	SHORT $LN4@init_erp_a
$LN2@init_erp_a:
	mov	eax, DWORD PTR _y$9[ebp]
	add	eax, 1
	mov	DWORD PTR _y$9[ebp], eax
$LN4@init_erp_a:
	mov	eax, DWORD PTR _y$9[ebp]
	cmp	eax, DWORD PTR _frame_height$[ebp]
	jge	SHORT $LN3@init_erp_a

; 182  :     total_weight += ws_weight(y, frame_height);

	mov	eax, DWORD PTR _frame_height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$9[ebp]
	push	ecx
	call	_ws_weight
	add	esp, 8
	fstp	QWORD PTR tv220[ebp]
	movsd	xmm0, QWORD PTR tv220[ebp]
	addsd	xmm0, QWORD PTR _total_weight$[ebp]
	movsd	QWORD PTR _total_weight$[ebp], xmm0

; 183  :   }

	jmp	SHORT $LN2@init_erp_a
$LN3@init_erp_a:

; 184  : 
; 185  :   for (int y_lcu = 0; y_lcu < height; y_lcu++) {

	mov	DWORD PTR _y_lcu$8[ebp], 0
	jmp	SHORT $LN7@init_erp_a
$LN5@init_erp_a:
	mov	eax, DWORD PTR _y_lcu$8[ebp]
	add	eax, 1
	mov	DWORD PTR _y_lcu$8[ebp], eax
$LN7@init_erp_a:
	mov	eax, DWORD PTR _y_lcu$8[ebp]
	cmp	eax, DWORD PTR _height$[ebp]
	jge	$LN6@init_erp_a

; 186  :     int y_orig = LCU_WIDTH * y_lcu;

	mov	eax, DWORD PTR _y_lcu$8[ebp]
	shl	eax, 6
	mov	DWORD PTR _y_orig$7[ebp], eax

; 187  :     int lcu_height = MIN(LCU_WIDTH, frame_height - y_orig);

	mov	eax, DWORD PTR _frame_height$[ebp]
	sub	eax, DWORD PTR _y_orig$7[ebp]
	cmp	eax, 64					; 00000040H
	jle	SHORT $LN19@init_erp_a
	mov	DWORD PTR tv90[ebp], 64			; 00000040H
	jmp	SHORT $LN20@init_erp_a
$LN19@init_erp_a:
	mov	ecx, DWORD PTR _frame_height$[ebp]
	sub	ecx, DWORD PTR _y_orig$7[ebp]
	mov	DWORD PTR tv90[ebp], ecx
$LN20@init_erp_a:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _lcu_height$6[ebp], edx

; 188  : 
; 189  :     double lcu_weight = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _lcu_weight$5[ebp], xmm0

; 190  :     for (int y = y_orig; y < y_orig + lcu_height; y++) {

	mov	eax, DWORD PTR _y_orig$7[ebp]
	mov	DWORD PTR _y$4[ebp], eax
	jmp	SHORT $LN10@init_erp_a
$LN8@init_erp_a:
	mov	eax, DWORD PTR _y$4[ebp]
	add	eax, 1
	mov	DWORD PTR _y$4[ebp], eax
$LN10@init_erp_a:
	mov	eax, DWORD PTR _y_orig$7[ebp]
	add	eax, DWORD PTR _lcu_height$6[ebp]
	cmp	DWORD PTR _y$4[ebp], eax
	jge	SHORT $LN9@init_erp_a

; 191  :       lcu_weight += ws_weight(y, frame_height);

	mov	eax, DWORD PTR _frame_height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$4[ebp]
	push	ecx
	call	_ws_weight
	add	esp, 8
	fstp	QWORD PTR tv237[ebp]
	movsd	xmm0, QWORD PTR tv237[ebp]
	addsd	xmm0, QWORD PTR _lcu_weight$5[ebp]
	movsd	QWORD PTR _lcu_weight$5[ebp], xmm0

; 192  :     }

	jmp	SHORT $LN8@init_erp_a
$LN9@init_erp_a:

; 193  :     // Normalize.
; 194  :     lcu_weight = (lcu_weight * frame_height) / (total_weight * lcu_height);

	cvtsi2sd xmm0, DWORD PTR _frame_height$[ebp]
	mulsd	xmm0, QWORD PTR _lcu_weight$5[ebp]
	cvtsi2sd xmm1, DWORD PTR _lcu_height$6[ebp]
	mulsd	xmm1, QWORD PTR _total_weight$[ebp]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _lcu_weight$5[ebp], xmm0

; 195  : 
; 196  :     int8_t qp_delta = round(-ERP_AQP_STRENGTH * log2(lcu_weight));

	movsd	xmm0, QWORD PTR _ERP_AQP_STRENGTH
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	mov	esi, esp
	sub	esp, 8
	movsd	xmm1, QWORD PTR _lcu_weight$5[ebp]
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv281[ebp], xmm0
	call	DWORD PTR __imp__log2
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	fstp	QWORD PTR tv249[ebp]
	movsd	xmm0, QWORD PTR tv281[ebp]
	mulsd	xmm0, QWORD PTR tv249[ebp]
	mov	esi, esp
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__round
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	call	__ftol2_sse
	mov	BYTE PTR _qp_delta$3[ebp], al

; 197  : 
; 198  :     if (orig_roi) {

	cmp	DWORD PTR _orig_roi$[ebp], 0
	je	$LN14@init_erp_a

; 199  :       // If a ROI array already exists, we copy the existing values to the
; 200  :       // new array while adding qp_delta to each.
; 201  :       int y_roi = y_lcu * orig_height / height;

	mov	eax, DWORD PTR _y_lcu$8[ebp]
	imul	eax, DWORD PTR _orig_height$[ebp]
	cdq
	idiv	DWORD PTR _height$[ebp]
	mov	DWORD PTR _y_roi$2[ebp], eax

; 202  :       for (int x = 0; x < width; x++) {

	mov	DWORD PTR _x$1[ebp], 0
	jmp	SHORT $LN13@init_erp_a
$LN11@init_erp_a:
	mov	eax, DWORD PTR _x$1[ebp]
	add	eax, 1
	mov	DWORD PTR _x$1[ebp], eax
$LN13@init_erp_a:
	mov	eax, DWORD PTR _x$1[ebp]
	cmp	eax, DWORD PTR _width$[ebp]
	jge	$LN12@init_erp_a

; 203  :         encoder->cfg.roi.dqps[x + y_lcu * width] =

	mov	eax, DWORD PTR _y_roi$2[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _x$1[ebp]
	mov	ecx, DWORD PTR _orig_roi$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	movsx	eax, BYTE PTR _qp_delta$3[ebp]
	add	edx, eax
	cmp	edx, 51					; 00000033H
	jle	SHORT $LN21@init_erp_a
	mov	DWORD PTR tv169[ebp], 51		; 00000033H
	jmp	SHORT $LN22@init_erp_a
$LN21@init_erp_a:
	mov	ecx, DWORD PTR _y_roi$2[ebp]
	imul	ecx, DWORD PTR _width$[ebp]
	add	ecx, DWORD PTR _x$1[ebp]
	mov	edx, DWORD PTR _orig_roi$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _qp_delta$3[ebp]
	add	eax, ecx
	mov	DWORD PTR tv169[ebp], eax
$LN22@init_erp_a:
	cmp	DWORD PTR tv169[ebp], -51		; ffffffcdH
	jge	SHORT $LN25@init_erp_a
	mov	DWORD PTR tv187[ebp], -51		; ffffffcdH
	jmp	SHORT $LN26@init_erp_a
$LN25@init_erp_a:
	mov	edx, DWORD PTR _y_roi$2[ebp]
	imul	edx, DWORD PTR _width$[ebp]
	add	edx, DWORD PTR _x$1[ebp]
	mov	eax, DWORD PTR _orig_roi$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	movsx	edx, BYTE PTR _qp_delta$3[ebp]
	add	ecx, edx
	cmp	ecx, 51					; 00000033H
	jle	SHORT $LN23@init_erp_a
	mov	DWORD PTR tv186[ebp], 51		; 00000033H
	jmp	SHORT $LN24@init_erp_a
$LN23@init_erp_a:
	mov	eax, DWORD PTR _y_roi$2[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR _x$1[ebp]
	mov	ecx, DWORD PTR _orig_roi$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	movsx	eax, BYTE PTR _qp_delta$3[ebp]
	add	edx, eax
	mov	DWORD PTR tv186[ebp], edx
$LN24@init_erp_a:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR tv187[ebp], ecx
$LN26@init_erp_a:
	mov	edx, DWORD PTR _y_lcu$8[ebp]
	imul	edx, DWORD PTR _width$[ebp]
	add	edx, DWORD PTR _x$1[ebp]
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2404]
	mov	al, BYTE PTR tv187[ebp]
	mov	BYTE PTR [ecx+edx], al

; 204  :           CLIP(-51, 51, orig_roi[x + y_roi * width] + qp_delta);
; 205  :       }

	jmp	$LN11@init_erp_a
$LN12@init_erp_a:

; 206  : 
; 207  :     } else {

	jmp	SHORT $LN15@init_erp_a
$LN14@init_erp_a:

; 208  :       // Otherwise, simply write qp_delta to the ROI array.
; 209  :       encoder->cfg.roi.dqps[y_lcu] = qp_delta;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2404]
	mov	edx, DWORD PTR _y_lcu$8[ebp]
	mov	al, BYTE PTR _qp_delta$3[ebp]
	mov	BYTE PTR [ecx+edx], al
$LN15@init_erp_a:

; 210  :     }
; 211  :   }

	jmp	$LN5@init_erp_a
$LN6@init_erp_a:

; 212  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_init_erp_aqp_roi ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
;	COMDAT _ws_weight
_TEXT	SEGMENT
_y$ = 8							; size = 4
_h$ = 12						; size = 4
_ws_weight PROC						; COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __747AF517_encoder@c
	call	@__CheckForDebuggerJustMyCode@4

; 150  :   return cos((y - 0.5 * h + 0.5) * (M_PI / h));

	cvtsi2sd xmm0, DWORD PTR _y$[ebp]
	cvtsi2sd xmm1, DWORD PTR _h$[ebp]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	subsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsi2sd xmm1, DWORD PTR _h$[ebp]
	movsd	xmm2, QWORD PTR __real@400921fb54442d18
	divsd	xmm2, xmm1
	mulsd	xmm0, xmm2
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_cos
	add	esp, 8

; 151  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ws_weight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
;	COMDAT _get_max_parallelism
_TEXT	SEGMENT
tv168 = -340						; size = 4
tv144 = -340						; size = 4
tv79 = -340						; size = 4
_num_frames$1 = -140					; size = 4
_direction$2 = -128					; size = 4
_step$3 = -116						; size = 4
_frame_delay$4 = -104					; size = 4
_diagonal$5 = -92					; size = 4
_last_diagonal$6 = -80					; size = 4
_threads_per_frame$7 = -68				; size = 4
_parallelism$ = -56					; size = 4
_par_frames$ = -44					; size = 4
_wpp_limit$ = -32					; size = 4
_height_lcu$ = -20					; size = 4
_width_lcu$ = -8					; size = 4
_encoder$ = 8						; size = 4
_get_max_parallelism PROC				; COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __747AF517_encoder@c
	call	@__CheckForDebuggerJustMyCode@4

; 71   :   const int width_lcu  = CEILDIV(encoder->cfg.width, LCU_WIDTH);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, 63					; 0000003fH
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR _width_lcu$[ebp], eax

; 72   :   const int height_lcu = CEILDIV(encoder->cfg.height, LCU_WIDTH);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [eax+16]
	add	eax, 63					; 0000003fH
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR _height_lcu$[ebp], eax

; 73   :   const int wpp_limit  = MIN(height_lcu, CEILDIV(width_lcu, 2));

	mov	eax, DWORD PTR _width_lcu$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	DWORD PTR _height_lcu$[ebp], eax
	jge	SHORT $LN16@get_max_pa
	mov	eax, DWORD PTR _height_lcu$[ebp]
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN17@get_max_pa
$LN16@get_max_pa:
	mov	eax, DWORD PTR _width_lcu$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv79[ebp], eax
$LN17@get_max_pa:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR _wpp_limit$[ebp], ecx

; 74   :   const int par_frames = encoder->cfg.owf + 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	add	ecx, 1
	mov	DWORD PTR _par_frames$[ebp], ecx

; 75   : 
; 76   :   int parallelism = 0;

	mov	DWORD PTR _parallelism$[ebp], 0

; 77   : 
; 78   :   if (encoder->cfg.intra_period == 1) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN5@get_max_pa

; 79   :     int threads_per_frame;
; 80   :     if (encoder->cfg.wpp) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	SHORT $LN7@get_max_pa

; 81   :       // Usually limited by width because starting to code a CTU requires
; 82   :       // that the next two CTUs in the row above have been completed.
; 83   :       threads_per_frame = wpp_limit;

	mov	eax, DWORD PTR _wpp_limit$[ebp]
	mov	DWORD PTR _threads_per_frame$7[ebp], eax

; 84   :     } else {

	jmp	SHORT $LN8@get_max_pa
$LN7@get_max_pa:

; 85   :       // One thread for each tile.
; 86   :       threads_per_frame = encoder->cfg.tiles_width_count *

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR _threads_per_frame$7[ebp], edx
$LN8@get_max_pa:

; 87   :                           encoder->cfg.tiles_height_count;
; 88   :     }
; 89   :     // Divide by two since all frames cannot achieve the maximum
; 90   :     // parallelism all the time.
; 91   :     parallelism = par_frames * threads_per_frame / 2;

	mov	eax, DWORD PTR _par_frames$[ebp]
	imul	eax, DWORD PTR _threads_per_frame$7[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _parallelism$[ebp], eax

; 92   : 
; 93   :   } else {

	jmp	$LN6@get_max_pa
$LN5@get_max_pa:

; 94   :     if (encoder->cfg.wpp) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+152], 0
	je	$LN9@get_max_pa

; 95   :       const int last_diagonal = (width_lcu - 1) + (height_lcu - 1) * 2;

	mov	eax, DWORD PTR _height_lcu$[ebp]
	mov	ecx, DWORD PTR _width_lcu$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-3]
	mov	DWORD PTR _last_diagonal$6[ebp], edx

; 96   : 
; 97   :       // Index of a diagonal. The diagonal contains CTUs whose coordinates
; 98   :       // satisfy x + 2*y == diagonal. We start the sum from the longest
; 99   :       // diagonal.
; 100  :       int diagonal = CEILDIV(last_diagonal, 2);

	mov	eax, DWORD PTR _last_diagonal$6[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _diagonal$5[ebp], eax

; 101  : 
; 102  :       // Difference between diagonal indices in consecutive frames.
; 103  :       const int frame_delay = 1 + encoder->max_inter_ref_lcu.right +

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4596]
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [edx+4600]
	lea	ecx, DWORD PTR [ecx+eax*2+1]
	mov	DWORD PTR _frame_delay$4[ebp], ecx

; 104  :                               2 * encoder->max_inter_ref_lcu.down;
; 105  :       int step = frame_delay;

	mov	eax, DWORD PTR _frame_delay$4[ebp]
	mov	DWORD PTR _step$3[ebp], eax

; 106  :       int direction = -1;

	mov	DWORD PTR _direction$2[ebp], -1

; 107  : 
; 108  :       // Compute number of threads for each parallel frame.
; 109  :       for (int num_frames = 0; num_frames < par_frames; num_frames++) {

	mov	DWORD PTR _num_frames$1[ebp], 0
	jmp	SHORT $LN4@get_max_pa
$LN2@get_max_pa:
	mov	eax, DWORD PTR _num_frames$1[ebp]
	add	eax, 1
	mov	DWORD PTR _num_frames$1[ebp], eax
$LN4@get_max_pa:
	mov	eax, DWORD PTR _num_frames$1[ebp]
	cmp	eax, DWORD PTR _par_frames$[ebp]
	jge	$LN3@get_max_pa

; 110  :         if (diagonal < 0 || diagonal > last_diagonal) {

	cmp	DWORD PTR _diagonal$5[ebp], 0
	jl	SHORT $LN12@get_max_pa
	mov	eax, DWORD PTR _diagonal$5[ebp]
	cmp	eax, DWORD PTR _last_diagonal$6[ebp]
	jle	SHORT $LN11@get_max_pa
$LN12@get_max_pa:

; 111  :           // No room for more threads.
; 112  :           break;

	jmp	$LN3@get_max_pa
$LN11@get_max_pa:

; 113  :         }
; 114  : 
; 115  :         // Count number of CTUs on the diagonal.
; 116  :         if (diagonal < MIN(2 * height_lcu, width_lcu)) {

	mov	eax, DWORD PTR _height_lcu$[ebp]
	shl	eax, 1
	cmp	eax, DWORD PTR _width_lcu$[ebp]
	jge	SHORT $LN18@get_max_pa
	mov	ecx, DWORD PTR _height_lcu$[ebp]
	shl	ecx, 1
	mov	DWORD PTR tv144[ebp], ecx
	jmp	SHORT $LN19@get_max_pa
$LN18@get_max_pa:
	mov	edx, DWORD PTR _width_lcu$[ebp]
	mov	DWORD PTR tv144[ebp], edx
$LN19@get_max_pa:
	mov	eax, DWORD PTR _diagonal$5[ebp]
	cmp	eax, DWORD PTR tv144[ebp]
	jge	SHORT $LN13@get_max_pa

; 117  :           parallelism += 1 + diagonal / 2;

	mov	eax, DWORD PTR _diagonal$5[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _parallelism$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _parallelism$[ebp], edx

; 118  :         } else {

	jmp	SHORT $LN14@get_max_pa
$LN13@get_max_pa:

; 119  :           parallelism += MIN(

	mov	eax, DWORD PTR _width_lcu$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _height_lcu$[ebp]
	lea	ecx, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR _diagonal$5[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	cmp	DWORD PTR _wpp_limit$[ebp], ecx
	jge	SHORT $LN20@get_max_pa
	mov	edx, DWORD PTR _wpp_limit$[ebp]
	mov	DWORD PTR tv168[ebp], edx
	jmp	SHORT $LN21@get_max_pa
$LN20@get_max_pa:
	mov	eax, DWORD PTR _width_lcu$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _height_lcu$[ebp]
	lea	ecx, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR _diagonal$5[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR tv168[ebp], ecx
$LN21@get_max_pa:
	mov	edx, DWORD PTR _parallelism$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _parallelism$[ebp], edx
$LN14@get_max_pa:

; 120  :             wpp_limit,
; 121  :             height_lcu + CEILDIV(width_lcu, 2) - 1 - CEILDIV(diagonal, 2)
; 122  :           );
; 123  :         }
; 124  :         diagonal += direction * step;

	mov	eax, DWORD PTR _direction$2[ebp]
	imul	eax, DWORD PTR _step$3[ebp]
	add	eax, DWORD PTR _diagonal$5[ebp]
	mov	DWORD PTR _diagonal$5[ebp], eax

; 125  :         step += frame_delay;

	mov	eax, DWORD PTR _step$3[ebp]
	add	eax, DWORD PTR _frame_delay$4[ebp]
	mov	DWORD PTR _step$3[ebp], eax

; 126  :         direction = -direction;

	mov	eax, DWORD PTR _direction$2[ebp]
	neg	eax
	mov	DWORD PTR _direction$2[ebp], eax

; 127  :       }

	jmp	$LN2@get_max_pa
$LN3@get_max_pa:

; 128  : 
; 129  :     } else {

	jmp	SHORT $LN6@get_max_pa
$LN9@get_max_pa:

; 130  :       parallelism = encoder->cfg.tiles_width_count *

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR _parallelism$[ebp], edx
$LN6@get_max_pa:

; 131  :                     encoder->cfg.tiles_height_count;
; 132  :     }
; 133  :   }
; 134  : 
; 135  :   return parallelism;

	mov	eax, DWORD PTR _parallelism$[ebp]

; 136  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_get_max_parallelism ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
;	COMDAT _cfg_num_threads
_TEXT	SEGMENT
_cfg_num_threads PROC					; COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __747AF517_encoder@c
	call	@__CheckForDebuggerJustMyCode@4

; 60   :   if (kvz_g_hardware_flags.logical_cpu_count == 0) {

	cmp	DWORD PTR _kvz_g_hardware_flags+48, 0
	jne	SHORT $LN2@cfg_num_th

; 61   :     // Default to 4 if we don't know the number of CPUs.
; 62   :     return 4;

	mov	eax, 4
	jmp	SHORT $LN1@cfg_num_th
$LN2@cfg_num_th:

; 63   :   }
; 64   : 
; 65   :   return kvz_g_hardware_flags.logical_cpu_count;

	mov	eax, DWORD PTR _kvz_g_hardware_flags+48
$LN1@cfg_num_th:

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_cfg_num_threads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
;	COMDAT _encoder_control_init_gop_layer_weights
_TEXT	SEGMENT
tv488 = -300						; size = 8
tv476 = -300						; size = 8
tv464 = -300						; size = 8
tv452 = -300						; size = 8
tv286 = -296						; size = 4
tv79 = -296						; size = 4
tv78 = -296						; size = 4
_i$1 = -96						; size = 4
_i$2 = -84						; size = 4
_sum_weights$ = -72					; size = 8
_i$3 = -56						; size = 4
_i$4 = -44						; size = 4
_num_layers$ = -32					; size = 4
_gop_len$ = -17						; size = 1
_gop$ = -8						; size = 4
_encoder$ = 8						; size = 4
_encoder_control_init_gop_layer_weights PROC		; COMDAT

; 796  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __747AF517_encoder@c
	call	@__CheckForDebuggerJustMyCode@4

; 797  : 
; 798  :   kvz_gop_config const * const gop = encoder->cfg.gop;

	mov	eax, DWORD PTR _encoder$[ebp]
	add	eax, 280				; 00000118H
	mov	DWORD PTR _gop$[ebp], eax

; 799  :   const int8_t gop_len = encoder->cfg.gop_len;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	cl, BYTE PTR [eax+276]
	mov	BYTE PTR _gop_len$[ebp], cl

; 800  : 
; 801  :   int num_layers = 0;

	mov	DWORD PTR _num_layers$[ebp], 0

; 802  :   for (int i = 0; i < gop_len; ++i) {

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@encoder_co
$LN2@encoder_co:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN4@encoder_co:
	movsx	eax, BYTE PTR _gop_len$[ebp]
	cmp	DWORD PTR _i$4[ebp], eax
	jge	SHORT $LN3@encoder_co

; 803  :     num_layers = MAX(gop[i].layer, num_layers);

	mov	eax, DWORD PTR _i$4[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _gop$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+10]
	cmp	edx, DWORD PTR _num_layers$[ebp]
	jle	SHORT $LN39@encoder_co
	mov	eax, DWORD PTR _i$4[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _gop$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+10]
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN40@encoder_co
$LN39@encoder_co:
	mov	eax, DWORD PTR _num_layers$[ebp]
	mov	DWORD PTR tv78[ebp], eax
$LN40@encoder_co:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _num_layers$[ebp], ecx

; 804  :   }

	jmp	SHORT $LN2@encoder_co
$LN3@encoder_co:

; 805  : 
; 806  :   switch (num_layers) {

	mov	eax, DWORD PTR _num_layers$[ebp]
	mov	DWORD PTR tv79[ebp], eax
	cmp	DWORD PTR tv79[ebp], 5
	ja	$LN35@encoder_co
	mov	ecx, DWORD PTR tv79[ebp]
	jmp	DWORD PTR $LN43@encoder_co[ecx*4]
$LN16@encoder_co:

; 807  :     case 0:
; 808  :     case 1:
; 809  :       encoder->gop_layer_weights[0] = 1;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 810  :       break;

	jmp	$LN5@encoder_co
$LN17@encoder_co:

; 811  : 
; 812  :     // Use the first layers of the 4-layer weights.
; 813  :     case 2:
; 814  :     case 3:
; 815  : 
; 816  :     case 4:
; 817  :       if (encoder->cfg.gop_lowdelay) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+277]
	test	ecx, ecx
	je	$LN18@encoder_co

; 818  :         // These weights are based on http://doi.org/10.1109/TIP.2014.2336550
; 819  :         // They are meant for lp-g4d3r4t1 gop, but work ok for others.
; 820  :         if (encoder->target_avg_bpp <= 0.05) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3fa999999999999a
	comisd	xmm0, QWORD PTR [eax+4528]
	jb	SHORT $LN20@encoder_co

; 821  :           encoder->gop_layer_weights[0] = 14;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@402c000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 822  :           encoder->gop_layer_weights[1] = 3;

	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 823  :           encoder->gop_layer_weights[2] = 2;

	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 824  :           encoder->gop_layer_weights[3] = 1;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0
	jmp	$LN25@encoder_co
$LN20@encoder_co:

; 825  :         } else if (encoder->target_avg_bpp <= 0.1) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3fb999999999999a
	comisd	xmm0, QWORD PTR [eax+4528]
	jb	SHORT $LN22@encoder_co

; 826  :           encoder->gop_layer_weights[0] = 12;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4028000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 827  :           encoder->gop_layer_weights[1] = 3;

	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 828  :           encoder->gop_layer_weights[2] = 2;

	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 829  :           encoder->gop_layer_weights[3] = 1;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0
	jmp	$LN25@encoder_co
$LN22@encoder_co:

; 830  :         } else if (encoder->target_avg_bpp <= 0.2) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3fc999999999999a
	comisd	xmm0, QWORD PTR [eax+4528]
	jb	SHORT $LN24@encoder_co

; 831  :           encoder->gop_layer_weights[0] = 10;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 832  :           encoder->gop_layer_weights[1] = 3;

	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 833  :           encoder->gop_layer_weights[2] = 2;

	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 834  :           encoder->gop_layer_weights[3] = 1;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 835  :         } else {

	jmp	SHORT $LN25@encoder_co
$LN24@encoder_co:

; 836  :           encoder->gop_layer_weights[0] = 6;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4018000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 837  :           encoder->gop_layer_weights[1] = 3;

	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 838  :           encoder->gop_layer_weights[2] = 2;

	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 839  :           encoder->gop_layer_weights[3] = 1;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0
$LN25@encoder_co:

; 840  :         }
; 841  :       } else {

	jmp	$LN31@encoder_co
$LN18@encoder_co:

; 842  :         // These weights are from http://doi.org/10.1109/TIP.2014.2336550
; 843  :         if (encoder->target_avg_bpp <= 0.05) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3fa999999999999a
	comisd	xmm0, QWORD PTR [eax+4528]
	jb	SHORT $LN26@encoder_co

; 844  :           encoder->gop_layer_weights[0] = 30;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@403e000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 845  :           encoder->gop_layer_weights[1] = 8;

	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4020000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 846  :           encoder->gop_layer_weights[2] = 4;

	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4010000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 847  :           encoder->gop_layer_weights[3] = 1;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0
	jmp	$LN31@encoder_co
$LN26@encoder_co:

; 848  :         } else if (encoder->target_avg_bpp <= 0.1) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3fb999999999999a
	comisd	xmm0, QWORD PTR [eax+4528]
	jb	SHORT $LN28@encoder_co

; 849  :           encoder->gop_layer_weights[0] = 25;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4039000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 850  :           encoder->gop_layer_weights[1] = 7;

	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@401c000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 851  :           encoder->gop_layer_weights[2] = 4;

	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4010000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 852  :           encoder->gop_layer_weights[3] = 1;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0
	jmp	$LN31@encoder_co
$LN28@encoder_co:

; 853  :         } else if (encoder->target_avg_bpp <= 0.2) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3fc999999999999a
	comisd	xmm0, QWORD PTR [eax+4528]
	jb	SHORT $LN30@encoder_co

; 854  :           encoder->gop_layer_weights[0] = 20;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4034000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 855  :           encoder->gop_layer_weights[1] = 6;

	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4018000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 856  :           encoder->gop_layer_weights[2] = 4;

	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4010000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 857  :           encoder->gop_layer_weights[3] = 1;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 858  :         } else {

	jmp	SHORT $LN31@encoder_co
$LN30@encoder_co:

; 859  :           encoder->gop_layer_weights[0] = 15;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@402e000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 860  :           encoder->gop_layer_weights[1] = 5;

	mov	eax, 8
	shl	eax, 0
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4014000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 861  :           encoder->gop_layer_weights[2] = 4;

	mov	eax, 8
	shl	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@4010000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 862  :           encoder->gop_layer_weights[3] = 1;

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [edx+ecx+4536], xmm0
$LN31@encoder_co:

; 863  :         }
; 864  :       }
; 865  :       break;

	jmp	$LN5@encoder_co
$LN32@encoder_co:

; 866  :     case 5:
; 867  :       if(!encoder->cfg.gop_lowdelay) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+277]
	test	ecx, ecx
	jne	$LN33@encoder_co

; 868  :         // These are obtained by running HM with RA GOP 16 collecting the ratio of bits spent for each
; 869  :         // layer from the CTC sequences and then fitting power curve
; 870  :         encoder->gop_layer_weights[0] = 13.0060187535 * pow(encoder->target_avg_bpp, -0.3727651453);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@bfd7db625709bd73
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _encoder$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+4528]
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv452[ebp]
	movsd	xmm0, QWORD PTR tv452[ebp]
	mulsd	xmm0, QWORD PTR __real@402a0314e3dae3ef
	mov	ecx, 8
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [eax+edx+4536], xmm0

; 871  :         encoder->gop_layer_weights[1] = 7.3654107392 * pow(encoder->target_avg_bpp, -0.0854329266);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@bfb5deeea9bfa22f
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _encoder$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+4528]
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv464[ebp]
	movsd	xmm0, QWORD PTR tv464[ebp]
	mulsd	xmm0, QWORD PTR __real@401d762e3b99e27e
	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 872  :         encoder->gop_layer_weights[2] = 3.6563990701 * pow(encoder->target_avg_bpp, -0.0576990493);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@bfad8abad381f0fc
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _encoder$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+4528]
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv476[ebp]
	movsd	xmm0, QWORD PTR tv476[ebp]
	mulsd	xmm0, QWORD PTR __real@400d404e27d9a26e
	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [edx+ecx+4536], xmm0

; 873  :         encoder->gop_layer_weights[3] = 2.1486937288 * pow(encoder->target_avg_bpp, -0.0155389471);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@bf8fd2e22cdec4ed
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _encoder$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+4528]
	movsd	QWORD PTR [esp], xmm0
	call	_pow
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv488[ebp]
	movsd	xmm0, QWORD PTR tv488[ebp]
	mulsd	xmm0, QWORD PTR __real@40013086567287c5
	mov	ecx, 8
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [eax+edx+4536], xmm0

; 874  :         encoder->gop_layer_weights[4] = 1;        

	mov	eax, 8
	shl	eax, 2
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [ecx+eax+4536], xmm0

; 875  :       } 

	jmp	SHORT $LN34@encoder_co
$LN33@encoder_co:

; 876  :       else {
; 877  :         fprintf(stderr, "Unsupported amount of layers (%d) for lowdelay GOP\n", num_layers);

	mov	eax, DWORD PTR _num_layers$[ebp]
	push	eax
	push	OFFSET ??_C@_0DE@IGDIJFAB@Unsupported?5amount?5of?5layers?5?$CI?$CF@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 878  :         return 0;

	xor	eax, eax
	jmp	$LN1@encoder_co
$LN34@encoder_co:

; 879  :       }
; 880  :       break;

	jmp	$LN5@encoder_co
$LN35@encoder_co:

; 881  :     default:
; 882  :       if (!encoder->cfg.gop_lowdelay && encoder->cfg.gop_len == 16) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+277]
	test	ecx, ecx
	jne	$LN36@encoder_co
	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	cmp	ecx, 16					; 00000010H
	jne	SHORT $LN36@encoder_co

; 883  :         fprintf(stdout, 

	mov	eax, DWORD PTR _num_layers$[ebp]
	push	eax
	push	OFFSET ??_C@_0DO@IKPPGHLL@Rate?5control?3?5Using?5experimenta@
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 884  :                 "Rate control: Using experimental weights for GOP layers (%d)\n",
; 885  :                 num_layers);
; 886  :         for (int i = 0; i < MAX_GOP_LAYERS; ++i) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN9@encoder_co
$LN7@encoder_co:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN9@encoder_co:
	cmp	DWORD PTR _i$3[ebp], 6
	jge	SHORT $LN8@encoder_co

; 887  :           encoder->gop_layer_weights[i] = (i == 0) ? 10 : 2;

	cmp	DWORD PTR _i$3[ebp], 0
	jne	SHORT $LN41@encoder_co
	mov	DWORD PTR tv286[ebp], 10		; 0000000aH
	jmp	SHORT $LN42@encoder_co
$LN41@encoder_co:
	mov	DWORD PTR tv286[ebp], 2
$LN42@encoder_co:
	cvtsi2sd xmm0, DWORD PTR tv286[ebp]
	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [ecx+eax*8+4536], xmm0

; 888  :         }

	jmp	SHORT $LN7@encoder_co
$LN8@encoder_co:

; 889  :       } else {

	jmp	SHORT $LN37@encoder_co
$LN36@encoder_co:

; 890  :         fprintf(stderr, "Unsupported number of GOP layers (%d)\n", num_layers);

	mov	eax, DWORD PTR _num_layers$[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@LJFEBHHN@Unsupported?5number?5of?5GOP?5layer@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 891  :         return 0;

	xor	eax, eax
	jmp	$LN1@encoder_co
$LN37@encoder_co:
$LN5@encoder_co:

; 892  :       }
; 893  :   }
; 894  : 
; 895  :   // Normalize weights so that the sum of weights in a GOP is one.
; 896  :   double sum_weights = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _sum_weights$[ebp], xmm0

; 897  :   for (int i = 0; i < gop_len; ++i) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN12@encoder_co
$LN10@encoder_co:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN12@encoder_co:
	movsx	eax, BYTE PTR _gop_len$[ebp]
	cmp	DWORD PTR _i$2[ebp], eax
	jge	SHORT $LN11@encoder_co

; 898  :     sum_weights += encoder->gop_layer_weights[gop[i].layer - 1];

	mov	eax, DWORD PTR _i$2[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _gop$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+10]
	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR _sum_weights$[ebp]
	addsd	xmm0, QWORD PTR [eax+edx*8+4528]
	movsd	QWORD PTR _sum_weights$[ebp], xmm0

; 899  :   }

	jmp	SHORT $LN10@encoder_co
$LN11@encoder_co:

; 900  :   for (int i = 0; i < num_layers; ++i) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN15@encoder_co
$LN13@encoder_co:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN15@encoder_co:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _num_layers$[ebp]
	jge	SHORT $LN14@encoder_co

; 901  :     encoder->gop_layer_weights[i] /= sum_weights;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax*8+4536]
	divsd	xmm0, QWORD PTR _sum_weights$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [eax+edx*8+4536], xmm0

; 902  :   }

	jmp	SHORT $LN13@encoder_co
$LN14@encoder_co:

; 903  : 
; 904  :   return 1;

	mov	eax, 1
$LN1@encoder_co:

; 905  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN43@encoder_co:
	DD	$LN16@encoder_co
	DD	$LN16@encoder_co
	DD	$LN17@encoder_co
	DD	$LN17@encoder_co
	DD	$LN17@encoder_co
	DD	$LN32@encoder_co
_encoder_control_init_gop_layer_weights ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
;	COMDAT _kvz_math_ceil_log2
_TEXT	SEGMENT
tv75 = -196						; size = 4
_value$ = 8						; size = 4
_kvz_math_ceil_log2 PROC				; COMDAT

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C4AC213E_kvz_math@h
	call	@__CheckForDebuggerJustMyCode@4

; 61   :   assert(value > 0);

	cmp	DWORD PTR _value$[ebp], 0
	ja	SHORT $LN3@kvz_math_c
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_math_ceil_log2@@9@9
	add	eax, 1
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1GO@JKKFCEKE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1BE@NLJBPLFJ@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@kvz_math_c:

; 62   : 
; 63   :   // The ceil_log2 is just floor_log2 + 1, except for exact powers of 2.
; 64   :   return kvz_math_floor_log2(value) + ((value & (value - 1)) ? 1 : 0);

	mov	eax, DWORD PTR _value$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _value$[ebp]
	je	SHORT $LN4@kvz_math_c
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN5@kvz_math_c
$LN4@kvz_math_c:
	mov	DWORD PTR tv75[ebp], 0
$LN5@kvz_math_c:
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_kvz_math_floor_log2
	add	esp, 4
	add	eax, DWORD PTR tv75[ebp]

; 65   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_math_ceil_log2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
;	COMDAT _kvz_math_floor_log2
_TEXT	SEGMENT
tv76 = -244						; size = 4
_shift$1 = -44						; size = 4
_bits$2 = -32						; size = 4
_i$3 = -20						; size = 4
_result$ = -8						; size = 4
_value$ = 8						; size = 4
_kvz_math_floor_log2 PROC				; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C4AC213E_kvz_math@h
	call	@__CheckForDebuggerJustMyCode@4

; 45   :   assert(value > 0);

	cmp	DWORD PTR _value$[ebp], 0
	ja	SHORT $LN6@kvz_math_f
	mov	eax, DWORD PTR ?__LINE__Var@?0??kvz_math_floor_log2@@9@9
	add	eax, 1
	mov	esi, esp
	push	eax
	push	OFFSET ??_C@_1GO@JKKFCEKE@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1BE@NLJBPLFJ@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@kvz_math_f:

; 46   : 
; 47   :   unsigned result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 48   : 
; 49   :   for (int i = 4; i >= 0; --i) {

	mov	DWORD PTR _i$3[ebp], 4
	jmp	SHORT $LN4@kvz_math_f
$LN2@kvz_math_f:
	mov	eax, DWORD PTR _i$3[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@kvz_math_f:
	cmp	DWORD PTR _i$3[ebp], 0
	jl	SHORT $LN3@kvz_math_f

; 50   :     unsigned bits = 1ull << i;

	mov	eax, 1
	xor	edx, edx
	mov	ecx, DWORD PTR _i$3[ebp]
	call	__allshl
	mov	DWORD PTR _bits$2[ebp], eax

; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	mov	eax, 1
	mov	ecx, DWORD PTR _bits$2[ebp]
	shl	eax, cl
	cmp	DWORD PTR _value$[ebp], eax
	jb	SHORT $LN7@kvz_math_f
	mov	ecx, DWORD PTR _bits$2[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	jmp	SHORT $LN8@kvz_math_f
$LN7@kvz_math_f:
	mov	DWORD PTR tv76[ebp], 0
$LN8@kvz_math_f:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _shift$1[ebp], edx

; 52   :     result += shift;

	mov	eax, DWORD PTR _result$[ebp]
	add	eax, DWORD PTR _shift$1[ebp]
	mov	DWORD PTR _result$[ebp], eax

; 53   :     value >>= shift;

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR _shift$1[ebp]
	shr	eax, cl
	mov	DWORD PTR _value$[ebp], eax

; 54   :   }

	jmp	SHORT $LN2@kvz_math_f
$LN3@kvz_math_f:

; 55   : 
; 56   :   return result;

	mov	eax, DWORD PTR _result$[ebp]

; 57   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_math_floor_log2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
;	COMDAT _kvz_encoder_control_input_init
_TEXT	SEGMENT
_encoder$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_kvz_encoder_control_input_init PROC			; COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __747AF517_encoder@c
	call	@__CheckForDebuggerJustMyCode@4

; 743  :   // Halve for interlaced content
; 744  :   if (encoder->in.source_scan_type != 0) height /= 2;

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+2512]
	test	ecx, ecx
	je	SHORT $LN2@kvz_encode
	mov	eax, DWORD PTR _height$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _height$[ebp], eax
$LN2@kvz_encode:

; 745  : 
; 746  :   encoder->in.width = width;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax+2480], ecx

; 747  :   encoder->in.height = height;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [eax+2484], ecx

; 748  :   encoder->in.real_width = width;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax+2496], ecx

; 749  :   encoder->in.real_height = height;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [eax+2500], ecx

; 750  : 
; 751  :   // If input dimensions are not divisible by the smallest block size, add
; 752  :   // pixels to the dimensions, so that they are. These extra pixels will be
; 753  :   // compressed along with the real ones but they will be cropped out before
; 754  :   // rendering.
; 755  :   if (encoder->in.width % CU_MIN_SIZE_PIXELS) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2480]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN8@kvz_encode
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN8@kvz_encode:
	test	ecx, ecx
	je	SHORT $LN3@kvz_encode

; 756  :     encoder->in.width += CU_MIN_SIZE_PIXELS - (width % CU_MIN_SIZE_PIXELS);

	mov	eax, DWORD PTR _width$[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN9@kvz_encode
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN9@kvz_encode:
	mov	ecx, 8
	sub	ecx, eax
	mov	edx, DWORD PTR _encoder$[ebp]
	add	ecx, DWORD PTR [edx+2480]
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+2480], ecx
$LN3@kvz_encode:

; 757  :   }
; 758  : 
; 759  :   if (encoder->in.height % CU_MIN_SIZE_PIXELS) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2484]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN10@kvz_encode
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN10@kvz_encode:
	test	ecx, ecx
	je	SHORT $LN4@kvz_encode

; 760  :     encoder->in.height += CU_MIN_SIZE_PIXELS - (height % CU_MIN_SIZE_PIXELS);

	mov	eax, DWORD PTR _height$[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN11@kvz_encode
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN11@kvz_encode:
	mov	ecx, 8
	sub	ecx, eax
	mov	edx, DWORD PTR _encoder$[ebp]
	add	ecx, DWORD PTR [edx+2484]
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+2484], ecx
$LN4@kvz_encode:

; 761  :   }
; 762  : 
; 763  :   encoder->in.height_in_lcu = encoder->in.height / LCU_WIDTH;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [eax+2484]
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [ecx+2492], eax

; 764  :   encoder->in.width_in_lcu  = encoder->in.width / LCU_WIDTH;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [eax+2480]
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [ecx+2488], eax

; 765  : 
; 766  :   // Add one extra LCU when image not divisible by LCU_WIDTH
; 767  :   if (encoder->in.height_in_lcu * LCU_WIDTH < height) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	shl	ecx, 6
	cmp	ecx, DWORD PTR _height$[ebp]
	jge	SHORT $LN5@kvz_encode

; 768  :     encoder->in.height_in_lcu++;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	add	ecx, 1
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [edx+2492], ecx
$LN5@kvz_encode:

; 769  :   }
; 770  : 
; 771  :   if (encoder->in.width_in_lcu * LCU_WIDTH < width) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	shl	ecx, 6
	cmp	ecx, DWORD PTR _width$[ebp]
	jge	SHORT $LN6@kvz_encode

; 772  :     encoder->in.width_in_lcu++;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	add	ecx, 1
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [edx+2488], ecx
$LN6@kvz_encode:

; 773  :   }
; 774  : 
; 775  :   encoder->in.pixels_per_pic = encoder->in.width * encoder->in.height;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [eax+2480]
	imul	eax, DWORD PTR [ecx+2484]
	cdq
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [ecx+2504], eax
	mov	DWORD PTR [ecx+2508], edx

; 776  : 
; 777  : 
; 778  :   #ifdef KVZ_DEBUG
; 779  :   if (width != encoder->in.width || height != encoder->in.height) {
; 780  :     printf("Picture buffer has been extended to be a multiple of the smallest block size:\r\n");
; 781  :     printf("  Width = %d (%d), Height = %d (%d)\r\n", width, encoder->in.width, height,
; 782  :            encoder->in.height);
; 783  :   }
; 784  :   #endif
; 785  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_encoder_control_input_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
;	COMDAT _kvz_encoder_control_free
_TEXT	SEGMENT
_encoder$ = 8						; size = 4
_kvz_encoder_control_free PROC				; COMDAT

; 709  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __747AF517_encoder@c
	call	@__CheckForDebuggerJustMyCode@4

; 710  :   if (!encoder) return;

	cmp	DWORD PTR _encoder$[ebp], 0
	jne	SHORT $LN2@kvz_encode
	jmp	$LN1@kvz_encode
$LN2@kvz_encode:

; 711  : 
; 712  :   //Slices
; 713  :   FREE_POINTER(encoder->slice_addresses_in_ts);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4512]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4512], 0

; 714  : 
; 715  :   //Tiles
; 716  :   FREE_POINTER(encoder->tiles_col_width);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4480]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4480], 0

; 717  :   FREE_POINTER(encoder->tiles_row_height);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4484]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4484], 0

; 718  : 
; 719  :   FREE_POINTER(encoder->tiles_col_bd);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4488]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4488], 0

; 720  :   FREE_POINTER(encoder->tiles_row_bd);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4492]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4492], 0

; 721  : 
; 722  :   FREE_POINTER(encoder->tiles_ctb_addr_rs_to_ts);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4496]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4496], 0

; 723  :   FREE_POINTER(encoder->tiles_ctb_addr_ts_to_rs);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4500]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4500], 0

; 724  : 
; 725  :   FREE_POINTER(encoder->tiles_tile_id);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4504]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4504], 0

; 726  : 
; 727  :   FREE_POINTER(encoder->cfg.roi.dqps);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2404]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+2404], 0

; 728  :   FREE_POINTER(encoder->cfg.optional_key);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2352]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+2352], 0

; 729  : 
; 730  :   kvz_scalinglist_destroy(&encoder->scaling_list);

	mov	eax, DWORD PTR _encoder$[ebp]
	add	eax, 2552				; 000009f8H
	push	eax
	call	_kvz_scalinglist_destroy
	add	esp, 4

; 731  : 
; 732  :   kvz_threadqueue_free(encoder->threadqueue);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4516]
	push	ecx
	call	_kvz_threadqueue_free
	add	esp, 4

; 733  :   encoder->threadqueue = NULL;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4516], 0

; 734  : 
; 735  :   kvz_close_rdcost_outfiles();

	call	_kvz_close_rdcost_outfiles

; 736  : 
; 737  :   free(encoder);

	mov	esi, esp
	mov	eax, DWORD PTR _encoder$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@kvz_encode:

; 738  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_encoder_control_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder.c
;	COMDAT _kvz_encoder_control_init
_TEXT	SEGMENT
tv166 = -1032						; size = 4
tv417 = -1028						; size = 4
tv271 = -1028						; size = 4
tv265 = -1028						; size = 4
tv227 = -1028						; size = 4
tv193 = -1028						; size = 4
tv186 = -1028						; size = 4
tv165 = -1028						; size = 4
_i$1 = -636						; size = 4
_i$2 = -624						; size = 4
_i$3 = -612						; size = 4
_slice_addresses_in_ts$4 = -600				; size = 4
_ts$5 = -588						; size = 4
_rs$6 = -576						; size = 4
_y$7 = -564						; size = 4
_x$8 = -552						; size = 4
_tile_col$9 = -540					; size = 4
_tile_row$10 = -528					; size = 4
_slice_id$11 = -516					; size = 4
_slice_addresses_in_ts$12 = -504			; size = 4
_x$13 = -492						; size = 4
_y$14 = -480						; size = 4
_i$15 = -468						; size = 4
_j$16 = -456						; size = 4
_tileIdx$17 = -444					; size = 4
_j$18 = -432						; size = 4
_i$19 = -420						; size = 4
_i$20 = -408						; size = 4
_i$21 = -396						; size = 4
_i$22 = -384						; size = 4
_tbY$23 = -372						; size = 4
_tbX$24 = -360						; size = 4
_tileY$25 = -348					; size = 4
_tileX$26 = -336					; size = 4
_j$27 = -324						; size = 4
_i$28 = -312						; size = 4
_i$29 = -300						; size = 4
_row_height_in_lcu$30 = -288				; size = 4
_i$31 = -276						; size = 4
_last_pos_in_px$32 = -264				; size = 4
_i$33 = -252						; size = 4
_column_width_in_lcu$34 = -240				; size = 4
_i$35 = -228						; size = 4
_last_pos_in_px$36 = -216				; size = 4
_i$37 = -204						; size = 4
_tiles_row_bd$38 = -192					; size = 4
_tiles_col_bd$39 = -180					; size = 4
_tiles_tile_id$40 = -168				; size = 4
_tiles_ctb_addr_ts_to_rs$41 = -156			; size = 4
_tiles_ctb_addr_rs_to_ts$42 = -144			; size = 4
_tiles_row_height$43 = -132				; size = 4
_tiles_col_width$44 = -120				; size = 4
_num_ctbs$45 = -108					; size = 4
_roi_size$46 = -96					; size = 4
_framerate$47 = -84					; size = 8
_fast_coeff_table_f$48 = -68				; size = 4
_cqmfile$49 = -56					; size = 4
_parallelism$50 = -44					; size = 4
_best_parallelism$51 = -32				; size = 4
_max_threads$ = -20					; size = 4
_encoder$ = -8						; size = 4
_cfg$ = 8						; size = 4
_kvz_encoder_control_init PROC				; COMDAT

; 222  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1032				; 00000408H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1032]
	mov	ecx, 258				; 00000102H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __747AF517_encoder@c
	call	@__CheckForDebuggerJustMyCode@4

; 223  :   encoder_control_t *encoder = NULL;

	mov	DWORD PTR _encoder$[ebp], 0

; 224  : 
; 225  :   if (!cfg) {

	cmp	DWORD PTR _cfg$[ebp], 0
	jne	SHORT $LN68@kvz_encode

; 226  :     fprintf(stderr, "Config object must not be null!\n");

	push	OFFSET ??_C@_0CB@KLODPDKM@Config?5object?5must?5not?5be?5null?$CB@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 227  :     goto init_failed;

	jmp	$init_failed$164
$LN68@kvz_encode:

; 228  :   }
; 229  : 
; 230  :   // Make sure that the parameters make sense.
; 231  :   if (!kvz_config_validate(cfg)) {

	mov	eax, DWORD PTR _cfg$[ebp]
	push	eax
	call	_kvz_config_validate
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN69@kvz_encode

; 232  :     goto init_failed;

	jmp	$init_failed$164
$LN69@kvz_encode:

; 233  :   }
; 234  : 
; 235  :   encoder = calloc(1, sizeof(encoder_control_t));

	mov	esi, esp
	push	5008					; 00001390H
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _encoder$[ebp], eax

; 236  :   if (!encoder) {

	cmp	DWORD PTR _encoder$[ebp], 0
	jne	SHORT $LN70@kvz_encode

; 237  :     fprintf(stderr, "Failed to allocate encoder control.\n");

	push	OFFSET ??_C@_0CF@HCNHEFAB@Failed?5to?5allocate?5encoder?5cont@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 238  :     goto init_failed;

	jmp	$init_failed$164
$LN70@kvz_encode:

; 239  :   }
; 240  : 
; 241  :   // Take a copy of the config.
; 242  :   memcpy(&encoder->cfg, cfg, sizeof(encoder->cfg));

	push	2480					; 000009b0H
	mov	eax, DWORD PTR _cfg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoder$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 243  :   // Set fields that are not copied to NULL.
; 244  :   encoder->cfg.cqmfile = NULL;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+132], 0

; 245  :   encoder->cfg.tiles_width_split = NULL;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+144], 0

; 246  :   encoder->cfg.tiles_height_split = NULL;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+148], 0

; 247  :   encoder->cfg.slice_addresses_in_ts = NULL;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+164], 0

; 248  :   encoder->cfg.fast_coeff_table_fn = NULL;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+2464], 0

; 249  : 
; 250  :   if (encoder->cfg.gop_len > 0) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	test	ecx, ecx
	jle	SHORT $LN74@kvz_encode

; 251  :     if (encoder->cfg.gop_lowdelay) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+277]
	test	ecx, ecx
	je	SHORT $LN74@kvz_encode

; 252  :       if (encoder->cfg.gop_len == 4 && encoder->cfg.ref_frames == 4) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	cmp	ecx, 4
	jne	SHORT $LN73@kvz_encode
	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+128], 4
	jne	SHORT $LN73@kvz_encode

; 253  :         memcpy(encoder->cfg.gop, kvz_gop_lowdelay4, sizeof(kvz_gop_lowdelay4));

	push	256					; 00000100H
	push	OFFSET _kvz_gop_lowdelay4
	mov	eax, DWORD PTR _encoder$[ebp]
	add	eax, 280				; 00000118H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 254  :       } else {

	jmp	SHORT $LN74@kvz_encode
$LN73@kvz_encode:

; 255  :         kvz_config_process_lp_gop(&encoder->cfg);

	mov	eax, DWORD PTR _encoder$[ebp]
	push	eax
	call	_kvz_config_process_lp_gop
	add	esp, 4
$LN74@kvz_encode:

; 256  :       }
; 257  :     }
; 258  :   } 
; 259  :   
; 260  :   if( encoder->cfg.intra_qp_offset_auto ) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movzx	ecx, BYTE PTR [eax+2429]
	test	ecx, ecx
	je	$LN75@kvz_encode

; 261  :     // Limit offset to -3 since HM/VTM seems to use it even for 32 frame gop
; 262  :     encoder->cfg.intra_qp_offset = encoder->cfg.gop_len > 1 ? MAX(-(int8_t)kvz_math_ceil_log2( encoder->cfg.gop_len ) + 1, -3) : 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	cmp	ecx, 1
	jle	SHORT $LN141@kvz_encode
	mov	edx, DWORD PTR _encoder$[ebp]
	movsx	eax, BYTE PTR [edx+276]
	push	eax
	call	_kvz_math_ceil_log2
	add	esp, 4
	movsx	ecx, al
	neg	ecx
	add	ecx, 1
	cmp	ecx, -3					; fffffffdH
	jle	SHORT $LN139@kvz_encode
	mov	edx, DWORD PTR _encoder$[ebp]
	movsx	eax, BYTE PTR [edx+276]
	push	eax
	call	_kvz_math_ceil_log2
	add	esp, 4
	movsx	ecx, al
	neg	ecx
	add	ecx, 1
	mov	DWORD PTR tv165[ebp], ecx
	jmp	SHORT $LN140@kvz_encode
$LN139@kvz_encode:
	mov	DWORD PTR tv165[ebp], -3		; fffffffdH
$LN140@kvz_encode:
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR tv166[ebp], edx
	jmp	SHORT $LN142@kvz_encode
$LN141@kvz_encode:
	mov	DWORD PTR tv166[ebp], 0
$LN142@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	cl, BYTE PTR tv166[ebp]
	mov	BYTE PTR [eax+2428], cl
$LN75@kvz_encode:

; 263  :   }
; 264  : 
; 265  :   // Disable GOP and QP offset for all-intra coding
; 266  :   if (encoder->cfg.intra_period == 1) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN76@kvz_encode

; 267  :     encoder->cfg.gop_len = 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+276], 0

; 268  :     encoder->cfg.intra_qp_offset = 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+2428], 0
$LN76@kvz_encode:

; 269  :   }
; 270  : 
; 271  :   encoder->poc_lsb_bits = MAX(4, kvz_math_ceil_log2(encoder->cfg.gop_len * 2 + 1));

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	lea	edx, DWORD PTR [ecx+ecx+1]
	push	edx
	call	_kvz_math_ceil_log2
	add	esp, 4
	cmp	eax, 4
	jae	SHORT $LN143@kvz_encode
	mov	DWORD PTR tv186[ebp], 4
	jmp	SHORT $LN144@kvz_encode
$LN143@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+276]
	lea	edx, DWORD PTR [ecx+ecx+1]
	push	edx
	call	_kvz_math_ceil_log2
	add	esp, 4
	mov	DWORD PTR tv186[ebp], eax
$LN144@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR [eax+4604], ecx

; 272  : 
; 273  :   encoder->max_inter_ref_lcu.right = 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4596], 1

; 274  :   encoder->max_inter_ref_lcu.down  = 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4600], 1

; 275  : 
; 276  :   int max_threads = encoder->cfg.threads;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR _max_threads$[ebp], ecx

; 277  :   if (max_threads < 0) {

	cmp	DWORD PTR _max_threads$[ebp], 0
	jge	SHORT $LN77@kvz_encode

; 278  :     max_threads = cfg_num_threads();

	call	_cfg_num_threads
	mov	DWORD PTR _max_threads$[ebp], eax
$LN77@kvz_encode:

; 279  :   }
; 280  :   max_threads = MAX(1, max_threads);

	cmp	DWORD PTR _max_threads$[ebp], 1
	jge	SHORT $LN145@kvz_encode
	mov	DWORD PTR tv193[ebp], 1
	jmp	SHORT $LN146@kvz_encode
$LN145@kvz_encode:
	mov	eax, DWORD PTR _max_threads$[ebp]
	mov	DWORD PTR tv193[ebp], eax
$LN146@kvz_encode:
	mov	ecx, DWORD PTR tv193[ebp]
	mov	DWORD PTR _max_threads$[ebp], ecx

; 281  : 
; 282  :   // Need to set owf before initializing threadqueue.
; 283  :   if (encoder->cfg.owf < 0) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+156], 0
	jge	$LN78@kvz_encode

; 284  :     int best_parallelism = 0;

	mov	DWORD PTR _best_parallelism$51[ebp], 0

; 285  : 
; 286  :     for (encoder->cfg.owf = 0; true; encoder->cfg.owf++) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+156], 0
	jmp	SHORT $LN4@kvz_encode
$LN2@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	add	ecx, 1
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [edx+156], ecx
$LN4@kvz_encode:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@kvz_encode

; 287  :       int parallelism = get_max_parallelism(encoder);

	mov	eax, DWORD PTR _encoder$[ebp]
	push	eax
	call	_get_max_parallelism
	add	esp, 4
	mov	DWORD PTR _parallelism$50[ebp], eax

; 288  : 
; 289  :       if (parallelism <= best_parallelism) {

	mov	eax, DWORD PTR _parallelism$50[ebp]
	cmp	eax, DWORD PTR _best_parallelism$51[ebp]
	jg	SHORT $LN79@kvz_encode

; 290  :         // No improvement over previous OWF.
; 291  :         encoder->cfg.owf--;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	sub	ecx, 1
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [edx+156], ecx

; 292  :         break;

	jmp	SHORT $LN3@kvz_encode
$LN79@kvz_encode:

; 293  :       }
; 294  : 
; 295  :       best_parallelism = parallelism;

	mov	eax, DWORD PTR _parallelism$50[ebp]
	mov	DWORD PTR _best_parallelism$51[ebp], eax

; 296  :       if (parallelism >= max_threads) {

	mov	eax, DWORD PTR _parallelism$50[ebp]
	cmp	eax, DWORD PTR _max_threads$[ebp]
	jl	SHORT $LN80@kvz_encode

; 297  :         // Cannot have more parallelism than there are threads.
; 298  :         break;

	jmp	SHORT $LN3@kvz_encode
$LN80@kvz_encode:

; 299  :       }
; 300  :     }

	jmp	SHORT $LN2@kvz_encode
$LN3@kvz_encode:

; 301  : 
; 302  :     // Add two frames so that we have frames ready to be coded when one is
; 303  :     // completed.
; 304  :     encoder->cfg.owf += 2;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	add	ecx, 2
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [edx+156], ecx

; 305  : 
; 306  :     fprintf(stderr, "--owf=auto value set to %d.\n", encoder->cfg.owf);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	push	OFFSET ??_C@_0BN@BAGGALEA@?9?9owf?$DNauto?5value?5set?5to?5?$CFd?4?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN78@kvz_encode:

; 307  :   }
; 308  : 
; 309  :   if (encoder->cfg.threads < 0) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+168], 0
	jge	SHORT $LN81@kvz_encode

; 310  :     encoder->cfg.threads = MIN(max_threads, get_max_parallelism(encoder));

	mov	eax, DWORD PTR _encoder$[ebp]
	push	eax
	call	_get_max_parallelism
	add	esp, 4
	cmp	DWORD PTR _max_threads$[ebp], eax
	jge	SHORT $LN147@kvz_encode
	mov	ecx, DWORD PTR _max_threads$[ebp]
	mov	DWORD PTR tv227[ebp], ecx
	jmp	SHORT $LN148@kvz_encode
$LN147@kvz_encode:
	mov	edx, DWORD PTR _encoder$[ebp]
	push	edx
	call	_get_max_parallelism
	add	esp, 4
	mov	DWORD PTR tv227[ebp], eax
$LN148@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR tv227[ebp]
	mov	DWORD PTR [eax+168], ecx

; 311  :     fprintf(stderr, "--threads=auto value set to %d.\n", encoder->cfg.threads);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	push	ecx
	push	OFFSET ??_C@_0CB@CBHENLKG@?9?9threads?$DNauto?5value?5set?5to?5?$CFd?4@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN81@kvz_encode:

; 312  :   }
; 313  : 
; 314  :   if (encoder->cfg.source_scan_type != KVZ_INTERLACING_NONE) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+88]
	test	ecx, ecx
	je	SHORT $LN83@kvz_encode

; 315  :     // If using interlaced coding with OWF, the OWF has to be an even number
; 316  :     // to ensure that the pair of fields will be output for the same picture.
; 317  :     if (encoder->cfg.owf % 2 == 1) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN163@kvz_encode
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN163@kvz_encode:
	cmp	ecx, 1
	jne	SHORT $LN83@kvz_encode

; 318  :       encoder->cfg.owf += 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	add	ecx, 1
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [edx+156], ecx
$LN83@kvz_encode:

; 319  :     }
; 320  :   }
; 321  : 
; 322  :   encoder->threadqueue = kvz_threadqueue_init(encoder->cfg.threads);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	push	ecx
	call	_kvz_threadqueue_init
	add	esp, 4
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [edx+4516], eax

; 323  :   if (!encoder->threadqueue) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+4516], 0
	jne	SHORT $LN84@kvz_encode

; 324  :     fprintf(stderr, "Could not initialize threadqueue.\n");

	push	OFFSET ??_C@_0CD@COALBNAK@Could?5not?5initialize?5threadqueu@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 325  :     goto init_failed;

	jmp	$init_failed$164
$LN84@kvz_encode:

; 326  :   }
; 327  : 
; 328  :   encoder->bitdepth = KVZ_BIT_DEPTH;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+2532], 8

; 329  : 
; 330  :   encoder->chroma_format = KVZ_FORMAT2CSP(encoder->cfg.input_format);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2376]
	movsx	edx, BYTE PTR ??_C@_04KJMIOICK@?$AA?$AB?$AC?$AD@[ecx]
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+2536], edx

; 331  : 
; 332  :   // Interlacing
; 333  :   encoder->in.source_scan_type = (int8_t)encoder->cfg.source_scan_type;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	dl, BYTE PTR [ecx+88]
	mov	BYTE PTR [eax+2512], dl

; 334  :   encoder->vui.field_seq_flag = encoder->cfg.source_scan_type != 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+88]
	test	ecx, ecx
	je	SHORT $LN149@kvz_encode
	mov	DWORD PTR tv265[ebp], 1
	jmp	SHORT $LN150@kvz_encode
$LN149@kvz_encode:
	mov	DWORD PTR tv265[ebp], 0
$LN150@kvz_encode:
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	al, BYTE PTR tv265[ebp]
	mov	BYTE PTR [edx+2548], al

; 335  :   encoder->vui.frame_field_info_present_flag = encoder->cfg.source_scan_type != 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+88]
	test	ecx, ecx
	je	SHORT $LN151@kvz_encode
	mov	DWORD PTR tv271[ebp], 1
	jmp	SHORT $LN152@kvz_encode
$LN151@kvz_encode:
	mov	DWORD PTR tv271[ebp], 0
$LN152@kvz_encode:
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	al, BYTE PTR tv271[ebp]
	mov	BYTE PTR [edx+2549], al

; 336  : 
; 337  :   // Initialize the scaling list
; 338  :   kvz_scalinglist_init(&encoder->scaling_list);

	mov	eax, DWORD PTR _encoder$[ebp]
	add	eax, 2552				; 000009f8H
	push	eax
	call	_kvz_scalinglist_init
	add	esp, 4

; 339  : 
; 340  :   // CQM
; 341  :   if (cfg->scaling_list == KVZ_SCALING_LIST_CUSTOM && cfg->cqmfile) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2440]
	cmp	ecx, 1
	jne	$LN85@kvz_encode
	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+132], 0
	je	$LN85@kvz_encode

; 342  :     FILE* cqmfile = fopen(cfg->cqmfile, "rb");

	mov	esi, esp
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cqmfile$49[ebp], eax

; 343  :     if (cqmfile) {

	cmp	DWORD PTR _cqmfile$49[ebp], 0
	je	SHORT $LN87@kvz_encode

; 344  :       kvz_scalinglist_parse(&encoder->scaling_list, cqmfile);

	mov	eax, DWORD PTR _cqmfile$49[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoder$[ebp]
	add	ecx, 2552				; 000009f8H
	push	ecx
	call	_kvz_scalinglist_parse
	add	esp, 8

; 345  :       fclose(cqmfile);

	mov	esi, esp
	mov	eax, DWORD PTR _cqmfile$49[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 346  :     } else {

	jmp	SHORT $LN88@kvz_encode
$LN87@kvz_encode:

; 347  :       fprintf(stderr, "Could not open CQM file.\n");

	push	OFFSET ??_C@_0BK@HJJLDGNG@Could?5not?5open?5CQM?5file?4?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 348  :       goto init_failed;

	jmp	$init_failed$164
$LN88@kvz_encode:

; 349  :     }

	jmp	SHORT $LN89@kvz_encode
$LN85@kvz_encode:

; 350  :   } else if (cfg->scaling_list == KVZ_SCALING_LIST_DEFAULT) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movsx	ecx, BYTE PTR [eax+2440]
	cmp	ecx, 2
	jne	SHORT $LN89@kvz_encode

; 351  :     // Enable scaling lists if default lists are used
; 352  :     encoder->scaling_list.enable = 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+2552], 1

; 353  :     encoder->scaling_list.use_default_list = 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+2553], 1
$LN89@kvz_encode:

; 354  :   }
; 355  : 
; 356  :   if (cfg->fast_coeff_table_fn) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2464], 0
	je	$LN90@kvz_encode

; 357  :     FILE *fast_coeff_table_f = fopen(cfg->fast_coeff_table_fn, "rb");

	mov	esi, esp
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2464]
	push	ecx
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fast_coeff_table_f$48[ebp], eax

; 358  :     if (fast_coeff_table_f == NULL) {

	cmp	DWORD PTR _fast_coeff_table_f$48[ebp], 0
	jne	SHORT $LN92@kvz_encode

; 359  :       fprintf(stderr, "Could not open fast coeff table file.\n");

	push	OFFSET ??_C@_0CH@FLHFJCEP@Could?5not?5open?5fast?5coeff?5table@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 360  :       goto init_failed;

	jmp	$init_failed$164
$LN92@kvz_encode:

; 361  :     }
; 362  :     if (kvz_fast_coeff_table_parse(&encoder->fast_coeff_table, fast_coeff_table_f) != 0) {

	mov	eax, DWORD PTR _fast_coeff_table_f$48[ebp]
	push	eax
	mov	ecx, DWORD PTR _encoder$[ebp]
	add	ecx, 4608				; 00001200H
	push	ecx
	call	_kvz_fast_coeff_table_parse
	add	esp, 8
	test	eax, eax
	je	SHORT $LN93@kvz_encode

; 363  :       fprintf(stderr, "Failed to parse fast coeff table, using default\n");

	push	OFFSET ??_C@_0DB@MHJCDLCN@Failed?5to?5parse?5fast?5coeff?5tabl@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 364  :       kvz_fast_coeff_use_default_table(&encoder->fast_coeff_table);

	mov	eax, DWORD PTR _encoder$[ebp]
	add	eax, 4608				; 00001200H
	push	eax
	call	_kvz_fast_coeff_use_default_table
	add	esp, 4
$LN93@kvz_encode:

; 365  :     }
; 366  :     fclose(fast_coeff_table_f);

	mov	esi, esp
	mov	eax, DWORD PTR _fast_coeff_table_f$48[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 367  :   } else {

	jmp	SHORT $LN91@kvz_encode
$LN90@kvz_encode:

; 368  :     kvz_fast_coeff_use_default_table(&encoder->fast_coeff_table);

	mov	eax, DWORD PTR _encoder$[ebp]
	add	eax, 4608				; 00001200H
	push	eax
	call	_kvz_fast_coeff_use_default_table
	add	esp, 4
$LN91@kvz_encode:

; 369  :   }
; 370  : 
; 371  :   if (cfg->fastrd_sampling_on || cfg->fastrd_accuracy_check_on) {

	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2469]
	test	ecx, ecx
	jne	SHORT $LN95@kvz_encode
	mov	eax, DWORD PTR _cfg$[ebp]
	movzx	ecx, BYTE PTR [eax+2470]
	test	ecx, ecx
	je	SHORT $LN97@kvz_encode
$LN95@kvz_encode:

; 372  :     if (cfg->fastrd_learning_outdir_fn == NULL) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2472], 0
	jne	SHORT $LN96@kvz_encode

; 373  :       fprintf(stderr, "No output file defined for Fast RD sampling or accuracy check.\n");

	push	OFFSET ??_C@_0EA@HAMPPOPI@No?5output?5file?5defined?5for?5Fast@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 374  :       goto init_failed;

	jmp	$init_failed$164
$LN96@kvz_encode:

; 375  :     }
; 376  :     if (kvz_init_rdcost_outfiles(cfg->fastrd_learning_outdir_fn) != 0) {

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2472]
	push	ecx
	call	_kvz_init_rdcost_outfiles
	add	esp, 4
	test	eax, eax
	je	SHORT $LN97@kvz_encode

; 377  :       goto init_failed;

	jmp	$init_failed$164
$LN97@kvz_encode:

; 378  :     }
; 379  :   }
; 380  : 
; 381  :   kvz_scalinglist_process(&encoder->scaling_list, encoder->bitdepth);

	mov	eax, DWORD PTR _encoder$[ebp]
	movzx	ecx, BYTE PTR [eax+2532]
	push	ecx
	mov	edx, DWORD PTR _encoder$[ebp]
	add	edx, 2552				; 000009f8H
	push	edx
	call	_kvz_scalinglist_process
	add	esp, 8

; 382  : 
; 383  :   kvz_encoder_control_input_init(encoder, encoder->cfg.width, encoder->cfg.height);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _encoder$[ebp]
	push	ecx
	call	_kvz_encoder_control_input_init
	add	esp, 12					; 0000000cH

; 384  : 
; 385  :   if (encoder->cfg.framerate_num != 0) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN98@kvz_encode

; 386  :     double framerate = encoder->cfg.framerate_num / (double)encoder->cfg.framerate_denom;

	mov	eax, DWORD PTR _encoder$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cvtsi2sd xmm1, DWORD PTR [ecx+36]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _framerate$47[ebp], xmm0

; 387  :     encoder->target_avg_bppic = encoder->cfg.target_bitrate / framerate;

	mov	eax, DWORD PTR _encoder$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+2328]
	divsd	xmm0, QWORD PTR _framerate$47[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [ecx+4520], xmm0

; 388  :   } else {

	jmp	SHORT $LN99@kvz_encode
$LN98@kvz_encode:

; 389  :     encoder->target_avg_bppic = encoder->cfg.target_bitrate / encoder->cfg.framerate;

	mov	eax, DWORD PTR _encoder$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+2328]
	mov	ecx, DWORD PTR _encoder$[ebp]
	divsd	xmm0, QWORD PTR [ecx+24]
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [edx+4520], xmm0
$LN99@kvz_encode:

; 390  :   }
; 391  :   encoder->target_avg_bpp = encoder->target_avg_bppic / encoder->in.pixels_per_pic;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2504]
	mov	edx, DWORD PTR [eax+2508]
	call	__ltod3
	mov	ecx, DWORD PTR _encoder$[ebp]
	movsd	xmm1, QWORD PTR [ecx+4520]
	divsd	xmm1, xmm0
	mov	edx, DWORD PTR _encoder$[ebp]
	movsd	QWORD PTR [edx+4528], xmm1

; 392  : 
; 393  :   if (encoder->cfg.target_bitrate > 0 &&

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+2328], 0
	jle	SHORT $LN100@kvz_encode
	mov	eax, DWORD PTR _encoder$[ebp]
	push	eax
	call	_encoder_control_init_gop_layer_weights
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN100@kvz_encode

; 394  :       !encoder_control_init_gop_layer_weights(encoder))
; 395  :   {
; 396  :     goto init_failed;

	jmp	$init_failed$164
$LN100@kvz_encode:

; 397  :   }
; 398  : 
; 399  :   if (cfg->erp_aqp) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2412], 0
	je	SHORT $LN101@kvz_encode

; 400  :     init_erp_aqp_roi(encoder,

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2400]
	push	ecx
	mov	edx, DWORD PTR _cfg$[ebp]
	mov	eax, DWORD PTR [edx+2396]
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+2404]
	push	edx
	mov	eax, DWORD PTR _encoder$[ebp]
	push	eax
	call	_init_erp_aqp_roi
	add	esp, 16					; 00000010H
	jmp	SHORT $LN103@kvz_encode
$LN101@kvz_encode:

; 401  :                      cfg->roi.dqps,
; 402  :                      cfg->roi.width,
; 403  :                      cfg->roi.height);
; 404  : 
; 405  :   } else if (cfg->roi.dqps) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+2404], 0
	je	SHORT $LN103@kvz_encode

; 406  :     // Copy delta QP array for ROI coding.
; 407  :     const size_t roi_size = encoder->cfg.roi.width * encoder->cfg.roi.height;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [eax+2396]
	imul	edx, DWORD PTR [ecx+2400]
	mov	DWORD PTR _roi_size$46[ebp], edx

; 408  :     encoder->cfg.roi.dqps = calloc(roi_size, sizeof(cfg->roi.dqps[0]));

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _roi_size$46[ebp]
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [ecx+2404], eax

; 409  :     memcpy(encoder->cfg.roi.dqps,

	mov	eax, DWORD PTR _roi_size$46[ebp]
	push	eax
	mov	ecx, DWORD PTR _cfg$[ebp]
	mov	edx, DWORD PTR [ecx+2404]
	push	edx
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2404]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN103@kvz_encode:

; 410  :            cfg->roi.dqps,
; 411  :            roi_size * sizeof(*cfg->roi.dqps));
; 412  : 
; 413  :   }
; 414  : 
; 415  :   // NOTE: When tr_depth_inter is equal to 0, the transform is still split
; 416  :   // for SMP and AMP partition units.
; 417  :   encoder->tr_depth_inter = 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4588], 0

; 418  : 
; 419  :   if (encoder->cfg.target_bitrate > 0 || encoder->cfg.roi.dqps || encoder->cfg.set_qp_in_cu || encoder->cfg.vaq) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+2328], 0
	jg	SHORT $LN106@kvz_encode
	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+2404], 0
	jne	SHORT $LN106@kvz_encode
	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+2431]
	test	ecx, ecx
	jne	SHORT $LN106@kvz_encode
	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+2436], 0
	je	SHORT $LN104@kvz_encode
$LN106@kvz_encode:

; 420  :     encoder->max_qp_delta_depth = 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+4584], 0

; 421  :   } else {

	jmp	SHORT $LN105@kvz_encode
$LN104@kvz_encode:

; 422  :     encoder->max_qp_delta_depth = -1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+4584], -1
$LN105@kvz_encode:

; 423  :   }
; 424  : 
; 425  :   //Tiles
; 426  :   encoder->tiles_enable = encoder->cfg.tiles_width_count > 1 ||

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+136], 1
	jg	SHORT $LN153@kvz_encode
	mov	ecx, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [ecx+140], 1
	jg	SHORT $LN153@kvz_encode
	mov	DWORD PTR tv417[ebp], 0
	jmp	SHORT $LN154@kvz_encode
$LN153@kvz_encode:
	mov	DWORD PTR tv417[ebp], 1
$LN154@kvz_encode:
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	al, BYTE PTR tv417[ebp]
	mov	BYTE PTR [edx+4476], al

; 427  :                           encoder->cfg.tiles_height_count > 1;
; 428  : 
; 429  :   {
; 430  :     const int num_ctbs = encoder->in.width_in_lcu * encoder->in.height_in_lcu;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [eax+2488]
	imul	edx, DWORD PTR [ecx+2492]
	mov	DWORD PTR _num_ctbs$45[ebp], edx

; 431  : 
; 432  :     //Temporary pointers to allow encoder fields to be const
; 433  :     int32_t *tiles_col_width, *tiles_row_height, *tiles_ctb_addr_rs_to_ts, *tiles_ctb_addr_ts_to_rs, *tiles_tile_id, *tiles_col_bd, *tiles_row_bd;
; 434  : 
; 435  :     if (encoder->cfg.tiles_width_count > encoder->in.width_in_lcu) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [eax+136]
	cmp	edx, DWORD PTR [ecx+2488]
	jle	SHORT $LN107@kvz_encode

; 436  :       fprintf(stderr, "Too many tiles (width)!\n");

	push	OFFSET ??_C@_0BJ@KNKDCEEJ@Too?5many?5tiles?5?$CIwidth?$CJ?$CB?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 437  :       goto init_failed;

	jmp	$init_failed$164
	jmp	SHORT $LN109@kvz_encode
$LN107@kvz_encode:

; 438  : 
; 439  :     } else if (encoder->cfg.tiles_height_count > encoder->in.height_in_lcu) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [eax+140]
	cmp	edx, DWORD PTR [ecx+2492]
	jle	SHORT $LN109@kvz_encode

; 440  :       fprintf(stderr, "Too many tiles (height)!\n");

	push	OFFSET ??_C@_0BK@DJMPICPN@Too?5many?5tiles?5?$CIheight?$CJ?$CB?6@
	mov	esi, esp
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_fprintf
	add	esp, 8

; 441  :       goto init_failed;

	jmp	$init_failed$164
$LN109@kvz_encode:

; 442  :     }
; 443  : 
; 444  :     //Will be (perhaps) changed later
; 445  :     encoder->tiles_uniform_spacing_flag = 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+4477], 1

; 446  : 
; 447  :     encoder->tiles_col_width = tiles_col_width =

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tiles_col_width$44[ebp], eax
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _tiles_col_width$44[ebp]
	mov	DWORD PTR [edx+4480], eax

; 448  :       MALLOC(int32_t, encoder->cfg.tiles_width_count);
; 449  :     encoder->tiles_row_height = tiles_row_height =

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tiles_row_height$43[ebp], eax
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _tiles_row_height$43[ebp]
	mov	DWORD PTR [edx+4484], eax

; 450  :       MALLOC(int32_t, encoder->cfg.tiles_height_count);
; 451  : 
; 452  :     encoder->tiles_col_bd = tiles_col_bd =

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tiles_col_bd$39[ebp], eax
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _tiles_col_bd$39[ebp]
	mov	DWORD PTR [eax+4488], ecx

; 453  :       MALLOC(int32_t, encoder->cfg.tiles_width_count + 1);
; 454  :     encoder->tiles_row_bd = tiles_row_bd =

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	lea	edx, DWORD PTR [ecx*4+4]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tiles_row_bd$38[ebp], eax
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	DWORD PTR [eax+4492], ecx

; 455  :       MALLOC(int32_t, encoder->cfg.tiles_height_count + 1);
; 456  : 
; 457  :     encoder->tiles_ctb_addr_rs_to_ts = tiles_ctb_addr_rs_to_ts =

	mov	eax, DWORD PTR _num_ctbs$45[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp], eax
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	mov	DWORD PTR [ecx+4496], edx

; 458  :       MALLOC(int32_t, num_ctbs);
; 459  :     encoder->tiles_ctb_addr_ts_to_rs = tiles_ctb_addr_ts_to_rs =

	mov	eax, DWORD PTR _num_ctbs$45[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tiles_ctb_addr_ts_to_rs$41[ebp], eax
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR _tiles_ctb_addr_ts_to_rs$41[ebp]
	mov	DWORD PTR [ecx+4500], edx

; 460  :       MALLOC(int32_t, num_ctbs);
; 461  :     encoder->tiles_tile_id = tiles_tile_id =

	mov	eax, DWORD PTR _num_ctbs$45[ebp]
	shl	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _tiles_tile_id$40[ebp], eax
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR _tiles_tile_id$40[ebp]
	mov	DWORD PTR [ecx+4504], edx

; 462  :       MALLOC(int32_t, num_ctbs);
; 463  : 
; 464  :     if (!tiles_col_width ||
; 465  :         !tiles_row_height ||
; 466  :         !tiles_row_bd ||
; 467  :         !tiles_col_bd ||
; 468  :         !tiles_ctb_addr_rs_to_ts ||
; 469  :         !tiles_ctb_addr_ts_to_rs ||

	cmp	DWORD PTR _tiles_col_width$44[ebp], 0
	je	SHORT $LN111@kvz_encode
	cmp	DWORD PTR _tiles_row_height$43[ebp], 0
	je	SHORT $LN111@kvz_encode
	cmp	DWORD PTR _tiles_row_bd$38[ebp], 0
	je	SHORT $LN111@kvz_encode
	cmp	DWORD PTR _tiles_col_bd$39[ebp], 0
	je	SHORT $LN111@kvz_encode
	cmp	DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp], 0
	je	SHORT $LN111@kvz_encode
	cmp	DWORD PTR _tiles_ctb_addr_ts_to_rs$41[ebp], 0
	je	SHORT $LN111@kvz_encode
	cmp	DWORD PTR _tiles_tile_id$40[ebp], 0
	jne	SHORT $LN110@kvz_encode
$LN111@kvz_encode:

; 470  :         !tiles_tile_id) {
; 471  :       goto init_failed;

	jmp	$init_failed$164
$LN110@kvz_encode:

; 472  :     }
; 473  : 
; 474  :     //(6-3) and (6-4) in ITU-T Rec. H.265 (04/2013)
; 475  :     if (!cfg->tiles_width_split) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+144], 0
	jne	SHORT $LN112@kvz_encode

; 476  :       for (int i = 0; i < encoder->cfg.tiles_width_count; ++i) {

	mov	DWORD PTR _i$37[ebp], 0
	jmp	SHORT $LN7@kvz_encode
$LN5@kvz_encode:
	mov	eax, DWORD PTR _i$37[ebp]
	add	eax, 1
	mov	DWORD PTR _i$37[ebp], eax
$LN7@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$37[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	SHORT $LN6@kvz_encode

; 477  :         tiles_col_width[i] =

	mov	eax, DWORD PTR _i$37[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	imul	eax, DWORD PTR [ecx+2488]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cdq
	idiv	DWORD PTR [ecx+136]
	mov	ecx, eax
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _i$37[ebp]
	imul	eax, DWORD PTR [edx+2488]
	mov	esi, DWORD PTR _encoder$[ebp]
	cdq
	idiv	DWORD PTR [esi+136]
	sub	ecx, eax
	mov	eax, DWORD PTR _i$37[ebp]
	mov	edx, DWORD PTR _tiles_col_width$44[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 478  :           (i+1) * encoder->in.width_in_lcu / encoder->cfg.tiles_width_count -
; 479  :            i    * encoder->in.width_in_lcu / encoder->cfg.tiles_width_count;
; 480  :       }

	jmp	SHORT $LN5@kvz_encode
$LN6@kvz_encode:

; 481  :     } else {

	jmp	$LN113@kvz_encode
$LN112@kvz_encode:

; 482  :       int32_t last_pos_in_px = 0;

	mov	DWORD PTR _last_pos_in_px$36[ebp], 0

; 483  :       tiles_col_width[encoder->cfg.tiles_width_count - 1] = encoder->in.width_in_lcu;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _tiles_col_width$44[ebp]
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [eax+2488]
	mov	DWORD PTR [edx+ecx*4-4], eax

; 484  :       for (int i = 0; i < encoder->cfg.tiles_width_count - 1; ++i) {

	mov	DWORD PTR _i$35[ebp], 0
	jmp	SHORT $LN10@kvz_encode
$LN8@kvz_encode:
	mov	eax, DWORD PTR _i$35[ebp]
	add	eax, 1
	mov	DWORD PTR _i$35[ebp], eax
$LN10@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	sub	ecx, 1
	cmp	DWORD PTR _i$35[ebp], ecx
	jge	SHORT $LN9@kvz_encode

; 485  :         int32_t column_width_in_lcu = (cfg->tiles_width_split[i] - last_pos_in_px) / LCU_WIDTH;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _i$35[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sub	eax, DWORD PTR _last_pos_in_px$36[ebp]
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR _column_width_in_lcu$34[ebp], eax

; 486  :         last_pos_in_px = cfg->tiles_width_split[i];

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _i$35[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _last_pos_in_px$36[ebp], eax

; 487  :         tiles_col_width[i] = column_width_in_lcu;

	mov	eax, DWORD PTR _i$35[ebp]
	mov	ecx, DWORD PTR _tiles_col_width$44[ebp]
	mov	edx, DWORD PTR _column_width_in_lcu$34[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 488  :         tiles_col_width[encoder->cfg.tiles_width_count - 1] -= column_width_in_lcu;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _tiles_col_width$44[ebp]
	mov	eax, DWORD PTR [edx+ecx*4-4]
	sub	eax, DWORD PTR _column_width_in_lcu$34[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	ecx, DWORD PTR _tiles_col_width$44[ebp]
	mov	DWORD PTR [ecx+edx*4-4], eax

; 489  :       }

	jmp	$LN8@kvz_encode
$LN9@kvz_encode:

; 490  :       encoder->tiles_uniform_spacing_flag = 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+4477], 0
$LN113@kvz_encode:

; 491  :     }
; 492  : 
; 493  :     if (!cfg->tiles_height_split) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+148], 0
	jne	SHORT $LN114@kvz_encode

; 494  :       for (int i = 0; i < encoder->cfg.tiles_height_count; ++i) {

	mov	DWORD PTR _i$33[ebp], 0
	jmp	SHORT $LN13@kvz_encode
$LN11@kvz_encode:
	mov	eax, DWORD PTR _i$33[ebp]
	add	eax, 1
	mov	DWORD PTR _i$33[ebp], eax
$LN13@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$33[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN12@kvz_encode

; 495  :         tiles_row_height[i] = ((i+1) * encoder->in.height_in_lcu) / encoder->cfg.tiles_height_count -

	mov	eax, DWORD PTR _i$33[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _encoder$[ebp]
	imul	eax, DWORD PTR [ecx+2492]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cdq
	idiv	DWORD PTR [ecx+140]
	mov	ecx, eax
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _i$33[ebp]
	imul	eax, DWORD PTR [edx+2492]
	mov	esi, DWORD PTR _encoder$[ebp]
	cdq
	idiv	DWORD PTR [esi+140]
	sub	ecx, eax
	mov	eax, DWORD PTR _i$33[ebp]
	mov	edx, DWORD PTR _tiles_row_height$43[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 496  :                                    i * encoder->in.height_in_lcu / encoder->cfg.tiles_height_count;
; 497  :       }

	jmp	SHORT $LN11@kvz_encode
$LN12@kvz_encode:

; 498  :     } else {

	jmp	$LN115@kvz_encode
$LN114@kvz_encode:

; 499  :       int32_t last_pos_in_px = 0;

	mov	DWORD PTR _last_pos_in_px$32[ebp], 0

; 500  :       tiles_row_height[encoder->cfg.tiles_height_count - 1] = encoder->in.height_in_lcu;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _tiles_row_height$43[ebp]
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [eax+2492]
	mov	DWORD PTR [edx+ecx*4-4], eax

; 501  :       for (int i = 0; i < encoder->cfg.tiles_height_count - 1; ++i) {

	mov	DWORD PTR _i$31[ebp], 0
	jmp	SHORT $LN16@kvz_encode
$LN14@kvz_encode:
	mov	eax, DWORD PTR _i$31[ebp]
	add	eax, 1
	mov	DWORD PTR _i$31[ebp], eax
$LN16@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	sub	ecx, 1
	cmp	DWORD PTR _i$31[ebp], ecx
	jge	$LN15@kvz_encode

; 502  :         int32_t row_height_in_lcu = (cfg->tiles_height_split[i] - last_pos_in_px) / LCU_WIDTH;

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _i$31[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	sub	eax, DWORD PTR _last_pos_in_px$32[ebp]
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR _row_height_in_lcu$30[ebp], eax

; 503  :         last_pos_in_px = cfg->tiles_height_split[i];

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _i$31[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _last_pos_in_px$32[ebp], eax

; 504  :         tiles_row_height[i] = row_height_in_lcu;

	mov	eax, DWORD PTR _i$31[ebp]
	mov	ecx, DWORD PTR _tiles_row_height$43[ebp]
	mov	edx, DWORD PTR _row_height_in_lcu$30[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 505  :         tiles_row_height[encoder->cfg.tiles_height_count - 1] -= row_height_in_lcu;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _tiles_row_height$43[ebp]
	mov	eax, DWORD PTR [edx+ecx*4-4]
	sub	eax, DWORD PTR _row_height_in_lcu$30[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	ecx, DWORD PTR _tiles_row_height$43[ebp]
	mov	DWORD PTR [ecx+edx*4-4], eax

; 506  :       }

	jmp	$LN14@kvz_encode
$LN15@kvz_encode:

; 507  :       encoder->tiles_uniform_spacing_flag = 0;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+4477], 0
$LN115@kvz_encode:

; 508  :     }
; 509  : 
; 510  :     //(6-5) in ITU-T Rec. H.265 (04/2013)
; 511  :     tiles_col_bd[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tiles_col_bd$39[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 512  :     for (int i = 0; i < encoder->cfg.tiles_width_count; ++i) {

	mov	DWORD PTR _i$29[ebp], 0
	jmp	SHORT $LN19@kvz_encode
$LN17@kvz_encode:
	mov	eax, DWORD PTR _i$29[ebp]
	add	eax, 1
	mov	DWORD PTR _i$29[ebp], eax
$LN19@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$29[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	SHORT $LN18@kvz_encode

; 513  :       tiles_col_bd[i+1] = tiles_col_bd[i] + tiles_col_width[i];

	mov	eax, DWORD PTR _i$29[ebp]
	mov	ecx, DWORD PTR _tiles_col_bd$39[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$29[ebp]
	mov	ecx, DWORD PTR _tiles_col_width$44[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$29[ebp]
	mov	ecx, DWORD PTR _tiles_col_bd$39[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 514  :     }

	jmp	SHORT $LN17@kvz_encode
$LN18@kvz_encode:

; 515  : 
; 516  :     //(6-6) in ITU-T Rec. H.265 (04/2013)
; 517  :     tiles_row_bd[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 518  :     for (int i = 0; i < encoder->cfg.tiles_height_count; ++i) {

	mov	DWORD PTR _i$28[ebp], 0
	jmp	SHORT $LN22@kvz_encode
$LN20@kvz_encode:
	mov	eax, DWORD PTR _i$28[ebp]
	add	eax, 1
	mov	DWORD PTR _i$28[ebp], eax
$LN22@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$28[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN21@kvz_encode

; 519  :       tiles_row_bd[i+1] = tiles_row_bd[i] + tiles_row_height[i];

	mov	eax, DWORD PTR _i$28[ebp]
	mov	ecx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$28[ebp]
	mov	ecx, DWORD PTR _tiles_row_height$43[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$28[ebp]
	mov	ecx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx

; 520  :     }

	jmp	SHORT $LN20@kvz_encode
$LN21@kvz_encode:

; 521  : 
; 522  :     //(6-7) in ITU-T Rec. H.265 (04/2013)
; 523  :     //j == ctbAddrRs
; 524  :     for (int j = 0; j < num_ctbs; ++j) {

	mov	DWORD PTR _j$27[ebp], 0
	jmp	SHORT $LN25@kvz_encode
$LN23@kvz_encode:
	mov	eax, DWORD PTR _j$27[ebp]
	add	eax, 1
	mov	DWORD PTR _j$27[ebp], eax
$LN25@kvz_encode:
	mov	eax, DWORD PTR _j$27[ebp]
	cmp	eax, DWORD PTR _num_ctbs$45[ebp]
	jge	$LN24@kvz_encode

; 525  :       int tileX = 0, tileY = 0;

	mov	DWORD PTR _tileX$26[ebp], 0
	mov	DWORD PTR _tileY$25[ebp], 0

; 526  :       int tbX = j % encoder->in.width_in_lcu;

	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _j$27[ebp]
	cdq
	idiv	DWORD PTR [ecx+2488]
	mov	DWORD PTR _tbX$24[ebp], edx

; 527  :       int tbY = j / encoder->in.width_in_lcu;

	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _j$27[ebp]
	cdq
	idiv	DWORD PTR [ecx+2488]
	mov	DWORD PTR _tbY$23[ebp], eax

; 528  : 
; 529  :       for (int i = 0; i < encoder->cfg.tiles_width_count; ++i) {

	mov	DWORD PTR _i$22[ebp], 0
	jmp	SHORT $LN28@kvz_encode
$LN26@kvz_encode:
	mov	eax, DWORD PTR _i$22[ebp]
	add	eax, 1
	mov	DWORD PTR _i$22[ebp], eax
$LN28@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$22[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	SHORT $LN27@kvz_encode

; 530  :         if (tbX >= tiles_col_bd[i]) tileX = i;

	mov	eax, DWORD PTR _i$22[ebp]
	mov	ecx, DWORD PTR _tiles_col_bd$39[ebp]
	mov	edx, DWORD PTR _tbX$24[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jl	SHORT $LN116@kvz_encode
	mov	eax, DWORD PTR _i$22[ebp]
	mov	DWORD PTR _tileX$26[ebp], eax
$LN116@kvz_encode:

; 531  :       }

	jmp	SHORT $LN26@kvz_encode
$LN27@kvz_encode:

; 532  : 
; 533  :       for (int i = 0; i < encoder->cfg.tiles_height_count; ++i) {

	mov	DWORD PTR _i$21[ebp], 0
	jmp	SHORT $LN31@kvz_encode
$LN29@kvz_encode:
	mov	eax, DWORD PTR _i$21[ebp]
	add	eax, 1
	mov	DWORD PTR _i$21[ebp], eax
$LN31@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$21[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $LN30@kvz_encode

; 534  :         if (tbY >= tiles_row_bd[i]) tileY = i;

	mov	eax, DWORD PTR _i$21[ebp]
	mov	ecx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	edx, DWORD PTR _tbY$23[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jl	SHORT $LN117@kvz_encode
	mov	eax, DWORD PTR _i$21[ebp]
	mov	DWORD PTR _tileY$25[ebp], eax
$LN117@kvz_encode:

; 535  :       }

	jmp	SHORT $LN29@kvz_encode
$LN30@kvz_encode:

; 536  : 
; 537  :       tiles_ctb_addr_rs_to_ts[j] = 0;

	mov	eax, DWORD PTR _j$27[ebp]
	mov	ecx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 538  :       for (int i = 0; i < tileX; ++i) {

	mov	DWORD PTR _i$20[ebp], 0
	jmp	SHORT $LN34@kvz_encode
$LN32@kvz_encode:
	mov	eax, DWORD PTR _i$20[ebp]
	add	eax, 1
	mov	DWORD PTR _i$20[ebp], eax
$LN34@kvz_encode:
	mov	eax, DWORD PTR _i$20[ebp]
	cmp	eax, DWORD PTR _tileX$26[ebp]
	jge	SHORT $LN33@kvz_encode

; 539  :         tiles_ctb_addr_rs_to_ts[j] += tiles_row_height[tileY] * tiles_col_width[i];

	mov	eax, DWORD PTR _tileY$25[ebp]
	mov	ecx, DWORD PTR _tiles_row_height$43[ebp]
	mov	edx, DWORD PTR _i$20[ebp]
	mov	esi, DWORD PTR _tiles_col_width$44[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	imul	eax, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR _j$27[ebp]
	mov	edx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _j$27[ebp]
	mov	edx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 540  :       }

	jmp	SHORT $LN32@kvz_encode
$LN33@kvz_encode:

; 541  :       for (int i = 0; i < tileY; ++i) {

	mov	DWORD PTR _i$19[ebp], 0
	jmp	SHORT $LN37@kvz_encode
$LN35@kvz_encode:
	mov	eax, DWORD PTR _i$19[ebp]
	add	eax, 1
	mov	DWORD PTR _i$19[ebp], eax
$LN37@kvz_encode:
	mov	eax, DWORD PTR _i$19[ebp]
	cmp	eax, DWORD PTR _tileY$25[ebp]
	jge	SHORT $LN36@kvz_encode

; 542  :         tiles_ctb_addr_rs_to_ts[j] += encoder->in.width_in_lcu * tiles_row_height[i];

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$19[ebp]
	mov	edx, DWORD PTR _tiles_row_height$43[ebp]
	mov	eax, DWORD PTR [eax+2488]
	imul	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _j$27[ebp]
	mov	edx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _j$27[ebp]
	mov	edx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 543  :       }

	jmp	SHORT $LN35@kvz_encode
$LN36@kvz_encode:

; 544  :       tiles_ctb_addr_rs_to_ts[j] += (tbY - tiles_row_bd[tileY]) * tiles_col_width[tileX] +

	mov	eax, DWORD PTR _tileY$25[ebp]
	mov	ecx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	edx, DWORD PTR _tbY$23[ebp]
	sub	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _tileX$26[ebp]
	mov	ecx, DWORD PTR _tiles_col_width$44[ebp]
	imul	edx, DWORD PTR [ecx+eax*4]
	add	edx, DWORD PTR _tbX$24[ebp]
	mov	eax, DWORD PTR _tileX$26[ebp]
	mov	ecx, DWORD PTR _tiles_col_bd$39[ebp]
	sub	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _j$27[ebp]
	mov	ecx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _j$27[ebp]
	mov	ecx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 545  :                                      tbX - tiles_col_bd[tileX];
; 546  :     }

	jmp	$LN23@kvz_encode
$LN24@kvz_encode:

; 547  : 
; 548  :     //(6-8) in ITU-T Rec. H.265 (04/2013)
; 549  :     //Make reverse map from tile scan to raster scan
; 550  :     for (int j = 0; j < num_ctbs; ++j) {

	mov	DWORD PTR _j$18[ebp], 0
	jmp	SHORT $LN40@kvz_encode
$LN38@kvz_encode:
	mov	eax, DWORD PTR _j$18[ebp]
	add	eax, 1
	mov	DWORD PTR _j$18[ebp], eax
$LN40@kvz_encode:
	mov	eax, DWORD PTR _j$18[ebp]
	cmp	eax, DWORD PTR _num_ctbs$45[ebp]
	jge	SHORT $LN39@kvz_encode

; 551  :       tiles_ctb_addr_ts_to_rs[tiles_ctb_addr_rs_to_ts[j]] = j;

	mov	eax, DWORD PTR _j$18[ebp]
	mov	ecx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _tiles_ctb_addr_ts_to_rs$41[ebp]
	mov	ecx, DWORD PTR _j$18[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 552  :     }

	jmp	SHORT $LN38@kvz_encode
$LN39@kvz_encode:

; 553  : 
; 554  :     //(6-9) in ITU-T Rec. H.265 (04/2013)
; 555  :     int tileIdx = 0;

	mov	DWORD PTR _tileIdx$17[ebp], 0

; 556  :     for (int j = 0; j < encoder->cfg.tiles_height_count; ++j) {

	mov	DWORD PTR _j$16[ebp], 0
	jmp	SHORT $LN43@kvz_encode
$LN41@kvz_encode:
	mov	eax, DWORD PTR _j$16[ebp]
	add	eax, 1
	mov	DWORD PTR _j$16[ebp], eax
$LN43@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _j$16[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$LN42@kvz_encode

; 557  :       for (int i = 0; i < encoder->cfg.tiles_width_count; ++i) {

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN46@kvz_encode
$LN44@kvz_encode:
	mov	eax, DWORD PTR _i$15[ebp]
	add	eax, 1
	mov	DWORD PTR _i$15[ebp], eax
$LN46@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$15[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	$LN45@kvz_encode

; 558  :         for (int y = tiles_row_bd[j]; y < tiles_row_bd[j+1]; ++y) {

	mov	eax, DWORD PTR _j$16[ebp]
	mov	ecx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _y$14[ebp], edx
	jmp	SHORT $LN49@kvz_encode
$LN47@kvz_encode:
	mov	eax, DWORD PTR _y$14[ebp]
	add	eax, 1
	mov	DWORD PTR _y$14[ebp], eax
$LN49@kvz_encode:
	mov	eax, DWORD PTR _j$16[ebp]
	mov	ecx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	edx, DWORD PTR _y$14[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+4]
	jge	SHORT $LN48@kvz_encode

; 559  :           for (int x = tiles_col_bd[i]; x < tiles_col_bd[i+1]; ++x) {

	mov	eax, DWORD PTR _i$15[ebp]
	mov	ecx, DWORD PTR _tiles_col_bd$39[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _x$13[ebp], edx
	jmp	SHORT $LN52@kvz_encode
$LN50@kvz_encode:
	mov	eax, DWORD PTR _x$13[ebp]
	add	eax, 1
	mov	DWORD PTR _x$13[ebp], eax
$LN52@kvz_encode:
	mov	eax, DWORD PTR _i$15[ebp]
	mov	ecx, DWORD PTR _tiles_col_bd$39[ebp]
	mov	edx, DWORD PTR _x$13[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+4]
	jge	SHORT $LN51@kvz_encode

; 560  :             tiles_tile_id[tiles_ctb_addr_rs_to_ts[y * encoder->in.width_in_lcu + x]] = tileIdx;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _y$14[ebp]
	imul	ecx, DWORD PTR [eax+2488]
	add	ecx, DWORD PTR _x$13[ebp]
	mov	edx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _tiles_tile_id$40[ebp]
	mov	edx, DWORD PTR _tileIdx$17[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 561  :           }

	jmp	SHORT $LN50@kvz_encode
$LN51@kvz_encode:

; 562  :         }

	jmp	$LN47@kvz_encode
$LN48@kvz_encode:

; 563  :         ++tileIdx;

	mov	eax, DWORD PTR _tileIdx$17[ebp]
	add	eax, 1
	mov	DWORD PTR _tileIdx$17[ebp], eax

; 564  :       }

	jmp	$LN44@kvz_encode
$LN45@kvz_encode:

; 565  :     }

	jmp	$LN41@kvz_encode
$LN42@kvz_encode:

; 566  : 
; 567  :     if (encoder->cfg.slices & KVZ_SLICES_WPP) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2408]
	and	ecx, 2
	je	SHORT $LN118@kvz_encode

; 568  :       // Each WPP row will be put into a dependent slice.
; 569  :       encoder->pps.dependent_slice_segments_enabled_flag = 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+4592], 1
$LN118@kvz_encode:

; 570  :     }
; 571  : 
; 572  :     //Slices
; 573  :     if (encoder->cfg.slices & KVZ_SLICES_TILES) {

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2408]
	and	ecx, 1
	je	$LN119@kvz_encode

; 574  :       // Configure a single independent slice per tile.
; 575  : 
; 576  :       int *slice_addresses_in_ts;
; 577  :       encoder->slice_count = encoder->cfg.tiles_width_count * encoder->cfg.tiles_height_count;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [eax+136]
	imul	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4508], edx

; 578  :       encoder->slice_addresses_in_ts = slice_addresses_in_ts = MALLOC(int, encoder->slice_count);

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4508]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _slice_addresses_in_ts$12[ebp], eax
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _slice_addresses_in_ts$12[ebp]
	mov	DWORD PTR [edx+4512], eax

; 579  : 
; 580  :       int slice_id = 0;

	mov	DWORD PTR _slice_id$11[ebp], 0

; 581  :       for (int tile_row = 0; tile_row < encoder->cfg.tiles_height_count; ++tile_row) {

	mov	DWORD PTR _tile_row$10[ebp], 0
	jmp	SHORT $LN55@kvz_encode
$LN53@kvz_encode:
	mov	eax, DWORD PTR _tile_row$10[ebp]
	add	eax, 1
	mov	DWORD PTR _tile_row$10[ebp], eax
$LN55@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _tile_row$10[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	$LN54@kvz_encode

; 582  :         for (int tile_col = 0; tile_col < encoder->cfg.tiles_width_count; ++tile_col) {

	mov	DWORD PTR _tile_col$9[ebp], 0
	jmp	SHORT $LN58@kvz_encode
$LN56@kvz_encode:
	mov	eax, DWORD PTR _tile_col$9[ebp]
	add	eax, 1
	mov	DWORD PTR _tile_col$9[ebp], eax
$LN58@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _tile_col$9[ebp]
	cmp	ecx, DWORD PTR [eax+136]
	jge	$LN57@kvz_encode

; 583  :           int x = tiles_col_bd[tile_col];

	mov	eax, DWORD PTR _tile_col$9[ebp]
	mov	ecx, DWORD PTR _tiles_col_bd$39[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _x$8[ebp], edx

; 584  :           int y = tiles_row_bd[tile_row];

	mov	eax, DWORD PTR _tile_row$10[ebp]
	mov	ecx, DWORD PTR _tiles_row_bd$38[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _y$7[ebp], edx

; 585  :           int rs = y * encoder->in.width_in_lcu + x;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _y$7[ebp]
	imul	ecx, DWORD PTR [eax+2488]
	add	ecx, DWORD PTR _x$8[ebp]
	mov	DWORD PTR _rs$6[ebp], ecx

; 586  :           int ts = tiles_ctb_addr_rs_to_ts[rs];

	mov	eax, DWORD PTR _rs$6[ebp]
	mov	ecx, DWORD PTR _tiles_ctb_addr_rs_to_ts$42[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _ts$5[ebp], edx

; 587  :           slice_addresses_in_ts[slice_id] = ts;

	mov	eax, DWORD PTR _slice_id$11[ebp]
	mov	ecx, DWORD PTR _slice_addresses_in_ts$12[ebp]
	mov	edx, DWORD PTR _ts$5[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 588  :           slice_id += 1;

	mov	eax, DWORD PTR _slice_id$11[ebp]
	add	eax, 1
	mov	DWORD PTR _slice_id$11[ebp], eax

; 589  :         }

	jmp	$LN56@kvz_encode
$LN57@kvz_encode:

; 590  :       }

	jmp	$LN53@kvz_encode
$LN54@kvz_encode:

; 591  : 
; 592  :     } else {

	jmp	$LN63@kvz_encode
$LN119@kvz_encode:

; 593  :       int *slice_addresses_in_ts;
; 594  :       encoder->slice_count = encoder->cfg.slice_count;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	DWORD PTR [eax+4508], edx

; 595  :       if (encoder->slice_count == 0) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+4508], 0
	jne	SHORT $LN121@kvz_encode

; 596  :         encoder->slice_count = 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+4508], 1

; 597  : 
; 598  :         encoder->slice_addresses_in_ts = slice_addresses_in_ts =

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4508]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _slice_addresses_in_ts$4[ebp], eax
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _slice_addresses_in_ts$4[ebp]
	mov	DWORD PTR [edx+4512], eax

; 599  :           MALLOC(int, encoder->slice_count);
; 600  :         if (!slice_addresses_in_ts) goto init_failed;

	cmp	DWORD PTR _slice_addresses_in_ts$4[ebp], 0
	jne	SHORT $LN123@kvz_encode
	jmp	$init_failed$164
$LN123@kvz_encode:

; 601  : 
; 602  :         slice_addresses_in_ts[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _slice_addresses_in_ts$4[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 603  : 
; 604  :       } else {

	jmp	$LN63@kvz_encode
$LN121@kvz_encode:

; 605  :         encoder->slice_addresses_in_ts = slice_addresses_in_ts =

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+4508]
	shl	ecx, 2
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _slice_addresses_in_ts$4[ebp], eax
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR _slice_addresses_in_ts$4[ebp]
	mov	DWORD PTR [edx+4512], eax

; 606  :           MALLOC(int, encoder->slice_count);
; 607  :         if (!slice_addresses_in_ts) goto init_failed;

	cmp	DWORD PTR _slice_addresses_in_ts$4[ebp], 0
	jne	SHORT $LN124@kvz_encode
	jmp	$init_failed$164
$LN124@kvz_encode:

; 608  : 
; 609  :         if (!cfg->slice_addresses_in_ts) {

	mov	eax, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [eax+164], 0
	jne	SHORT $LN125@kvz_encode

; 610  :           slice_addresses_in_ts[0] = 0;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _slice_addresses_in_ts$4[ebp]
	mov	DWORD PTR [edx+ecx], 0

; 611  :           for (int i = 1; i < encoder->slice_count; ++i) {

	mov	DWORD PTR _i$3[ebp], 1
	jmp	SHORT $LN61@kvz_encode
$LN59@kvz_encode:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN61@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax+4508]
	jge	SHORT $LN60@kvz_encode

; 612  :             slice_addresses_in_ts[i] = encoder->in.width_in_lcu * encoder->in.height_in_lcu * i / encoder->slice_count;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [eax+2488]
	imul	eax, DWORD PTR [ecx+2492]
	imul	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cdq
	idiv	DWORD PTR [ecx+4508]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _slice_addresses_in_ts$4[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 613  :           }

	jmp	SHORT $LN59@kvz_encode
$LN60@kvz_encode:

; 614  :         } else {

	jmp	SHORT $LN63@kvz_encode
$LN125@kvz_encode:

; 615  :           for (int i = 0; i < encoder->slice_count; ++i) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN64@kvz_encode
$LN62@kvz_encode:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN64@kvz_encode:
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR [eax+4508]
	jge	SHORT $LN63@kvz_encode

; 616  :             slice_addresses_in_ts[i] = cfg->slice_addresses_in_ts[i];

	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _slice_addresses_in_ts$4[ebp]
	mov	esi, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx

; 617  :           }

	jmp	SHORT $LN62@kvz_encode
$LN63@kvz_encode:

; 618  :         }
; 619  :       }
; 620  :     }
; 621  : 
; 622  : #ifdef _DEBUG_PRINT_THREADING_INFO
; 623  :     printf("Tiles columns width:");
; 624  :     for (int i = 0; i < encoder->cfg.tiles_width_count; ++i) {
; 625  :       printf(" %d", encoder->tiles_col_width[i]);
; 626  :     }
; 627  :     printf("\n");
; 628  :     printf("Tiles row height:");
; 629  :     for (int i = 0; i < encoder->cfg.tiles_height_count; ++i) {
; 630  :       printf(" %d", encoder->tiles_row_height[i]);
; 631  :     }
; 632  :     printf("\n");
; 633  :     //Print tile index map
; 634  :     for (int y = 0; y < encoder->in.height_in_lcu; ++y) {
; 635  :       for (int x = 0; x < encoder->in.width_in_lcu; ++x) {
; 636  :         const int lcu_id_rs = y * encoder->in.width_in_lcu + x;
; 637  :         const int lcu_id_ts = encoder->tiles_ctb_addr_rs_to_ts[lcu_id_rs];
; 638  :         const char slice_start = kvz_lcu_at_slice_start(encoder, lcu_id_ts) ? '|' : ' ';
; 639  :         const char slice_end = kvz_lcu_at_slice_end(encoder, lcu_id_ts)  ? '|' : ' ';
; 640  : 
; 641  :         printf("%c%03d%c", slice_start, encoder->tiles_tile_id[lcu_id_ts], slice_end);
; 642  :       }
; 643  :       printf("\n");
; 644  :     }
; 645  :     printf("\n");
; 646  :     if (encoder->cfg.wpp) {
; 647  :       printf("Wavefront Parallel Processing: enabled\n");
; 648  :     } else {
; 649  :       printf("Wavefront Parallel Processing: disabled\n");
; 650  :     }
; 651  :     printf("\n");
; 652  : #endif //KVZ_DEBUG
; 653  :   }
; 654  : 
; 655  :   for( size_t i = 0; i < KVZ_MAX_GOP_LAYERS; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN67@kvz_encode
$LN65@kvz_encode:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN67@kvz_encode:
	cmp	DWORD PTR _i$1[ebp], 6
	jae	$LN66@kvz_encode

; 656  :   {
; 657  :       if( encoder->cfg.pu_depth_inter.min[i] < 0 || cfg->pu_depth_inter.max[i] < 0 ) continue;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [ecx+eax*4+176], 0
	jl	SHORT $LN128@kvz_encode
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+200], 0
	jge	SHORT $LN127@kvz_encode
$LN128@kvz_encode:
	jmp	SHORT $LN65@kvz_encode
$LN127@kvz_encode:

; 658  :       assert( WITHIN( encoder->cfg.pu_depth_inter.min[i], PU_DEPTH_INTER_MIN, PU_DEPTH_INTER_MAX ) );

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [ecx+eax*4+176], 0
	jl	SHORT $LN155@kvz_encode
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+edx*4+176], 3
	jle	SHORT $LN156@kvz_encode
$LN155@kvz_encode:
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_encoder_control_init@@9@9
	add	ecx, 436				; 000001b4H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1GM@LCDACKMB@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1KK@KGMAGOM@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN156@kvz_encode:

; 659  :       assert( WITHIN( encoder->cfg.pu_depth_inter.max[i], PU_DEPTH_INTER_MIN, PU_DEPTH_INTER_MAX ) );

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [ecx+eax*4+200], 0
	jl	SHORT $LN157@kvz_encode
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+edx*4+200], 3
	jle	SHORT $LN158@kvz_encode
$LN157@kvz_encode:
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_encoder_control_init@@9@9
	add	ecx, 437				; 000001b5H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1GM@LCDACKMB@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1KK@DCBCFFMB@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN158@kvz_encode:

; 660  : 
; 661  :       if( encoder->cfg.pu_depth_intra.min[i] < 0 || cfg->pu_depth_intra.max[i] < 0 ) continue;

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [ecx+eax*4+224], 0
	jl	SHORT $LN130@kvz_encode
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _cfg$[ebp]
	cmp	DWORD PTR [ecx+eax*4+248], 0
	jge	SHORT $LN129@kvz_encode
$LN130@kvz_encode:
	jmp	$LN65@kvz_encode
$LN129@kvz_encode:

; 662  :       assert( WITHIN( encoder->cfg.pu_depth_intra.min[i], PU_DEPTH_INTRA_MIN, PU_DEPTH_INTRA_MAX ) );

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [ecx+eax*4+224], 0
	jl	SHORT $LN159@kvz_encode
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+edx*4+224], 4
	jle	SHORT $LN160@kvz_encode
$LN159@kvz_encode:
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_encoder_control_init@@9@9
	add	ecx, 440				; 000001b8H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1GM@LCDACKMB@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1KK@CPCODEGA@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN160@kvz_encode:

; 663  :       assert( WITHIN( encoder->cfg.pu_depth_intra.max[i], PU_DEPTH_INTRA_MIN, PU_DEPTH_INTRA_MAX ) );

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [ecx+eax*4+248], 0
	jl	SHORT $LN161@kvz_encode
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+edx*4+248], 4
	jle	SHORT $LN162@kvz_encode
$LN161@kvz_encode:
	mov	ecx, DWORD PTR ?__LINE__Var@?0??kvz_encoder_control_init@@9@9
	add	ecx, 441				; 000001b9H
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1GM@LCDACKMB@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1KK@BHFAGHEN@?$AAW?$AAI?$AAT?$AAH?$AAI?$AAN?$AA?$CI?$AA?5?$AAe?$AAn?$AAc?$AAo?$AAd?$AAe?$AAr@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN162@kvz_encode:

; 664  :   }

	jmp	$LN65@kvz_encode
$LN66@kvz_encode:

; 665  :   // Disable in-loop filters, sign hiding and transform skip when using
; 666  :   // lossless coding.
; 667  :   if (encoder->cfg.lossless) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+2364], 0
	je	SHORT $LN131@kvz_encode

; 668  :     encoder->cfg.deblock_enable  = false;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+40], 0

; 669  :     encoder->cfg.sao_type        = false;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+44], 0

; 670  :     encoder->cfg.signhide_enable = false;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+52], 0

; 671  :     encoder->cfg.trskip_enable   = false;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+72], 0
$LN131@kvz_encode:

; 672  :   }
; 673  : 
; 674  :   // If fractional framerate is set, use that instead of the floating point framerate.
; 675  :   if (encoder->cfg.framerate_num != 0) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN133@kvz_encode

; 676  :     encoder->vui.timing_info_present_flag = 1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	BYTE PTR [eax+2550], 1

; 677  :     encoder->vui.num_units_in_tick = encoder->cfg.framerate_denom;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+2540], edx

; 678  :     encoder->vui.time_scale = encoder->cfg.framerate_num;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+2544], edx

; 679  :     if (encoder->cfg.source_scan_type != KVZ_INTERLACING_NONE) {

	mov	eax, DWORD PTR _encoder$[ebp]
	movsx	ecx, BYTE PTR [eax+88]
	test	ecx, ecx
	je	SHORT $LN133@kvz_encode

; 680  :       // when field_seq_flag=1, the time_scale and num_units_in_tick refer to
; 681  :       // field rate rather than frame rate.
; 682  :       encoder->vui.time_scale *= 2;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR [eax+2544]
	shl	ecx, 1
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [edx+2544], ecx
$LN133@kvz_encode:

; 683  :     }
; 684  :   }
; 685  : 
; 686  :   if (encoder->cfg.vps_period >= 0) {

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jl	SHORT $LN134@kvz_encode

; 687  :     encoder->cfg.vps_period = encoder->cfg.vps_period * encoder->cfg.intra_period;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	edx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+8], edx

; 688  :   } else {

	jmp	SHORT $LN135@kvz_encode
$LN134@kvz_encode:

; 689  :     encoder->cfg.vps_period = -1;

	mov	eax, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [eax+8], -1
$LN135@kvz_encode:

; 690  :   }
; 691  : 
; 692  :   if(encoder->cfg.optional_key){

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+2352], 0
	je	SHORT $LN136@kvz_encode

; 693  :     encoder->cfg.optional_key = MALLOC(uint8_t,16);

	mov	esi, esp
	push	16					; 00000010H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _encoder$[ebp]
	mov	DWORD PTR [ecx+2352], eax

; 694  :     if (!encoder->cfg.optional_key) goto init_failed;

	mov	eax, DWORD PTR _encoder$[ebp]
	cmp	DWORD PTR [eax+2352], 0
	jne	SHORT $LN137@kvz_encode
	jmp	SHORT $init_failed$164
$LN137@kvz_encode:

; 695  :     memcpy(encoder->cfg.optional_key, cfg->optional_key, 16);

	push	16					; 00000010H
	mov	eax, DWORD PTR _cfg$[ebp]
	mov	ecx, DWORD PTR [eax+2352]
	push	ecx
	mov	edx, DWORD PTR _encoder$[ebp]
	mov	eax, DWORD PTR [edx+2352]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN136@kvz_encode:

; 696  :   }
; 697  : 
; 698  :   return encoder;

	mov	eax, DWORD PTR _encoder$[ebp]
	jmp	SHORT $LN1@kvz_encode
$init_failed$164:

; 699  : 
; 700  : init_failed:
; 701  :   kvz_encoder_control_free(encoder);

	mov	eax, DWORD PTR _encoder$[ebp]
	push	eax
	call	_kvz_encoder_control_free
	add	esp, 4

; 702  :   return NULL;

	xor	eax, eax
$LN1@kvz_encode:

; 703  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 1032				; 00000408H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_kvz_encoder_control_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 842  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9FF75F13_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 644  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1850469A_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
