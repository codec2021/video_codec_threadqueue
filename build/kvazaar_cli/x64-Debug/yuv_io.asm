; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__066B2C95_yuv_io@c DB 01H
msvcjmc	ENDS
PUBLIC	yuv_io_read
PUBLIC	yuv_io_seek
PUBLIC	yuv_io_write
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??shift_to_bitdepth_and_spread@@9@9 ; `shift_to_bitdepth_and_spread'::`1'::__LINE__Var
PUBLIC	??_C@_1HI@PNALOPMB@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@ ; `string'
PUBLIC	??_C@_1CM@FBMJPBMB@?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAk?$AAv?$AAz?$AA_?$AAp?$AAi?$AAx?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??yuv_io_read@@9@9		; `yuv_io_read'::`1'::__LINE__Var
PUBLIC	??_C@_1CE@DNDNGCON@?$AAi?$AAn?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_1CG@FPGHNEAG@?$AAo?$AAu?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN@ ; `string'
EXTRN	memcpy:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_getc:PROC
EXTRN	__imp__wassert:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$yuv_io_read DD imagerel $LN11
	DD	imagerel $LN11+587
	DD	imagerel $unwind$yuv_io_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$yuv_io_seek DD imagerel $LN18
	DD	imagerel $LN18+590
	DD	imagerel $unwind$yuv_io_seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$yuv_io_write DD imagerel $LN13
	DD	imagerel $LN13+452
	DD	imagerel $unwind$yuv_io_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_after_frame DD imagerel fill_after_frame
	DD	imagerel fill_after_frame+209
	DD	imagerel $unwind$fill_after_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_and_fill_frame_data DD imagerel read_and_fill_frame_data
	DD	imagerel read_and_fill_frame_data+293
	DD	imagerel $unwind$read_and_fill_frame_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$swap_16b_buffer_bytes DD imagerel swap_16b_buffer_bytes
	DD	imagerel swap_16b_buffer_bytes+161
	DD	imagerel $unwind$swap_16b_buffer_bytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$shift_to_bitdepth DD imagerel shift_to_bitdepth
	DD	imagerel shift_to_bitdepth+248
	DD	imagerel $unwind$shift_to_bitdepth
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$shift_to_bitdepth_and_spread DD imagerel shift_to_bitdepth_and_spread
	DD	imagerel shift_to_bitdepth_and_spread+291
	DD	imagerel $unwind$shift_to_bitdepth_and_spread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$machine_is_big_endian DD imagerel machine_is_big_endian
	DD	imagerel machine_is_big_endian+136
	DD	imagerel $unwind$machine_is_big_endian
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mask_to_bitdepth DD imagerel mask_to_bitdepth
	DD	imagerel mask_to_bitdepth+171
	DD	imagerel $unwind$mask_to_bitdepth
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$yuv_io_read_plane DD imagerel yuv_io_read_plane
	DD	imagerel yuv_io_read_plane+508
	DD	imagerel $unwind$yuv_io_read_plane
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_frame_header DD imagerel read_frame_header
	DD	imagerel read_frame_header+254
	DD	imagerel $unwind$read_frame_header
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1CG@FPGHNEAG@?$AAo?$AAu?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1CG@FPGHNEAG@?$AAo?$AAu?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'd', 00H
	DB	't', 00H, 'h', 00H, ' ', 00H, '%', 00H, ' ', 00H, '2', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@DNDNGCON@?$AAi?$AAn?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@DNDNGCON@?$AAi?$AAn?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN?$AA?$DN@ DB 'i'
	DB	00H, 'n', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '%', 00H, ' ', 00H, '2', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??yuv_io_read@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??yuv_io_read@@9@9 DD 0efH		; `yuv_io_read'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CM@FBMJPBMB@?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAk?$AAv?$AAz?$AA_?$AAp?$AAi?$AAx?$AAe@
CONST	SEGMENT
??_C@_1CM@FBMJPBMB@?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAk?$AAv?$AAz?$AA_?$AAp?$AAi?$AAx?$AAe@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H
	DB	'k', 00H, 'v', 00H, 'z', 00H, '_', 00H, 'p', 00H, 'i', 00H, 'x'
	DB	00H, 'e', 00H, 'l', 00H, ')', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'1', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HI@PNALOPMB@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
CONST	SEGMENT
??_C@_1HI@PNALOPMB@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, '8', 00H, '4', 00H, '0', 00H, '3', 00H, '8'
	DB	00H, '\', 00H, 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H
	DB	'o', 00H, 'p', 00H, '\', 00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e'
	DB	00H, 'o', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'c', 00H, '_', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, '_', 00H, 't', 00H, 'e', 00H, 's', 00H, 't', 00H
	DB	'\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'y', 00H, 'u'
	DB	00H, 'v', 00H, '_', 00H, 'i', 00H, 'o', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??shift_to_bitdepth_and_spread@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??shift_to_bitdepth_and_spread@@9@9 DD 070H ; `shift_to_bitdepth_and_spread'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_frame_header DD 025053b19H
	DD	010e2313H
	DD	070070049H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0238H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
read_frame_header$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+9
read_frame_header$rtcVarDesc DD 030H
	DD	0100H
	DQ	FLAT:read_frame_header$rtcName$0
	ORG $+48
read_frame_header$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:read_frame_header$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$yuv_io_read_plane DD 035053801H
	DD	011c3321H
	DD	07015002fH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mask_to_bitdepth DD 025053301H
	DD	0117231cH
	DD	070100025H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$machine_is_big_endian DD 025051e01H
	DD	010a230fH
	DD	070030025H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$shift_to_bitdepth_and_spread DD 025053801H
	DD	011c2321H
	DD	07015002dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$shift_to_bitdepth DD 025053801H
	DD	011c2321H
	DD	070150029H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$swap_16b_buffer_bytes DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_and_fill_frame_data DD 025053801H
	DD	011c2321H
	DD	07015002dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_after_frame DD 025053601H
	DD	011b2320H
	DD	070140025H
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$yuv_io_write DD 025053901H
	DD	011d2322H
	DD	07016002dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$yuv_io_seek DD 025054f19H
	DD	01222327H
	DD	0701510e3H
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	08700H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
yuv_io_seek$rtcName$0 DB 074H
	DB	06dH
	DB	070H
	DB	00H
	ORG $+12
yuv_io_seek$rtcVarDesc DD 0b0H
	DD	08000H
	DQ	FLAT:yuv_io_seek$rtcName$0
	ORG $+48
yuv_io_seek$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:yuv_io_seek$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$yuv_io_read DD 045053801H
	DD	011c4321H
	DD	070150035H
	DD	05014H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT read_frame_header
_TEXT	SEGMENT
buffer$ = 16
frame_start$ = 292
i$4 = 324
__$ArrayPad$ = 536
input$ = 576
read_frame_header PROC					; COMDAT

; 203  : static int read_frame_header(FILE* input) {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 584				; 00000248H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 146				; 00000092H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+616]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 204  :   char buffer[256];
; 205  :   bool frame_start = false;

	mov	BYTE PTR frame_start$[rbp], 0
$LN2@read_frame:

; 206  : 
; 207  :   while (!frame_start) {

	movzx	eax, BYTE PTR frame_start$[rbp]
	test	eax, eax
	jne	SHORT $LN3@read_frame

; 208  :     for (int i = 0; i < 256; i++) {

	mov	DWORD PTR i$4[rbp], 0
	jmp	SHORT $LN6@read_frame
$LN4@read_frame:
	mov	eax, DWORD PTR i$4[rbp]
	inc	eax
	mov	DWORD PTR i$4[rbp], eax
$LN6@read_frame:
	cmp	DWORD PTR i$4[rbp], 256			; 00000100H
	jge	SHORT $LN5@read_frame

; 209  :       buffer[i] = getc(input);

	mov	rcx, QWORD PTR input$[rbp]
	call	QWORD PTR __imp_getc
	movsxd	rcx, DWORD PTR i$4[rbp]
	mov	BYTE PTR buffer$[rbp+rcx], al

; 210  :       if (buffer[i] == EOF) return 0;

	movsxd	rax, DWORD PTR i$4[rbp]
	movsx	eax, BYTE PTR buffer$[rbp+rax]
	cmp	eax, -1
	jne	SHORT $LN7@read_frame
	xor	eax, eax
	jmp	SHORT $LN1@read_frame
$LN7@read_frame:

; 211  :       // ToDo: frame headers can have some information structured same as start headers
; 212  :       // This info is just skipped for now, since it's not clear what it could be.
; 213  :       if (buffer[i] == 0x0A) {

	movsxd	rax, DWORD PTR i$4[rbp]
	movsx	eax, BYTE PTR buffer$[rbp+rax]
	cmp	eax, 10
	jne	SHORT $LN8@read_frame

; 214  :         frame_start = true;

	mov	BYTE PTR frame_start$[rbp], 1

; 215  :         break;

	jmp	SHORT $LN5@read_frame
$LN8@read_frame:

; 216  :       }
; 217  :     }

	jmp	SHORT $LN4@read_frame
$LN5@read_frame:

; 218  :   }

	jmp	SHORT $LN2@read_frame
$LN3@read_frame:

; 219  :   return 1;

	mov	eax, 1
$LN1@read_frame:

; 220  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:read_frame_header$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+552]
	pop	rdi
	pop	rbp
	ret	0
read_frame_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT yuv_io_read_plane
_TEXT	SEGMENT
bytes_per_sample$ = 4
buf_bytes$ = 36
out_length$ = 68
pixel_size$1 = 104
tv65 = 308
file$ = 352
in_width$ = 360
in_height$ = 368
in_bitdepth$ = 376
out_width$ = 384
out_height$ = 392
out_bitdepth$ = 400
out_buf$ = 408
yuv_io_read_plane PROC					; COMDAT

; 162  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+408]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 163  :   unsigned bytes_per_sample = in_bitdepth > 8 ? 2 : 1;

	cmp	DWORD PTR in_bitdepth$[rbp], 8
	jbe	SHORT $LN15@yuv_io_rea
	mov	DWORD PTR tv65[rbp], 2
	jmp	SHORT $LN16@yuv_io_rea
$LN15@yuv_io_rea:
	mov	DWORD PTR tv65[rbp], 1
$LN16@yuv_io_rea:
	mov	eax, DWORD PTR tv65[rbp]
	mov	DWORD PTR bytes_per_sample$[rbp], eax

; 164  :   unsigned buf_bytes = in_width * in_height * bytes_per_sample;

	mov	eax, DWORD PTR in_width$[rbp]
	imul	eax, DWORD PTR in_height$[rbp]
	imul	eax, DWORD PTR bytes_per_sample$[rbp]
	mov	DWORD PTR buf_bytes$[rbp], eax

; 165  :   unsigned out_length = out_width * out_height;

	mov	eax, DWORD PTR out_width$[rbp]
	imul	eax, DWORD PTR out_height$[rbp]
	mov	DWORD PTR out_length$[rbp], eax

; 166  : 
; 167  :   if (in_width == out_width) {

	mov	eax, DWORD PTR out_width$[rbp]
	cmp	DWORD PTR in_width$[rbp], eax
	jne	SHORT $LN2@yuv_io_rea

; 168  :     // No need to extend pixels.
; 169  :     const size_t pixel_size = sizeof(unsigned char);

	mov	QWORD PTR pixel_size$1[rbp], 1

; 170  :     if (fread(out_buf, pixel_size, buf_bytes, file) != buf_bytes)  return 0;

	mov	eax, DWORD PTR buf_bytes$[rbp]
	mov	r9, QWORD PTR file$[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR pixel_size$1[rbp]
	mov	rcx, QWORD PTR out_buf$[rbp]
	call	QWORD PTR __imp_fread
	mov	ecx, DWORD PTR buf_bytes$[rbp]
	cmp	rax, rcx
	je	SHORT $LN4@yuv_io_rea
	xor	eax, eax
	jmp	$LN1@yuv_io_rea
$LN4@yuv_io_rea:

; 171  :   } else {

	jmp	SHORT $LN3@yuv_io_rea
$LN2@yuv_io_rea:

; 172  :     // Need to copy pixels to fill the image in horizontal direction.
; 173  :     if (!read_and_fill_frame_data(file, in_width, in_height, bytes_per_sample, out_width, out_buf)) return 0;

	mov	rax, QWORD PTR out_buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR out_width$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR bytes_per_sample$[rbp]
	mov	r8d, DWORD PTR in_height$[rbp]
	mov	edx, DWORD PTR in_width$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	call	read_and_fill_frame_data
	test	eax, eax
	jne	SHORT $LN5@yuv_io_rea
	xor	eax, eax
	jmp	$LN1@yuv_io_rea
$LN5@yuv_io_rea:
$LN3@yuv_io_rea:

; 174  :   }
; 175  : 
; 176  :   if (in_height != out_height) {

	mov	eax, DWORD PTR out_height$[rbp]
	cmp	DWORD PTR in_height$[rbp], eax
	je	SHORT $LN6@yuv_io_rea

; 177  :     // Need to copy pixels to fill the image in vertical direction.
; 178  :     fill_after_frame(in_height, out_width, out_height, out_buf);

	mov	r9, QWORD PTR out_buf$[rbp]
	mov	r8d, DWORD PTR out_height$[rbp]
	mov	edx, DWORD PTR out_width$[rbp]
	mov	ecx, DWORD PTR in_height$[rbp]
	call	fill_after_frame
$LN6@yuv_io_rea:

; 179  :   }
; 180  : 
; 181  :   if (in_bitdepth > 8) {

	cmp	DWORD PTR in_bitdepth$[rbp], 8
	jbe	SHORT $LN7@yuv_io_rea

; 182  :     // Assume little endian input.
; 183  :     if (machine_is_big_endian()) {

	call	machine_is_big_endian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@yuv_io_rea

; 184  :       swap_16b_buffer_bytes(out_buf, out_length);

	mov	edx, DWORD PTR out_length$[rbp]
	mov	rcx, QWORD PTR out_buf$[rbp]
	call	swap_16b_buffer_bytes
$LN8@yuv_io_rea:
$LN7@yuv_io_rea:

; 185  :     }
; 186  :   }
; 187  : 
; 188  :   // Shift the data to the correct bitdepth.
; 189  :   // Ignore any bits larger than in_bitdepth to guarantee ouput data will be
; 190  :   // in the correct range.
; 191  :   if (in_bitdepth <= 8 && out_bitdepth > 8) {

	cmp	DWORD PTR in_bitdepth$[rbp], 8
	ja	SHORT $LN9@yuv_io_rea
	cmp	DWORD PTR out_bitdepth$[rbp], 8
	jbe	SHORT $LN9@yuv_io_rea

; 192  :     shift_to_bitdepth_and_spread(out_buf, out_length, in_bitdepth, out_bitdepth);

	mov	r9d, DWORD PTR out_bitdepth$[rbp]
	mov	r8d, DWORD PTR in_bitdepth$[rbp]
	mov	edx, DWORD PTR out_length$[rbp]
	mov	rcx, QWORD PTR out_buf$[rbp]
	call	shift_to_bitdepth_and_spread
	jmp	SHORT $LN10@yuv_io_rea
$LN9@yuv_io_rea:

; 193  :   } else if (in_bitdepth != out_bitdepth) {

	mov	eax, DWORD PTR out_bitdepth$[rbp]
	cmp	DWORD PTR in_bitdepth$[rbp], eax
	je	SHORT $LN11@yuv_io_rea

; 194  :     shift_to_bitdepth(out_buf, out_length, in_bitdepth, out_bitdepth);

	mov	r9d, DWORD PTR out_bitdepth$[rbp]
	mov	r8d, DWORD PTR in_bitdepth$[rbp]
	mov	edx, DWORD PTR out_length$[rbp]
	mov	rcx, QWORD PTR out_buf$[rbp]
	call	shift_to_bitdepth
	jmp	SHORT $LN12@yuv_io_rea
$LN11@yuv_io_rea:

; 195  :   } else if (in_bitdepth % 8 != 0) {

	xor	edx, edx
	mov	eax, DWORD PTR in_bitdepth$[rbp]
	mov	ecx, 8
	div	ecx
	mov	eax, edx
	test	eax, eax
	je	SHORT $LN13@yuv_io_rea

; 196  :     mask_to_bitdepth(out_buf, out_length, out_bitdepth);

	mov	r8d, DWORD PTR out_bitdepth$[rbp]
	mov	edx, DWORD PTR out_length$[rbp]
	mov	rcx, QWORD PTR out_buf$[rbp]
	call	mask_to_bitdepth
$LN13@yuv_io_rea:
$LN12@yuv_io_rea:
$LN10@yuv_io_rea:

; 197  :   }
; 198  : 
; 199  :   return 1;

	mov	eax, 1
$LN1@yuv_io_rea:

; 200  : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
yuv_io_read_plane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT mask_to_bitdepth
_TEXT	SEGMENT
bitdepth_mask$ = 4
i$1 = 36
tv82 = 244
buf$ = 288
length$ = 296
bitdepth$ = 304
mask_to_bitdepth PROC					; COMDAT

; 149  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 150  :   kvz_pixel bitdepth_mask = (1 << bitdepth) - 1;

	mov	eax, DWORD PTR bitdepth$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv82[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv82[rbp]
	shl	eax, cl
	dec	eax
	mov	BYTE PTR bitdepth_mask$[rbp], al

; 151  :   for (int i = 0; i < length; ++i) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@mask_to_bi
$LN2@mask_to_bi:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@mask_to_bi:
	mov	eax, DWORD PTR length$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@mask_to_bi

; 152  :     buf[i] = buf[i] & bitdepth_mask;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR buf$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	movzx	ecx, BYTE PTR bitdepth_mask$[rbp]
	and	eax, ecx
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR buf$[rbp]
	mov	BYTE PTR [rdx+rcx], al

; 153  :   }

	jmp	SHORT $LN2@mask_to_bi
$LN3@mask_to_bi:

; 154  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
mask_to_bitdepth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT machine_is_big_endian
_TEXT	SEGMENT
number$ = 4
first_byte$ = 36
tv66 = 244
tv68 = 248
machine_is_big_endian PROC				; COMDAT

; 136  : {

	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 137  :   // Big and little endianess refers to which end of the egg you prefer to eat
; 138  :   // first. Therefore in big endian system, the most significant bits are in
; 139  :   // the first address.
; 140  : 
; 141  :   uint16_t number = 1;

	mov	eax, 1
	mov	WORD PTR number$[rbp], ax

; 142  :   char first_byte = *(char*)&number;

	movzx	eax, BYTE PTR number$[rbp]
	mov	BYTE PTR first_byte$[rbp], al

; 143  : 
; 144  :   return (first_byte == 0);

	movsx	eax, BYTE PTR first_byte$[rbp]
	test	eax, eax
	jne	SHORT $LN3@machine_is
	mov	DWORD PTR tv66[rbp], 1
	jmp	SHORT $LN4@machine_is
$LN3@machine_is:
	mov	DWORD PTR tv66[rbp], 0
$LN4@machine_is:
	cmp	DWORD PTR tv66[rbp], 0
	jne	SHORT $LN5@machine_is
	mov	DWORD PTR tv68[rbp], 0
	jmp	SHORT $LN6@machine_is
$LN5@machine_is:
	mov	DWORD PTR tv68[rbp], 1
$LN6@machine_is:
	movzx	eax, BYTE PTR tv68[rbp]

; 145  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
machine_is_big_endian ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT shift_to_bitdepth_and_spread
_TEXT	SEGMENT
shift$ = 4
byte_buf$ = 40
bitdepth_mask$ = 68
i$1 = 100
tv145 = 308
input$ = 352
size$ = 360
from_bitdepth$ = 368
to_bitdepth$ = 376
shift_to_bitdepth_and_spread PROC			; COMDAT

; 112  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 360				; 00000168H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+392]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 113  :   assert(sizeof(kvz_pixel) > 1);

	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN8@shift_to_b
	mov	eax, DWORD PTR ?__LINE__Var@?0??shift_to_bitdepth_and_spread@@9@9
	inc	eax
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1HI@PNALOPMB@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1CM@FBMJPBMB@?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAk?$AAv?$AAz?$AA_?$AAp?$AAi?$AAx?$AAe@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN8@shift_to_b:

; 114  :   int shift = to_bitdepth - from_bitdepth;

	mov	eax, DWORD PTR from_bitdepth$[rbp]
	mov	ecx, DWORD PTR to_bitdepth$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR shift$[rbp], eax

; 115  :   unsigned char *byte_buf = (unsigned char *)input;

	mov	rax, QWORD PTR input$[rbp]
	mov	QWORD PTR byte_buf$[rbp], rax

; 116  :   kvz_pixel bitdepth_mask = (1 << from_bitdepth) - 1;

	mov	eax, DWORD PTR from_bitdepth$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv145[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv145[rbp]
	shl	eax, cl
	dec	eax
	mov	BYTE PTR bitdepth_mask$[rbp], al

; 117  :   
; 118  :   // Starting from the back of the 1-byte samples, copy each sample to it's
; 119  :   // place in the 2-byte per sample array, overwriting the bytes that have
; 120  :   // already been copied in the process.
; 121  :   // Even though the two pointers are aliased, this should work because the
; 122  :   // future values read through byte_buf poiner never change as a result of
; 123  :   // writing through input pointer.
; 124  :   for (int i = size - 1; i >= 0; --i) {

	mov	eax, DWORD PTR size$[rbp]
	dec	eax
	mov	DWORD PTR i$1[rbp], eax
	jmp	SHORT $LN4@shift_to_b
$LN2@shift_to_b:
	mov	eax, DWORD PTR i$1[rbp]
	dec	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@shift_to_b:
	cmp	DWORD PTR i$1[rbp], 0
	jl	SHORT $LN3@shift_to_b

; 125  :     // Shifting by a negative number is undefined.
; 126  :     if (shift > 0) {

	cmp	DWORD PTR shift$[rbp], 0
	jle	SHORT $LN5@shift_to_b

; 127  :       input[i] = (byte_buf[i] & bitdepth_mask) << shift;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR byte_buf$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	movzx	ecx, BYTE PTR bitdepth_mask$[rbp]
	and	eax, ecx
	mov	ecx, DWORD PTR shift$[rbp]
	shl	eax, cl
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR input$[rbp]
	mov	BYTE PTR [rdx+rcx], al

; 128  :     } else {

	jmp	SHORT $LN6@shift_to_b
$LN5@shift_to_b:

; 129  :       input[i] = (byte_buf[i] & bitdepth_mask) >> shift;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR byte_buf$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	movzx	ecx, BYTE PTR bitdepth_mask$[rbp]
	and	eax, ecx
	mov	ecx, DWORD PTR shift$[rbp]
	sar	eax, cl
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR input$[rbp]
	mov	BYTE PTR [rdx+rcx], al
$LN6@shift_to_b:

; 130  :     }
; 131  :   }

	jmp	SHORT $LN2@shift_to_b
$LN3@shift_to_b:

; 132  : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
shift_to_bitdepth_and_spread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT shift_to_bitdepth
_TEXT	SEGMENT
shift$ = 4
bitdepth_mask$ = 36
i$1 = 68
tv134 = 276
input$ = 320
size$ = 328
from_bitdepth$ = 336
to_bitdepth$ = 344
shift_to_bitdepth PROC					; COMDAT

; 92   : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 93   :   int shift = to_bitdepth - from_bitdepth;

	mov	eax, DWORD PTR from_bitdepth$[rbp]
	mov	ecx, DWORD PTR to_bitdepth$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR shift$[rbp], eax

; 94   :   kvz_pixel bitdepth_mask = (1 << from_bitdepth) - 1;

	mov	eax, DWORD PTR from_bitdepth$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv134[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv134[rbp]
	shl	eax, cl
	dec	eax
	mov	BYTE PTR bitdepth_mask$[rbp], al

; 95   : 
; 96   :   for (int i = 0; i < size; ++i) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@shift_to_b
$LN2@shift_to_b:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@shift_to_b:
	mov	eax, DWORD PTR size$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jge	SHORT $LN3@shift_to_b

; 97   :     // Shifting by a negative number is undefined.
; 98   :     if (shift > 0) {

	cmp	DWORD PTR shift$[rbp], 0
	jle	SHORT $LN5@shift_to_b

; 99   :       input[i] = (input[i] & bitdepth_mask) << shift;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR input$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	movzx	ecx, BYTE PTR bitdepth_mask$[rbp]
	and	eax, ecx
	mov	ecx, DWORD PTR shift$[rbp]
	shl	eax, cl
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR input$[rbp]
	mov	BYTE PTR [rdx+rcx], al

; 100  :     } else {

	jmp	SHORT $LN6@shift_to_b
$LN5@shift_to_b:

; 101  :       input[i] = (input[i] & bitdepth_mask) >> shift;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR input$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	movzx	ecx, BYTE PTR bitdepth_mask$[rbp]
	and	eax, ecx
	mov	ecx, DWORD PTR shift$[rbp]
	sar	eax, cl
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR input$[rbp]
	mov	BYTE PTR [rdx+rcx], al
$LN6@shift_to_b:

; 102  :     }
; 103  :   }

	jmp	SHORT $LN2@shift_to_b
$LN3@shift_to_b:

; 104  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
shift_to_bitdepth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT swap_16b_buffer_bytes
_TEXT	SEGMENT
i$1 = 4
input$ = 256
size$ = 264
swap_16b_buffer_bytes PROC				; COMDAT

; 84   : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 85   :   for (int i = 0; i < size; ++i) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@swap_16b_b
$LN2@swap_16b_b:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@swap_16b_b:
	mov	eax, DWORD PTR size$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jge	SHORT $LN3@swap_16b_b

; 86   :     input[i] = ((input[i] & 0xff) << 8) + ((input[i] & 0xff00) >> 8);

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR input$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 255				; 000000ffH
	shl	eax, 8
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR input$[rbp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	and	ecx, 65280				; 0000ff00H
	sar	ecx, 8
	add	eax, ecx
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR input$[rbp]
	mov	BYTE PTR [rdx+rcx], al

; 87   :   }

	jmp	SHORT $LN2@swap_16b_b
$LN3@swap_16b_b:

; 88   : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
swap_16b_buffer_bytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT read_and_fill_frame_data
_TEXT	SEGMENT
p$ = 8
end$ = 40
fill_char$ = 68
i$ = 100
tv68 = 312
file$ = 352
width$ = 360
height$ = 368
bytes_per_sample$ = 376
array_width$ = 384
data$ = 392
read_and_fill_frame_data PROC				; COMDAT

; 59   : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 360				; 00000168H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+392]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 60   :   kvz_pixel* p = data;

	mov	rax, QWORD PTR data$[rbp]
	mov	QWORD PTR p$[rbp], rax

; 61   :   kvz_pixel* end = data + array_width * height;

	mov	eax, DWORD PTR array_width$[rbp]
	imul	eax, DWORD PTR height$[rbp]
	mov	eax, eax
	mov	rcx, QWORD PTR data$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$[rbp], rax
$LN2@read_and_f:

; 62   :   kvz_pixel fill_char;
; 63   :   unsigned i;
; 64   : 
; 65   :   while (p < end) {

	mov	rax, QWORD PTR end$[rbp]
	cmp	QWORD PTR p$[rbp], rax
	jae	$LN3@read_and_f

; 66   :     // Read the beginning of the line from input.
; 67   :     if (width != fread(p, bytes_per_sample, width, file))

	mov	eax, DWORD PTR width$[rbp]
	mov	QWORD PTR tv68[rbp], rax
	mov	ecx, DWORD PTR width$[rbp]
	mov	edx, DWORD PTR bytes_per_sample$[rbp]
	mov	r9, QWORD PTR file$[rbp]
	mov	r8d, ecx
	mov	rcx, QWORD PTR p$[rbp]
	call	QWORD PTR __imp_fread
	mov	rcx, QWORD PTR tv68[rbp]
	cmp	rcx, rax
	je	SHORT $LN7@read_and_f

; 68   :       return 0;

	xor	eax, eax
	jmp	SHORT $LN1@read_and_f
$LN7@read_and_f:

; 69   : 
; 70   :     // Fill the rest with the last pixel value.
; 71   :     fill_char = p[width - 1];

	mov	eax, DWORD PTR width$[rbp]
	dec	eax
	mov	eax, eax
	mov	rcx, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR fill_char$[rbp], al

; 72   : 
; 73   :     for (i = width; i < array_width; ++i) {

	mov	eax, DWORD PTR width$[rbp]
	mov	DWORD PTR i$[rbp], eax
	jmp	SHORT $LN6@read_and_f
$LN4@read_and_f:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN6@read_and_f:
	mov	eax, DWORD PTR array_width$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jae	SHORT $LN5@read_and_f

; 74   :       p[i] = fill_char;

	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movzx	edx, BYTE PTR fill_char$[rbp]
	mov	BYTE PTR [rcx+rax], dl

; 75   :     }

	jmp	SHORT $LN4@read_and_f
$LN5@read_and_f:

; 76   : 
; 77   :     p += array_width;

	mov	eax, DWORD PTR array_width$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rbp], rax

; 78   :   }

	jmp	$LN2@read_and_f
$LN3@read_and_f:

; 79   :   return 1;

	mov	eax, 1
$LN1@read_and_f:

; 80   : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
read_and_fill_frame_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT fill_after_frame
_TEXT	SEGMENT
p$ = 8
end$ = 40
height$ = 288
array_width$ = 296
array_height$ = 304
data$ = 312
fill_after_frame PROC					; COMDAT

; 44   : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 45   :   kvz_pixel* p = data + height * array_width;

	mov	eax, DWORD PTR height$[rbp]
	imul	eax, DWORD PTR array_width$[rbp]
	mov	eax, eax
	mov	rcx, QWORD PTR data$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rbp], rax

; 46   :   kvz_pixel* end = data + array_width * array_height;

	mov	eax, DWORD PTR array_width$[rbp]
	imul	eax, DWORD PTR array_height$[rbp]
	mov	eax, eax
	mov	rcx, QWORD PTR data$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR end$[rbp], rax
$LN2@fill_after:

; 47   : 
; 48   :   while (p < end) {

	mov	rax, QWORD PTR end$[rbp]
	cmp	QWORD PTR p$[rbp], rax
	jae	SHORT $LN3@fill_after

; 49   :     // Fill the line by copying the line above.
; 50   :     memcpy(p, p - array_width, array_width);

	mov	eax, DWORD PTR array_width$[rbp]
	mov	ecx, DWORD PTR array_width$[rbp]
	mov	rdx, QWORD PTR p$[rbp]
	sub	rdx, rcx
	mov	rcx, rdx
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR p$[rbp]
	call	memcpy

; 51   :     p += array_width;

	mov	eax, DWORD PTR array_width$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR p$[rbp], rax

; 52   :   }

	jmp	SHORT $LN2@fill_after
$LN3@fill_after:

; 53   : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
fill_after_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT yuv_io_write
_TEXT	SEGMENT
width$ = 4
y$1 = 36
y$2 = 68
y$3 = 100
tv132 = 312
tv85 = 312
file$ = 352
img$ = 360
output_width$ = 368
output_height$ = 376
yuv_io_write PROC					; COMDAT

; 341  : {

$LN13:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 360				; 00000168H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+392]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 342  :   const int width = img->width;

	mov	rax, QWORD PTR img$[rbp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR width$[rbp], eax

; 343  :   for (int y = 0; y < output_height; ++y) {

	mov	DWORD PTR y$1[rbp], 0
	jmp	SHORT $LN4@yuv_io_wri
$LN2@yuv_io_wri:
	mov	eax, DWORD PTR y$1[rbp]
	inc	eax
	mov	DWORD PTR y$1[rbp], eax
$LN4@yuv_io_wri:
	mov	eax, DWORD PTR output_height$[rbp]
	cmp	DWORD PTR y$1[rbp], eax
	jae	SHORT $LN3@yuv_io_wri

; 344  :     fwrite(&img->y[y * width], sizeof(*img->y), output_width, file);

	mov	eax, DWORD PTR output_width$[rbp]
	mov	ecx, DWORD PTR y$1[rbp]
	imul	ecx, DWORD PTR width$[rbp]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR img$[rbp]
	mov	rdx, QWORD PTR [rdx+16]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, QWORD PTR file$[rbp]
	mov	r8d, eax
	mov	edx, 1
	call	QWORD PTR __imp_fwrite

; 345  :     // TODO: Check that fwrite succeeded.
; 346  :   }

	jmp	SHORT $LN2@yuv_io_wri
$LN3@yuv_io_wri:

; 347  : 
; 348  :   if (img->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR img$[rbp]
	cmp	DWORD PTR [rax+116], 0
	je	$LN11@yuv_io_wri

; 349  :     for (int y = 0; y < output_height / 2; ++y) {

	mov	DWORD PTR y$2[rbp], 0
	jmp	SHORT $LN7@yuv_io_wri
$LN5@yuv_io_wri:
	mov	eax, DWORD PTR y$2[rbp]
	inc	eax
	mov	DWORD PTR y$2[rbp], eax
$LN7@yuv_io_wri:
	xor	edx, edx
	mov	eax, DWORD PTR output_height$[rbp]
	mov	ecx, 2
	div	ecx
	cmp	DWORD PTR y$2[rbp], eax
	jae	SHORT $LN6@yuv_io_wri

; 350  :       fwrite(&img->u[y * width / 2], sizeof(*img->u), output_width / 2, file);

	xor	edx, edx
	mov	eax, DWORD PTR output_width$[rbp]
	mov	ecx, 2
	div	ecx
	mov	eax, eax
	mov	QWORD PTR tv85[rbp], rax
	mov	ecx, DWORD PTR y$2[rbp]
	imul	ecx, DWORD PTR width$[rbp]
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	cdqe
	mov	rcx, QWORD PTR img$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR tv85[rbp]
	mov	r8, rcx
	mov	edx, 1
	mov	rcx, rax
	call	QWORD PTR __imp_fwrite

; 351  :     }

	jmp	SHORT $LN5@yuv_io_wri
$LN6@yuv_io_wri:

; 352  :     for (int y = 0; y < output_height / 2; ++y) {

	mov	DWORD PTR y$3[rbp], 0
	jmp	SHORT $LN10@yuv_io_wri
$LN8@yuv_io_wri:
	mov	eax, DWORD PTR y$3[rbp]
	inc	eax
	mov	DWORD PTR y$3[rbp], eax
$LN10@yuv_io_wri:
	xor	edx, edx
	mov	eax, DWORD PTR output_height$[rbp]
	mov	ecx, 2
	div	ecx
	cmp	DWORD PTR y$3[rbp], eax
	jae	SHORT $LN9@yuv_io_wri

; 353  :       fwrite(&img->v[y * width / 2], sizeof(*img->v), output_width / 2, file);

	xor	edx, edx
	mov	eax, DWORD PTR output_width$[rbp]
	mov	ecx, 2
	div	ecx
	mov	eax, eax
	mov	QWORD PTR tv132[rbp], rax
	mov	ecx, DWORD PTR y$3[rbp]
	imul	ecx, DWORD PTR width$[rbp]
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	cdqe
	mov	rcx, QWORD PTR img$[rbp]
	mov	rcx, QWORD PTR [rcx+32]
	add	rcx, rax
	mov	rax, rcx
	mov	r9, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR tv132[rbp]
	mov	r8, rcx
	mov	edx, 1
	mov	rcx, rax
	call	QWORD PTR __imp_fwrite

; 354  :     }

	jmp	SHORT $LN8@yuv_io_wri
$LN9@yuv_io_wri:
$LN11@yuv_io_wri:

; 355  :   }
; 356  : 
; 357  :   return 1;

	mov	eax, 1

; 358  : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
yuv_io_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT yuv_io_seek
_TEXT	SEGMENT
frame_bytes$ = 8
i$4 = 36
skip_bytes$ = 72
error$ = 104
tmp$ = 144
bytes_left$ = 32936
skip$5 = 32968
tv136 = 34516
tv129 = 34516
tv90 = 34520
__$ArrayPad$ = 34528
file$ = 34576
frames$ = 34584
input_width$ = 34592
input_height$ = 34600
file_format$ = 34608
yuv_io_seek PROC					; COMDAT

; 297  : {

$LN18:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	mov	eax, 34584				; 00008718H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 8646				; 000021c6H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+34616]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 298  :     const size_t frame_bytes = input_width * input_height * 3 / 2;

	mov	eax, DWORD PTR input_width$[rbp]
	imul	eax, DWORD PTR input_height$[rbp]
	imul	eax, eax, 3
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	mov	eax, eax
	mov	QWORD PTR frame_bytes$[rbp], rax

; 299  : 
; 300  :     if (file_format == KVZ_FORMAT_Y4M) {

	cmp	DWORD PTR file_format$[rbp], 1
	jne	SHORT $LN7@yuv_io_see

; 301  :       for (unsigned i = 0; i < frames; i++) {

	mov	DWORD PTR i$4[rbp], 0
	jmp	SHORT $LN4@yuv_io_see
$LN2@yuv_io_see:
	mov	eax, DWORD PTR i$4[rbp]
	inc	eax
	mov	DWORD PTR i$4[rbp], eax
$LN4@yuv_io_see:
	mov	eax, DWORD PTR frames$[rbp]
	cmp	DWORD PTR i$4[rbp], eax
	jae	SHORT $LN3@yuv_io_see

; 302  :         if (!read_frame_header(file)) return 0;

	mov	rcx, QWORD PTR file$[rbp]
	call	read_frame_header
	test	eax, eax
	jne	SHORT $LN8@yuv_io_see
	xor	eax, eax
	jmp	$LN1@yuv_io_see
$LN8@yuv_io_see:

; 303  :         if (fseek(file, frame_bytes, SEEK_CUR)) return 0;

	mov	r8d, 1
	mov	edx, DWORD PTR frame_bytes$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	call	QWORD PTR __imp_fseek
	test	eax, eax
	je	SHORT $LN9@yuv_io_see
	xor	eax, eax
	jmp	$LN1@yuv_io_see
$LN9@yuv_io_see:

; 304  :       }

	jmp	SHORT $LN2@yuv_io_see
$LN3@yuv_io_see:

; 305  :       return 1;

	mov	eax, 1
	jmp	$LN1@yuv_io_see
$LN7@yuv_io_see:

; 306  :     }
; 307  : 
; 308  :     const int64_t skip_bytes = (int64_t)(frames * frame_bytes);

	mov	eax, DWORD PTR frames$[rbp]
	imul	rax, QWORD PTR frame_bytes$[rbp]
	mov	QWORD PTR skip_bytes$[rbp], rax

; 309  : 
; 310  :     // Attempt to seek normally.
; 311  :     size_t error = fseek(file, skip_bytes, SEEK_CUR);

	mov	r8d, 1
	mov	edx, DWORD PTR skip_bytes$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	call	QWORD PTR __imp_fseek
	cdqe
	mov	QWORD PTR error$[rbp], rax

; 312  :     if (!error) return 1;

	cmp	QWORD PTR error$[rbp], 0
	jne	SHORT $LN10@yuv_io_see
	mov	eax, 1
	jmp	$LN1@yuv_io_see
$LN10@yuv_io_see:

; 313  : 
; 314  :     // Seek failed. Skip data by reading.
; 315  :     error = 0;

	mov	QWORD PTR error$[rbp], 0

; 316  :     unsigned char* tmp[4096];
; 317  :     size_t bytes_left = skip_bytes;

	mov	rax, QWORD PTR skip_bytes$[rbp]
	mov	QWORD PTR bytes_left$[rbp], rax
$LN5@yuv_io_see:

; 318  :     while (bytes_left > 0 && !error) {

	cmp	QWORD PTR bytes_left$[rbp], 0
	jbe	$LN6@yuv_io_see
	cmp	QWORD PTR error$[rbp], 0
	jne	$LN6@yuv_io_see

; 319  :       const size_t skip = MIN(4096, bytes_left);

	cmp	QWORD PTR bytes_left$[rbp], 4096	; 00001000H
	jbe	SHORT $LN12@yuv_io_see
	mov	QWORD PTR tv90[rbp], 4096		; 00001000H
	jmp	SHORT $LN13@yuv_io_see
$LN12@yuv_io_see:
	mov	rax, QWORD PTR bytes_left$[rbp]
	mov	QWORD PTR tv90[rbp], rax
$LN13@yuv_io_see:
	mov	rax, QWORD PTR tv90[rbp]
	mov	QWORD PTR skip$5[rbp], rax

; 320  :       error = fread(tmp, sizeof(unsigned char), skip, file) != skip;

	mov	r9, QWORD PTR file$[rbp]
	mov	r8, QWORD PTR skip$5[rbp]
	mov	edx, 1
	lea	rcx, QWORD PTR tmp$[rbp]
	call	QWORD PTR __imp_fread
	cmp	rax, QWORD PTR skip$5[rbp]
	je	SHORT $LN14@yuv_io_see
	mov	DWORD PTR tv129[rbp], 1
	jmp	SHORT $LN15@yuv_io_see
$LN14@yuv_io_see:
	mov	DWORD PTR tv129[rbp], 0
$LN15@yuv_io_see:
	movsxd	rax, DWORD PTR tv129[rbp]
	mov	QWORD PTR error$[rbp], rax

; 321  :       bytes_left -= skip;

	mov	rax, QWORD PTR skip$5[rbp]
	mov	rcx, QWORD PTR bytes_left$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR bytes_left$[rbp], rax

; 322  :     }

	jmp	$LN5@yuv_io_see
$LN6@yuv_io_see:

; 323  : 
; 324  :     return !error || feof(file);

	cmp	QWORD PTR error$[rbp], 0
	je	SHORT $LN16@yuv_io_see
	mov	rcx, QWORD PTR file$[rbp]
	call	QWORD PTR __imp_feof
	test	eax, eax
	jne	SHORT $LN16@yuv_io_see
	mov	DWORD PTR tv136[rbp], 0
	jmp	SHORT $LN17@yuv_io_see
$LN16@yuv_io_see:
	mov	DWORD PTR tv136[rbp], 1
$LN17@yuv_io_see:
	mov	eax, DWORD PTR tv136[rbp]
$LN1@yuv_io_see:

; 325  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:yuv_io_seek$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+34552]
	pop	rdi
	pop	rbp
	ret	0
yuv_io_seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\84038\Desktop\video_codec_thread_test\src\yuv_io.c
;	COMDAT yuv_io_read
_TEXT	SEGMENT
ok$ = 4
uv_width_in$1 = 36
uv_height_in$2 = 68
uv_width_out$3 = 100
uv_height_out$4 = 132
file$ = 384
in_width$ = 392
out_width$ = 400
in_bitdepth$ = 408
out_bitdepth$ = 416
img_out$ = 424
file_format$ = 432
yuv_io_read PROC					; COMDAT

; 239  : {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	lea	rcx, OFFSET FLAT:__066B2C95_yuv_io@c
	call	__CheckForDebuggerJustMyCode

; 240  :   assert(in_width % 2 == 0);

	xor	edx, edx
	mov	eax, DWORD PTR in_width$[rbp]
	mov	ecx, 2
	div	ecx
	mov	eax, edx
	test	eax, eax
	je	SHORT $LN9@yuv_io_rea
	mov	eax, DWORD PTR ?__LINE__Var@?0??yuv_io_read@@9@9
	inc	eax
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1HI@PNALOPMB@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1CE@DNDNGCON@?$AAi?$AAn?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN?$AA?$DN@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN9@yuv_io_rea:

; 241  :   assert(out_width % 2 == 0);

	xor	edx, edx
	mov	eax, DWORD PTR out_width$[rbp]
	mov	ecx, 2
	div	ecx
	mov	eax, edx
	test	eax, eax
	je	SHORT $LN10@yuv_io_rea
	mov	eax, DWORD PTR ?__LINE__Var@?0??yuv_io_read@@9@9
	add	eax, 2
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:??_C@_1HI@PNALOPMB@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AA8?$AA4?$AA0?$AA3?$AA8?$AA?2@
	lea	rcx, OFFSET FLAT:??_C@_1CG@FPGHNEAG@?$AAo?$AAu?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN@
	call	QWORD PTR __imp__wassert
	xor	eax, eax
$LN10@yuv_io_rea:

; 242  : 
; 243  :   int ok;
; 244  : 
; 245  :   if (file_format == KVZ_FORMAT_Y4M) {

	cmp	DWORD PTR file_format$[rbp], 1
	jne	SHORT $LN2@yuv_io_rea

; 246  :     ok = read_frame_header(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	read_frame_header
	mov	DWORD PTR ok$[rbp], eax

; 247  :     if (!ok) return 0;

	cmp	DWORD PTR ok$[rbp], 0
	jne	SHORT $LN3@yuv_io_rea
	xor	eax, eax
	jmp	$LN1@yuv_io_rea
$LN3@yuv_io_rea:
$LN2@yuv_io_rea:

; 248  :   }
; 249  : 
; 250  :   
; 251  : 
; 252  :   ok = yuv_io_read_plane(

	mov	rax, QWORD PTR img_out$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR out_bitdepth$[rbp]
	mov	DWORD PTR [rsp+48], eax
	mov	rax, QWORD PTR img_out$[rbp]
	mov	eax, DWORD PTR [rax+68]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR img_out$[rbp]
	mov	eax, DWORD PTR [rax+64]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR in_bitdepth$[rbp]
	mov	r8d, DWORD PTR out_width$[rbp]
	mov	edx, DWORD PTR in_width$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	call	yuv_io_read_plane
	mov	DWORD PTR ok$[rbp], eax

; 253  :       file, 
; 254  :       in_width, out_width, in_bitdepth,
; 255  :       img_out->width, img_out->height, out_bitdepth,
; 256  :       img_out->y);
; 257  :   if (!ok) return 0;

	cmp	DWORD PTR ok$[rbp], 0
	jne	SHORT $LN4@yuv_io_rea
	xor	eax, eax
	jmp	$LN1@yuv_io_rea
$LN4@yuv_io_rea:

; 258  : 
; 259  :   if (img_out->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR img_out$[rbp]
	cmp	DWORD PTR [rax+116], 0
	je	$LN5@yuv_io_rea

; 260  :     unsigned uv_width_in = in_width / 2;

	xor	edx, edx
	mov	eax, DWORD PTR in_width$[rbp]
	mov	ecx, 2
	div	ecx
	mov	DWORD PTR uv_width_in$1[rbp], eax

; 261  :     unsigned uv_height_in = out_width / 2;

	xor	edx, edx
	mov	eax, DWORD PTR out_width$[rbp]
	mov	ecx, 2
	div	ecx
	mov	DWORD PTR uv_height_in$2[rbp], eax

; 262  :     unsigned uv_width_out = img_out->width / 2;

	mov	rax, QWORD PTR img_out$[rbp]
	mov	eax, DWORD PTR [rax+64]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR uv_width_out$3[rbp], eax

; 263  :     unsigned uv_height_out = img_out->height / 2;

	mov	rax, QWORD PTR img_out$[rbp]
	mov	eax, DWORD PTR [rax+68]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR uv_height_out$4[rbp], eax

; 264  : 
; 265  :     ok = yuv_io_read_plane(

	mov	rax, QWORD PTR img_out$[rbp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR out_bitdepth$[rbp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR uv_height_out$4[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR uv_width_out$3[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR in_bitdepth$[rbp]
	mov	r8d, DWORD PTR uv_height_in$2[rbp]
	mov	edx, DWORD PTR uv_width_in$1[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	call	yuv_io_read_plane
	mov	DWORD PTR ok$[rbp], eax

; 266  :         file,
; 267  :         uv_width_in, uv_height_in, in_bitdepth,
; 268  :         uv_width_out, uv_height_out, out_bitdepth,
; 269  :         img_out->u);
; 270  :     if (!ok) return 0;

	cmp	DWORD PTR ok$[rbp], 0
	jne	SHORT $LN6@yuv_io_rea
	xor	eax, eax
	jmp	SHORT $LN1@yuv_io_rea
$LN6@yuv_io_rea:

; 271  : 
; 272  :     ok = yuv_io_read_plane(

	mov	rax, QWORD PTR img_out$[rbp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR out_bitdepth$[rbp]
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR uv_height_out$4[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR uv_width_out$3[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR in_bitdepth$[rbp]
	mov	r8d, DWORD PTR uv_height_in$2[rbp]
	mov	edx, DWORD PTR uv_width_in$1[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	call	yuv_io_read_plane
	mov	DWORD PTR ok$[rbp], eax

; 273  :         file, 
; 274  :         uv_width_in, uv_height_in, in_bitdepth,
; 275  :         uv_width_out, uv_height_out, out_bitdepth,
; 276  :         img_out->v);
; 277  :     if (!ok) return 0;

	cmp	DWORD PTR ok$[rbp], 0
	jne	SHORT $LN7@yuv_io_rea
	xor	eax, eax
	jmp	SHORT $LN1@yuv_io_rea
$LN7@yuv_io_rea:
$LN5@yuv_io_rea:

; 278  :   }
; 279  :   
; 280  :   return 1;

	mov	eax, 1
$LN1@yuv_io_rea:

; 281  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
yuv_io_read ENDP
_TEXT	ENDS
END
