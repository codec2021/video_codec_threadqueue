; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ED9CC025_corecrt_memcpy_s@h DB 01H
__875914C9_corecrt_wstring@h DB 01H
__731387C4_string@h DB 01H
__1850469A_corecrt_stdio_config@h DB 01H
__01D10305_corecrt_wstdio@h DB 01H
__9FF75F13_stdio@h DB 01H
__964E3860_yuv_io@c DB 01H
msvcjmc	ENDS
PUBLIC	_yuv_io_read
PUBLIC	_yuv_io_seek
PUBLIC	_yuv_io_write
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??shift_to_bitdepth_and_spread@@9@9 ; `shift_to_bitdepth_and_spread'::`1'::__LINE__Var
PUBLIC	??_C@_1GK@GJKGPPFL@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ ; `string'
PUBLIC	??_C@_1CM@FBMJPBMB@?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAk?$AAv?$AAz?$AA_?$AAp?$AAi?$AAx?$AAe@ ; `string'
PUBLIC	?__LINE__Var@?0??yuv_io_read@@9@9		; `yuv_io_read'::`1'::__LINE__Var
PUBLIC	??_C@_1CE@DNDNGCON@?$AAi?$AAn?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN?$AA?$DN@ ; `string'
PUBLIC	??_C@_1CG@FPGHNEAG@?$AAo?$AAu?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN@ ; `string'
EXTRN	_memcpy:PROC
EXTRN	__imp__feof:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__getc:PROC
EXTRN	__imp___wassert:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1CG@FPGHNEAG@?$AAo?$AAu?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1CG@FPGHNEAG@?$AAo?$AAu?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'd', 00H
	DB	't', 00H, 'h', 00H, ' ', 00H, '%', 00H, ' ', 00H, '2', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@DNDNGCON@?$AAi?$AAn?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@DNDNGCON@?$AAi?$AAn?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN?$AA?$DN@ DB 'i'
	DB	00H, 'n', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '%', 00H, ' ', 00H, '2', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??yuv_io_read@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??yuv_io_read@@9@9 DD 0efH		; `yuv_io_read'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CM@FBMJPBMB@?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAk?$AAv?$AAz?$AA_?$AAp?$AAi?$AAx?$AAe@
CONST	SEGMENT
??_C@_1CM@FBMJPBMB@?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAk?$AAv?$AAz?$AA_?$AAp?$AAi?$AAx?$AAe@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H
	DB	'k', 00H, 'v', 00H, 'z', 00H, '_', 00H, 'p', 00H, 'i', 00H, 'x'
	DB	00H, 'e', 00H, 'l', 00H, ')', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'1', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@GJKGPPFL@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
CONST	SEGMENT
??_C@_1GK@GJKGPPFL@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@ DB 'F'
	DB	00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c', 00H, '_'
	DB	00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H, '_', 00H
	DB	'2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k', 00H, 'v'
	DB	00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H, '-', 00H
	DB	'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'y', 00H, 'u', 00H
	DB	'v', 00H, '_', 00H, 'i', 00H, 'o', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??shift_to_bitdepth_and_spread@@9@9
_DATA	SEGMENT
?__LINE__Var@?0??shift_to_bitdepth_and_spread@@9@9 DD 070H ; `shift_to_bitdepth_and_spread'::`1'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _read_frame_header
_TEXT	SEGMENT
_i$1 = -288						; size = 4
_frame_start$ = -273					; size = 1
_buffer$ = -264						; size = 256
__$ArrayPad$ = -4					; size = 4
_input$ = 8						; size = 4
_read_frame_header PROC					; COMDAT

; 203  : static int read_frame_header(FILE* input) {

	push	ebp
	mov	ebp, esp
	sub	esp, 484				; 000001e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-484]
	mov	ecx, 121				; 00000079H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 204  :   char buffer[256];
; 205  :   bool frame_start = false;

	mov	BYTE PTR _frame_start$[ebp], 0
$LN2@read_frame:

; 206  : 
; 207  :   while (!frame_start) {

	movzx	eax, BYTE PTR _frame_start$[ebp]
	test	eax, eax
	jne	$LN3@read_frame

; 208  :     for (int i = 0; i < 256; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN6@read_frame
$LN4@read_frame:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN6@read_frame:
	cmp	DWORD PTR _i$1[ebp], 256		; 00000100H
	jge	SHORT $LN5@read_frame

; 209  :       buffer[i] = getc(input);

	mov	esi, esp
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	DWORD PTR __imp__getc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR _buffer$[ebp+ecx], al

; 210  :       if (buffer[i] == EOF) return 0;

	mov	eax, DWORD PTR _i$1[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, -1
	jne	SHORT $LN7@read_frame
	xor	eax, eax
	jmp	SHORT $LN1@read_frame
$LN7@read_frame:

; 211  :       // ToDo: frame headers can have some information structured same as start headers
; 212  :       // This info is just skipped for now, since it's not clear what it could be.
; 213  :       if (buffer[i] == 0x0A) {

	mov	eax, DWORD PTR _i$1[ebp]
	movsx	ecx, BYTE PTR _buffer$[ebp+eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN8@read_frame

; 214  :         frame_start = true;

	mov	BYTE PTR _frame_start$[ebp], 1

; 215  :         break;

	jmp	SHORT $LN5@read_frame
$LN8@read_frame:

; 216  :       }
; 217  :     }

	jmp	SHORT $LN4@read_frame
$LN5@read_frame:

; 218  :   }

	jmp	$LN2@read_frame
$LN3@read_frame:

; 219  :   return 1;

	mov	eax, 1
$LN1@read_frame:

; 220  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@read_frame
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 484				; 000001e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@read_frame:
	DD	1
	DD	$LN11@read_frame
$LN11@read_frame:
	DD	-264					; fffffef8H
	DD	256					; 00000100H
	DD	$LN10@read_frame
$LN10@read_frame:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_read_frame_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _yuv_io_read_plane
_TEXT	SEGMENT
tv65 = -244						; size = 4
_pixel_size$1 = -44					; size = 4
_out_length$ = -32					; size = 4
_buf_bytes$ = -20					; size = 4
_bytes_per_sample$ = -8					; size = 4
_file$ = 8						; size = 4
_in_width$ = 12						; size = 4
_in_height$ = 16					; size = 4
_in_bitdepth$ = 20					; size = 4
_out_width$ = 24					; size = 4
_out_height$ = 28					; size = 4
_out_bitdepth$ = 32					; size = 4
_out_buf$ = 36						; size = 4
_yuv_io_read_plane PROC					; COMDAT

; 162  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 163  :   unsigned bytes_per_sample = in_bitdepth > 8 ? 2 : 1;

	cmp	DWORD PTR _in_bitdepth$[ebp], 8
	jbe	SHORT $LN15@yuv_io_rea
	mov	DWORD PTR tv65[ebp], 2
	jmp	SHORT $LN16@yuv_io_rea
$LN15@yuv_io_rea:
	mov	DWORD PTR tv65[ebp], 1
$LN16@yuv_io_rea:
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _bytes_per_sample$[ebp], eax

; 164  :   unsigned buf_bytes = in_width * in_height * bytes_per_sample;

	mov	eax, DWORD PTR _in_width$[ebp]
	imul	eax, DWORD PTR _in_height$[ebp]
	imul	eax, DWORD PTR _bytes_per_sample$[ebp]
	mov	DWORD PTR _buf_bytes$[ebp], eax

; 165  :   unsigned out_length = out_width * out_height;

	mov	eax, DWORD PTR _out_width$[ebp]
	imul	eax, DWORD PTR _out_height$[ebp]
	mov	DWORD PTR _out_length$[ebp], eax

; 166  : 
; 167  :   if (in_width == out_width) {

	mov	eax, DWORD PTR _in_width$[ebp]
	cmp	eax, DWORD PTR _out_width$[ebp]
	jne	SHORT $LN2@yuv_io_rea

; 168  :     // No need to extend pixels.
; 169  :     const size_t pixel_size = sizeof(unsigned char);

	mov	DWORD PTR _pixel_size$1[ebp], 1

; 170  :     if (fread(out_buf, pixel_size, buf_bytes, file) != buf_bytes)  return 0;

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf_bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pixel_size$1[ebp]
	push	edx
	mov	eax, DWORD PTR _out_buf$[ebp]
	push	eax
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR _buf_bytes$[ebp]
	je	SHORT $LN4@yuv_io_rea
	xor	eax, eax
	jmp	$LN1@yuv_io_rea
$LN4@yuv_io_rea:

; 171  :   } else {

	jmp	SHORT $LN3@yuv_io_rea
$LN2@yuv_io_rea:

; 172  :     // Need to copy pixels to fill the image in horizontal direction.
; 173  :     if (!read_and_fill_frame_data(file, in_width, in_height, bytes_per_sample, out_width, out_buf)) return 0;

	mov	eax, DWORD PTR _out_buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out_width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bytes_per_sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _in_height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in_width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_read_and_fill_frame_data
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN3@yuv_io_rea
	xor	eax, eax
	jmp	$LN1@yuv_io_rea
$LN3@yuv_io_rea:

; 174  :   }
; 175  : 
; 176  :   if (in_height != out_height) {

	mov	eax, DWORD PTR _in_height$[ebp]
	cmp	eax, DWORD PTR _out_height$[ebp]
	je	SHORT $LN6@yuv_io_rea

; 177  :     // Need to copy pixels to fill the image in vertical direction.
; 178  :     fill_after_frame(in_height, out_width, out_height, out_buf);

	mov	eax, DWORD PTR _out_buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out_height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_width$[ebp]
	push	edx
	mov	eax, DWORD PTR _in_height$[ebp]
	push	eax
	call	_fill_after_frame
	add	esp, 16					; 00000010H
$LN6@yuv_io_rea:

; 179  :   }
; 180  : 
; 181  :   if (in_bitdepth > 8) {

	cmp	DWORD PTR _in_bitdepth$[ebp], 8
	jbe	SHORT $LN7@yuv_io_rea

; 182  :     // Assume little endian input.
; 183  :     if (machine_is_big_endian()) {

	call	_machine_is_big_endian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@yuv_io_rea

; 184  :       swap_16b_buffer_bytes(out_buf, out_length);

	mov	eax, DWORD PTR _out_length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out_buf$[ebp]
	push	ecx
	call	_swap_16b_buffer_bytes
	add	esp, 8
$LN7@yuv_io_rea:

; 185  :     }
; 186  :   }
; 187  : 
; 188  :   // Shift the data to the correct bitdepth.
; 189  :   // Ignore any bits larger than in_bitdepth to guarantee ouput data will be
; 190  :   // in the correct range.
; 191  :   if (in_bitdepth <= 8 && out_bitdepth > 8) {

	cmp	DWORD PTR _in_bitdepth$[ebp], 8
	ja	SHORT $LN9@yuv_io_rea
	cmp	DWORD PTR _out_bitdepth$[ebp], 8
	jbe	SHORT $LN9@yuv_io_rea

; 192  :     shift_to_bitdepth_and_spread(out_buf, out_length, in_bitdepth, out_bitdepth);

	mov	eax, DWORD PTR _out_bitdepth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in_bitdepth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_length$[ebp]
	push	edx
	mov	eax, DWORD PTR _out_buf$[ebp]
	push	eax
	call	_shift_to_bitdepth_and_spread
	add	esp, 16					; 00000010H
	jmp	SHORT $LN10@yuv_io_rea
$LN9@yuv_io_rea:

; 193  :   } else if (in_bitdepth != out_bitdepth) {

	mov	eax, DWORD PTR _in_bitdepth$[ebp]
	cmp	eax, DWORD PTR _out_bitdepth$[ebp]
	je	SHORT $LN11@yuv_io_rea

; 194  :     shift_to_bitdepth(out_buf, out_length, in_bitdepth, out_bitdepth);

	mov	eax, DWORD PTR _out_bitdepth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in_bitdepth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_length$[ebp]
	push	edx
	mov	eax, DWORD PTR _out_buf$[ebp]
	push	eax
	call	_shift_to_bitdepth
	add	esp, 16					; 00000010H
	jmp	SHORT $LN10@yuv_io_rea
$LN11@yuv_io_rea:

; 195  :   } else if (in_bitdepth % 8 != 0) {

	mov	eax, DWORD PTR _in_bitdepth$[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	test	edx, edx
	je	SHORT $LN10@yuv_io_rea

; 196  :     mask_to_bitdepth(out_buf, out_length, out_bitdepth);

	mov	eax, DWORD PTR _out_bitdepth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out_length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_buf$[ebp]
	push	edx
	call	_mask_to_bitdepth
	add	esp, 12					; 0000000cH
$LN10@yuv_io_rea:

; 197  :   }
; 198  : 
; 199  :   return 1;

	mov	eax, 1
$LN1@yuv_io_rea:

; 200  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_yuv_io_read_plane ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _mask_to_bitdepth
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_bitdepth_mask$ = -5					; size = 1
_buf$ = 8						; size = 4
_length$ = 12						; size = 4
_bitdepth$ = 16						; size = 4
_mask_to_bitdepth PROC					; COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 150  :   kvz_pixel bitdepth_mask = (1 << bitdepth) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _bitdepth$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	BYTE PTR _bitdepth_mask$[ebp], al

; 151  :   for (int i = 0; i < length; ++i) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@mask_to_bi
$LN2@mask_to_bi:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@mask_to_bi:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _length$[ebp]
	jae	SHORT $LN1@mask_to_bi

; 152  :     buf[i] = buf[i] & bitdepth_mask;

	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _bitdepth_mask$[ebp]
	and	ecx, edx
	mov	eax, DWORD PTR _buf$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [eax], cl

; 153  :   }

	jmp	SHORT $LN2@mask_to_bi
$LN1@mask_to_bi:

; 154  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_mask_to_bitdepth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _machine_is_big_endian
_TEXT	SEGMENT
tv68 = -224						; size = 4
tv66 = -220						; size = 4
_first_byte$ = -17					; size = 1
_number$ = -8						; size = 2
_machine_is_big_endian PROC				; COMDAT

; 136  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 137  :   // Big and little endianess refers to which end of the egg you prefer to eat
; 138  :   // first. Therefore in big endian system, the most significant bits are in
; 139  :   // the first address.
; 140  : 
; 141  :   uint16_t number = 1;

	mov	eax, 1
	mov	WORD PTR _number$[ebp], ax

; 142  :   char first_byte = *(char*)&number;

	mov	al, BYTE PTR _number$[ebp]
	mov	BYTE PTR _first_byte$[ebp], al

; 143  : 
; 144  :   return (first_byte == 0);

	movsx	eax, BYTE PTR _first_byte$[ebp]
	test	eax, eax
	jne	SHORT $LN3@machine_is
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@machine_is
$LN3@machine_is:
	mov	DWORD PTR tv66[ebp], 0
$LN4@machine_is:
	cmp	DWORD PTR tv66[ebp], 0
	jne	SHORT $LN5@machine_is
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN6@machine_is
$LN5@machine_is:
	mov	DWORD PTR tv68[ebp], 1
$LN6@machine_is:
	mov	al, BYTE PTR tv68[ebp]

; 145  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_machine_is_big_endian ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _shift_to_bitdepth_and_spread
_TEXT	SEGMENT
_i$1 = -44						; size = 4
_bitdepth_mask$ = -29					; size = 1
_byte_buf$ = -20					; size = 4
_shift$ = -8						; size = 4
_input$ = 8						; size = 4
_size$ = 12						; size = 4
_from_bitdepth$ = 16					; size = 4
_to_bitdepth$ = 20					; size = 4
_shift_to_bitdepth_and_spread PROC			; COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 113  :   assert(sizeof(kvz_pixel) > 1);

	xor	eax, eax
	jne	SHORT $LN8@shift_to_b
	mov	ecx, DWORD PTR ?__LINE__Var@?0??shift_to_bitdepth_and_spread@@9@9
	add	ecx, 1
	mov	esi, esp
	push	ecx
	push	OFFSET ??_C@_1GK@GJKGPPFL@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1CM@FBMJPBMB@?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAk?$AAv?$AAz?$AA_?$AAp?$AAi?$AAx?$AAe@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@shift_to_b:

; 114  :   int shift = to_bitdepth - from_bitdepth;

	mov	eax, DWORD PTR _to_bitdepth$[ebp]
	sub	eax, DWORD PTR _from_bitdepth$[ebp]
	mov	DWORD PTR _shift$[ebp], eax

; 115  :   unsigned char *byte_buf = (unsigned char *)input;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR _byte_buf$[ebp], eax

; 116  :   kvz_pixel bitdepth_mask = (1 << from_bitdepth) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _from_bitdepth$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	BYTE PTR _bitdepth_mask$[ebp], al

; 117  :   
; 118  :   // Starting from the back of the 1-byte samples, copy each sample to it's
; 119  :   // place in the 2-byte per sample array, overwriting the bytes that have
; 120  :   // already been copied in the process.
; 121  :   // Even though the two pointers are aliased, this should work because the
; 122  :   // future values read through byte_buf poiner never change as a result of
; 123  :   // writing through input pointer.
; 124  :   for (int i = size - 1; i >= 0; --i) {

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@shift_to_b
$LN2@shift_to_b:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@shift_to_b:
	cmp	DWORD PTR _i$1[ebp], 0
	jl	SHORT $LN1@shift_to_b

; 125  :     // Shifting by a negative number is undefined.
; 126  :     if (shift > 0) {

	cmp	DWORD PTR _shift$[ebp], 0
	jle	SHORT $LN5@shift_to_b

; 127  :       input[i] = (byte_buf[i] & bitdepth_mask) << shift;

	mov	eax, DWORD PTR _byte_buf$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	movzx	edx, BYTE PTR [eax]
	movzx	eax, BYTE PTR _bitdepth_mask$[ebp]
	and	edx, eax
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	ecx, DWORD PTR _input$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [ecx], dl

; 128  :     } else {

	jmp	SHORT $LN6@shift_to_b
$LN5@shift_to_b:

; 129  :       input[i] = (byte_buf[i] & bitdepth_mask) >> shift;

	mov	eax, DWORD PTR _byte_buf$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	movzx	edx, BYTE PTR [eax]
	movzx	eax, BYTE PTR _bitdepth_mask$[ebp]
	and	edx, eax
	mov	ecx, DWORD PTR _shift$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR _input$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [ecx], dl
$LN6@shift_to_b:

; 130  :     }
; 131  :   }

	jmp	SHORT $LN2@shift_to_b
$LN1@shift_to_b:

; 132  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_shift_to_bitdepth_and_spread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _shift_to_bitdepth
_TEXT	SEGMENT
_i$1 = -32						; size = 4
_bitdepth_mask$ = -17					; size = 1
_shift$ = -8						; size = 4
_input$ = 8						; size = 4
_size$ = 12						; size = 4
_from_bitdepth$ = 16					; size = 4
_to_bitdepth$ = 20					; size = 4
_shift_to_bitdepth PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 93   :   int shift = to_bitdepth - from_bitdepth;

	mov	eax, DWORD PTR _to_bitdepth$[ebp]
	sub	eax, DWORD PTR _from_bitdepth$[ebp]
	mov	DWORD PTR _shift$[ebp], eax

; 94   :   kvz_pixel bitdepth_mask = (1 << from_bitdepth) - 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _from_bitdepth$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	BYTE PTR _bitdepth_mask$[ebp], al

; 95   : 
; 96   :   for (int i = 0; i < size; ++i) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@shift_to_b
$LN2@shift_to_b:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@shift_to_b:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN1@shift_to_b

; 97   :     // Shifting by a negative number is undefined.
; 98   :     if (shift > 0) {

	cmp	DWORD PTR _shift$[ebp], 0
	jle	SHORT $LN5@shift_to_b

; 99   :       input[i] = (input[i] & bitdepth_mask) << shift;

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	movzx	edx, BYTE PTR [eax]
	movzx	eax, BYTE PTR _bitdepth_mask$[ebp]
	and	edx, eax
	mov	ecx, DWORD PTR _shift$[ebp]
	shl	edx, cl
	mov	ecx, DWORD PTR _input$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [ecx], dl

; 100  :     } else {

	jmp	SHORT $LN6@shift_to_b
$LN5@shift_to_b:

; 101  :       input[i] = (input[i] & bitdepth_mask) >> shift;

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	movzx	edx, BYTE PTR [eax]
	movzx	eax, BYTE PTR _bitdepth_mask$[ebp]
	and	edx, eax
	mov	ecx, DWORD PTR _shift$[ebp]
	sar	edx, cl
	mov	ecx, DWORD PTR _input$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [ecx], dl
$LN6@shift_to_b:

; 102  :     }
; 103  :   }

	jmp	SHORT $LN2@shift_to_b
$LN1@shift_to_b:

; 104  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_shift_to_bitdepth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _swap_16b_buffer_bytes
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_input$ = 8						; size = 4
_size$ = 12						; size = 4
_swap_16b_buffer_bytes PROC				; COMDAT

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 85   :   for (int i = 0; i < size; ++i) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@swap_16b_b
$LN2@swap_16b_b:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@swap_16b_b:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $LN1@swap_16b_b

; 86   :     input[i] = ((input[i] & 0xff) << 8) + ((input[i] & 0xff00) >> 8);

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 255				; 000000ffH
	shl	ecx, 8
	mov	edx, DWORD PTR _input$[ebp]
	add	edx, DWORD PTR _i$1[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 65280				; 0000ff00H
	sar	eax, 8
	add	ecx, eax
	mov	edx, DWORD PTR _input$[ebp]
	add	edx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [edx], cl

; 87   :   }

	jmp	SHORT $LN2@swap_16b_b
$LN1@swap_16b_b:

; 88   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_swap_16b_buffer_bytes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _read_and_fill_frame_data
_TEXT	SEGMENT
_i$ = -44						; size = 4
_fill_char$ = -29					; size = 1
_end$ = -20						; size = 4
_p$ = -8						; size = 4
_file$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_bytes_per_sample$ = 20					; size = 4
_array_width$ = 24					; size = 4
_data$ = 28						; size = 4
_read_and_fill_frame_data PROC				; COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 60   :   kvz_pixel* p = data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 61   :   kvz_pixel* end = data + array_width * height;

	mov	eax, DWORD PTR _array_width$[ebp]
	imul	eax, DWORD PTR _height$[ebp]
	add	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _end$[ebp], eax
$LN2@read_and_f:

; 62   :   kvz_pixel fill_char;
; 63   :   unsigned i;
; 64   : 
; 65   :   while (p < end) {

	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	SHORT $LN3@read_and_f

; 66   :     // Read the beginning of the line from input.
; 67   :     if (width != fread(p, bytes_per_sample, width, file))

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bytes_per_sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR _width$[ebp], eax
	je	SHORT $LN7@read_and_f

; 68   :       return 0;

	xor	eax, eax
	jmp	SHORT $LN1@read_and_f
$LN7@read_and_f:

; 69   : 
; 70   :     // Fill the rest with the last pixel value.
; 71   :     fill_char = p[width - 1];

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _width$[ebp]
	mov	cl, BYTE PTR [eax-1]
	mov	BYTE PTR _fill_char$[ebp], cl

; 72   : 
; 73   :     for (i = width; i < array_width; ++i) {

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN6@read_and_f
$LN4@read_and_f:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@read_and_f:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _array_width$[ebp]
	jae	SHORT $LN5@read_and_f

; 74   :       p[i] = fill_char;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _fill_char$[ebp]
	mov	BYTE PTR [eax], cl

; 75   :     }

	jmp	SHORT $LN4@read_and_f
$LN5@read_and_f:

; 76   : 
; 77   :     p += array_width;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _array_width$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 78   :   }

	jmp	SHORT $LN2@read_and_f
$LN3@read_and_f:

; 79   :   return 1;

	mov	eax, 1
$LN1@read_and_f:

; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_read_and_fill_frame_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _fill_after_frame
_TEXT	SEGMENT
_end$ = -20						; size = 4
_p$ = -8						; size = 4
_height$ = 8						; size = 4
_array_width$ = 12					; size = 4
_array_height$ = 16					; size = 4
_data$ = 20						; size = 4
_fill_after_frame PROC					; COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 45   :   kvz_pixel* p = data + height * array_width;

	mov	eax, DWORD PTR _height$[ebp]
	imul	eax, DWORD PTR _array_width$[ebp]
	add	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 46   :   kvz_pixel* end = data + array_width * array_height;

	mov	eax, DWORD PTR _array_width$[ebp]
	imul	eax, DWORD PTR _array_height$[ebp]
	add	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR _end$[ebp], eax
$LN2@fill_after:

; 47   : 
; 48   :   while (p < end) {

	mov	eax, DWORD PTR _p$[ebp]
	cmp	eax, DWORD PTR _end$[ebp]
	jae	SHORT $LN1@fill_after

; 49   :     // Fill the line by copying the line above.
; 50   :     memcpy(p, p - array_width, array_width);

	mov	eax, DWORD PTR _array_width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	sub	ecx, DWORD PTR _array_width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 51   :     p += array_width;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, DWORD PTR _array_width$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 52   :   }

	jmp	SHORT $LN2@fill_after
$LN1@fill_after:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_fill_after_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _yuv_io_write
_TEXT	SEGMENT
_y$1 = -44						; size = 4
_y$2 = -32						; size = 4
_y$3 = -20						; size = 4
_width$ = -8						; size = 4
_file$ = 8						; size = 4
_img$ = 12						; size = 4
_output_width$ = 16					; size = 4
_output_height$ = 20					; size = 4
_yuv_io_write PROC					; COMDAT

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 342  :   const int width = img->width;

	mov	eax, DWORD PTR _img$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _width$[ebp], ecx

; 343  :   for (int y = 0; y < output_height; ++y) {

	mov	DWORD PTR _y$3[ebp], 0
	jmp	SHORT $LN4@yuv_io_wri
$LN2@yuv_io_wri:
	mov	eax, DWORD PTR _y$3[ebp]
	add	eax, 1
	mov	DWORD PTR _y$3[ebp], eax
$LN4@yuv_io_wri:
	mov	eax, DWORD PTR _y$3[ebp]
	cmp	eax, DWORD PTR _output_height$[ebp]
	jae	SHORT $LN3@yuv_io_wri

; 344  :     fwrite(&img->y[y * width], sizeof(*img->y), output_width, file);

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output_width$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _y$3[ebp]
	imul	edx, DWORD PTR _width$[ebp]
	mov	eax, DWORD PTR _img$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, edx
	push	ecx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 345  :     // TODO: Check that fwrite succeeded.
; 346  :   }

	jmp	SHORT $LN2@yuv_io_wri
$LN3@yuv_io_wri:

; 347  : 
; 348  :   if (img->chroma_format != KVZ_CSP_400) {

	mov	eax, DWORD PTR _img$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN11@yuv_io_wri

; 349  :     for (int y = 0; y < output_height / 2; ++y) {

	mov	DWORD PTR _y$2[ebp], 0
	jmp	SHORT $LN7@yuv_io_wri
$LN5@yuv_io_wri:
	mov	eax, DWORD PTR _y$2[ebp]
	add	eax, 1
	mov	DWORD PTR _y$2[ebp], eax
$LN7@yuv_io_wri:
	mov	eax, DWORD PTR _output_height$[ebp]
	shr	eax, 1
	cmp	DWORD PTR _y$2[ebp], eax
	jae	SHORT $LN6@yuv_io_wri

; 350  :       fwrite(&img->u[y * width / 2], sizeof(*img->u), output_width / 2, file);

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output_width$[ebp]
	shr	ecx, 1
	push	ecx
	push	1
	mov	eax, DWORD PTR _y$2[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _img$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	add	ecx, eax
	push	ecx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 351  :     }

	jmp	SHORT $LN5@yuv_io_wri
$LN6@yuv_io_wri:

; 352  :     for (int y = 0; y < output_height / 2; ++y) {

	mov	DWORD PTR _y$1[ebp], 0
	jmp	SHORT $LN10@yuv_io_wri
$LN8@yuv_io_wri:
	mov	eax, DWORD PTR _y$1[ebp]
	add	eax, 1
	mov	DWORD PTR _y$1[ebp], eax
$LN10@yuv_io_wri:
	mov	eax, DWORD PTR _output_height$[ebp]
	shr	eax, 1
	cmp	DWORD PTR _y$1[ebp], eax
	jae	SHORT $LN11@yuv_io_wri

; 353  :       fwrite(&img->v[y * width / 2], sizeof(*img->v), output_width / 2, file);

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output_width$[ebp]
	shr	ecx, 1
	push	ecx
	push	1
	mov	eax, DWORD PTR _y$1[ebp]
	imul	eax, DWORD PTR _width$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _img$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	add	ecx, eax
	push	ecx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 354  :     }

	jmp	SHORT $LN8@yuv_io_wri
$LN11@yuv_io_wri:

; 355  :   }
; 356  : 
; 357  :   return 1;

	mov	eax, 1

; 358  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_yuv_io_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _yuv_io_seek
_TEXT	SEGMENT
tv135 = -18012						; size = 4
tv129 = -18012						; size = 4
tv90 = -18012						; size = 4
_skip$1 = -16468					; size = 4
_bytes_left$ = -16456					; size = 4
_tmp$ = -16444						; size = 16384
_error$ = -52						; size = 4
_skip_bytes$ = -40					; size = 8
_i$2 = -24						; size = 4
_frame_bytes$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_file$ = 8						; size = 4
_frames$ = 12						; size = 4
_input_width$ = 16					; size = 4
_input_height$ = 20					; size = 4
_file_format$ = 24					; size = 4
_yuv_io_seek PROC					; COMDAT

; 297  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 18012				; 0000465cH
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-18012]
	mov	ecx, 4503				; 00001197H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 298  :     const size_t frame_bytes = input_width * input_height * 3 / 2;

	mov	eax, DWORD PTR _input_width$[ebp]
	imul	eax, DWORD PTR _input_height$[ebp]
	imul	ecx, eax, 3
	shr	ecx, 1
	mov	DWORD PTR _frame_bytes$[ebp], ecx

; 299  : 
; 300  :     if (file_format == KVZ_FORMAT_Y4M) {

	cmp	DWORD PTR _file_format$[ebp], 1
	jne	SHORT $LN7@yuv_io_see

; 301  :       for (unsigned i = 0; i < frames; i++) {

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@yuv_io_see
$LN2@yuv_io_see:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@yuv_io_see:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _frames$[ebp]
	jae	SHORT $LN3@yuv_io_see

; 302  :         if (!read_frame_header(file)) return 0;

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_read_frame_header
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@yuv_io_see
	xor	eax, eax
	jmp	$LN1@yuv_io_see
$LN8@yuv_io_see:

; 303  :         if (fseek(file, frame_bytes, SEEK_CUR)) return 0;

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _frame_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN9@yuv_io_see
	xor	eax, eax
	jmp	$LN1@yuv_io_see
$LN9@yuv_io_see:

; 304  :       }

	jmp	SHORT $LN2@yuv_io_see
$LN3@yuv_io_see:

; 305  :       return 1;

	mov	eax, 1
	jmp	$LN1@yuv_io_see
$LN7@yuv_io_see:

; 306  :     }
; 307  : 
; 308  :     const int64_t skip_bytes = (int64_t)(frames * frame_bytes);

	mov	eax, DWORD PTR _frames$[ebp]
	imul	eax, DWORD PTR _frame_bytes$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _skip_bytes$[ebp], eax
	mov	DWORD PTR _skip_bytes$[ebp+4], ecx

; 309  : 
; 310  :     // Attempt to seek normally.
; 311  :     size_t error = fseek(file, skip_bytes, SEEK_CUR);

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _skip_bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _error$[ebp], eax

; 312  :     if (!error) return 1;

	cmp	DWORD PTR _error$[ebp], 0
	jne	SHORT $LN10@yuv_io_see
	mov	eax, 1
	jmp	$LN1@yuv_io_see
$LN10@yuv_io_see:

; 313  : 
; 314  :     // Seek failed. Skip data by reading.
; 315  :     error = 0;

	mov	DWORD PTR _error$[ebp], 0

; 316  :     unsigned char* tmp[4096];
; 317  :     size_t bytes_left = skip_bytes;

	mov	eax, DWORD PTR _skip_bytes$[ebp]
	mov	DWORD PTR _bytes_left$[ebp], eax
$LN5@yuv_io_see:

; 318  :     while (bytes_left > 0 && !error) {

	cmp	DWORD PTR _bytes_left$[ebp], 0
	jbe	$LN6@yuv_io_see
	cmp	DWORD PTR _error$[ebp], 0
	jne	$LN6@yuv_io_see

; 319  :       const size_t skip = MIN(4096, bytes_left);

	cmp	DWORD PTR _bytes_left$[ebp], 4096	; 00001000H
	jbe	SHORT $LN12@yuv_io_see
	mov	DWORD PTR tv90[ebp], 4096		; 00001000H
	jmp	SHORT $LN13@yuv_io_see
$LN12@yuv_io_see:
	mov	eax, DWORD PTR _bytes_left$[ebp]
	mov	DWORD PTR tv90[ebp], eax
$LN13@yuv_io_see:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _skip$1[ebp], ecx

; 320  :       error = fread(tmp, sizeof(unsigned char), skip, file) != skip;

	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _skip$1[ebp]
	push	ecx
	push	1
	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR _skip$1[ebp]
	je	SHORT $LN14@yuv_io_see
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN15@yuv_io_see
$LN14@yuv_io_see:
	mov	DWORD PTR tv129[ebp], 0
$LN15@yuv_io_see:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR _error$[ebp], eax

; 321  :       bytes_left -= skip;

	mov	eax, DWORD PTR _bytes_left$[ebp]
	sub	eax, DWORD PTR _skip$1[ebp]
	mov	DWORD PTR _bytes_left$[ebp], eax

; 322  :     }

	jmp	$LN5@yuv_io_see
$LN6@yuv_io_see:

; 323  : 
; 324  :     return !error || feof(file);

	cmp	DWORD PTR _error$[ebp], 0
	je	SHORT $LN16@yuv_io_see
	mov	esi, esp
	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	DWORD PTR __imp__feof
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN16@yuv_io_see
	mov	DWORD PTR tv135[ebp], 0
	jmp	SHORT $LN17@yuv_io_see
$LN16@yuv_io_see:
	mov	DWORD PTR tv135[ebp], 1
$LN17@yuv_io_see:
	mov	eax, DWORD PTR tv135[ebp]
$LN1@yuv_io_see:

; 325  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@yuv_io_see
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 18012				; 0000465cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@yuv_io_see:
	DD	1
	DD	$LN19@yuv_io_see
$LN19@yuv_io_see:
	DD	-16444					; ffffbfc4H
	DD	16384					; 00004000H
	DD	$LN18@yuv_io_see
$LN18@yuv_io_see:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_yuv_io_seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File F:\open_codec_learn_2021\kvazaar-master\src\yuv_io.c
;	COMDAT _yuv_io_read
_TEXT	SEGMENT
_uv_height_out$1 = -56					; size = 4
_uv_width_out$2 = -44					; size = 4
_uv_height_in$3 = -32					; size = 4
_uv_width_in$4 = -20					; size = 4
_ok$ = -8						; size = 4
_file$ = 8						; size = 4
_in_width$ = 12						; size = 4
_out_width$ = 16					; size = 4
_in_bitdepth$ = 20					; size = 4
_out_bitdepth$ = 24					; size = 4
_img_out$ = 28						; size = 4
_file_format$ = 32					; size = 4
_yuv_io_read PROC					; COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __964E3860_yuv_io@c
	call	@__CheckForDebuggerJustMyCode@4

; 240  :   assert(in_width % 2 == 0);

	mov	eax, DWORD PTR _in_width$[ebp]
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	test	edx, edx
	je	SHORT $LN9@yuv_io_rea
	mov	edx, DWORD PTR ?__LINE__Var@?0??yuv_io_read@@9@9
	add	edx, 1
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1GK@GJKGPPFL@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1CE@DNDNGCON@?$AAi?$AAn?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN?$AA?$DN@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@yuv_io_rea:

; 241  :   assert(out_width % 2 == 0);

	mov	eax, DWORD PTR _out_width$[ebp]
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	test	edx, edx
	je	SHORT $LN10@yuv_io_rea
	mov	edx, DWORD PTR ?__LINE__Var@?0??yuv_io_read@@9@9
	add	edx, 2
	mov	esi, esp
	push	edx
	push	OFFSET ??_C@_1GK@GJKGPPFL@?$AAF?$AA?3?$AA?2?$AAo?$AAp?$AAe?$AAn?$AA_?$AAc?$AAo?$AAd?$AAe?$AAc?$AA_?$AAl@
	push	OFFSET ??_C@_1CG@FPGHNEAG@?$AAo?$AAu?$AAt?$AA_?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA2?$AA?5?$AA?$DN@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@yuv_io_rea:

; 242  : 
; 243  :   int ok;
; 244  : 
; 245  :   if (file_format == KVZ_FORMAT_Y4M) {

	cmp	DWORD PTR _file_format$[ebp], 1
	jne	SHORT $LN2@yuv_io_rea

; 246  :     ok = read_frame_header(file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	call	_read_frame_header
	add	esp, 4
	mov	DWORD PTR _ok$[ebp], eax

; 247  :     if (!ok) return 0;

	cmp	DWORD PTR _ok$[ebp], 0
	jne	SHORT $LN2@yuv_io_rea
	xor	eax, eax
	jmp	$LN1@yuv_io_rea
$LN2@yuv_io_rea:

; 248  :   }
; 249  : 
; 250  :   
; 251  : 
; 252  :   ok = yuv_io_read_plane(

	mov	eax, DWORD PTR _img_out$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _out_bitdepth$[ebp]
	push	edx
	mov	eax, DWORD PTR _img_out$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _img_out$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _in_bitdepth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_width$[ebp]
	push	edx
	mov	eax, DWORD PTR _in_width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_yuv_io_read_plane
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ok$[ebp], eax

; 253  :       file, 
; 254  :       in_width, out_width, in_bitdepth,
; 255  :       img_out->width, img_out->height, out_bitdepth,
; 256  :       img_out->y);
; 257  :   if (!ok) return 0;

	cmp	DWORD PTR _ok$[ebp], 0
	jne	SHORT $LN4@yuv_io_rea
	xor	eax, eax
	jmp	$LN1@yuv_io_rea
$LN4@yuv_io_rea:

; 258  : 
; 259  :   if (img_out->chroma_format != KVZ_CSP_400) {

	mov	eax, DWORD PTR _img_out$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	$LN5@yuv_io_rea

; 260  :     unsigned uv_width_in = in_width / 2;

	mov	eax, DWORD PTR _in_width$[ebp]
	shr	eax, 1
	mov	DWORD PTR _uv_width_in$4[ebp], eax

; 261  :     unsigned uv_height_in = out_width / 2;

	mov	eax, DWORD PTR _out_width$[ebp]
	shr	eax, 1
	mov	DWORD PTR _uv_height_in$3[ebp], eax

; 262  :     unsigned uv_width_out = img_out->width / 2;

	mov	eax, DWORD PTR _img_out$[ebp]
	mov	eax, DWORD PTR [eax+32]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _uv_width_out$2[ebp], eax

; 263  :     unsigned uv_height_out = img_out->height / 2;

	mov	eax, DWORD PTR _img_out$[ebp]
	mov	eax, DWORD PTR [eax+36]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _uv_height_out$1[ebp], eax

; 264  : 
; 265  :     ok = yuv_io_read_plane(

	mov	eax, DWORD PTR _img_out$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _out_bitdepth$[ebp]
	push	edx
	mov	eax, DWORD PTR _uv_height_out$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _uv_width_out$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _in_bitdepth$[ebp]
	push	edx
	mov	eax, DWORD PTR _uv_height_in$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _uv_width_in$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_yuv_io_read_plane
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ok$[ebp], eax

; 266  :         file,
; 267  :         uv_width_in, uv_height_in, in_bitdepth,
; 268  :         uv_width_out, uv_height_out, out_bitdepth,
; 269  :         img_out->u);
; 270  :     if (!ok) return 0;

	cmp	DWORD PTR _ok$[ebp], 0
	jne	SHORT $LN6@yuv_io_rea
	xor	eax, eax
	jmp	SHORT $LN1@yuv_io_rea
$LN6@yuv_io_rea:

; 271  : 
; 272  :     ok = yuv_io_read_plane(

	mov	eax, DWORD PTR _img_out$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _out_bitdepth$[ebp]
	push	edx
	mov	eax, DWORD PTR _uv_height_out$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _uv_width_out$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _in_bitdepth$[ebp]
	push	edx
	mov	eax, DWORD PTR _uv_height_in$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _uv_width_in$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	call	_yuv_io_read_plane
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ok$[ebp], eax

; 273  :         file, 
; 274  :         uv_width_in, uv_height_in, in_bitdepth,
; 275  :         uv_width_out, uv_height_out, out_bitdepth,
; 276  :         img_out->v);
; 277  :     if (!ok) return 0;

	cmp	DWORD PTR _ok$[ebp], 0
	jne	SHORT $LN5@yuv_io_rea
	xor	eax, eax
	jmp	SHORT $LN1@yuv_io_rea
$LN5@yuv_io_rea:

; 278  :   }
; 279  :   
; 280  :   return 1;

	mov	eax, 1
$LN1@yuv_io_rea:

; 281  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_yuv_io_read ENDP
_TEXT	ENDS
END
