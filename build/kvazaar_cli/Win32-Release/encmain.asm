; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

	TITLE	c:\users\84038\desktop\video_codec_thread_test\src\encmain.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__malloc:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp____acrt_iob_func:PROC
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
PUBLIC	_main
PUBLIC	_task_test
PUBLIC	_printf
PUBLIC	_fprintf
PUBLIC	__vfprintf_l
PUBLIC	___local_stdio_printf_options
PUBLIC	__xmm@00000003000000020000000100000000
PUBLIC	__xmm@00000007000000060000000500000004
PUBLIC	__xmm@0000000b0000000a0000000900000008
PUBLIC	__xmm@0000000f0000000e0000000d0000000c
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT __xmm@0000000f0000000e0000000d0000000c
CONST	SEGMENT
__xmm@0000000f0000000e0000000d0000000c DB 0cH, 00H, 00H, 00H, 0dH, 00H, 00H
	DB	00H, 0eH, 00H, 00H, 00H, 0fH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000b0000000a0000000900000008
CONST	SEGMENT
__xmm@0000000b0000000a0000000900000008 DB 08H, 00H, 00H, 00H, 09H, 00H, 00H
	DB	00H, 0aH, 00H, 00H, 00H, 0bH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000007000000060000000500000004
CONST	SEGMENT
__xmm@00000007000000060000000500000004 DB 04H, 00H, 00H, 00H, 05H, 00H, 00H
	DB	00H, 06H, 00H, 00H, 00H, 07H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000020000000100000000
CONST	SEGMENT
__xmm@00000003000000020000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
$SG4294967287 DB '@@@@@@@@@@@@@@@ theradqueue test end!', 0aH, 00H
	ORG $+1
$SG4294967288 DB 'Could not initialize threadqueue.', 0aH, 00H
	ORG $+1
$SG4294967289 DB '@@@@@@@@@@@@@@@ theradqueue test start!', 0aH, 00H
	ORG $+3
$SG4294967290 DB 'input number is %d in fuction <%s>', 0aH, 00H
$SG4294967291 DB 'task_test', 00H
__ehfuncinfo$_main DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vfprintf_l PROC					; COMDAT
; __Stream$ = ecx
; __Format$ = edx

; 642  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	edx
	push	ecx
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 644  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __Stream$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);
; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;
; 842  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	esi

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);
; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	esi, DWORD PTR __Format$[ebp]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	lea	ecx, DWORD PTR __Format$[ebp+4]
	push	ecx
	push	0
	push	esi
	push	eax
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;
; 961  :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c
_TEXT	SEGMENT
_arg$ = 8						; size = 4
_task_test PROC

; 26   : 	int* input = (int*)arg;
; 27   : 
; 28   : 	printf("input number is %d in fuction <%s>\n", *input, __FUNCTION__);

	mov	eax, DWORD PTR _arg$[esp-4]
	push	OFFSET $SG4294967291
	push	DWORD PTR [eax]
	push	OFFSET $SG4294967290
	call	_printf
	add	esp, 12					; 0000000cH

; 29   : 	return;
; 30   : }

	ret	0
_task_test ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadwrapper\src\pthread.cpp
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c
_TEXT	SEGMENT
_input$ = -112						; size = 80
_test_jobs$1$ = -28					; size = 4
tv1155 = -24						; size = 4
tv1156 = -20						; size = 4
_i$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 40   : {

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$_main
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 41   : 	printf("@@@@@@@@@@@@@@@ theradqueue test start!\n");

	push	OFFSET $SG4294967289
	call	_printf
	add	esp, 4

; 42   : 	int threads_cnt = 4;//设置线程个数
; 43   : 
; 44   : 	//初始化线程队列
; 45   : 	threadqueue_queue_t* threadqueue = kvz_threadqueue_init(threads_cnt);

	call	_kvz_threadqueue_init
	mov	ebx, eax

; 46   : 	if (!threadqueue)

	test	ebx, ebx
	jne	SHORT $LN11@main

; 47   : 	{
; 48   : 		fprintf(stderr, "Could not initialize threadqueue.\n");

	push	OFFSET $SG4294967288
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 49   : 		return -1;

	or	eax, -1

; 90   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@main:

; 50   : 	}
; 51   : 
; 52   : 	int num_jobs = 10;//设置job个数
; 53   : 	threadqueue_job_t** test_jobs = MALLOC(threadqueue_job_t*, num_jobs);

	mov	edi, DWORD PTR __imp__malloc
	push	40					; 00000028H
	call	edi

; 54   : 	for (int i = 0; i < num_jobs; ++i) 
; 55   : 	{
; 56   : 		test_jobs[i] = NULL;
; 57   : 	}
; 58   : 
; 59   : 	int input[20];
; 60   : 	for (int i = 0;i < 20;i++)
; 61   : 	{
; 62   : 		input[i] = i;

	movaps	xmm0, XMMWORD PTR __xmm@00000003000000020000000100000000
	mov	ecx, eax
	movups	XMMWORD PTR _input$[ebp], xmm0
	add	esp, 4
	mov	DWORD PTR _test_jobs$1$[ebp], ecx
	movaps	xmm0, XMMWORD PTR __xmm@00000007000000060000000500000004
	mov	eax, 16					; 00000010H
	movups	XMMWORD PTR _input$[ebp+16], xmm0
	mov	DWORD PTR [ecx], 0
	movaps	xmm0, XMMWORD PTR __xmm@0000000b0000000a0000000900000008
	movups	XMMWORD PTR _input$[ebp+32], xmm0
	mov	DWORD PTR [ecx+4], 0
	movaps	xmm0, XMMWORD PTR __xmm@0000000f0000000e0000000d0000000c
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	movups	XMMWORD PTR _input$[ebp+48], xmm0
	npad	5
$LL165@main:
	mov	DWORD PTR _input$[ebp+eax*4], eax
	inc	eax
	cmp	eax, 20					; 00000014H
	jl	SHORT $LL165@main

; 65   : 	for (int i = 0;i < num_jobs;i++)

	lea	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR _i$1$[ebp], 0
	mov	esi, ecx
	sub	eax, ecx
	mov	DWORD PTR tv1156[ebp], esi
	mov	DWORD PTR tv1155[ebp], eax
	npad	2
$LL10@main:
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c

; 433  :   threadqueue_job_t *job = MALLOC(threadqueue_job_t, 1);

	push	40					; 00000028H
	call	edi
	mov	edi, eax
	add	esp, 4

; 434  :   if (!job) {

	test	edi, edi
	jne	SHORT $LN14@main

; 435  :     fprintf(stderr, "Could not alloc job!\n");

	push	OFFSET $SG4294967030
	push	2
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 436  :     return NULL;

	jmp	SHORT $LN13@main
$LN14@main:
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	push	2
	push	esi
	call	DWORD PTR __imp___Mtx_init_in_situ
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c

; 451  :   job->arg            = arg;

	mov	eax, DWORD PTR tv1155[ebp]
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	add	esp, 12					; 0000000cH
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	DWORD PTR [edi], esi
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c

; 451  :   job->arg            = arg;

	mov	esi, DWORD PTR tv1156[ebp]
	add	eax, esi
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
	mov	DWORD PTR [edi+24], 1
	mov	DWORD PTR [edi+28], OFFSET _task_test
	mov	DWORD PTR [edi+32], eax
$LN13@main:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	push	DWORD PTR [ebx]
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c

; 68   : 		test_jobs[i] = kvz_threadqueue_job_create(task_test, (void*)arg);//创建job

	mov	DWORD PTR [esi], edi
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	call	DWORD PTR __imp___Mtx_lock
	add	esp, 4
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	jne	$LN156@main
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	push	DWORD PTR [edi]
	call	DWORD PTR __imp___Mtx_lock
	add	esp, 4
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	jne	$LN156@main
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c

; 461  :   assert(job->state == THREADQUEUE_JOB_STATE_PAUSED);

	cmp	DWORD PTR [edi+4], eax
	je	SHORT $LN38@main
	push	461					; 000001cdH
	push	OFFSET $SG4294967020
	push	OFFSET $SG4294967019
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN38@main:

; 462  : 
; 463  :   if (threadqueue->thread_count == 0) 

	cmp	DWORD PTR [ebx+16], 0
	jne	SHORT $LN29@main

; 464  :   {
; 465  :     // When not using threads, run the job immediately.
; 466  :     job->fptr(job->arg);

	push	DWORD PTR [edi+32]
	mov	eax, DWORD PTR [edi+28]
	call	eax
	add	esp, 4

; 467  :     job->state = THREADQUEUE_JOB_STATE_DONE;

	mov	DWORD PTR [edi+4], 4

; 468  :   } 

	jmp	$LN32@main
$LN29@main:

; 469  :   else if (job->ndepends == 0) 

	cmp	DWORD PTR [edi+8], 0
	jne	$LN31@main

; 531  :   int32_t new_refcount = KVZ_ATOMIC_INC(&job->refcount);

	mov	eax, 1
	lock	 xadd	 DWORD PTR [edi+24], eax
	inc	eax

; 532  :   // The caller should have had another reference and we added one
; 533  :   // reference so refcount should be at least 2.
; 534  :   assert(new_refcount >= 2);

	cmp	eax, 2
	jge	SHORT $LN62@main
	push	534					; 00000216H
	push	OFFSET $SG4294966990
	push	OFFSET $SG4294966989
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN62@main:

; 241  :   assert(job->ndepends == 0);

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN67@main
	push	241					; 000000f1H
	push	OFFSET $SG4294967104
	push	OFFSET $SG4294967103
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN67@main:

; 242  :   job->state = THREADQUEUE_JOB_STATE_READY;

	mov	DWORD PTR [edi+4], 2

; 243  : 
; 244  :   if (threadqueue->first == NULL) //如果没有job转备好

	cmp	DWORD PTR [ebx+28], 0
	jne	SHORT $LN64@main

; 245  :   {
; 246  :     threadqueue->first = job;

	mov	DWORD PTR [ebx+28], edi

; 247  :   } 

	jmp	SHORT $LN65@main
$LN64@main:

; 248  :   else 
; 249  :   {
; 250  :     threadqueue->last->next = job;//尾插法

	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR [eax+36], edi
$LN65@main:

; 251  :   }
; 252  : 
; 253  :   threadqueue->last = job;

	mov	DWORD PTR [ebx+32], edi

; 254  :   job->next = NULL;

	mov	DWORD PTR [edi+36], 0
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 588  :     void notify_one() noexcept { // wake up one waiter

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 589  :         _Check_C_return(_Cnd_signal(_Mycnd()));

	push	DWORD PTR [ebx+4]
	call	DWORD PTR __imp___Cnd_signal
	add	esp, 4
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	jne	SHORT $LN156@main
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 590  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c

; 473  :   } 

	jmp	SHORT $LN32@main
$LN31@main:

; 474  :   else 
; 475  :   {
; 476  :     job->state = THREADQUEUE_JOB_STATE_WAITING;

	mov	DWORD PTR [edi+4], 1
$LN32@main:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	push	DWORD PTR [edi]
	mov	edi, DWORD PTR __imp___Mtx_unlock
	call	edi
	add	esp, 4
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	jne	SHORT $LN156@main
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	push	DWORD PTR [ebx]
	call	edi
	add	esp, 4
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	jne	SHORT $LN156@main
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c

; 65   : 	for (int i = 0;i < num_jobs;i++)

	mov	eax, DWORD PTR _i$1$[ebp]
	add	esi, 4
	inc	eax
	mov	DWORD PTR tv1156[ebp], esi
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN191@main
	mov	edi, DWORD PTR __imp__malloc
	jmp	$LL10@main
$LN191@main:

; 69   : 
; 70   : 		//添加job之间的依赖关系
; 71   : 		//if (i > 0) 
; 72   : 		//{
; 73   : 		//	kvz_threadqueue_job_dep_add(test_jobs[i], test_jobs[i - 1]);
; 74   : 		//}	
; 75   : 
; 76   : 		//提交job去执行
; 77   : 		kvz_threadqueue_submit(threadqueue, test_jobs[i]);
; 78   : 	}
; 79   : 
; 80   : 	//等待最后一个job执行完成
; 81   : 	kvz_threadqueue_waitfor(threadqueue, test_jobs[num_jobs - 1]);

	mov	esi, DWORD PTR _test_jobs$1$[ebp]
	mov	esi, DWORD PTR [esi+36]
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	push	DWORD PTR [esi]
	call	DWORD PTR __imp___Mtx_lock
	add	esp, 4
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN112@main
$LN156@main:
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c

; 90   : }

	push	eax
	call	DWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
$LN112@main:
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c

; 580  :   while (job->state != THREADQUEUE_JOB_STATE_DONE) {

	cmp	DWORD PTR [esi+4], 4
	je	SHORT $LN99@main
	mov	edi, DWORD PTR __imp___Cnd_wait
$LL98@main:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 598  :         _Check_C_return(_Cnd_wait(_Mycnd(), _Lck.mutex()->_Mymtx()));

	push	DWORD PTR [esi]
	push	DWORD PTR [ebx+8]
	call	edi
	add	esp, 8
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	jne	SHORT $LN156@main
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 190  :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Users\84038\Desktop\video_codec_thread_test\src\threadqueue.c

; 580  :   while (job->state != THREADQUEUE_JOB_STATE_DONE) {

	cmp	DWORD PTR [esi+4], 4
	jne	SHORT $LL98@main

; 581  :     PTHREAD_COND_WAIT(&threadqueue->job_done, &job->lock);

	mov	edi, DWORD PTR __imp___Mtx_unlock
$LN99@main:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	push	DWORD PTR [esi]
	call	edi
	add	esp, 4
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN146@main

; 131  :         _Throw_C_error(_Res);

	push	eax
	call	DWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
$LN146@main:
; File C:\Users\84038\Desktop\video_codec_thread_test\src\encmain.c

; 85   : 	kvz_threadqueue_free(threadqueue);

	mov	ecx, ebx
	call	_kvz_threadqueue_free

; 86   : 	threadqueue = NULL;
; 87   : 
; 88   : 	printf("@@@@@@@@@@@@@@@ theradqueue test end!\n");

	push	OFFSET $SG4294967287
	call	_printf

; 90   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN193@main:
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$_main:
	npad	1
	npad	1
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
END
