; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
?priorityList0@?6??kvz_inter_get_merge_cand@@9@9 DB 00H	; `kvz_inter_get_merge_cand'::`7'::priorityList0
	DB	01H
	DB	00H
	DB	02H
	DB	01H
	DB	02H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	02H
	DB	03H
	ORG $+4
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
?priorityList1@?6??kvz_inter_get_merge_cand@@9@9 DB 01H	; `kvz_inter_get_merge_cand'::`7'::priorityList1
	DB	00H
	DB	02H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	02H
	ORG $+4
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
PUBLIC	kvz_inter_get_merge_cand
PUBLIC	kvz_inter_get_mv_cand
PUBLIC	kvz_inter_pred_pu
PUBLIC	kvz_inter_recon_bipred
PUBLIC	kvz_inter_recon_cu
PUBLIC	kvz_inter_get_mv_cand_cua
pdata	SEGMENT
$pdata$kvz_inter_get_merge_cand DD imagerel $LN230
	DD	imagerel $LN230+29
	DD	imagerel $unwind$kvz_inter_get_merge_cand
$pdata$1$kvz_inter_get_merge_cand DD imagerel $LN230+29
	DD	imagerel $LN230+1887
	DD	imagerel $chain$1$kvz_inter_get_merge_cand
$pdata$2$kvz_inter_get_merge_cand DD imagerel $LN230+1887
	DD	imagerel $LN230+1938
	DD	imagerel $chain$2$kvz_inter_get_merge_cand
$pdata$5$kvz_inter_get_merge_cand DD imagerel $LN230+1938
	DD	imagerel $LN230+2264
	DD	imagerel $chain$5$kvz_inter_get_merge_cand
$pdata$6$kvz_inter_get_merge_cand DD imagerel $LN230+2264
	DD	imagerel $LN230+2452
	DD	imagerel $chain$6$kvz_inter_get_merge_cand
$pdata$add_merge_candidate DD imagerel add_merge_candidate
	DD	imagerel add_merge_candidate+342
	DD	imagerel $unwind$add_merge_candidate
$pdata$kvz_inter_get_mv_cand DD imagerel $LN159
	DD	imagerel $LN159+264
	DD	imagerel $unwind$kvz_inter_get_mv_cand
$pdata$get_mv_cand_from_candidates DD imagerel get_mv_cand_from_candidates
	DD	imagerel get_mv_cand_from_candidates+1278
	DD	imagerel $unwind$get_mv_cand_from_candidates
$pdata$add_mvp_candidate DD imagerel add_mvp_candidate
	DD	imagerel add_mvp_candidate+350
	DD	imagerel $unwind$add_mvp_candidate
$pdata$add_temporal_candidate DD imagerel add_temporal_candidate
	DD	imagerel add_temporal_candidate+57
	DD	imagerel $unwind$add_temporal_candidate
$pdata$1$add_temporal_candidate DD imagerel add_temporal_candidate+57
	DD	imagerel add_temporal_candidate+262
	DD	imagerel $chain$1$add_temporal_candidate
$pdata$2$add_temporal_candidate DD imagerel add_temporal_candidate+262
	DD	imagerel add_temporal_candidate+280
	DD	imagerel $chain$2$add_temporal_candidate
$pdata$apply_mv_scaling DD imagerel apply_mv_scaling
	DD	imagerel apply_mv_scaling+98
	DD	imagerel $unwind$apply_mv_scaling
$pdata$get_spatial_merge_candidates_cua DD imagerel get_spatial_merge_candidates_cua
	DD	imagerel get_spatial_merge_candidates_cua+355
	DD	imagerel $unwind$get_spatial_merge_candidates_cua
$pdata$get_spatial_merge_candidates DD imagerel get_spatial_merge_candidates
	DD	imagerel get_spatial_merge_candidates+751
	DD	imagerel $unwind$get_spatial_merge_candidates
$pdata$get_temporal_merge_candidates DD imagerel get_temporal_merge_candidates
	DD	imagerel get_temporal_merge_candidates+76
	DD	imagerel $unwind$get_temporal_merge_candidates
$pdata$2$get_temporal_merge_candidates DD imagerel get_temporal_merge_candidates+76
	DD	imagerel get_temporal_merge_candidates+328
	DD	imagerel $chain$2$get_temporal_merge_candidates
$pdata$3$get_temporal_merge_candidates DD imagerel get_temporal_merge_candidates+328
	DD	imagerel get_temporal_merge_candidates+338
	DD	imagerel $chain$3$get_temporal_merge_candidates
$pdata$is_b0_cand_coded DD imagerel is_b0_cand_coded
	DD	imagerel is_b0_cand_coded+129
	DD	imagerel $unwind$is_b0_cand_coded
$pdata$is_a0_cand_coded DD imagerel is_a0_cand_coded
	DD	imagerel is_a0_cand_coded+137
	DD	imagerel $unwind$is_a0_cand_coded
$pdata$kvz_inter_pred_pu DD imagerel $LN6
	DD	imagerel $LN6+624
	DD	imagerel $unwind$kvz_inter_pred_pu
$pdata$kvz_inter_recon_bipred DD imagerel $LN4
	DD	imagerel $LN4+525
	DD	imagerel $unwind$kvz_inter_recon_bipred
$pdata$inter_recon_unipred DD imagerel inter_recon_unipred
	DD	imagerel inter_recon_unipred+2273
	DD	imagerel $unwind$inter_recon_unipred
$pdata$inter_cp_with_ext_border DD imagerel inter_cp_with_ext_border
	DD	imagerel inter_cp_with_ext_border+72
	DD	imagerel $unwind$inter_cp_with_ext_border
$pdata$3$inter_cp_with_ext_border DD imagerel inter_cp_with_ext_border+72
	DD	imagerel inter_cp_with_ext_border+290
	DD	imagerel $chain$3$inter_cp_with_ext_border
$pdata$4$inter_cp_with_ext_border DD imagerel inter_cp_with_ext_border+290
	DD	imagerel inter_cp_with_ext_border+302
	DD	imagerel $chain$4$inter_cp_with_ext_border
$pdata$inter_recon_frac_chroma_hi DD imagerel inter_recon_frac_chroma_hi
	DD	imagerel inter_recon_frac_chroma_hi+519
	DD	imagerel $unwind$inter_recon_frac_chroma_hi
$pdata$inter_recon_frac_chroma DD imagerel inter_recon_frac_chroma
	DD	imagerel inter_recon_frac_chroma+519
	DD	imagerel $unwind$inter_recon_frac_chroma
$pdata$inter_recon_frac_luma_hi DD imagerel inter_recon_frac_luma_hi
	DD	imagerel inter_recon_frac_luma_hi+370
	DD	imagerel $unwind$inter_recon_frac_luma_hi
$pdata$inter_recon_frac_luma DD imagerel inter_recon_frac_luma
	DD	imagerel inter_recon_frac_luma+370
	DD	imagerel $unwind$inter_recon_frac_luma
$pdata$kvz_inter_recon_cu DD imagerel $LN15
	DD	imagerel $LN15+123
	DD	imagerel $unwind$kvz_inter_recon_cu
$pdata$4$kvz_inter_recon_cu DD imagerel $LN15+123
	DD	imagerel $LN15+761
	DD	imagerel $chain$4$kvz_inter_recon_cu
$pdata$5$kvz_inter_recon_cu DD imagerel $LN15+761
	DD	imagerel $LN15+773
	DD	imagerel $chain$5$kvz_inter_recon_cu
$pdata$kvz_inter_get_mv_cand_cua DD imagerel $LN117
	DD	imagerel $LN117+564
	DD	imagerel $unwind$kvz_inter_get_mv_cand_cua
xdata	SEGMENT
$unwind$kvz_inter_get_merge_cand DD 081d01H
	DD	019011dH
	DD	0d014f016H
	DD	060117012H
	DD	0300f5010H
$chain$1$kvz_inter_get_merge_cand DD 040b21H
	DD	017e40bH
	DD	018c404H
	DD	imagerel $LN230
	DD	imagerel $LN230+29
	DD	imagerel $unwind$kvz_inter_get_merge_cand
$chain$2$kvz_inter_get_merge_cand DD 021H
	DD	imagerel $LN230
	DD	imagerel $LN230+29
	DD	imagerel $unwind$kvz_inter_get_merge_cand
$chain$5$kvz_inter_get_merge_cand DD 061d21H
	DD	08881dH
	DD	097812H
	DD	0a6808H
	DD	imagerel $LN230+1887
	DD	imagerel $LN230+1938
	DD	imagerel $chain$2$kvz_inter_get_merge_cand
$chain$6$kvz_inter_get_merge_cand DD 021H
	DD	imagerel $LN230+1887
	DD	imagerel $LN230+1938
	DD	imagerel $chain$2$kvz_inter_get_merge_cand
$unwind$add_merge_candidate DD 081401H
	DD	04e414H
	DD	03740fH
	DD	02640aH
	DD	013405H
$unwind$kvz_inter_get_mv_cand DD 0b1c01H
	DD	017741cH
	DD	016641cH
	DD	015541cH
	DD	014341cH
	DD	012011cH
	DD	0e015H
$unwind$get_mv_cand_from_candidates DD 0c1c01H
	DD	011641cH
	DD	010541cH
	DD	0f341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
$unwind$add_mvp_candidate DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
$unwind$add_temporal_candidate DD 060f01H
	DD	0b640fH
	DD	0a540fH
	DD	0700b520fH
$chain$1$add_temporal_candidate DD 040a21H
	DD	09e40aH
	DD	083405H
	DD	imagerel add_temporal_candidate
	DD	imagerel add_temporal_candidate+57
	DD	imagerel $unwind$add_temporal_candidate
$chain$2$add_temporal_candidate DD 021H
	DD	imagerel add_temporal_candidate
	DD	imagerel add_temporal_candidate+57
	DD	imagerel $unwind$add_temporal_candidate
$unwind$apply_mv_scaling DD 030601H
	DD	023406H
	DD	07006H
$unwind$get_spatial_merge_candidates_cua DD 0c1c01H
	DD	0d641cH
	DD	0c541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
$unwind$get_spatial_merge_candidates DD 0a1901H
	DD	0d3419H
	DD	0f0153219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
$unwind$get_temporal_merge_candidates DD 050901H
	DD	073409H
	DD	07007e009H
	DD	06006H
$chain$2$get_temporal_merge_candidates DD 060f21H
	DD	06f40fH
	DD	05c40aH
	DD	045405H
	DD	imagerel get_temporal_merge_candidates
	DD	imagerel get_temporal_merge_candidates+76
	DD	imagerel $unwind$get_temporal_merge_candidates
$chain$3$get_temporal_merge_candidates DD 021H
	DD	imagerel get_temporal_merge_candidates
	DD	imagerel get_temporal_merge_candidates+76
	DD	imagerel $unwind$get_temporal_merge_candidates
$unwind$is_b0_cand_coded DD 020501H
	DD	013405H
$unwind$is_a0_cand_coded DD 020501H
	DD	013405H
$unwind$kvz_inter_pred_pu DD 0a1d01H
	DD	015741dH
	DD	014641dH
	DD	013541dH
	DD	012341dH
	DD	0e016f21dH
$unwind$kvz_inter_recon_bipred DD 0d3601H
	DD	0122e742aH
	DD	0122d642aH
	DD	0122c342aH
	DD	01226012aH
	DD	0e01bf01dH
	DD	0c017d019H
	DD	05015H
$unwind$inter_recon_unipred DD 0bc901H
	DD	02a5d4c9H
	DD	029c012eH
	DD	0e017f019H
	DD	07013c015H
	DD	030116012H
	DD	05010H
$unwind$inter_cp_with_ext_border DD 051501H
	DD	0f0112215H
	DD	0c00dd00fH
	DD	0300bH
$chain$3$inter_cp_with_ext_border DD 081c21H
	DD	0e41cH
	DD	017418H
	DD	02640eH
	DD	085405H
	DD	imagerel inter_cp_with_ext_border
	DD	imagerel inter_cp_with_ext_border+72
	DD	imagerel $unwind$inter_cp_with_ext_border
$chain$4$inter_cp_with_ext_border DD 021H
	DD	imagerel inter_cp_with_ext_border
	DD	imagerel inter_cp_with_ext_border+72
	DD	imagerel $unwind$inter_cp_with_ext_border
$unwind$inter_recon_frac_chroma_hi DD 0b2401H
	DD	0c83424H
	DD	0be0124H
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
$unwind$inter_recon_frac_chroma DD 0b2401H
	DD	0c83424H
	DD	0be0124H
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
$unwind$inter_recon_frac_luma_hi DD 0b2701H
	DD	029f6427H
	DD	029d3427H
	DD	02960127H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
$unwind$inter_recon_frac_luma DD 0b2701H
	DD	029f6427H
	DD	029d3427H
	DD	02960127H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
$unwind$kvz_inter_recon_cu DD 051501H
	DD	0140115H
	DD	0700cc00eH
	DD	0500bH
$chain$4$kvz_inter_recon_cu DD 0a3321H
	DD	010f433H
	DD	011e42bH
	DD	012d41aH
	DD	0136412H
	DD	0183408H
	DD	imagerel $LN15
	DD	imagerel $LN15+123
	DD	imagerel $unwind$kvz_inter_recon_cu
$chain$5$kvz_inter_recon_cu DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+123
	DD	imagerel $unwind$kvz_inter_recon_cu
$unwind$kvz_inter_get_mv_cand_cua DD 0b1d01H
	DD	01d341dH
	DD	012011dH
	DD	0e014f016H
	DD	0c010d012H
	DD	0600d700eH
	DD	0500cH
	ORG $+5
$SG4294943115 DB 'c', 00H, 'a', 00H, 'n', 00H, 'd', 00H, '-', 00H, '>', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'm'
	DB	00H, 'v', 00H, '_', 00H, 'd', 00H, 'i', 00H, 'r', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H
$SG4294943116 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
picture_height$1$ = 80
merge_cand$ = 88
state$ = 208
x_local$1$ = 216
x$ = 216
picture_width$1$ = 224
y$ = 224
width$ = 232
height$ = 240
mv_cand$ = 248
cur_cu$ = 256
reflist$ = 264
kvz_inter_get_mv_cand_cua PROC

; 1373 : {

$LN117:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	mov	QWORD PTR [rax+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H

; 1037 :   if (x != 0) {

	mov	r15d, DWORD PTR height$[rsp]
	xorps	xmm0, xmm0

; 1374 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };

	movdqu	XMMWORD PTR [rax-112], xmm0
	mov	QWORD PTR [rax-64], 0
	mov	edi, r8d
	movdqu	XMMWORD PTR [rax-80], xmm0

; 1035 :   int32_t y_local = SUB_SCU(y);

	mov	r12d, edi

; 1373 : {

	mov	r13, rcx
	xorps	xmm1, xmm1

; 1035 :   int32_t y_local = SUB_SCU(y);

	and	r12d, 63				; 0000003fH

; 1374 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };

	movdqu	XMMWORD PTR [rax-96], xmm1

; 1375 : 
; 1376 :   const cu_array_t *cua = state->tile->frame->cu_array;

	mov	rax, QWORD PTR [rcx+48]
	mov	esi, r9d
	mov	ebx, edx
	mov	r8, QWORD PTR [rax]

; 1377 :   get_spatial_merge_candidates_cua(cua,

	mov	eax, DWORD PTR [r8+20]
	mov	ecx, DWORD PTR [r8+16]
	mov	r14, QWORD PTR [r8+32]
	mov	DWORD PTR picture_height$1$[rsp], eax

; 1034 :   int32_t x_local = SUB_SCU(x); //!< coordinates from top-left of this LCU

	mov	eax, edx
	and	eax, 63					; 0000003fH

; 1377 :   get_spatial_merge_candidates_cua(cua,

	mov	DWORD PTR picture_width$1$[rsp], ecx

; 1034 :   int32_t x_local = SUB_SCU(x); //!< coordinates from top-left of this LCU

	mov	DWORD PTR x_local$1$[rsp], eax

; 1036 :   // A0 and A1 availability testing
; 1037 :   if (x != 0) {

	test	edx, edx
	je	$LN7@kvz_inter_

; 1038 :     const cu_info_t *a1 = kvz_cu_array_at_const(cua, x - 1, y + height - 1);

	lea	ebp, DWORD PTR [rdi+r15]
	dec	edx
	lea	r8d, DWORD PTR [rbp-1]
	mov	rcx, r14
	call	kvz_cu_array_at_const

; 1039 :     // The block above is always coded before the current one.
; 1040 :     if (a1->type == CU_INTER) {

	mov	r9, QWORD PTR merge_cand$[rsp+8]
	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	cmove	r9, rax

; 1041 :       cand_out->a[1] = a1;
; 1042 :     }
; 1043 : 
; 1044 :     if (y_local + height < LCU_WIDTH && y + height < picture_height) {

	lea	eax, DWORD PTR [r12+r15]
	mov	QWORD PTR merge_cand$[rsp+8], r9
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN115@kvz_inter_
	cmp	ebp, DWORD PTR picture_height$1$[rsp]
	jge	SHORT $LN115@kvz_inter_

; 1045 :       const cu_info_t *a0 = kvz_cu_array_at_const(cua, x - 1, y + height);

	mov	r8d, ebp
	lea	edx, DWORD PTR [rbx-1]
	mov	rcx, r14
	call	kvz_cu_array_at_const
	mov	rbp, rax

; 1046 :       if (a0->type == CU_INTER && is_a0_cand_coded(x, y, width, height)) {

	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	jne	SHORT $LN115@kvz_inter_
	mov	r9d, r15d
	mov	r8d, esi
	mov	edx, edi
	mov	ecx, ebx
	call	is_a0_cand_coded
	mov	rcx, QWORD PTR merge_cand$[rsp]
	test	al, al
	cmovne	rcx, rbp
	mov	QWORD PTR merge_cand$[rsp], rcx
$LN115@kvz_inter_:

; 1047 :         cand_out->a[0] = a0;
; 1048 :       }
; 1049 :     }
; 1050 :   }
; 1051 : 
; 1052 :   // B0, B1 and B2 availability testing
; 1053 :   if (y != 0) {

	mov	r13, QWORD PTR state$[rsp]
	mov	ecx, DWORD PTR picture_width$1$[rsp]
	mov	eax, DWORD PTR x_local$1$[rsp]
$LN7@kvz_inter_:
	test	edi, edi
	je	$LN14@kvz_inter_

; 1054 :     if (x + width < picture_width && (x_local + width < LCU_WIDTH || y_local == 0)) {

	lea	ebp, DWORD PTR [rbx+rsi]
	cmp	ebp, ecx
	jge	SHORT $LN11@kvz_inter_
	add	eax, esi
	cmp	eax, 64					; 00000040H
	jl	SHORT $LN10@kvz_inter_
	test	r12d, r12d
	jne	SHORT $LN11@kvz_inter_
$LN10@kvz_inter_:

; 1055 :       const cu_info_t *b0 = kvz_cu_array_at_const(cua, x + width, y - 1);

	lea	r8d, DWORD PTR [rdi-1]
	mov	edx, ebp
	mov	rcx, r14
	call	kvz_cu_array_at_const
	mov	r12, rax

; 1056 :       if (b0->type == CU_INTER && is_b0_cand_coded(x, y, width, height)) {

	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	jne	SHORT $LN11@kvz_inter_
	mov	r9d, r15d
	mov	r8d, esi
	mov	edx, edi
	mov	ecx, ebx
	call	is_b0_cand_coded
	mov	rcx, QWORD PTR merge_cand$[rsp+16]
	test	al, al
	cmovne	rcx, r12
	mov	QWORD PTR merge_cand$[rsp+16], rcx
$LN11@kvz_inter_:

; 1057 :         cand_out->b[0] = b0;
; 1058 :       }
; 1059 :     }
; 1060 : 
; 1061 :     const cu_info_t *b1 = kvz_cu_array_at_const(cua, x + width - 1, y - 1);

	lea	edx, DWORD PTR [rbp-1]
	mov	rcx, r14
	lea	r8d, DWORD PTR [rdi-1]
	call	kvz_cu_array_at_const

; 1062 :     // The block to the left is always coded before the current one.
; 1063 :     if (b1->type == CU_INTER) {

	mov	r9, QWORD PTR merge_cand$[rsp+24]
	movzx	edx, BYTE PTR [rax]
	and	dl, 3
	cmp	dl, 2
	cmove	r9, rax
	mov	QWORD PTR merge_cand$[rsp+24], r9

; 1064 :       cand_out->b[1] = b1;
; 1065 :     }
; 1066 : 
; 1067 :     if (x != 0) {

	test	ebx, ebx
	je	SHORT $LN14@kvz_inter_

; 1068 :       const cu_info_t *b2 = kvz_cu_array_at_const(cua, x - 1, y - 1);

	lea	edx, DWORD PTR [rbx-1]
	mov	rcx, r14
	lea	r8d, DWORD PTR [rdi-1]
	call	kvz_cu_array_at_const

; 1069 :       // The block above and to the left is always coded before the current
; 1070 :       // one.
; 1071 :       if (b2->type == CU_INTER) {

	mov	rdx, QWORD PTR merge_cand$[rsp+32]
	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	cmove	rdx, rax
	mov	QWORD PTR merge_cand$[rsp+32], rdx
$LN14@kvz_inter_:

; 1378 :                                    x, y, width, height,
; 1379 :                                    state->tile->frame->width, state->tile->frame->height,
; 1380 :                                    &merge_cand);
; 1381 :   get_temporal_merge_candidates(state, x, y, width, height, 1, 0, &merge_cand);

	lea	rax, QWORD PTR merge_cand$[rsp]
	mov	r9d, esi
	mov	QWORD PTR [rsp+56], rax
	mov	r8d, edi
	mov	edx, ebx
	mov	DWORD PTR [rsp+32], r15d
	mov	rcx, r13
	call	get_temporal_merge_candidates

; 1382 :   get_mv_cand_from_candidates(state, x, y, width, height, &merge_cand, cur_cu, reflist, mv_cand);

	mov	rax, QWORD PTR mv_cand$[rsp]
	mov	r9d, esi
	mov	QWORD PTR [rsp+64], rax
	mov	r8d, edi
	movzx	eax, BYTE PTR reflist$[rsp]
	mov	edx, ebx
	mov	BYTE PTR [rsp+56], al
	mov	rcx, r13
	mov	rax, QWORD PTR cur_cu$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR merge_cand$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], r15d
	call	get_mv_cand_from_candidates

; 1383 : }

	mov	rbx, QWORD PTR [rsp+232]
	add	rsp, 144				; 00000090H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
kvz_inter_get_mv_cand_cua ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
lcu_adapter$2 = 96
state$ = 192
tv842 = 200
lcu$ = 200
x$ = 208
y$ = 216
width$ = 224
predict_luma$ = 232
predict_chroma$ = 240
kvz_inter_recon_cu PROC

; 582  : {

$LN15:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	push	rbp
	push	rdi
	push	r12
	sub	rsp, 160				; 000000a0H
	mov	r11d, r9d
	mov	rdi, rcx

; 583  :   cu_info_t *cu = LCU_GET_CU_AT_PX(lcu, SUB_SCU(x), SUB_SCU(y));

	mov	eax, r11d

; 584  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	lea	rcx, QWORD PTR [rdx+25336]
	sar	eax, 2
	mov	r9d, r8d
	and	eax, 15
	mov	rbp, rdx
	imul	r10d, eax, 17
	mov	eax, r8d
	sar	eax, 2
	and	eax, 15
	add	r10d, eax
	lea	r8, QWORD PTR [r10+r10*4]
	movzx	eax, BYTE PTR [rcx+r8*4]
	lea	rcx, QWORD PTR [rcx+r8*4]
	shr	rax, 5
	lea	r10, OFFSET FLAT:__ImageBase
	mov	QWORD PTR tv842[rsp], rcx

; 585  :   for (int i = 0; i < num_pu; ++i) {

	movzx	r12d, BYTE PTR kvz_part_mode_num_parts[rax+r10]
	test	r12, r12
	je	$LN3@kvz_inter_
	mov	r8d, DWORD PTR width$[rsp]
	mov	QWORD PTR [rsp+192], rbx
	xor	ebx, ebx
	mov	QWORD PTR [rsp+152], rsi
	mov	QWORD PTR [rsp+144], r13
	movzx	r13d, BYTE PTR predict_chroma$[rsp]
	mov	QWORD PTR [rsp+136], r14
	mov	QWORD PTR [rsp+128], r15
	npad	2
$LL4@kvz_inter_:

; 615  :   const int pu_x = PU_GET_X(cu->part_size, width, x, i_pu);

	movzx	eax, BYTE PTR [rcx]
	shr	rax, 5
	lea	rax, QWORD PTR [rbx+rax*4]
	lea	rcx, QWORD PTR [rax+rax]
	movzx	eax, BYTE PTR kvz_part_mode_offsets[rcx+r10]
	imul	eax, r8d
	cdq
	and	edx, 3
	lea	esi, DWORD PTR [rdx+rax]

; 616  :   const int pu_y = PU_GET_Y(cu->part_size, width, y, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[rcx+r10+1]
	imul	eax, r8d
	sar	esi, 2
	add	esi, r9d
	cdq
	and	edx, 3
	lea	r9d, DWORD PTR [rdx+rax]

; 617  :   const int pu_w = PU_GET_W(cu->part_size, width, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[rcx+r10]
	imul	eax, r8d
	sar	r9d, 2
	add	r9d, r11d
	cdq
	and	edx, 3
	lea	r14d, DWORD PTR [rdx+rax]

; 618  :   const int pu_h = PU_GET_H(cu->part_size, width, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[rcx+r10+1]
	imul	eax, r8d

; 619  :   cu_info_t *pu = LCU_GET_CU_AT_PX(lcu, SUB_SCU(pu_x), SUB_SCU(pu_y));

	mov	ecx, r9d
	sar	ecx, 2
	and	ecx, 15
	sar	r14d, 2
	cdq
	and	edx, 3
	lea	r15d, DWORD PTR [rdx+rax]
	imul	edx, ecx, 17
	mov	ecx, esi
	sar	r15d, 2
	sar	ecx, 2
	and	ecx, 15
	add	edx, ecx
	mov	ecx, edx
	lea	rdx, QWORD PTR [rdx*4+6334]
	add	rdx, rcx
	lea	r11, QWORD PTR [rdx*4]
	add	r11, rbp

; 620  : 
; 621  :   if (pu->inter.mv_dir == 3) {

	movzx	edx, BYTE PTR [r11+18]
	movzx	eax, dl
	and	al, 192					; 000000c0H
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN7@kvz_inter_

; 622  :     const kvz_picture *const refs[2] = {

	mov	r10, QWORD PTR [rdi+40]

; 623  :       state->frame->ref->images[
; 624  :         state->frame->ref_LX[0][
; 625  :           pu->inter.mv_ref[0]]],
; 626  :       state->frame->ref->images[
; 627  :         state->frame->ref_LX[1][
; 628  :           pu->inter.mv_ref[1]]],
; 629  :     };
; 630  :     kvz_inter_recon_bipred(state,

	mov	BYTE PTR [rsp+80], r13b
	mov	rax, QWORD PTR [r10+40]
	mov	r8, QWORD PTR [rax]
	movzx	eax, BYTE PTR [r11+16]
	movzx	ecx, BYTE PTR [rax+r10+49]
	movzx	eax, BYTE PTR [r11+17]
	mov	rdx, QWORD PTR [r8+rcx*8]
	movzx	ecx, BYTE PTR [rax+r10+65]
	lea	rax, QWORD PTR [r11+8]
	movzx	r10d, BYTE PTR predict_luma$[rsp]
	mov	BYTE PTR [rsp+72], r10b
	mov	QWORD PTR [rsp+64], rbp
	mov	r8, QWORD PTR [r8+rcx*8]
	mov	rcx, rdi
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], r15d
	mov	DWORD PTR [rsp+40], r14d
	mov	DWORD PTR [rsp+32], r9d
	mov	r9d, esi
	call	kvz_inter_recon_bipred

; 631  :       refs[0], refs[1],
; 632  :       pu_x, pu_y,
; 633  :       pu_w, pu_h,
; 634  :       pu->inter.mv,
; 635  :       lcu,
; 636  :       predict_luma, predict_chroma);
; 637  :   }

	jmp	$LN2@kvz_inter_
$LN7@kvz_inter_:

; 638  :   else {
; 639  :     const int mv_idx = pu->inter.mv_dir - 1;
; 640  :     const kvz_picture *const ref =
; 641  :       state->frame->ref->images[
; 642  :         state->frame->ref_LX[mv_idx][
; 643  :           pu->inter.mv_ref[mv_idx]]];
; 644  : 
; 645  :     const unsigned offset_luma = SUB_SCU(pu_y) * LCU_WIDTH + SUB_SCU(pu_x);
; 646  :     const unsigned offset_chroma = SUB_SCU(pu_y) / 2 * LCU_WIDTH_C + SUB_SCU(pu_x) / 2;
; 647  :     yuv_t lcu_adapter;
; 648  :     lcu_adapter.size = pu_w * pu_h;
; 649  :     lcu_adapter.y = lcu->rec.y + offset_luma,
; 650  :     lcu_adapter.u = lcu->rec.u + offset_chroma,
; 651  :     lcu_adapter.v = lcu->rec.v + offset_chroma,

	mov	BYTE PTR [rsp+88], r13b
	mov	eax, r15d
	imul	eax, r14d
	mov	ecx, r9d
	and	ecx, 63					; 0000003fH
	shr	rdx, 6
	shl	ecx, 6
	dec	rdx
	mov	DWORD PTR lcu_adapter$2[rsp], eax
	mov	eax, esi
	and	eax, 63					; 0000003fH
	lea	r8, QWORD PTR [rdx+2]
	add	eax, ecx
	lea	r8, QWORD PTR [r11+r8*4]
	lea	rcx, QWORD PTR [rbp+6540]
	add	rcx, rax
	mov	eax, esi
	sar	eax, 1
	and	eax, 31
	mov	QWORD PTR lcu_adapter$2[rsp+8], rcx
	mov	ecx, r9d
	sar	ecx, 1
	and	ecx, 31
	shl	ecx, 5
	add	ecx, eax
	lea	rax, QWORD PTR [rbp+10636]
	add	rax, rcx
	mov	QWORD PTR lcu_adapter$2[rsp+16], rax
	lea	rax, QWORD PTR [rbp+11660]
	add	rax, rcx
	mov	rcx, QWORD PTR [rdi+40]
	mov	QWORD PTR lcu_adapter$2[rsp+24], rax
	movzx	eax, BYTE PTR [rdx+r11+16]
	add	rdx, rdx
	add	rax, rcx
	movzx	r10d, BYTE PTR [rax+rdx*8+49]
	mov	rax, QWORD PTR [rcx+40]
	mov	rcx, rdi
	mov	rdx, QWORD PTR [rax]
	movzx	eax, BYTE PTR predict_luma$[rsp]
	mov	BYTE PTR [rsp+80], al
	lea	rax, QWORD PTR lcu_adapter$2[rsp]
	mov	QWORD PTR [rsp+72], 0
	mov	rdx, QWORD PTR [rdx+r10*8]
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r8
	mov	r8d, esi
	mov	DWORD PTR [rsp+48], 64			; 00000040H
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r14d
	call	inter_recon_unipred
$LN2@kvz_inter_:

; 585  :   for (int i = 0; i < num_pu; ++i) {

	mov	r8d, DWORD PTR width$[rsp]
	lea	r10, OFFSET FLAT:__ImageBase
	mov	r11d, DWORD PTR y$[rsp]
	inc	rbx
	mov	r9d, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR tv842[rsp]
	cmp	rbx, r12
	jl	$LL4@kvz_inter_
	mov	r15, QWORD PTR [rsp+128]
	mov	r14, QWORD PTR [rsp+136]
	mov	r13, QWORD PTR [rsp+144]
	mov	rsi, QWORD PTR [rsp+152]
	mov	rbx, QWORD PTR [rsp+192]
$LN3@kvz_inter_:

; 586  :     kvz_inter_pred_pu(state, lcu, x, y, width, predict_luma, predict_chroma, i);
; 587  :   }
; 588  : }

	add	rsp, 160				; 000000a0H
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
kvz_inter_recon_cu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
epol_args$ = 80
ext_buffer$ = 176
ext$ = 5344
state$ = 5344
ref$ = 5352
ext_s$ = 5360
xpos$ = 5360
ypos$ = 5368
block_width$ = 5376
block_height$ = 5384
ext_origin$ = 5392
mv_param$ = 5392
out$ = 5400
out_stride$ = 5408
inter_recon_frac_luma PROC

; 64   : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-5040]
	mov	eax, 5296				; 000014b0H
	call	__chkstk
	sub	rsp, rax

; 65   :   int mv_frac_x = (mv_param[0] & 3);

	mov	r14, QWORD PTR mv_param$[rbp-256]

; 66   :   int mv_frac_y = (mv_param[1] & 3);
; 67   : 
; 68   :   // Space for extrapolated pixels and the part from the picture.
; 69   :   // Some extra for AVX2.
; 70   :   // The extrapolation function will set the pointers and stride.
; 71   :   kvz_pixel ext_buffer[KVZ_IPOL_MAX_INPUT_SIZE_LUMA_SIMD];
; 72   :   kvz_pixel *ext = NULL;

	xor	eax, eax

; 73   :   kvz_pixel *ext_origin = NULL;
; 74   :   int ext_s = 0;
; 75   :   kvz_epol_args epol_args = {

	mov	edi, DWORD PTR block_width$[rbp-256]
	mov	r12, rcx
	mov	ebx, DWORD PTR block_height$[rbp-256]
	mov	QWORD PTR ext$[rbp-256], rax
	movsx	r15d, WORD PTR [r14]
	movsx	esi, WORD PTR [r14+2]
	mov	QWORD PTR ext_origin$[rbp-256], rax
	mov	DWORD PTR ext_s$[rbp-256], eax
	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR epol_args$[rsp], rax
	mov	eax, DWORD PTR [rdx+64]
	mov	DWORD PTR epol_args$[rsp+8], eax
	mov	eax, DWORD PTR [rdx+68]
	mov	DWORD PTR epol_args$[rsp+12], eax
	mov	eax, DWORD PTR [rdx+72]
	mov	rdx, QWORD PTR [rcx+48]
	mov	DWORD PTR epol_args$[rsp+16], eax
	mov	eax, r15d
	sar	eax, 2
	mov	ecx, DWORD PTR [rdx+20]
	add	ecx, eax
	mov	eax, esi
	add	ecx, r8d
	sar	eax, 2
	mov	DWORD PTR epol_args$[rsp+20], ecx
	mov	ecx, DWORD PTR [rdx+24]
	add	ecx, eax
	mov	DWORD PTR epol_args$[rsp+28], edi
	add	ecx, r9d
	mov	DWORD PTR epol_args$[rsp+32], ebx

; 76   :     .src = ref->y,
; 77   :     .src_w = ref->width,
; 78   :     .src_h = ref->height,
; 79   :     .src_s = ref->stride,
; 80   :     .blk_x = state->tile->offset_x + xpos + (mv_param[0] >> 2),
; 81   :     .blk_y = state->tile->offset_y + ypos + (mv_param[1] >> 2),
; 82   :     .blk_w = block_width,
; 83   :     .blk_h = block_height,
; 84   :     .pad_l = KVZ_LUMA_FILTER_OFFSET,
; 85   :     .pad_r = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 86   :     .pad_t = KVZ_LUMA_FILTER_OFFSET,
; 87   :     .pad_b = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 88   :     .pad_b_simd = 1 // One row for AVX2
; 89   :   };
; 90   : 
; 91   :   // Initialize separately. Gets rid of warning
; 92   :   // about using nonstandard extension.
; 93   :   epol_args.buf = ext_buffer;

	lea	rax, QWORD PTR ext_buffer$[rbp-256]
	mov	DWORD PTR epol_args$[rsp+24], ecx
	mov	QWORD PTR epol_args$[rbp-200], rax

; 94   :   epol_args.ext = &ext;
; 95   :   epol_args.ext_origin = &ext_origin;
; 96   :   epol_args.ext_s = &ext_s;
; 97   : 
; 98   :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$[rsp]
	lea	rax, QWORD PTR ext$[rbp-256]
	mov	DWORD PTR epol_args$[rsp+36], 3
	mov	QWORD PTR epol_args$[rbp-192], rax
	lea	rax, QWORD PTR ext_origin$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-184], rax
	lea	rax, QWORD PTR ext_s$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-176], rax
	mov	DWORD PTR epol_args$[rsp+40], 4
	mov	DWORD PTR epol_args$[rsp+44], 3
	mov	DWORD PTR epol_args$[rbp-208], 4
	mov	DWORD PTR epol_args$[rbp-204], 1
	call	QWORD PTR kvz_get_extended_block

; 99   :   kvz_sample_quarterpel_luma(state->encoder_control,

	movzx	eax, WORD PTR out_stride$[rbp-256]
	and	sil, 3
	movzx	r8d, WORD PTR ext_s$[rbp-256]
	and	r15b, 3
	mov	rdx, QWORD PTR ext_origin$[rbp-256]
	mov	r9d, edi
	mov	QWORD PTR [rsp+72], r14
	mov	BYTE PTR [rsp+64], sil
	mov	BYTE PTR [rsp+56], r15b
	mov	WORD PTR [rsp+48], ax
	mov	rax, QWORD PTR out$[rbp-256]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [r12]
	mov	DWORD PTR [rsp+32], ebx
	call	QWORD PTR kvz_sample_quarterpel_luma

; 100  :     ext_origin,
; 101  :     ext_s,
; 102  :     block_width,
; 103  :     block_height,
; 104  :     out->y,
; 105  :     out_stride,
; 106  :     mv_frac_x,
; 107  :     mv_frac_y,
; 108  :     mv_param);
; 109  : }

	lea	r11, QWORD PTR [rsp+5296]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
inter_recon_frac_luma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
epol_args$ = 80
ext_buffer$ = 176
ext$ = 5344
state$ = 5344
ref$ = 5352
ext_s$ = 5360
xpos$ = 5360
ypos$ = 5368
block_width$ = 5376
block_height$ = 5384
ext_origin$ = 5392
mv_param$ = 5392
out$ = 5400
out_stride$ = 5408
inter_recon_frac_luma_hi PROC

; 120  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-5040]
	mov	eax, 5296				; 000014b0H
	call	__chkstk
	sub	rsp, rax

; 121  :   int mv_frac_x = (mv_param[0] & 3);

	mov	r14, QWORD PTR mv_param$[rbp-256]

; 122  :   int mv_frac_y = (mv_param[1] & 3);
; 123  : 
; 124  :   // Space for extrapolated pixels and the part from the picture.
; 125  :   // Some extra for AVX2.
; 126  :   // The extrapolation function will set the pointers and stride.
; 127  :   kvz_pixel ext_buffer[KVZ_IPOL_MAX_INPUT_SIZE_LUMA_SIMD];
; 128  :   kvz_pixel *ext = NULL;

	xor	eax, eax

; 129  :   kvz_pixel *ext_origin = NULL;
; 130  :   int ext_s = 0;
; 131  :   kvz_epol_args epol_args = {

	mov	edi, DWORD PTR block_width$[rbp-256]
	mov	r12, rcx
	mov	ebx, DWORD PTR block_height$[rbp-256]
	mov	QWORD PTR ext$[rbp-256], rax
	movsx	r15d, WORD PTR [r14]
	movsx	esi, WORD PTR [r14+2]
	mov	QWORD PTR ext_origin$[rbp-256], rax
	mov	DWORD PTR ext_s$[rbp-256], eax
	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR epol_args$[rsp], rax
	mov	eax, DWORD PTR [rdx+64]
	mov	DWORD PTR epol_args$[rsp+8], eax
	mov	eax, DWORD PTR [rdx+68]
	mov	DWORD PTR epol_args$[rsp+12], eax
	mov	eax, DWORD PTR [rdx+72]
	mov	rdx, QWORD PTR [rcx+48]
	mov	DWORD PTR epol_args$[rsp+16], eax
	mov	eax, r15d
	sar	eax, 2
	mov	ecx, DWORD PTR [rdx+20]
	add	ecx, eax
	mov	eax, esi
	add	ecx, r8d
	sar	eax, 2
	mov	DWORD PTR epol_args$[rsp+20], ecx
	mov	ecx, DWORD PTR [rdx+24]
	add	ecx, eax
	mov	DWORD PTR epol_args$[rsp+28], edi
	add	ecx, r9d
	mov	DWORD PTR epol_args$[rsp+32], ebx

; 132  :     .src = ref->y,
; 133  :     .src_w = ref->width,
; 134  :     .src_h = ref->height,
; 135  :     .src_s = ref->stride,
; 136  :     .blk_x = state->tile->offset_x + xpos + (mv_param[0] >> 2),
; 137  :     .blk_y = state->tile->offset_y + ypos + (mv_param[1] >> 2),
; 138  :     .blk_w = block_width,
; 139  :     .blk_h = block_height,
; 140  :     .pad_l = KVZ_LUMA_FILTER_OFFSET,
; 141  :     .pad_r = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 142  :     .pad_t = KVZ_LUMA_FILTER_OFFSET,
; 143  :     .pad_b = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 144  :     .pad_b_simd = 1 // One row for AVX2
; 145  :   };
; 146  : 
; 147  :   // Initialize separately. Gets rid of warning
; 148  :   // about using nonstandard extension.
; 149  :   epol_args.buf = ext_buffer;

	lea	rax, QWORD PTR ext_buffer$[rbp-256]
	mov	DWORD PTR epol_args$[rsp+24], ecx
	mov	QWORD PTR epol_args$[rbp-200], rax

; 150  :   epol_args.ext = &ext;
; 151  :   epol_args.ext_origin = &ext_origin;
; 152  :   epol_args.ext_s = &ext_s;
; 153  : 
; 154  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$[rsp]
	lea	rax, QWORD PTR ext$[rbp-256]
	mov	DWORD PTR epol_args$[rsp+36], 3
	mov	QWORD PTR epol_args$[rbp-192], rax
	lea	rax, QWORD PTR ext_origin$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-184], rax
	lea	rax, QWORD PTR ext_s$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-176], rax
	mov	DWORD PTR epol_args$[rsp+40], 4
	mov	DWORD PTR epol_args$[rsp+44], 3
	mov	DWORD PTR epol_args$[rbp-208], 4
	mov	DWORD PTR epol_args$[rbp-204], 1
	call	QWORD PTR kvz_get_extended_block

; 155  :   kvz_sample_quarterpel_luma_hi(state->encoder_control,

	movzx	eax, WORD PTR out_stride$[rbp-256]
	and	sil, 3
	movzx	r8d, WORD PTR ext_s$[rbp-256]
	and	r15b, 3
	mov	rdx, QWORD PTR ext_origin$[rbp-256]
	mov	r9d, edi
	mov	QWORD PTR [rsp+72], r14
	mov	BYTE PTR [rsp+64], sil
	mov	BYTE PTR [rsp+56], r15b
	mov	WORD PTR [rsp+48], ax
	mov	rax, QWORD PTR out$[rbp-256]
	mov	rcx, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [r12]
	mov	DWORD PTR [rsp+32], ebx
	call	QWORD PTR kvz_sample_quarterpel_luma_hi

; 156  :     ext_origin,
; 157  :     ext_s,
; 158  :     block_width,
; 159  :     block_height,
; 160  :     out->y,
; 161  :     out_stride,
; 162  :     mv_frac_x,
; 163  :     mv_frac_y,
; 164  :     mv_param);
; 165  : }

	lea	r11, QWORD PTR [rsp+5296]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
inter_recon_frac_luma_hi ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
epol_args$ = 80
ext_buffer$ = 176
state$ = 1584
ext$ = 1592
ref$ = 1592
pu_x$ = 1600
pu_y$ = 1608
ext_s$ = 1616
pu_w$ = 1616
tv313 = 1624
pu_h$ = 1624
ext_origin$ = 1632
mv_param$ = 1632
out$ = 1640
out_stride$ = 1648
inter_recon_frac_chroma PROC

; 176  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-1264]
	sub	rsp, 1520				; 000005f0H

; 177  :   int mv_frac_x = (mv_param[0] & 7);
; 178  :   int mv_frac_y = (mv_param[1] & 7);
; 179  : 
; 180  :   // Take into account chroma subsampling
; 181  :   unsigned pb_w = pu_w / 2;

	mov	eax, DWORD PTR pu_w$[rbp-256]
	mov	r15, rdx
	cdq
	mov	r12, QWORD PTR mv_param$[rbp-256]
	sub	eax, edx
	mov	r10d, r8d

; 182  :   unsigned pb_h = pu_h / 2;
; 183  : 
; 184  :   // Space for extrapolated pixels and the part from the picture.
; 185  :   // Some extra for AVX2.
; 186  :   // The extrapolation function will set the pointers and stride.
; 187  :   kvz_pixel ext_buffer[KVZ_IPOL_MAX_INPUT_SIZE_CHROMA_SIMD];
; 188  :   kvz_pixel *ext = NULL;
; 189  :   kvz_pixel *ext_origin = NULL;
; 190  :   int ext_s = 0;
; 191  : 
; 192  :   // Chroma U
; 193  :   // Divisions by 2 due to 4:2:0 chroma subsampling
; 194  :   kvz_epol_args epol_args = {

	mov	r8, QWORD PTR [rcx+48]
	sar	eax, 1
	mov	r13d, eax
	mov	rcx, QWORD PTR [r15+24]
	mov	eax, DWORD PTR pu_h$[rbp-256]
	movsx	ebx, WORD PTR [r12]
	cdq
	movsx	r14d, WORD PTR [r12+2]
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	mov	QWORD PTR epol_args$[rsp], rcx
	xor	eax, eax
	mov	ecx, ebx
	mov	QWORD PTR ext$[rbp-256], rax
	mov	QWORD PTR ext_origin$[rbp-256], rax
	mov	DWORD PTR ext_s$[rbp-256], eax
	mov	eax, DWORD PTR [r15+64]
	cdq
	sar	ecx, 3
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$[rsp+8], eax
	mov	eax, DWORD PTR [r15+68]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$[rsp+12], eax
	mov	eax, DWORD PTR [r15+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$[rsp+16], eax
	mov	eax, DWORD PTR [r8+20]
	add	eax, r10d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	ecx, r14d
	mov	DWORD PTR epol_args$[rsp+20], eax
	mov	eax, DWORD PTR [r8+24]
	add	eax, r9d
	sar	ecx, 3
	cdq
	mov	DWORD PTR epol_args$[rsp+28], r13d
	sub	eax, edx
	mov	DWORD PTR epol_args$[rsp+32], esi
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR epol_args$[rsp+36], 1
	mov	DWORD PTR epol_args$[rsp+24], eax

; 195  :     .src = ref->u,
; 196  :     .src_w = ref->width / 2,
; 197  :     .src_h = ref->height / 2,
; 198  :     .src_s = ref->stride / 2,
; 199  :     .blk_x = (state->tile->offset_x + pu_x) / 2 + (mv_param[0] >> 3),
; 200  :     .blk_y = (state->tile->offset_y + pu_y) / 2 + (mv_param[1] >> 3),
; 201  :     .blk_w = pb_w,
; 202  :     .blk_h = pb_h,
; 203  :     .pad_l = KVZ_CHROMA_FILTER_OFFSET,
; 204  :     .pad_r = KVZ_EXT_PADDING_CHROMA - KVZ_CHROMA_FILTER_OFFSET,
; 205  :     .pad_t = KVZ_CHROMA_FILTER_OFFSET,
; 206  :     .pad_b = KVZ_EXT_PADDING_CHROMA - KVZ_CHROMA_FILTER_OFFSET,
; 207  :     .pad_b_simd = 3 // Three rows for AVX2
; 208  :   };
; 209  : 
; 210  :   // Initialize separately. Gets rid of warning
; 211  :   // about using nonstandard extension.
; 212  :   epol_args.buf = ext_buffer;
; 213  :   epol_args.ext = &ext;
; 214  :   epol_args.ext_origin = &ext_origin;
; 215  :   epol_args.ext_s = &ext_s;
; 216  : 
; 217  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$[rsp]
	lea	rax, QWORD PTR ext_buffer$[rbp-256]
	mov	DWORD PTR epol_args$[rsp+40], 2
	mov	QWORD PTR epol_args$[rbp-200], rax
	lea	rax, QWORD PTR ext$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-192], rax
	lea	rax, QWORD PTR ext_origin$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-184], rax
	lea	rax, QWORD PTR ext_s$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-176], rax
	mov	DWORD PTR epol_args$[rsp+44], 1
	mov	DWORD PTR epol_args$[rbp-208], 2
	mov	DWORD PTR epol_args$[rbp-204], 3
	call	QWORD PTR kvz_get_extended_block

; 218  :   kvz_sample_octpel_chroma(state->encoder_control,

	movzx	edi, WORD PTR out_stride$[rbp-256]
	and	r14b, 7
	and	bl, 7
	mov	QWORD PTR [rsp+72], r12
	mov	BYTE PTR [rsp+64], r14b
	mov	BYTE PTR [rsp+56], bl
	mov	DWORD PTR tv313[rbp-256], ebx
	mov	rbx, QWORD PTR out$[rbp-256]
	mov	WORD PTR [rsp+48], di
	mov	rax, QWORD PTR [rbx+16]
	mov	r9d, r13d
	mov	rcx, QWORD PTR state$[rbp-256]
	movzx	r8d, WORD PTR ext_s$[rbp-256]
	mov	rdx, QWORD PTR ext_origin$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, QWORD PTR [rcx]
	mov	DWORD PTR [rsp+32], esi
	call	QWORD PTR kvz_sample_octpel_chroma

; 219  :     ext_origin,
; 220  :     ext_s,
; 221  :     pb_w,
; 222  :     pb_h,
; 223  :     out->u,
; 224  :     out_stride,
; 225  :     mv_frac_x,
; 226  :     mv_frac_y,
; 227  :     mv_param);
; 228  : 
; 229  :   // Chroma V
; 230  :   epol_args.src = ref->v;

	mov	rax, QWORD PTR [r15+32]

; 231  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$[rsp]
	mov	QWORD PTR epol_args$[rsp], rax
	call	QWORD PTR kvz_get_extended_block

; 232  :   kvz_sample_octpel_chroma(state->encoder_control,

	mov	eax, DWORD PTR tv313[rbp-256]
	mov	r9d, r13d
	movzx	r8d, WORD PTR ext_s$[rbp-256]
	mov	rdx, QWORD PTR ext_origin$[rbp-256]
	mov	QWORD PTR [rsp+72], r12
	mov	BYTE PTR [rsp+64], r14b
	mov	BYTE PTR [rsp+56], al
	mov	rax, QWORD PTR [rbx+24]
	mov	WORD PTR [rsp+48], di
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR state$[rbp-256]
	mov	DWORD PTR [rsp+32], esi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR kvz_sample_octpel_chroma

; 233  :     ext_origin,
; 234  :     ext_s,
; 235  :     pb_w,
; 236  :     pb_h,
; 237  :     out->v,
; 238  :     out_stride,
; 239  :     mv_frac_x,
; 240  :     mv_frac_y,
; 241  :     mv_param);
; 242  : }

	mov	rbx, QWORD PTR [rsp+1600]
	add	rsp, 1520				; 000005f0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
inter_recon_frac_chroma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
epol_args$ = 80
ext_buffer$ = 176
state$ = 1584
ext$ = 1592
ref$ = 1592
pu_x$ = 1600
pu_y$ = 1608
ext_s$ = 1616
pu_w$ = 1616
tv313 = 1624
pu_h$ = 1624
ext_origin$ = 1632
mv_param$ = 1632
out$ = 1640
out_stride$ = 1648
inter_recon_frac_chroma_hi PROC

; 253  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-1264]
	sub	rsp, 1520				; 000005f0H

; 254  :   int mv_frac_x = (mv_param[0] & 7);
; 255  :   int mv_frac_y = (mv_param[1] & 7);
; 256  : 
; 257  :   // Take into account chroma subsampling
; 258  :   unsigned pb_w = pu_w / 2;

	mov	eax, DWORD PTR pu_w$[rbp-256]
	mov	r15, rdx
	cdq
	mov	r12, QWORD PTR mv_param$[rbp-256]
	sub	eax, edx
	mov	r10d, r8d

; 259  :   unsigned pb_h = pu_h / 2;
; 260  : 
; 261  :   // Space for extrapolated pixels and the part from the picture.
; 262  :   // Some extra for AVX2.
; 263  :   // The extrapolation function will set the pointers and stride.
; 264  :   kvz_pixel ext_buffer[KVZ_IPOL_MAX_INPUT_SIZE_CHROMA_SIMD];
; 265  :   kvz_pixel *ext = NULL;
; 266  :   kvz_pixel *ext_origin = NULL;
; 267  :   int ext_s = 0;
; 268  : 
; 269  :   // Chroma U
; 270  :   // Divisions by 2 due to 4:2:0 chroma subsampling
; 271  :   kvz_epol_args epol_args = {

	mov	r8, QWORD PTR [rcx+48]
	sar	eax, 1
	mov	r13d, eax
	mov	rcx, QWORD PTR [r15+24]
	mov	eax, DWORD PTR pu_h$[rbp-256]
	movsx	ebx, WORD PTR [r12]
	cdq
	movsx	r14d, WORD PTR [r12+2]
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	mov	QWORD PTR epol_args$[rsp], rcx
	xor	eax, eax
	mov	ecx, ebx
	mov	QWORD PTR ext$[rbp-256], rax
	mov	QWORD PTR ext_origin$[rbp-256], rax
	mov	DWORD PTR ext_s$[rbp-256], eax
	mov	eax, DWORD PTR [r15+64]
	cdq
	sar	ecx, 3
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$[rsp+8], eax
	mov	eax, DWORD PTR [r15+68]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$[rsp+12], eax
	mov	eax, DWORD PTR [r15+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$[rsp+16], eax
	mov	eax, DWORD PTR [r8+20]
	add	eax, r10d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	ecx, r14d
	mov	DWORD PTR epol_args$[rsp+20], eax
	mov	eax, DWORD PTR [r8+24]
	add	eax, r9d
	sar	ecx, 3
	cdq
	mov	DWORD PTR epol_args$[rsp+28], r13d
	sub	eax, edx
	mov	DWORD PTR epol_args$[rsp+32], esi
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR epol_args$[rsp+36], 1
	mov	DWORD PTR epol_args$[rsp+24], eax

; 272  :     .src = ref->u,
; 273  :     .src_w = ref->width / 2,
; 274  :     .src_h = ref->height / 2,
; 275  :     .src_s = ref->stride / 2,
; 276  :     .blk_x = (state->tile->offset_x + pu_x) / 2 + (mv_param[0] >> 3),
; 277  :     .blk_y = (state->tile->offset_y + pu_y) / 2 + (mv_param[1] >> 3),
; 278  :     .blk_w = pb_w,
; 279  :     .blk_h = pb_h,
; 280  :     .pad_l = KVZ_CHROMA_FILTER_OFFSET,
; 281  :     .pad_r = KVZ_EXT_PADDING_CHROMA - KVZ_CHROMA_FILTER_OFFSET,
; 282  :     .pad_t = KVZ_CHROMA_FILTER_OFFSET,
; 283  :     .pad_b = KVZ_EXT_PADDING_CHROMA - KVZ_CHROMA_FILTER_OFFSET,
; 284  :     .pad_b_simd = 3 // Three rows for AVX2
; 285  :   };
; 286  : 
; 287  :   // Initialize separately. Gets rid of warning
; 288  :   // about using nonstandard extension.
; 289  :   epol_args.buf = ext_buffer;
; 290  :   epol_args.ext = &ext;
; 291  :   epol_args.ext_origin = &ext_origin;
; 292  :   epol_args.ext_s = &ext_s;
; 293  : 
; 294  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$[rsp]
	lea	rax, QWORD PTR ext_buffer$[rbp-256]
	mov	DWORD PTR epol_args$[rsp+40], 2
	mov	QWORD PTR epol_args$[rbp-200], rax
	lea	rax, QWORD PTR ext$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-192], rax
	lea	rax, QWORD PTR ext_origin$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-184], rax
	lea	rax, QWORD PTR ext_s$[rbp-256]
	mov	QWORD PTR epol_args$[rbp-176], rax
	mov	DWORD PTR epol_args$[rsp+44], 1
	mov	DWORD PTR epol_args$[rbp-208], 2
	mov	DWORD PTR epol_args$[rbp-204], 3
	call	QWORD PTR kvz_get_extended_block

; 295  :   kvz_sample_octpel_chroma_hi(state->encoder_control,

	movzx	edi, WORD PTR out_stride$[rbp-256]
	and	r14b, 7
	and	bl, 7
	mov	QWORD PTR [rsp+72], r12
	mov	BYTE PTR [rsp+64], r14b
	mov	BYTE PTR [rsp+56], bl
	mov	DWORD PTR tv313[rbp-256], ebx
	mov	rbx, QWORD PTR out$[rbp-256]
	mov	WORD PTR [rsp+48], di
	mov	rax, QWORD PTR [rbx+16]
	mov	r9d, r13d
	mov	rcx, QWORD PTR state$[rbp-256]
	movzx	r8d, WORD PTR ext_s$[rbp-256]
	mov	rdx, QWORD PTR ext_origin$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, QWORD PTR [rcx]
	mov	DWORD PTR [rsp+32], esi
	call	QWORD PTR kvz_sample_octpel_chroma_hi

; 296  :     ext_origin,
; 297  :     ext_s,
; 298  :     pb_w,
; 299  :     pb_h,
; 300  :     out->u,
; 301  :     out_stride,
; 302  :     mv_frac_x,
; 303  :     mv_frac_y,
; 304  :     mv_param);
; 305  : 
; 306  :   // Chroma V
; 307  :   epol_args.src = ref->v;

	mov	rax, QWORD PTR [r15+32]

; 308  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$[rsp]
	mov	QWORD PTR epol_args$[rsp], rax
	call	QWORD PTR kvz_get_extended_block

; 309  :   kvz_sample_octpel_chroma_hi(state->encoder_control,

	mov	eax, DWORD PTR tv313[rbp-256]
	mov	r9d, r13d
	movzx	r8d, WORD PTR ext_s$[rbp-256]
	mov	rdx, QWORD PTR ext_origin$[rbp-256]
	mov	QWORD PTR [rsp+72], r12
	mov	BYTE PTR [rsp+64], r14b
	mov	BYTE PTR [rsp+56], al
	mov	rax, QWORD PTR [rbx+24]
	mov	WORD PTR [rsp+48], di
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR state$[rbp-256]
	mov	DWORD PTR [rsp+32], esi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR kvz_sample_octpel_chroma_hi

; 310  :     ext_origin,
; 311  :     ext_s,
; 312  :     pb_w,
; 313  :     pb_h,
; 314  :     out->v,
; 315  :     out_stride,
; 316  :     mv_frac_x,
; 317  :     mv_frac_y,
; 318  :     mv_param);
; 319  : }

	mov	rbx, QWORD PTR [rsp+1600]
	add	rsp, 1520				; 000005f0H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
inter_recon_frac_chroma_hi ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
ref_buf$ = 64
ref_stride$ = 72
ref_width$ = 80
ref_height$ = 88
rec_buf$ = 96
rec_stride$ = 104
width$ = 112
height$ = 120
tv356 = 128
mv_in_frame$ = 128
inter_cp_with_ext_border PROC

; 340  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	push	rbx
	push	r12
	push	r13
	push	r15
	sub	rsp, 24

; 341  :   for (int y = mv_in_frame->y; y < mv_in_frame->y + height; ++y) {

	mov	r11, QWORD PTR mv_in_frame$[rsp]
	mov	r12, rcx
	mov	r13d, DWORD PTR height$[rsp]
	mov	ebx, r9d
	mov	r9d, r8d
	mov	r15d, edx
	mov	ecx, DWORD PTR [r11+4]
	add	r13d, ecx
	mov	DWORD PTR tv356[rsp], ecx
	mov	r10d, ecx
	cmp	ecx, r13d
	jge	$LN3@inter_cp_w

; 342  :     for (int x = mv_in_frame->x; x < mv_in_frame->x + width; ++x) {

	mov	QWORD PTR [rsp+64], rbp
	mov	ebp, DWORD PTR width$[rsp]
	mov	QWORD PTR [rsp+16], rsi
	mov	esi, DWORD PTR [r11]
	add	ebp, esi
	mov	QWORD PTR [rsp+8], rdi
	mov	QWORD PTR [rsp], r14
	mov	r14, QWORD PTR rec_buf$[rsp]
	npad	7
$LL4@inter_cp_w:
	mov	r8d, esi
	cmp	esi, ebp
	jge	$LN2@inter_cp_w

; 343  :       vector2d_t in_frame = {

	lea	r11d, DWORD PTR [rbx-1]
	dec	r9d
	cmp	r11d, r10d
	mov	ebx, r11d
	mov	edi, r10d
	cmovge	ebx, r10d
	sub	edi, ecx
	imul	edi, DWORD PTR rec_stride$[rsp]
	npad	10
$LL7@inter_cp_w:
	cmp	r9d, r8d
	mov	eax, r9d
	cmovge	eax, r8d
	test	eax, eax
	jns	SHORT $LN13@inter_cp_w
	xor	edx, edx
	jmp	SHORT $LN11@inter_cp_w
$LN13@inter_cp_w:
	cmp	r9d, r8d
	mov	edx, r8d
	cmovl	edx, r9d
$LN11@inter_cp_w:
	test	ebx, ebx
	jns	SHORT $LN19@inter_cp_w
	xor	eax, eax
	jmp	SHORT $LN17@inter_cp_w
$LN19@inter_cp_w:
	cmp	r11d, r10d
	mov	eax, r10d
	cmovl	eax, r11d
$LN17@inter_cp_w:

; 344  :         CLIP(0, ref_width - 1, x),
; 345  :         CLIP(0, ref_height - 1, y),
; 346  :       };
; 347  :       vector2d_t in_pu = {
; 348  :         x - mv_in_frame->x,
; 349  :         y - mv_in_frame->y,
; 350  :       };
; 351  :       int pu_index = in_pu.y * rec_stride + in_pu.x;
; 352  :       int frame_index = in_frame.y * ref_stride + in_frame.x;

	imul	eax, r15d
	mov	ecx, r8d
	sub	ecx, esi
	inc	r8d
	add	eax, edx

; 353  :       rec_buf[pu_index] = ref_buf[frame_index];

	movsxd	rdx, eax
	lea	eax, DWORD PTR [rdi+rcx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rdx+r12]
	mov	BYTE PTR [rcx+r14], al
	cmp	r8d, ebp
	jl	SHORT $LL7@inter_cp_w
	mov	ecx, DWORD PTR tv356[rsp]
	mov	ebx, DWORD PTR ref_height$[rsp]
	mov	r9d, DWORD PTR ref_width$[rsp]
$LN2@inter_cp_w:

; 341  :   for (int y = mv_in_frame->y; y < mv_in_frame->y + height; ++y) {

	inc	r10d
	cmp	r10d, r13d
	jl	$LL4@inter_cp_w
	mov	r14, QWORD PTR [rsp]
	mov	rdi, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rbp, QWORD PTR [rsp+64]
$LN3@inter_cp_w:

; 354  :     }
; 355  :   }
; 356  : }

	add	rsp, 24
	pop	r15
	pop	r13
	pop	r12
	pop	rbx
	ret	0
inter_cp_with_ext_border ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
$T1 = 80
$T2 = 81
ext_origin$3 = 88
ext_origin$4 = 88
int_mv_in_frame$ = 88
tv1535 = 96
ext$5 = 104
ext$6 = 104
ext$7 = 104
ext$8 = 104
epol_args$9 = 112
epol_args$10 = 112
epol_args$11 = 112
epol_args$12 = 112
ext_origin$13 = 208
ext_origin$14 = 208
ext_buffer$15 = 224
ext_buffer$16 = 224
ext_buffer$17 = 224
ext_buffer$18 = 224
int_mv_in_frame_c$19 = 5408
state$ = 5408
ref$ = 5416
pu_x$ = 5424
pu_y$ = 5432
pu_w$ = 5440
pu_h$ = 5448
out_stride_luma$ = 5456
mv_param$ = 5464
yuv_px$ = 5472
yuv_im$ = 5480
out_stride_c$1$ = 5488
ext_s$20 = 5488
ext_s$21 = 5488
predict_luma$ = 5488
ext_s$22 = 5496
ext_s$23 = 5496
predict_chroma$ = 5496
inter_recon_unipred PROC

; 386  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-5088]
	mov	eax, 5344				; 000014e0H
	call	__chkstk
	sub	rsp, rax

; 387  :   const vector2d_t int_mv = { mv_param[0] >> 2, mv_param[1] >> 2 };

	mov	rax, QWORD PTR mv_param$[rbp-256]
	mov	ebx, r9d

; 388  :   const vector2d_t int_mv_in_frame = {

	mov	esi, DWORD PTR pu_w$[rbp-256]
	mov	r15, rdx
	mov	r9, rcx
	mov	rcx, QWORD PTR [rcx+48]
	movsx	r11d, WORD PTR [rax]
	movsx	r12d, WORD PTR [rax+2]
	mov	edx, r11d
	mov	eax, DWORD PTR [rcx+20]
	mov	r10d, r12d
	mov	edi, DWORD PTR [rcx+24]
	mov	r14d, r11d
	sar	edx, 2
	sar	r10d, 2
	add	eax, edx
	add	edi, r10d
	mov	WORD PTR tv1535[rsp], r12w
	add	edi, ebx
	add	r8d, eax
	mov	ebx, DWORD PTR pu_h$[rbp-256]
	mov	DWORD PTR int_mv_in_frame$[rsp], r8d
	mov	DWORD PTR int_mv_in_frame$[rsp+4], edi
	test	r8d, r8d

; 389  :     int_mv.x + pu_x + state->tile->offset_x,
; 390  :     int_mv.y + pu_y + state->tile->offset_y
; 391  :   };
; 392  : 
; 393  :   const bool int_mv_outside_frame = int_mv_in_frame.x < 0 ||

	js	SHORT $LN18@inter_reco
	test	edi, edi
	js	SHORT $LN18@inter_reco
	lea	eax, DWORD PTR [r8+rsi]
	cmp	eax, DWORD PTR [r15+64]
	jg	SHORT $LN18@inter_reco
	lea	eax, DWORD PTR [rdi+rbx]
	cmp	eax, DWORD PTR [r15+68]
	jg	SHORT $LN18@inter_reco
	xor	al, al
	jmp	SHORT $LN38@inter_reco
$LN18@inter_reco:
	mov	al, 1
$LN38@inter_reco:
	mov	BYTE PTR $T2[rsp], al
	test	dl, 1

; 394  :     int_mv_in_frame.y < 0 ||
; 395  :     int_mv_in_frame.x + pu_w > ref->width ||
; 396  :     int_mv_in_frame.y + pu_h > ref->height;
; 397  : 
; 398  :   // With 420, odd coordinates need interpolation.
; 399  :   const bool fractional_chroma = (int_mv.x & 1) || (int_mv.y & 1);

	jne	SHORT $LN20@inter_reco
	mov	BYTE PTR $T1[rsp], 0
	test	r10b, 1
	je	SHORT $LN21@inter_reco
$LN20@inter_reco:
	mov	BYTE PTR $T1[rsp], 1
$LN21@inter_reco:
	mov	QWORD PTR [rsp+5416], r13

; 400  :   const bool fractional_luma = (mv_param[0] & 3) || (mv_param[1] & 3);

	test	r11b, 3
	jne	SHORT $LN34@inter_reco
	test	r12b, 3
	jne	SHORT $LN34@inter_reco
	xor	r13b, r13b
	jmp	SHORT $LN23@inter_reco
$LN34@inter_reco:
	mov	r13b, 1
$LN23@inter_reco:

; 401  : 
; 402  :   // Generate prediction for luma.
; 403  :   if (predict_luma) {

	xor	r12d, r12d
	cmp	BYTE PTR predict_luma$[rbp-256], r12b
	je	$LN37@inter_reco

; 404  :     if (fractional_luma) {

	test	r13b, r13b
	je	$LN3@inter_reco

; 405  :       // With a fractional MV, do interpolation.
; 406  :       if (state->encoder_control->cfg.bipred && yuv_im) {

	mov	rax, QWORD PTR [r9]
	cmp	DWORD PTR [rax+92], r12d
	je	$LN5@inter_reco
	cmp	QWORD PTR yuv_im$[rbp-256], r12
	je	$LN5@inter_reco

; 131  :   kvz_epol_args epol_args = {

	mov	rax, QWORD PTR [r15+16]

; 132  :     .src = ref->y,
; 133  :     .src_w = ref->width,
; 134  :     .src_h = ref->height,
; 135  :     .src_s = ref->stride,
; 136  :     .blk_x = state->tile->offset_x + xpos + (mv_param[0] >> 2),
; 137  :     .blk_y = state->tile->offset_y + ypos + (mv_param[1] >> 2),
; 138  :     .blk_w = block_width,
; 139  :     .blk_h = block_height,
; 140  :     .pad_l = KVZ_LUMA_FILTER_OFFSET,
; 141  :     .pad_r = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 142  :     .pad_t = KVZ_LUMA_FILTER_OFFSET,
; 143  :     .pad_b = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 144  :     .pad_b_simd = 1 // One row for AVX2
; 145  :   };
; 146  : 
; 147  :   // Initialize separately. Gets rid of warning
; 148  :   // about using nonstandard extension.
; 149  :   epol_args.buf = ext_buffer;
; 150  :   epol_args.ext = &ext;
; 151  :   epol_args.ext_origin = &ext_origin;
; 152  :   epol_args.ext_s = &ext_s;
; 153  : 
; 154  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$12[rsp]
	mov	QWORD PTR epol_args$12[rsp], rax
	mov	eax, DWORD PTR [r15+64]
	mov	DWORD PTR epol_args$12[rsp+8], eax
	mov	eax, DWORD PTR [r15+68]
	mov	DWORD PTR epol_args$12[rsp+12], eax
	mov	eax, DWORD PTR [r15+72]
	mov	DWORD PTR epol_args$12[rbp-240], eax
	lea	rax, QWORD PTR ext_buffer$18[rbp-256]
	mov	QWORD PTR epol_args$12[rbp-200], rax
	lea	rax, QWORD PTR ext$8[rsp]
	mov	QWORD PTR epol_args$12[rbp-192], rax
	lea	rax, QWORD PTR ext_origin$14[rbp-256]
	mov	QWORD PTR epol_args$12[rbp-184], rax
	lea	rax, QWORD PTR ext_s$21[rbp-256]
	mov	QWORD PTR epol_args$12[rbp-176], rax
	mov	QWORD PTR ext$8[rsp], r12
	mov	QWORD PTR ext_origin$14[rbp-256], r12
	mov	DWORD PTR ext_s$21[rbp-256], r12d
	mov	DWORD PTR epol_args$12[rbp-236], r8d
	mov	DWORD PTR epol_args$12[rbp-232], edi
	mov	DWORD PTR epol_args$12[rbp-228], esi
	mov	DWORD PTR epol_args$12[rbp-224], ebx
	mov	DWORD PTR epol_args$12[rbp-220], 3
	mov	DWORD PTR epol_args$12[rbp-216], 4
	mov	DWORD PTR epol_args$12[rbp-212], 3
	mov	DWORD PTR epol_args$12[rbp-208], 4
	mov	DWORD PTR epol_args$12[rbp-204], 1
	call	QWORD PTR kvz_get_extended_block
	movsx	eax, WORD PTR tv1535[rsp]
	and	r14b, 3

; 155  :   kvz_sample_quarterpel_luma_hi(state->encoder_control,

	mov	rcx, QWORD PTR mv_param$[rbp-256]
	and	al, 3
	movzx	r8d, WORD PTR ext_s$21[rbp-256]
	mov	r9d, esi
	mov	rdx, QWORD PTR ext_origin$14[rbp-256]
	mov	QWORD PTR [rsp+72], rcx
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	BYTE PTR [rsp+64], al
	mov	eax, DWORD PTR out_stride_luma$[rbp-256]
	mov	BYTE PTR [rsp+56], r14b
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rsp+48], ax
	mov	rax, QWORD PTR yuv_im$[rbp-256]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], ebx
	call	QWORD PTR kvz_sample_quarterpel_luma_hi

; 407  :         inter_recon_frac_luma_hi(state, ref,
; 408  :           pu_x, pu_y,
; 409  :           pu_w, pu_h,
; 410  :           mv_param, yuv_im, out_stride_luma);
; 411  :       }

	mov	r8d, DWORD PTR int_mv_in_frame$[rsp]
	mov	r9, QWORD PTR state$[rbp-256]
$LN37@inter_reco:

; 431  :           yuv_px->y,
; 432  :           pu_w, pu_h,
; 433  :           ref->width, out_stride_luma);
; 434  :       }
; 435  :     }
; 436  :   }
; 437  : 
; 438  :   if (!predict_chroma) {

	mov	r14, QWORD PTR yuv_px$[rbp-256]
$LN8@inter_reco:
	cmp	BYTE PTR predict_chroma$[rbp-256], r12b
	jne	$LN9@inter_reco

; 439  :     return fractional_luma;

	movzx	eax, r13b
	jmp	$LN1@inter_reco
$LN5@inter_reco:

; 75   :   kvz_epol_args epol_args = {

	mov	rax, QWORD PTR [r15+16]

; 76   :     .src = ref->y,
; 77   :     .src_w = ref->width,
; 78   :     .src_h = ref->height,
; 79   :     .src_s = ref->stride,
; 80   :     .blk_x = state->tile->offset_x + xpos + (mv_param[0] >> 2),
; 81   :     .blk_y = state->tile->offset_y + ypos + (mv_param[1] >> 2),
; 82   :     .blk_w = block_width,
; 83   :     .blk_h = block_height,
; 84   :     .pad_l = KVZ_LUMA_FILTER_OFFSET,
; 85   :     .pad_r = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 86   :     .pad_t = KVZ_LUMA_FILTER_OFFSET,
; 87   :     .pad_b = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 88   :     .pad_b_simd = 1 // One row for AVX2
; 89   :   };
; 90   : 
; 91   :   // Initialize separately. Gets rid of warning
; 92   :   // about using nonstandard extension.
; 93   :   epol_args.buf = ext_buffer;
; 94   :   epol_args.ext = &ext;
; 95   :   epol_args.ext_origin = &ext_origin;
; 96   :   epol_args.ext_s = &ext_s;
; 97   : 
; 98   :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$11[rsp]
	mov	QWORD PTR epol_args$11[rsp], rax
	mov	eax, DWORD PTR [r15+64]
	mov	DWORD PTR epol_args$11[rsp+8], eax
	mov	eax, DWORD PTR [r15+68]
	mov	DWORD PTR epol_args$11[rsp+12], eax
	mov	eax, DWORD PTR [r15+72]
	mov	DWORD PTR epol_args$11[rbp-240], eax
	lea	rax, QWORD PTR ext_buffer$17[rbp-256]
	mov	QWORD PTR epol_args$11[rbp-200], rax
	lea	rax, QWORD PTR ext$7[rsp]
	mov	QWORD PTR epol_args$11[rbp-192], rax
	lea	rax, QWORD PTR ext_origin$13[rbp-256]
	mov	QWORD PTR epol_args$11[rbp-184], rax
	lea	rax, QWORD PTR ext_s$20[rbp-256]
	mov	QWORD PTR epol_args$11[rbp-176], rax
	mov	QWORD PTR ext$7[rsp], r12
	mov	QWORD PTR ext_origin$13[rbp-256], r12
	mov	DWORD PTR ext_s$20[rbp-256], r12d
	mov	DWORD PTR epol_args$11[rbp-236], r8d
	mov	DWORD PTR epol_args$11[rbp-232], edi
	mov	DWORD PTR epol_args$11[rbp-228], esi
	mov	DWORD PTR epol_args$11[rbp-224], ebx
	mov	DWORD PTR epol_args$11[rbp-220], 3
	mov	DWORD PTR epol_args$11[rbp-216], 4
	mov	DWORD PTR epol_args$11[rbp-212], 3
	mov	DWORD PTR epol_args$11[rbp-208], 4
	mov	DWORD PTR epol_args$11[rbp-204], 1
	call	QWORD PTR kvz_get_extended_block
	movsx	eax, WORD PTR tv1535[rsp]
	and	r14b, 3

; 99   :   kvz_sample_quarterpel_luma(state->encoder_control,

	mov	rcx, QWORD PTR mv_param$[rbp-256]
	and	al, 3
	movzx	r8d, WORD PTR ext_s$20[rbp-256]
	mov	r9d, esi
	mov	rdx, QWORD PTR ext_origin$13[rbp-256]
	mov	QWORD PTR [rsp+72], rcx
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	BYTE PTR [rsp+64], al
	mov	eax, DWORD PTR out_stride_luma$[rbp-256]
	mov	BYTE PTR [rsp+56], r14b
	mov	r14, QWORD PTR yuv_px$[rbp-256]
	mov	rcx, QWORD PTR [rcx]
	mov	WORD PTR [rsp+48], ax
	mov	rax, QWORD PTR [r14+8]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], ebx
	call	QWORD PTR kvz_sample_quarterpel_luma

; 412  :       else {
; 413  :         inter_recon_frac_luma(state, ref,
; 414  :           pu_x, pu_y,
; 415  :           pu_w, pu_h,
; 416  :           mv_param, yuv_px, out_stride_luma);
; 417  :       }
; 418  :     }

	mov	r8d, DWORD PTR int_mv_in_frame$[rsp]
	mov	r9, QWORD PTR state$[rbp-256]
	jmp	$LN8@inter_reco
$LN3@inter_reco:

; 419  :     else {
; 420  :       // With an integer MV, copy pixels directly from the reference.
; 421  :       if (int_mv_outside_frame) {

	mov	edx, DWORD PTR [r15+64]
	mov	r14, QWORD PTR yuv_px$[rbp-256]
	test	al, al
	je	SHORT $LN7@inter_reco

; 422  :         inter_cp_with_ext_border(ref->y, ref->width,

	mov	r9d, DWORD PTR [r15+68]
	lea	rax, QWORD PTR int_mv_in_frame$[rsp]
	mov	rcx, QWORD PTR [r15+16]
	mov	r8d, edx
	mov	QWORD PTR [rsp+64], rax
	mov	eax, DWORD PTR out_stride_luma$[rbp-256]
	mov	DWORD PTR [rsp+56], ebx
	mov	DWORD PTR [rsp+48], esi
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR [r14+8]
	mov	QWORD PTR [rsp+32], rax
	call	inter_cp_with_ext_border

; 423  :           ref->width, ref->height,
; 424  :           yuv_px->y, out_stride_luma,
; 425  :           pu_w, pu_h,
; 426  :           &int_mv_in_frame);
; 427  :       }

	mov	r8d, DWORD PTR int_mv_in_frame$[rsp]
	mov	r9, QWORD PTR state$[rbp-256]
	jmp	$LN8@inter_reco
$LN7@inter_reco:

; 428  :       else {
; 429  :         const int frame_mv_index = int_mv_in_frame.y * ref->width + int_mv_in_frame.x;

	mov	eax, edx

; 430  :         kvz_pixels_blit(&ref->y[frame_mv_index],

	mov	r9d, ebx
	imul	eax, edi
	add	eax, r8d
	mov	r8d, esi
	movsxd	rcx, eax
	mov	eax, DWORD PTR out_stride_luma$[rbp-256]
	add	rcx, QWORD PTR [r15+16]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], edx
	mov	rdx, QWORD PTR [r14+8]
	call	kvz_pixels_blit
	mov	r8d, DWORD PTR int_mv_in_frame$[rsp]
	mov	r9, QWORD PTR state$[rbp-256]
	jmp	$LN8@inter_reco
$LN9@inter_reco:

; 440  :   }
; 441  : 
; 442  :   const unsigned out_stride_c = out_stride_luma / 2;

	mov	eax, DWORD PTR out_stride_luma$[rbp-256]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR out_stride_c$1$[rbp-256], eax
	mov	r11d, eax

; 443  : 
; 444  :   // Generate prediction for chroma.
; 445  :   if (fractional_luma || fractional_chroma) {

	test	r13b, r13b
	jne	$LN12@inter_reco
	cmp	BYTE PTR $T1[rsp], r12b
	jne	$LN12@inter_reco

; 453  :       inter_recon_frac_chroma(state, ref,
; 454  :                               pu_x, pu_y,
; 455  :                               pu_w, pu_h,
; 456  :                               mv_param, yuv_px, out_stride_c);
; 457  :     }
; 458  :   } else {
; 459  :     // With an integer MV, copy pixels directly from the reference.
; 460  :     const vector2d_t int_mv_in_frame_c = { int_mv_in_frame.x / 2, int_mv_in_frame.y / 2 };

	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r8d, eax
	mov	DWORD PTR int_mv_in_frame_c$19[rbp-256], eax
	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r9d, eax
	mov	DWORD PTR int_mv_in_frame_c$19[rbp-252], eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax

; 461  : 
; 462  :     if (int_mv_outside_frame) {

	mov	eax, DWORD PTR [r15+64]
	cmp	BYTE PTR $T2[rsp], r12b
	je	$LN15@inter_reco

; 463  :       inter_cp_with_ext_border(ref->u, ref->width / 2,

	mov	rcx, QWORD PTR [r14+16]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r10d, eax
	mov	eax, DWORD PTR [r15+68]
	cdq
	mov	r8d, r10d
	sub	eax, edx
	mov	edx, r10d
	sar	eax, 1
	mov	r9d, eax
	lea	rax, QWORD PTR int_mv_in_frame_c$19[rbp-256]
	mov	QWORD PTR [rsp+64], rax
	mov	DWORD PTR [rsp+56], edi
	mov	DWORD PTR [rsp+48], esi
	mov	DWORD PTR [rsp+40], r11d
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR [r15+24]
	call	inter_cp_with_ext_border

; 464  :                                ref->width / 2, ref->height / 2,
; 465  :                                yuv_px->u, out_stride_c,
; 466  :                                pu_w / 2, pu_h / 2,
; 467  :                                &int_mv_in_frame_c);
; 468  :       inter_cp_with_ext_border(ref->v, ref->width / 2,

	mov	eax, DWORD PTR [r15+64]
	mov	rcx, QWORD PTR [r14+24]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r10d, eax
	mov	eax, DWORD PTR [r15+68]
	cdq
	mov	r8d, r10d
	sub	eax, edx
	mov	edx, DWORD PTR out_stride_c$1$[rbp-256]
	sar	eax, 1
	mov	r9d, eax
	lea	rax, QWORD PTR int_mv_in_frame_c$19[rbp-256]
	mov	QWORD PTR [rsp+64], rax
	mov	DWORD PTR [rsp+56], edi
	mov	DWORD PTR [rsp+48], esi
	mov	DWORD PTR [rsp+40], edx
	mov	edx, r10d
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR [r15+32]
	call	inter_cp_with_ext_border

; 469  :                                ref->width / 2, ref->height / 2,
; 470  :                                yuv_px->v, out_stride_c,
; 471  :                                pu_w / 2, pu_h / 2,
; 472  :                                &int_mv_in_frame_c);
; 473  :     } else {

	jmp	$LN25@inter_reco
$LN15@inter_reco:

; 474  :       const int frame_mv_index = int_mv_in_frame_c.y * ref->width / 2 + int_mv_in_frame_c.x;
; 475  : 
; 476  :       kvz_pixels_blit(&ref->u[frame_mv_index],

	mov	rcx, QWORD PTR [r15+24]
	imul	eax, r9d
	mov	r9d, edi
	mov	DWORD PTR [rsp+40], r11d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r8d
	mov	r8d, esi
	movsxd	rbx, eax
	mov	eax, DWORD PTR [r15+64]
	add	rcx, rbx
	cdq
	sub	eax, edx
	mov	rdx, QWORD PTR [r14+16]
	sar	eax, 1
	mov	DWORD PTR [rsp+32], eax
	call	kvz_pixels_blit

; 477  :                       yuv_px->u,
; 478  :                       pu_w / 2, pu_h / 2,
; 479  :                       ref->width / 2, out_stride_c);
; 480  :       kvz_pixels_blit(&ref->v[frame_mv_index],

	mov	eax, DWORD PTR [r15+64]
	mov	r9d, edi
	mov	rcx, QWORD PTR [r15+32]
	cdq
	sub	eax, edx
	add	rcx, rbx
	mov	edx, DWORD PTR out_stride_c$1$[rbp-256]
	mov	r8d, esi
	mov	DWORD PTR [rsp+40], edx
	mov	rdx, QWORD PTR [r14+24]
	sar	eax, 1
	mov	DWORD PTR [rsp+32], eax
	call	kvz_pixels_blit
	jmp	$LN25@inter_reco
$LN12@inter_reco:

; 446  :     // With a fractional MV, do interpolation.
; 447  :     if (state->encoder_control->cfg.bipred && yuv_im) {

	mov	rax, QWORD PTR [r9]
	cmp	DWORD PTR [rax+92], r12d
	je	$LN13@inter_reco
	cmp	QWORD PTR yuv_im$[rbp-256], r12
	je	$LN13@inter_reco

; 254  :   int mv_frac_x = (mv_param[0] & 7);

	mov	rax, QWORD PTR mv_param$[rbp-256]

; 255  :   int mv_frac_y = (mv_param[1] & 7);
; 256  : 
; 257  :   // Take into account chroma subsampling
; 258  :   unsigned pb_w = pu_w / 2;
; 259  :   unsigned pb_h = pu_h / 2;
; 260  : 
; 261  :   // Space for extrapolated pixels and the part from the picture.
; 262  :   // Some extra for AVX2.
; 263  :   // The extrapolation function will set the pointers and stride.
; 264  :   kvz_pixel ext_buffer[KVZ_IPOL_MAX_INPUT_SIZE_CHROMA_SIMD];
; 265  :   kvz_pixel *ext = NULL;
; 266  :   kvz_pixel *ext_origin = NULL;
; 267  :   int ext_s = 0;
; 268  : 
; 269  :   // Chroma U
; 270  :   // Divisions by 2 due to 4:2:0 chroma subsampling
; 271  :   kvz_epol_args epol_args = {

	mov	rcx, QWORD PTR [r15+24]
	mov	r8, QWORD PTR [r9+48]
	mov	QWORD PTR epol_args$10[rsp], rcx
	movsx	r14d, WORD PTR [rax]
	movsx	edi, WORD PTR [rax+2]
	mov	ecx, r14d
	sar	ecx, 3
	mov	eax, esi
	cdq
	mov	QWORD PTR ext$6[rsp], r12
	sub	eax, edx
	mov	QWORD PTR ext_origin$4[rsp], r12
	sar	eax, 1
	mov	esi, eax
	mov	DWORD PTR ext_s$23[rbp-256], r12d
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ebx, eax
	mov	eax, DWORD PTR [r15+64]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$10[rsp+8], eax
	mov	eax, DWORD PTR [r15+68]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$10[rsp+12], eax
	mov	eax, DWORD PTR [r15+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$10[rbp-240], eax
	mov	eax, DWORD PTR [r8+20]
	add	eax, DWORD PTR pu_x$[rbp-256]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	ecx, edi
	mov	DWORD PTR epol_args$10[rbp-236], eax
	mov	eax, DWORD PTR [r8+24]
	add	eax, DWORD PTR pu_y$[rbp-256]
	cdq
	sar	ecx, 3
	sub	eax, edx
	mov	DWORD PTR epol_args$10[rbp-228], esi
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR epol_args$10[rbp-224], ebx
	mov	DWORD PTR epol_args$10[rbp-232], eax

; 272  :     .src = ref->u,
; 273  :     .src_w = ref->width / 2,
; 274  :     .src_h = ref->height / 2,
; 275  :     .src_s = ref->stride / 2,
; 276  :     .blk_x = (state->tile->offset_x + pu_x) / 2 + (mv_param[0] >> 3),
; 277  :     .blk_y = (state->tile->offset_y + pu_y) / 2 + (mv_param[1] >> 3),
; 278  :     .blk_w = pb_w,
; 279  :     .blk_h = pb_h,
; 280  :     .pad_l = KVZ_CHROMA_FILTER_OFFSET,
; 281  :     .pad_r = KVZ_EXT_PADDING_CHROMA - KVZ_CHROMA_FILTER_OFFSET,
; 282  :     .pad_t = KVZ_CHROMA_FILTER_OFFSET,
; 283  :     .pad_b = KVZ_EXT_PADDING_CHROMA - KVZ_CHROMA_FILTER_OFFSET,
; 284  :     .pad_b_simd = 3 // Three rows for AVX2
; 285  :   };
; 286  : 
; 287  :   // Initialize separately. Gets rid of warning
; 288  :   // about using nonstandard extension.
; 289  :   epol_args.buf = ext_buffer;
; 290  :   epol_args.ext = &ext;
; 291  :   epol_args.ext_origin = &ext_origin;
; 292  :   epol_args.ext_s = &ext_s;
; 293  : 
; 294  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$10[rsp]
	lea	rax, QWORD PTR ext_buffer$16[rbp-256]
	mov	DWORD PTR epol_args$10[rbp-220], 1
	mov	QWORD PTR epol_args$10[rbp-200], rax
	lea	rax, QWORD PTR ext$6[rsp]
	mov	QWORD PTR epol_args$10[rbp-192], rax
	lea	rax, QWORD PTR ext_origin$4[rsp]
	mov	QWORD PTR epol_args$10[rbp-184], rax
	lea	rax, QWORD PTR ext_s$23[rbp-256]
	mov	QWORD PTR epol_args$10[rbp-176], rax
	mov	DWORD PTR epol_args$10[rbp-216], 2
	mov	DWORD PTR epol_args$10[rbp-212], 1
	mov	DWORD PTR epol_args$10[rbp-208], 2
	mov	DWORD PTR epol_args$10[rbp-204], 3
	call	QWORD PTR kvz_get_extended_block

; 295  :   kvz_sample_octpel_chroma_hi(state->encoder_control,

	mov	rax, QWORD PTR yuv_im$[rbp-256]
	and	dil, 7
	mov	rcx, QWORD PTR mv_param$[rbp-256]
	and	r14b, 7
	mov	edx, DWORD PTR out_stride_c$1$[rbp-256]
	mov	QWORD PTR [rsp+72], rcx
	mov	rax, QWORD PTR [rax+16]
	mov	BYTE PTR [rsp+64], dil
	mov	BYTE PTR [rsp+56], r14b
	mov	WORD PTR [rsp+48], dx
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], ebx
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	r9d, esi
	movzx	r8d, WORD PTR ext_s$23[rbp-256]
	mov	rdx, QWORD PTR ext_origin$4[rsp]
	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR kvz_sample_octpel_chroma_hi

; 296  :     ext_origin,
; 297  :     ext_s,
; 298  :     pb_w,
; 299  :     pb_h,
; 300  :     out->u,
; 301  :     out_stride,
; 302  :     mv_frac_x,
; 303  :     mv_frac_y,
; 304  :     mv_param);
; 305  : 
; 306  :   // Chroma V
; 307  :   epol_args.src = ref->v;

	mov	rax, QWORD PTR [r15+32]

; 308  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$10[rsp]
	mov	QWORD PTR epol_args$10[rsp], rax
	call	QWORD PTR kvz_get_extended_block

; 309  :   kvz_sample_octpel_chroma_hi(state->encoder_control,

	mov	rax, QWORD PTR mv_param$[rbp-256]
	mov	r9d, esi
	movzx	r8d, WORD PTR ext_s$23[rbp-256]
	mov	rdx, QWORD PTR ext_origin$4[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR out_stride_c$1$[rbp-256]
	mov	BYTE PTR [rsp+64], dil
	mov	BYTE PTR [rsp+56], r14b
	mov	WORD PTR [rsp+48], ax
	mov	rax, QWORD PTR yuv_im$[rbp-256]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR state$[rbp-256]
	mov	DWORD PTR [rsp+32], ebx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR kvz_sample_octpel_chroma_hi

; 448  :       inter_recon_frac_chroma_hi(state, ref,
; 449  :                                     pu_x, pu_y,
; 450  :                                     pu_w, pu_h, 
; 451  :                                     mv_param, yuv_im, out_stride_c);
; 452  :     } else {

	jmp	$LN32@inter_reco
$LN13@inter_reco:

; 177  :   int mv_frac_x = (mv_param[0] & 7);

	mov	rax, QWORD PTR mv_param$[rbp-256]

; 178  :   int mv_frac_y = (mv_param[1] & 7);
; 179  : 
; 180  :   // Take into account chroma subsampling
; 181  :   unsigned pb_w = pu_w / 2;
; 182  :   unsigned pb_h = pu_h / 2;
; 183  : 
; 184  :   // Space for extrapolated pixels and the part from the picture.
; 185  :   // Some extra for AVX2.
; 186  :   // The extrapolation function will set the pointers and stride.
; 187  :   kvz_pixel ext_buffer[KVZ_IPOL_MAX_INPUT_SIZE_CHROMA_SIMD];
; 188  :   kvz_pixel *ext = NULL;
; 189  :   kvz_pixel *ext_origin = NULL;
; 190  :   int ext_s = 0;
; 191  : 
; 192  :   // Chroma U
; 193  :   // Divisions by 2 due to 4:2:0 chroma subsampling
; 194  :   kvz_epol_args epol_args = {

	mov	rcx, QWORD PTR [r15+24]
	mov	r8, QWORD PTR [r9+48]
	mov	QWORD PTR epol_args$9[rsp], rcx
	movsx	r14d, WORD PTR [rax]
	movsx	edi, WORD PTR [rax+2]
	mov	ecx, r14d
	sar	ecx, 3
	mov	eax, esi
	cdq
	mov	QWORD PTR ext$5[rsp], r12
	sub	eax, edx
	mov	QWORD PTR ext_origin$3[rsp], r12
	sar	eax, 1
	mov	esi, eax
	mov	DWORD PTR ext_s$22[rbp-256], r12d
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ebx, eax
	mov	eax, DWORD PTR [r15+64]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$9[rsp+8], eax
	mov	eax, DWORD PTR [r15+68]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$9[rsp+12], eax
	mov	eax, DWORD PTR [r15+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR epol_args$9[rbp-240], eax
	mov	eax, DWORD PTR [r8+20]
	add	eax, DWORD PTR pu_x$[rbp-256]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	ecx, edi
	mov	DWORD PTR epol_args$9[rbp-236], eax
	mov	eax, DWORD PTR [r8+24]
	add	eax, DWORD PTR pu_y$[rbp-256]
	cdq
	sar	ecx, 3
	sub	eax, edx
	mov	DWORD PTR epol_args$9[rbp-228], esi
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR epol_args$9[rbp-224], ebx
	mov	DWORD PTR epol_args$9[rbp-232], eax

; 195  :     .src = ref->u,
; 196  :     .src_w = ref->width / 2,
; 197  :     .src_h = ref->height / 2,
; 198  :     .src_s = ref->stride / 2,
; 199  :     .blk_x = (state->tile->offset_x + pu_x) / 2 + (mv_param[0] >> 3),
; 200  :     .blk_y = (state->tile->offset_y + pu_y) / 2 + (mv_param[1] >> 3),
; 201  :     .blk_w = pb_w,
; 202  :     .blk_h = pb_h,
; 203  :     .pad_l = KVZ_CHROMA_FILTER_OFFSET,
; 204  :     .pad_r = KVZ_EXT_PADDING_CHROMA - KVZ_CHROMA_FILTER_OFFSET,
; 205  :     .pad_t = KVZ_CHROMA_FILTER_OFFSET,
; 206  :     .pad_b = KVZ_EXT_PADDING_CHROMA - KVZ_CHROMA_FILTER_OFFSET,
; 207  :     .pad_b_simd = 3 // Three rows for AVX2
; 208  :   };
; 209  : 
; 210  :   // Initialize separately. Gets rid of warning
; 211  :   // about using nonstandard extension.
; 212  :   epol_args.buf = ext_buffer;
; 213  :   epol_args.ext = &ext;
; 214  :   epol_args.ext_origin = &ext_origin;
; 215  :   epol_args.ext_s = &ext_s;
; 216  : 
; 217  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$9[rsp]
	lea	rax, QWORD PTR ext_buffer$15[rbp-256]
	mov	DWORD PTR epol_args$9[rbp-220], 1
	mov	QWORD PTR epol_args$9[rbp-200], rax
	lea	rax, QWORD PTR ext$5[rsp]
	mov	QWORD PTR epol_args$9[rbp-192], rax
	lea	rax, QWORD PTR ext_origin$3[rsp]
	mov	QWORD PTR epol_args$9[rbp-184], rax
	lea	rax, QWORD PTR ext_s$22[rbp-256]
	mov	QWORD PTR epol_args$9[rbp-176], rax
	mov	DWORD PTR epol_args$9[rbp-216], 2
	mov	DWORD PTR epol_args$9[rbp-212], 1
	mov	DWORD PTR epol_args$9[rbp-208], 2
	mov	DWORD PTR epol_args$9[rbp-204], 3
	call	QWORD PTR kvz_get_extended_block

; 218  :   kvz_sample_octpel_chroma(state->encoder_control,

	mov	rax, QWORD PTR mv_param$[rbp-256]
	and	dil, 7
	mov	QWORD PTR [rsp+72], rax
	and	r14b, 7
	mov	eax, DWORD PTR out_stride_c$1$[rbp-256]
	mov	BYTE PTR [rsp+64], dil
	mov	BYTE PTR [rsp+56], r14b
	mov	WORD PTR [rsp+48], ax
	mov	rax, QWORD PTR yuv_px$[rbp-256]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], ebx
	mov	rax, QWORD PTR state$[rbp-256]
	mov	r9d, esi
	movzx	r8d, WORD PTR ext_s$22[rbp-256]
	mov	rdx, QWORD PTR ext_origin$3[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR kvz_sample_octpel_chroma

; 219  :     ext_origin,
; 220  :     ext_s,
; 221  :     pb_w,
; 222  :     pb_h,
; 223  :     out->u,
; 224  :     out_stride,
; 225  :     mv_frac_x,
; 226  :     mv_frac_y,
; 227  :     mv_param);
; 228  : 
; 229  :   // Chroma V
; 230  :   epol_args.src = ref->v;

	mov	rax, QWORD PTR [r15+32]

; 231  :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$9[rsp]
	mov	QWORD PTR epol_args$9[rsp], rax
	call	QWORD PTR kvz_get_extended_block

; 232  :   kvz_sample_octpel_chroma(state->encoder_control,

	mov	rax, QWORD PTR mv_param$[rbp-256]
	mov	r9d, esi
	movzx	r8d, WORD PTR ext_s$22[rbp-256]
	mov	rdx, QWORD PTR ext_origin$3[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	eax, DWORD PTR out_stride_c$1$[rbp-256]
	mov	BYTE PTR [rsp+64], dil
	mov	BYTE PTR [rsp+56], r14b
	mov	WORD PTR [rsp+48], ax
	mov	rax, QWORD PTR yuv_px$[rbp-256]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR state$[rbp-256]
	mov	DWORD PTR [rsp+32], ebx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR kvz_sample_octpel_chroma
$LN32@inter_reco:

; 481  :                       yuv_px->v,
; 482  :                       pu_w / 2, pu_h / 2,
; 483  :                       ref->width / 2, out_stride_c);
; 484  :     }
; 485  :   }
; 486  : 
; 487  :   return fractional_luma | ((fractional_luma || fractional_chroma) << 1);

	test	r13b, r13b
	jne	SHORT $LN24@inter_reco
	cmp	BYTE PTR $T1[rsp], r12b
	je	SHORT $LN25@inter_reco
$LN24@inter_reco:
	mov	r12d, 2
$LN25@inter_reco:
	movzx	eax, r13b
	or	eax, r12d
$LN1@inter_reco:
	mov	r13, QWORD PTR [rsp+5416]

; 488  : }

	add	rsp, 5344				; 000014e0H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
inter_recon_unipred ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
im_L1$ = 0
im_L0$ = 32
px_L1$ = 64
px_L0$ = 96
px_buf_L0$ = 128
px_buf_L1$ = 6272
im_buf_L0$ = 12416
im_buf_L1$ = 24704
state$ = 37216
ref1$ = 37224
ref2$ = 37232
pu_x$ = 37240
pu_y$ = 37248
pu_w$ = 37256
pu_h$ = 37264
mv_param$ = 37272
lcu$ = 37280
predict_luma$ = 37288
predict_chroma$ = 37296
kvz_inter_recon_bipred PROC

; 515  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	DWORD PTR [rsp+32], r9d
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	eax, 37168				; 00009130H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+176]
	and	rbp, -64				; ffffffffffffffc0H

; 516  :   // Allocate maximum size arrays for interpolated and copied samples
; 517  :   ALIGNED(64) kvz_pixel px_buf_L0[LCU_LUMA_SIZE + 2 * LCU_CHROMA_SIZE];
; 518  :   ALIGNED(64) kvz_pixel px_buf_L1[LCU_LUMA_SIZE + 2 * LCU_CHROMA_SIZE];
; 519  :   ALIGNED(64) kvz_pixel_im im_buf_L0[LCU_LUMA_SIZE + 2 * LCU_CHROMA_SIZE];
; 520  :   ALIGNED(64) kvz_pixel_im im_buf_L1[LCU_LUMA_SIZE + 2 * LCU_CHROMA_SIZE];
; 521  : 
; 522  :   yuv_t px_L0;
; 523  :   px_L0.size = pu_w * pu_h;
; 524  :   px_L0.y = &px_buf_L0[0];
; 525  :   px_L0.u = &px_buf_L0[LCU_LUMA_SIZE];
; 526  :   px_L0.v = &px_buf_L0[LCU_LUMA_SIZE + LCU_CHROMA_SIZE];
; 527  : 
; 528  :   yuv_t px_L1;
; 529  :   px_L1.size = pu_w * pu_h;
; 530  :   px_L1.y = &px_buf_L1[0];
; 531  :   px_L1.u = &px_buf_L1[LCU_LUMA_SIZE];
; 532  :   px_L1.v = &px_buf_L1[LCU_LUMA_SIZE + LCU_CHROMA_SIZE];
; 533  : 
; 534  :   yuv_im_t im_L0;
; 535  :   im_L0.size = pu_w * pu_h;
; 536  :   im_L0.y = &im_buf_L0[0];
; 537  :   im_L0.u = &im_buf_L0[LCU_LUMA_SIZE];
; 538  :   im_L0.v = &im_buf_L0[LCU_LUMA_SIZE + LCU_CHROMA_SIZE];
; 539  : 
; 540  :   yuv_im_t im_L1;
; 541  :   im_L1.size = pu_w * pu_h;
; 542  :   im_L1.y = &im_buf_L1[0];
; 543  :   im_L1.u = &im_buf_L1[LCU_LUMA_SIZE];
; 544  :   im_L1.v = &im_buf_L1[LCU_LUMA_SIZE + LCU_CHROMA_SIZE];
; 545  : 
; 546  :   // Sample blocks from both reference picture lists.
; 547  :   // Flags state if the outputs were written to high-precision / interpolated sample buffers.
; 548  :   unsigned im_flags_L0 = inter_recon_unipred(state, ref1, pu_x, pu_y, pu_w, pu_h, pu_w, mv_param[0],

	movzx	r15d, BYTE PTR predict_chroma$[rsp]
	mov	r10d, r9d
	movzx	r14d, BYTE PTR predict_luma$[rsp]
	lea	r9, QWORD PTR px_buf_L0$[rbp]
	mov	rbx, QWORD PTR mv_param$[rsp]
	mov	r13, r8
	mov	r8d, DWORD PTR pu_w$[rsp]
	mov	r12, rcx
	mov	ecx, DWORD PTR pu_h$[rsp]
	mov	eax, r8d
	mov	esi, DWORD PTR pu_y$[rsp]
	imul	eax, ecx
	mov	QWORD PTR px_L0$[rbp+8], r9
	lea	r9, QWORD PTR px_buf_L0$[rbp+4096]
	mov	QWORD PTR px_L0$[rbp+16], r9
	lea	r9, QWORD PTR px_buf_L0$[rbp+5120]
	mov	QWORD PTR px_L0$[rbp+24], r9
	lea	r9, QWORD PTR px_buf_L1$[rbp]
	mov	QWORD PTR px_L1$[rbp+8], r9
	lea	r9, QWORD PTR px_buf_L1$[rbp+4096]
	mov	BYTE PTR [rsp+88], r15b
	mov	DWORD PTR px_L0$[rbp], eax
	mov	DWORD PTR px_L1$[rbp], eax
	mov	DWORD PTR im_L0$[rbp], eax
	mov	DWORD PTR im_L1$[rbp], eax
	lea	rax, QWORD PTR im_buf_L1$[rbp]
	mov	QWORD PTR px_L1$[rbp+16], r9
	lea	r9, QWORD PTR px_buf_L1$[rbp+5120]
	mov	BYTE PTR [rsp+80], r14b
	mov	QWORD PTR im_L1$[rbp+8], rax
	lea	rax, QWORD PTR im_buf_L1$[rbp+8192]
	mov	QWORD PTR px_L1$[rbp+24], r9
	lea	r9, QWORD PTR im_buf_L0$[rbp]
	mov	QWORD PTR im_L1$[rbp+16], rax
	lea	rax, QWORD PTR im_buf_L1$[rbp+10240]
	mov	QWORD PTR im_L0$[rbp+8], r9
	lea	r9, QWORD PTR im_buf_L0$[rbp+8192]
	mov	QWORD PTR im_L1$[rbp+24], rax
	lea	rax, QWORD PTR im_L0$[rbp]
	mov	QWORD PTR [rsp+72], rax
	lea	rax, QWORD PTR px_L0$[rbp]
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], rbx
	mov	DWORD PTR [rsp+48], r8d
	mov	QWORD PTR im_L0$[rbp+16], r9
	lea	r9, QWORD PTR im_buf_L0$[rbp+10240]
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], r8d
	mov	r8d, r10d
	mov	QWORD PTR im_L0$[rbp+24], r9
	mov	r9d, esi
	call	inter_recon_unipred

; 549  :                                              &px_L0, &im_L0, predict_luma, predict_chroma);
; 550  :   unsigned im_flags_L1 = inter_recon_unipred(state, ref2, pu_x, pu_y, pu_w, pu_h, pu_w, mv_param[1],

	mov	r8d, DWORD PTR pu_x$[rsp]
	lea	rcx, QWORD PTR [rbx+4]
	mov	ebx, DWORD PTR pu_h$[rsp]
	mov	edi, eax
	mov	BYTE PTR [rsp+88], r15b
	lea	rax, QWORD PTR im_L1$[rbp]
	mov	BYTE PTR [rsp+80], r14b
	mov	r9d, esi
	mov	QWORD PTR [rsp+72], rax
	mov	rdx, r13
	lea	rax, QWORD PTR px_L1$[rbp]
	mov	QWORD PTR [rsp+64], rax
	mov	eax, DWORD PTR pu_w$[rsp]
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, r12
	mov	DWORD PTR [rsp+48], eax
	mov	DWORD PTR [rsp+40], ebx
	mov	DWORD PTR [rsp+32], eax
	call	inter_recon_unipred

; 551  :                                              &px_L1, &im_L1, predict_luma, predict_chroma);
; 552  : 
; 553  :   // After reconstruction, merge the predictors by taking an average of each pixel
; 554  :   kvz_bipred_average(lcu, &px_L0, &px_L1, &im_L0, &im_L1,

	mov	BYTE PTR [rsp+96], r15b
	mov	BYTE PTR [rsp+88], r14b
	mov	DWORD PTR [rsp+80], eax
	mov	eax, DWORD PTR pu_w$[rsp]
	mov	DWORD PTR [rsp+72], edi
	mov	DWORD PTR [rsp+64], ebx
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR pu_x$[rsp]
	mov	DWORD PTR [rsp+48], esi
	mov	rcx, QWORD PTR lcu$[rsp]
	lea	r9, QWORD PTR im_L0$[rbp]
	mov	DWORD PTR [rsp+40], eax
	lea	r8, QWORD PTR px_L1$[rbp]
	lea	rax, QWORD PTR im_L1$[rbp]
	lea	rdx, QWORD PTR px_L0$[rbp]
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR kvz_bipred_average

; 555  :                      pu_x, pu_y, pu_w, pu_h,
; 556  :                      im_flags_L0, im_flags_L1,
; 557  :                      predict_luma, predict_chroma);
; 558  : }

	lea	r11, QWORD PTR [rsp+37168]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
kvz_inter_recon_bipred ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
lcu_adapter$2 = 96
state$ = 144
lcu$ = 152
x$ = 160
y$ = 168
width$ = 176
predict_luma$ = 184
predict_chroma$ = 192
i_pu$ = 200
kvz_inter_pred_pu PROC

; 613  : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 128				; 00000080H
	mov	rbp, rdx
	mov	rbx, rcx

; 614  :   cu_info_t *cu = LCU_GET_CU_AT_PX(lcu, SUB_SCU(x), SUB_SCU(y));

	mov	eax, r9d
	mov	r11d, r8d
	sar	eax, 2
	and	eax, 15
	imul	r10d, eax, 17
	mov	eax, r8d
	sar	eax, 2
	and	eax, 15
	add	r10d, eax

; 615  :   const int pu_x = PU_GET_X(cu->part_size, width, x, i_pu);

	movsxd	rax, DWORD PTR i_pu$[rsp]
	lea	r8, QWORD PTR [r10+r10*4]
	movzx	edx, BYTE PTR [rdx+r8*4+25336]
	lea	r10, OFFSET FLAT:__ImageBase
	shr	rdx, 5
	lea	rcx, QWORD PTR [rax+rdx*4]
	lea	r8, QWORD PTR [rcx+rcx]
	mov	ecx, DWORD PTR width$[rsp]
	movzx	eax, BYTE PTR kvz_part_mode_offsets[r8+r10]
	imul	eax, ecx
	cdq
	and	edx, 3
	lea	edi, DWORD PTR [rdx+rax]

; 616  :   const int pu_y = PU_GET_Y(cu->part_size, width, y, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[r8+r10+1]
	imul	eax, ecx
	sar	edi, 2
	add	edi, r11d
	cdq
	and	edx, 3
	lea	esi, DWORD PTR [rdx+rax]

; 617  :   const int pu_w = PU_GET_W(cu->part_size, width, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[r8+r10]
	imul	eax, ecx
	sar	esi, 2
	add	esi, r9d
	cdq
	and	edx, 3
	lea	r9d, DWORD PTR [rdx+rax]

; 618  :   const int pu_h = PU_GET_H(cu->part_size, width, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[r8+r10+1]
	imul	eax, ecx

; 619  :   cu_info_t *pu = LCU_GET_CU_AT_PX(lcu, SUB_SCU(pu_x), SUB_SCU(pu_y));

	mov	ecx, esi
	sar	ecx, 2
	and	ecx, 15
	sar	r9d, 2
	cdq
	and	edx, 3
	lea	r14d, DWORD PTR [rdx+rax]
	imul	edx, ecx, 17
	mov	ecx, edi
	sar	r14d, 2
	sar	ecx, 2
	and	ecx, 15
	add	edx, ecx
	mov	ecx, edx
	lea	rdx, QWORD PTR [rdx*4+6334]
	add	rdx, rcx
	lea	r11, QWORD PTR [rdx*4]
	add	r11, rbp

; 620  : 
; 621  :   if (pu->inter.mv_dir == 3) {

	movzx	edx, BYTE PTR [r11+18]
	movzx	eax, dl
	and	al, 192					; 000000c0H
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN2@kvz_inter_

; 622  :     const kvz_picture *const refs[2] = {

	mov	r10, QWORD PTR [rbx+40]
	mov	rax, QWORD PTR [r10+40]
	mov	r8, QWORD PTR [rax]
	movzx	eax, BYTE PTR [r11+16]
	movzx	ecx, BYTE PTR [rax+r10+49]
	movzx	eax, BYTE PTR [r11+17]
	mov	rdx, QWORD PTR [r8+rcx*8]
	movzx	ecx, BYTE PTR [rax+r10+65]

; 623  :       state->frame->ref->images[
; 624  :         state->frame->ref_LX[0][
; 625  :           pu->inter.mv_ref[0]]],
; 626  :       state->frame->ref->images[
; 627  :         state->frame->ref_LX[1][
; 628  :           pu->inter.mv_ref[1]]],
; 629  :     };
; 630  :     kvz_inter_recon_bipred(state,

	movzx	eax, BYTE PTR predict_chroma$[rsp]
	mov	BYTE PTR [rsp+80], al
	movzx	eax, BYTE PTR predict_luma$[rsp]
	mov	r8, QWORD PTR [r8+rcx*8]
	lea	rcx, QWORD PTR [r11+8]
	mov	BYTE PTR [rsp+72], al
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, rbx
	mov	DWORD PTR [rsp+48], r14d
	mov	DWORD PTR [rsp+40], r9d
	mov	r9d, edi
	mov	DWORD PTR [rsp+32], esi
	call	kvz_inter_recon_bipred

; 631  :       refs[0], refs[1],
; 632  :       pu_x, pu_y,
; 633  :       pu_w, pu_h,
; 634  :       pu->inter.mv,
; 635  :       lcu,
; 636  :       predict_luma, predict_chroma);
; 637  :   }

	jmp	$LN3@kvz_inter_
$LN2@kvz_inter_:

; 638  :   else {
; 639  :     const int mv_idx = pu->inter.mv_dir - 1;

	shr	rdx, 6

; 640  :     const kvz_picture *const ref =
; 641  :       state->frame->ref->images[
; 642  :         state->frame->ref_LX[mv_idx][
; 643  :           pu->inter.mv_ref[mv_idx]]];
; 644  : 
; 645  :     const unsigned offset_luma = SUB_SCU(pu_y) * LCU_WIDTH + SUB_SCU(pu_x);
; 646  :     const unsigned offset_chroma = SUB_SCU(pu_y) / 2 * LCU_WIDTH_C + SUB_SCU(pu_x) / 2;
; 647  :     yuv_t lcu_adapter;
; 648  :     lcu_adapter.size = pu_w * pu_h;

	mov	eax, r14d
	imul	eax, r9d

; 649  :     lcu_adapter.y = lcu->rec.y + offset_luma,
; 650  :     lcu_adapter.u = lcu->rec.u + offset_chroma,
; 651  :     lcu_adapter.v = lcu->rec.v + offset_chroma,

	dec	rdx
	mov	ecx, esi
	and	ecx, 63					; 0000003fH
	shl	ecx, 6
	lea	r8, QWORD PTR [rdx+2]
	mov	DWORD PTR lcu_adapter$2[rsp], eax
	lea	r8, QWORD PTR [r11+r8*4]
	mov	eax, edi
	and	eax, 63					; 0000003fH
	add	eax, ecx
	lea	rcx, QWORD PTR [rbp+6540]
	add	rcx, rax
	mov	eax, edi
	sar	eax, 1
	and	eax, 31
	mov	QWORD PTR lcu_adapter$2[rsp+8], rcx
	mov	ecx, esi
	sar	ecx, 1
	and	ecx, 31
	shl	ecx, 5
	add	ecx, eax
	lea	rax, QWORD PTR [rbp+10636]
	add	rax, rcx
	mov	QWORD PTR lcu_adapter$2[rsp+16], rax
	lea	rax, QWORD PTR [rbp+11660]
	add	rax, rcx
	mov	rcx, QWORD PTR [rbx+40]
	mov	QWORD PTR lcu_adapter$2[rsp+24], rax
	movzx	eax, BYTE PTR [rdx+r11+16]
	add	rdx, rdx
	add	rax, rcx
	movzx	r10d, BYTE PTR [rax+rdx*8+49]
	mov	rax, QWORD PTR [rcx+40]
	mov	rcx, rbx
	mov	rdx, QWORD PTR [rax]
	movzx	eax, BYTE PTR predict_chroma$[rsp]
	mov	BYTE PTR [rsp+88], al
	movzx	eax, BYTE PTR predict_luma$[rsp]
	mov	rdx, QWORD PTR [rdx+r10*8]
	mov	BYTE PTR [rsp+80], al
	lea	rax, QWORD PTR lcu_adapter$2[rsp]
	mov	QWORD PTR [rsp+72], 0
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r8
	mov	r8d, edi
	mov	DWORD PTR [rsp+48], 64			; 00000040H
	mov	DWORD PTR [rsp+40], r14d
	mov	DWORD PTR [rsp+32], r9d
	mov	r9d, esi
	call	inter_recon_unipred
$LN3@kvz_inter_:

; 652  : 
; 653  :     inter_recon_unipred(state,
; 654  :       ref,
; 655  :       pu_x, pu_y,
; 656  :       pu_w, pu_h,
; 657  :       LCU_WIDTH,
; 658  :       pu->inter.mv[mv_idx],
; 659  :       &lcu_adapter,
; 660  :       NULL,
; 661  :       predict_luma, predict_chroma);
; 662  :   }
; 663  : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
kvz_inter_pred_pu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
cu$ = 8
inter_clear_cu_unused PROC

; 671  :   for (unsigned i = 0; i < 2; ++i) {
; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	movzx	eax, BYTE PTR [rcx+18]
	xor	edx, edx
	shr	eax, 6
	test	al, 1
	jne	SHORT $LN2@inter_clea

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rcx+8], edx

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rcx+16], 255			; 000000ffH
$LN2@inter_clea:

; 671  :   for (unsigned i = 0; i < 2; ++i) {
; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	test	al, 2
	jne	SHORT $LN10@inter_clea

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rcx+12], edx

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rcx+17], 255			; 000000ffH
$LN10@inter_clea:

; 677  :   }
; 678  : }

	ret	0
inter_clear_cu_unused ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
x$ = 8
y$ = 16
width$ = 24
height$ = 32
is_a0_cand_coded PROC

; 690  : {

	mov	QWORD PTR [rsp+8], rbx

; 691  :   int size = MIN(width & ~(width - 1), height & ~(height - 1));

	mov	r10d, r8d
	mov	eax, r9d
	neg	r10d
	neg	eax
	and	r10d, r8d
	and	eax, r9d

; 692  : 
; 693  :   if (height != size) {

	cmp	r10d, eax
	mov	r11d, edx
	mov	ebx, ecx
	cmovge	r10d, eax
	cmp	r9d, r10d
	je	SHORT $LN14@is_a0_cand

; 694  :     // For SMP and AMP blocks the situation is equivalent to a square block
; 695  :     // at the lower left corner of the PU.
; 696  :     y = y + height - size;

	sub	r9d, r10d
	add	r11d, r9d
$LN14@is_a0_cand:

; 697  :   }
; 698  : 
; 699  :   while (size < LCU_WIDTH) {

	cmp	r10d, 64				; 00000040H
	jge	SHORT $LN3@is_a0_cand
$LL2@is_a0_cand:

; 700  :     const int parent_size = 2 * size;
; 701  :     const int cu_index    = (x % parent_size != 0) + 2 * (y % parent_size != 0);

	xor	ecx, ecx
	lea	r8d, DWORD PTR [r10+r10]
	mov	eax, ebx
	cdq
	idiv	r8d
	mov	eax, r11d
	test	edx, edx
	cdq
	setne	cl
	idiv	r8d
	neg	edx
	sbb	eax, eax
	and	eax, 2
	add	ecx, eax

; 702  :     switch (cu_index) {

	je	SHORT $LN7@is_a0_cand
	sub	ecx, 1
	je	SHORT $LN3@is_a0_cand
	sub	ecx, 1
	je	SHORT $LN9@is_a0_cand
	cmp	ecx, 1
	jne	SHORT $LN4@is_a0_cand
$LN3@is_a0_cand:

; 733  :         break;
; 734  : 
; 735  :       case 3:
; 736  :         // A0 is in the CU directly down of the parent CU so is has not
; 737  :         // been coded yet.
; 738  :         //    +---+---+
; 739  :         //    |   |   |
; 740  :         //    |---+---+
; 741  :         //    |   | X |
; 742  :         //    +---+---+
; 743  :         //     A0
; 744  :         return false;
; 745  :     }
; 746  :   }
; 747  : 
; 748  :   // For 64x64 blocks A0 candidate is located outside the LCU.
; 749  :   return false;

	xor	al, al

; 750  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN9@is_a0_cand:

; 703  :       case 0:
; 704  :         // A0 is in the CU directly left of the parent CU so it has been
; 705  :         // coded already.
; 706  :         //    +---+---+
; 707  :         //    | X |   |
; 708  :         //    |---+---+
; 709  :         // A0 |   |   |
; 710  :         //    +---+---+
; 711  :         return true;
; 712  : 
; 713  :       case 1:
; 714  :         // A0 is in the CU that will be coded after the current CU.
; 715  :         //    +---+---+
; 716  :         //    |   | X |
; 717  :         //    |---+---+
; 718  :         //    |A0 |   |
; 719  :         //    +---+---+
; 720  :         return false;
; 721  : 
; 722  :       case 2:
; 723  :         //    +---+---+
; 724  :         //    |   |   |
; 725  :         //    |---+---+
; 726  :         //    | X |   |
; 727  :         //    +---+---+
; 728  :         // A0
; 729  : 
; 730  :         // Move to the parent block.
; 731  :         y -= size;

	sub	r11d, r10d

; 732  :         size = parent_size;

	mov	r10d, r8d
$LN4@is_a0_cand:

; 697  :   }
; 698  : 
; 699  :   while (size < LCU_WIDTH) {

	cmp	r10d, 64				; 00000040H
	jl	SHORT $LL2@is_a0_cand

; 733  :         break;
; 734  : 
; 735  :       case 3:
; 736  :         // A0 is in the CU directly down of the parent CU so is has not
; 737  :         // been coded yet.
; 738  :         //    +---+---+
; 739  :         //    |   |   |
; 740  :         //    |---+---+
; 741  :         //    |   | X |
; 742  :         //    +---+---+
; 743  :         //     A0
; 744  :         return false;
; 745  :     }
; 746  :   }
; 747  : 
; 748  :   // For 64x64 blocks A0 candidate is located outside the LCU.
; 749  :   return false;

	xor	al, al

; 750  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN7@is_a0_cand:
	mov	rbx, QWORD PTR [rsp+8]
	mov	al, 1
	ret	0
is_a0_cand_coded ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
x$ = 8
y$ = 16
width$ = 24
height$ = 32
is_b0_cand_coded PROC

; 762  : {

	mov	QWORD PTR [rsp+8], rbx

; 763  :   int size = MIN(width & ~(width - 1), height & ~(height - 1));

	mov	r10d, r8d
	mov	eax, r9d
	neg	r10d
	neg	eax
	and	r10d, r8d
	and	eax, r9d

; 764  : 
; 765  :   if (width != size) {

	cmp	r10d, eax
	mov	ebx, edx
	mov	r11d, ecx
	cmovge	r10d, eax
	cmp	r8d, r10d
	je	SHORT $LN14@is_b0_cand

; 766  :     // For SMP and AMP blocks the situation is equivalent to a square block
; 767  :     // at the upper right corner of the PU.
; 768  :     x = x + width - size;

	sub	r8d, r10d
	add	r11d, r8d
$LN14@is_b0_cand:

; 769  :   }
; 770  : 
; 771  :   while (size < LCU_WIDTH) {

	cmp	r10d, 64				; 00000040H
	jge	SHORT $LN17@is_b0_cand
$LL2@is_b0_cand:

; 772  :     const int parent_size = 2 * size;
; 773  :     const int cu_index    = (x % parent_size != 0) + 2 * (y % parent_size != 0);

	xor	ecx, ecx
	lea	r8d, DWORD PTR [r10+r10]
	mov	eax, r11d
	cdq
	idiv	r8d
	mov	eax, ebx
	test	edx, edx
	cdq
	setne	cl
	idiv	r8d
	neg	edx
	sbb	eax, eax
	and	eax, 2
	add	ecx, eax

; 774  :     switch (cu_index) {

	je	SHORT $LN17@is_b0_cand
	sub	ecx, 1
	je	SHORT $LN8@is_b0_cand
	sub	ecx, 1
	je	SHORT $LN17@is_b0_cand
	cmp	ecx, 1
	jne	SHORT $LN4@is_b0_cand

; 797  :         break;
; 798  : 
; 799  :       case 2:
; 800  :         //    +---+---+
; 801  :         //    |   |B0 |
; 802  :         //    |---+---+
; 803  :         //    | X |   |
; 804  :         //    +---+---+
; 805  :         return true;
; 806  : 
; 807  :       case 3:
; 808  :         // B0 is in the CU directly right of the parent CU so is has not
; 809  :         // been coded yet.
; 810  :         //    +---+---+
; 811  :         //    |   |   | B0
; 812  :         //    |---+---+
; 813  :         //    |   | X |
; 814  :         //    +---+---+
; 815  :         return false;

	xor	al, al

; 816  :     }
; 817  :   }
; 818  : 
; 819  :   // The LCU to the right and up of the current LCU has been coded already.
; 820  :   return true;
; 821  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN8@is_b0_cand:

; 775  :       case 0:
; 776  :         // B0 is in the CU directly above the parent CU so it has been
; 777  :         // coded already.
; 778  :         //         B0
; 779  :         //    +---+---+
; 780  :         //    | X |   |
; 781  :         //    |---+---+
; 782  :         //    |   |   |
; 783  :         //    +---+---+
; 784  :         return true;
; 785  : 
; 786  :       case 1:
; 787  :         //             B0
; 788  :         //    +---+---+
; 789  :         //    |   | X |
; 790  :         //    |---+---+
; 791  :         //    |   |   |
; 792  :         //    +---+---+
; 793  : 
; 794  :         // Move to the parent block.
; 795  :         x -= size;

	sub	r11d, r10d

; 796  :         size = parent_size;

	mov	r10d, r8d
$LN4@is_b0_cand:

; 769  :   }
; 770  : 
; 771  :   while (size < LCU_WIDTH) {

	cmp	r10d, 64				; 00000040H
	jl	SHORT $LL2@is_b0_cand
$LN17@is_b0_cand:

; 816  :     }
; 817  :   }
; 818  : 
; 819  :   // The LCU to the right and up of the current LCU has been coded already.
; 820  :   return true;
; 821  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	al, 1
	ret	0
is_b0_cand_coded ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
state$ = 32
x$ = 40
y$ = 48
width$ = 56
height$ = 64
ref_list$dead$ = 72
ref_idx$dead$ = 80
cand_out$ = 88
get_temporal_merge_candidates PROC

; 844  : {

	mov	QWORD PTR [rsp+32], rbx
	push	rsi
	push	rdi
	push	r14

; 845  :   /*
; 846  :   Predictor block locations
; 847  :   _________
; 848  :   |CurrentPU|
; 849  :   | |C0|__  |
; 850  :   |    |C3| |
; 851  :   |_________|_
; 852  :             |H|
; 853  :   */
; 854  : 
; 855  :   cand_out->c3 = cand_out->h = NULL;

	mov	r10, QWORD PTR cand_out$[rsp]
	xor	eax, eax
	mov	edi, r9d
	mov	r14d, r8d
	mov	esi, edx
	mov	rbx, rcx
	mov	QWORD PTR [r10+48], rax
	mov	QWORD PTR [r10+40], rax

; 856  : 
; 857  :   // Find temporal reference
; 858  :   if (state->frame->ref->used_size) {

	mov	rax, QWORD PTR [rcx+40]
	mov	r11, QWORD PTR [rax+40]
	cmp	DWORD PTR [r11+36], 0
	je	$LN3@get_tempor

; 859  :     uint32_t colocated_ref;
; 860  : 
; 861  :     // Select L0/L1 ref_idx reference
; 862  :     if (state->frame->ref_LX_size[ref_list-1] > ref_idx) {

	cmp	BYTE PTR [rax+81], 0
	jbe	$LN3@get_tempor

; 863  :       colocated_ref = state->frame->ref_LX[ref_list - 1][ref_idx];
; 864  :     } else {
; 865  :       // not found
; 866  :       return;
; 867  :     }
; 868  : 
; 869  :     cu_array_t *ref_cu_array = state->frame->ref->cu_arrays[colocated_ref];

	movzx	ecx, BYTE PTR [rax+49]
	mov	rax, QWORD PTR [r11+8]

; 870  :     int cu_per_width = ref_cu_array->width / SCU_WIDTH;
; 871  : 
; 872  :     uint32_t xColBr = x + width;

	lea	r11d, DWORD PTR [rsi+r9]
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+40], r12
	mov	QWORD PTR [rsp+48], r15
	mov	rbp, QWORD PTR [rax+rcx*8]

; 873  :     uint32_t yColBr = y + height;

	mov	r15d, DWORD PTR height$[rsp]
	mov	eax, DWORD PTR [rbp+16]
	cdq
	lea	r9d, DWORD PTR [r8+r15]
	and	edx, 3
	lea	r12d, DWORD PTR [rdx+rax]

; 874  : 
; 875  :     // H must be available
; 876  :     if (xColBr < state->encoder_control->in.width &&

	mov	rdx, QWORD PTR [rbx]
	sar	r12d, 2
	mov	r8, rdx
	cmp	r11d, DWORD PTR [rdx+2528]
	jae	SHORT $LN8@get_tempor
	cmp	r9d, DWORD PTR [rdx+2532]
	jae	SHORT $LN8@get_tempor

; 877  :         yColBr < state->encoder_control->in.height) {
; 878  :       int32_t H_offset = -1;

	mov	ecx, -1

; 879  : 
; 880  :       // Y inside the current CTU / LCU
; 881  :       if (yColBr % LCU_WIDTH != 0) {

	test	r9b, 63					; 0000003fH
	je	SHORT $LN6@get_tempor

; 882  :         H_offset = ((xColBr >> 4) << 4) / SCU_WIDTH +

	shr	r11d, 2
	mov	ecx, r9d
	shr	ecx, 2
	and	r11d, 1073741820			; 3ffffffcH
	and	ecx, 1073741820				; 3ffffffcH
	imul	ecx, r12d
	add	ecx, r11d
$LN6@get_tempor:

; 883  :                   (((yColBr >> 4) << 4) / SCU_WIDTH) * cu_per_width;
; 884  :       }
; 885  : 
; 886  :       if (H_offset >= 0) {

	test	ecx, ecx
	js	SHORT $LN8@get_tempor

; 887  :         // Only use when it's inter block
; 888  :         if (ref_cu_array->data[H_offset].type == CU_INTER) {

	movsxd	rax, ecx
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbp+8]
	lea	r9, QWORD PTR [rax+rcx*4]
	movzx	eax, BYTE PTR [rax+rcx*4]
	and	al, 3
	cmp	al, 2
	jne	SHORT $LN8@get_tempor

; 889  :           cand_out->h = &ref_cu_array->data[H_offset];

	mov	QWORD PTR [r10+48], r9
	mov	r8, QWORD PTR [rbx]
$LN8@get_tempor:

; 890  :         }
; 891  :       }
; 892  :     }
; 893  :     uint32_t xColCtr = x + (width / 2);

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ecx, DWORD PTR [rsi+rax]

; 895  : 
; 896  :     // C3 must be inside the LCU, in the center position of current CU
; 897  :     if (xColCtr < state->encoder_control->in.width && yColCtr < state->encoder_control->in.height) {

	cmp	ecx, DWORD PTR [r8+2528]
	jae	SHORT $LN14@get_tempor

; 894  :     uint32_t yColCtr = y + (height / 2);

	mov	eax, r15d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, r14d

; 895  : 
; 896  :     // C3 must be inside the LCU, in the center position of current CU
; 897  :     if (xColCtr < state->encoder_control->in.width && yColCtr < state->encoder_control->in.height) {

	cmp	eax, DWORD PTR [r8+2532]
	jae	SHORT $LN14@get_tempor

; 898  :       uint32_t C3_offset = ((xColCtr >> 4) << 4) / SCU_WIDTH + ((((yColCtr >> 4) << 4) / SCU_WIDTH) * cu_per_width);

	shr	eax, 2
	and	eax, 1073741820				; 3ffffffcH
	shr	ecx, 2
	imul	eax, r12d
	and	ecx, 1073741820				; 3ffffffcH
	add	eax, ecx

; 899  :       if (ref_cu_array->data[C3_offset].type == CU_INTER) {

	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbp+8]
	lea	rdx, QWORD PTR [rax+rcx*4]
	mov	rcx, QWORD PTR [r10+40]
	movzx	eax, BYTE PTR [rdx]
	and	al, 3
	cmp	al, 2
	cmove	rcx, rdx
	mov	QWORD PTR [r10+40], rcx
$LN14@get_tempor:
	mov	r12, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+32]
	mov	r15, QWORD PTR [rsp+48]
$LN3@get_tempor:

; 900  :         cand_out->c3 = &ref_cu_array->data[C3_offset];
; 901  :       }
; 902  :     }
; 903  :   }
; 904  : }

	mov	rbx, QWORD PTR [rsp+56]
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
get_temporal_merge_candidates ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
x_local$1$ = 96
x$ = 96
y$ = 104
width$ = 112
height$ = 120
picture_width$ = 128
picture_height$ = 136
lcu$ = 144
cand_out$ = 152
get_spatial_merge_candidates PROC

; 930  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	DWORD PTR [rsp+32], r9d
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 931  :   /*
; 932  :   Predictor block locations
; 933  :   ____      _______
; 934  :   |B2|______|B1|B0|
; 935  :      |         |
; 936  :      |  Cur CU |
; 937  :    __|         |
; 938  :   |A1|_________|
; 939  :   |A0|
; 940  :   */
; 941  :   int32_t x_local = SUB_SCU(x); //!< coordinates from top-left of this LCU
; 942  :   int32_t y_local = SUB_SCU(y);
; 943  :   // A0 and A1 availability testing
; 944  :   if (x != 0) {

	mov	rdi, QWORD PTR cand_out$[rsp]
	mov	r12d, ecx
	mov	r13, QWORD PTR lcu$[rsp]
	and	r12d, 63				; 0000003fH
	mov	r15d, edx
	mov	DWORD PTR x_local$1$[rsp], r12d
	and	r15d, 63				; 0000003fH
	xor	r11d, r11d
	mov	ebp, r8d
	mov	esi, edx
	mov	r14d, ecx
	test	ecx, ecx
	je	$LN5@get_spatia

; 945  :     cu_info_t *a1 = LCU_GET_CU_AT_PX(lcu, x_local - 1, y_local + height - 1);

	lea	edx, DWORD PTR [r15+r9]
	lea	eax, DWORD PTR [rdx-1]
	sar	eax, 2
	lea	r10d, DWORD PTR [r12-1]
	imul	eax, eax, 17
	sar	r10d, 2
	add	eax, r10d
	cdqe
	add	rax, 18
	lea	rax, QWORD PTR [rax+rax*4]
	lea	rcx, QWORD PTR [rax*4]
	add	rcx, r13
	lea	r8, QWORD PTR [rcx+24976]

; 946  :     // Do not check a1->coded because the block above is always coded before
; 947  :     // the current one and the flag is not set when searching an SMP block.
; 948  :     if (a1->type == CU_INTER) {

	movzx	eax, BYTE PTR [r8]
	and	al, 3
	cmp	al, 2
	jne	SHORT $LN3@get_spatia

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	movzx	eax, BYTE PTR [rcx+24994]
	shr	eax, 6
	test	al, 1
	jne	SHORT $LN17@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rcx+24984], r11d

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rcx+24992], 255		; 000000ffH
$LN17@get_spatia:

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	test	al, 2
	jne	SHORT $LN57@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rcx+24988], r11d

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rcx+24993], 255		; 000000ffH
$LN57@get_spatia:

; 949  :       inter_clear_cu_unused(a1);
; 950  :       cand_out->a[1] = a1;

	mov	QWORD PTR [rdi+8], r8
$LN3@get_spatia:

; 951  :     }
; 952  : 
; 953  :     if (y_local + height < LCU_WIDTH && y + height < picture_height) {

	cmp	edx, 64					; 00000040H
	jge	$LN5@get_spatia
	lea	eax, DWORD PTR [rsi+r9]
	cmp	eax, DWORD PTR picture_height$[rsp]
	jge	$LN5@get_spatia

; 954  :       cu_info_t *a0 = LCU_GET_CU_AT_PX(lcu, x_local - 1, y_local + height);

	sar	edx, 2
	imul	eax, edx, 17
	add	eax, r10d
	movsxd	rcx, eax
	add	rcx, 18
	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	rbx, QWORD PTR [rax*4]
	add	rbx, r13
	lea	r12, QWORD PTR [rbx+24976]

; 955  :       if (a0->type == CU_INTER && is_a0_cand_coded(x, y, width, height)) {

	movzx	eax, BYTE PTR [r12]
	and	al, 3
	cmp	al, 2
	jne	SHORT $LN77@get_spatia
	mov	r8d, ebp
	mov	edx, esi
	mov	ecx, r14d
	call	is_a0_cand_coded
	test	al, al
	je	SHORT $LN76@get_spatia

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	movzx	eax, BYTE PTR [rbx+24994]
	shr	eax, 6
	test	al, 1
	jne	SHORT $LN23@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	xor	r11d, r11d
	mov	DWORD PTR [rbx+24984], r11d

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rbx+24992], 255		; 000000ffH
$LN23@get_spatia:

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	test	al, 2
	jne	SHORT $LN59@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rbx+24988], 0

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rbx+24993], 255		; 000000ffH
$LN59@get_spatia:

; 956  :         inter_clear_cu_unused(a0);
; 957  :         cand_out->a[0] = a0;

	mov	QWORD PTR [rdi], r12
$LN76@get_spatia:

; 958  :       }
; 959  :     }
; 960  :   }
; 961  : 
; 962  :   // B0, B1 and B2 availability testing
; 963  :   if (y != 0) {

	mov	r9d, DWORD PTR height$[rsp]
$LN77@get_spatia:
	mov	r12d, DWORD PTR x_local$1$[rsp]
$LN5@get_spatia:
	test	esi, esi
	je	$LN14@get_spatia

; 964  :     cu_info_t *b0 = NULL;
; 965  :     if (x + width < picture_width) {

	lea	eax, DWORD PTR [r14+rbp]
	cmp	eax, DWORD PTR picture_width$[rsp]
	jge	$LN11@get_spatia

; 966  :       if (x_local + width < LCU_WIDTH) {

	lea	edx, DWORD PTR [r12+rbp]
	cmp	edx, 64					; 00000040H
	jge	SHORT $LN8@get_spatia

; 967  :         b0 = LCU_GET_CU_AT_PX(lcu, x_local + width, y_local - 1);

	lea	eax, DWORD PTR [r15-1]
	sar	edx, 2
	sar	eax, 2
	lea	rbx, QWORD PTR [r13+24976]
	imul	eax, eax, 17
	add	eax, 18
	add	eax, edx
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	rbx, QWORD PTR [rbx+rax*4]
	jmp	SHORT $LN10@get_spatia
$LN8@get_spatia:

; 968  :       } else if (y_local == 0) {

	test	r15d, r15d
	jne	SHORT $LN11@get_spatia

; 969  :         // Special case, top-right CU
; 970  :         b0 = LCU_GET_TOP_RIGHT_CU(lcu);

	lea	rbx, QWORD PTR [r13+30756]
$LN10@get_spatia:

; 971  :       }
; 972  :     }
; 973  :     if (b0 && b0->type == CU_INTER && is_b0_cand_coded(x, y, width, height)) {

	test	rbx, rbx
	je	SHORT $LN11@get_spatia
	movzx	eax, BYTE PTR [rbx]
	and	al, 3
	cmp	al, 2
	jne	SHORT $LN11@get_spatia
	mov	r8d, ebp
	mov	edx, esi
	mov	ecx, r14d
	call	is_b0_cand_coded
	test	al, al
	je	SHORT $LN11@get_spatia

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	movzx	eax, BYTE PTR [rbx+18]
	shr	eax, 6
	test	al, 1
	jne	SHORT $LN29@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	xor	r9d, r9d
	mov	DWORD PTR [rbx+8], r9d

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rbx+16], 255			; 000000ffH
$LN29@get_spatia:

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	test	al, 2
	jne	SHORT $LN61@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rbx+12], 0

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rbx+17], 255			; 000000ffH
$LN61@get_spatia:

; 974  :       inter_clear_cu_unused(b0);
; 975  :       cand_out->b[0] = b0;

	mov	QWORD PTR [rdi+16], rbx
$LN11@get_spatia:

; 976  :     }
; 977  : 
; 978  :     cu_info_t *b1 = LCU_GET_CU_AT_PX(lcu, x_local + width - 1, y_local - 1);

	lea	eax, DWORD PTR [r15-1]
	sar	eax, 2
	imul	r8d, eax, 17
	lea	eax, DWORD PTR [rbp-1]
	add	eax, r12d
	sar	eax, 2
	add	eax, r8d
	cdqe
	add	rax, 18
	lea	rax, QWORD PTR [rax+rax*4]
	lea	rcx, QWORD PTR [rax*4]
	add	rcx, r13
	lea	rdx, QWORD PTR [rcx+24976]

; 979  :     // Do not check b1->coded because the block to the left is always coded
; 980  :     // before the current one and the flag is not set when searching an SMP
; 981  :     // block.
; 982  :     if (b1->type == CU_INTER) {

	movzx	eax, BYTE PTR [rdx]
	and	al, 3
	cmp	al, 2
	jne	SHORT $LN12@get_spatia

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	movzx	eax, BYTE PTR [rcx+24994]
	shr	eax, 6
	test	al, 1
	jne	SHORT $LN35@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rcx+24984], 0

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rcx+24992], 255		; 000000ffH
$LN35@get_spatia:

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	test	al, 2
	jne	SHORT $LN63@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rcx+24988], 0

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rcx+24993], 255		; 000000ffH
$LN63@get_spatia:

; 983  :       inter_clear_cu_unused(b1);
; 984  :       cand_out->b[1] = b1;

	mov	QWORD PTR [rdi+24], rdx
$LN12@get_spatia:

; 985  :     }
; 986  : 
; 987  :     if (x != 0) {

	test	r14d, r14d
	je	SHORT $LN14@get_spatia

; 988  :       cu_info_t *b2 = LCU_GET_CU_AT_PX(lcu, x_local - 1, y_local - 1);

	lea	eax, DWORD PTR [r12-1]
	sar	eax, 2
	add	eax, r8d
	cdqe
	add	rax, 18
	lea	rax, QWORD PTR [rax+rax*4]
	lea	rcx, QWORD PTR [rax*4]
	add	rcx, r13
	lea	rdx, QWORD PTR [rcx+24976]

; 989  :       // Do not check b2->coded because the block above and to the left is
; 990  :       // always coded before the current one.
; 991  :       if (b2->type == CU_INTER) {

	movzx	eax, BYTE PTR [rdx]
	and	al, 3
	cmp	al, 2
	jne	SHORT $LN14@get_spatia

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	movzx	eax, BYTE PTR [rcx+24994]
	shr	eax, 6
	test	al, 1
	jne	SHORT $LN41@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rcx+24984], 0

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rcx+24992], 255		; 000000ffH
$LN41@get_spatia:

; 672  :     if (cu->inter.mv_dir & (1 << i)) continue;

	test	al, 2
	jne	SHORT $LN65@get_spatia

; 673  : 
; 674  :     cu->inter.mv[i][0] = 0;

	mov	DWORD PTR [rcx+24988], 0

; 675  :     cu->inter.mv[i][1] = 0;
; 676  :     cu->inter.mv_ref[i] = 255;

	mov	BYTE PTR [rcx+24993], 255		; 000000ffH
$LN65@get_spatia:

; 992  :         inter_clear_cu_unused(b2);
; 993  :         cand_out->b[2] = b2;

	mov	QWORD PTR [rdi+32], rdx
$LN14@get_spatia:

; 994  :       }
; 995  :     }
; 996  :   }
; 997  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
get_spatial_merge_candidates ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
cua$ = 80
x_local$1$ = 88
x$ = 88
y$ = 96
width$ = 104
height$ = 112
picture_width$ = 120
picture_height$ = 128
cand_out$ = 136
get_spatial_merge_candidates_cua PROC

; 1023 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1024 :   /*
; 1025 :   Predictor block locations
; 1026 :   ____      _______
; 1027 :   |B2|______|B1|B0|
; 1028 :      |         |
; 1029 :      |  Cur CU |
; 1030 :    __|         |
; 1031 :   |A1|_________|
; 1032 :   |A0|
; 1033 :   */
; 1034 :   int32_t x_local = SUB_SCU(x); //!< coordinates from top-left of this LCU
; 1035 :   int32_t y_local = SUB_SCU(y);
; 1036 :   // A0 and A1 availability testing
; 1037 :   if (x != 0) {

	mov	rdi, QWORD PTR cand_out$[rsp]
	mov	eax, edx
	mov	r13d, DWORD PTR height$[rsp]
	and	eax, 63					; 0000003fH
	mov	r14d, r8d
	mov	DWORD PTR x_local$1$[rsp], eax
	and	r14d, 63				; 0000003fH
	mov	r15d, r9d
	mov	esi, r8d
	mov	ebx, edx
	mov	r12, rcx
	test	edx, edx
	je	SHORT $LN5@get_spatia

; 1038 :     const cu_info_t *a1 = kvz_cu_array_at_const(cua, x - 1, y + height - 1);

	lea	ebp, DWORD PTR [r8+r13]
	dec	edx
	lea	r8d, DWORD PTR [rbp-1]
	call	kvz_cu_array_at_const

; 1039 :     // The block above is always coded before the current one.
; 1040 :     if (a1->type == CU_INTER) {

	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	jne	SHORT $LN3@get_spatia

; 1041 :       cand_out->a[1] = a1;

	mov	QWORD PTR [rdi+8], rax
$LN3@get_spatia:

; 1042 :     }
; 1043 : 
; 1044 :     if (y_local + height < LCU_WIDTH && y + height < picture_height) {

	lea	eax, DWORD PTR [r14+r13]
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN17@get_spatia
	cmp	ebp, DWORD PTR picture_height$[rsp]
	jge	SHORT $LN17@get_spatia

; 1045 :       const cu_info_t *a0 = kvz_cu_array_at_const(cua, x - 1, y + height);

	mov	r8d, ebp
	lea	edx, DWORD PTR [rbx-1]
	mov	rcx, r12
	call	kvz_cu_array_at_const
	mov	rbp, rax

; 1046 :       if (a0->type == CU_INTER && is_a0_cand_coded(x, y, width, height)) {

	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	jne	SHORT $LN17@get_spatia
	mov	r9d, r13d
	mov	r8d, r15d
	mov	edx, esi
	mov	ecx, ebx
	call	is_a0_cand_coded
	test	al, al
	mov	eax, DWORD PTR x_local$1$[rsp]
	je	SHORT $LN5@get_spatia

; 1047 :         cand_out->a[0] = a0;

	mov	QWORD PTR [rdi], rbp

; 1048 :       }
; 1049 :     }
; 1050 :   }
; 1051 : 
; 1052 :   // B0, B1 and B2 availability testing
; 1053 :   if (y != 0) {

	jmp	SHORT $LN5@get_spatia
$LN17@get_spatia:
	mov	eax, DWORD PTR x_local$1$[rsp]
$LN5@get_spatia:
	test	esi, esi
	je	$LN12@get_spatia

; 1054 :     if (x + width < picture_width && (x_local + width < LCU_WIDTH || y_local == 0)) {

	lea	ebp, DWORD PTR [rbx+r15]
	cmp	ebp, DWORD PTR picture_width$[rsp]
	jge	SHORT $LN9@get_spatia
	add	eax, r15d
	cmp	eax, 64					; 00000040H
	jl	SHORT $LN8@get_spatia
	test	r14d, r14d
	jne	SHORT $LN9@get_spatia
$LN8@get_spatia:

; 1055 :       const cu_info_t *b0 = kvz_cu_array_at_const(cua, x + width, y - 1);

	lea	r8d, DWORD PTR [rsi-1]
	mov	edx, ebp
	mov	rcx, r12
	call	kvz_cu_array_at_const
	mov	r14, rax

; 1056 :       if (b0->type == CU_INTER && is_b0_cand_coded(x, y, width, height)) {

	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	jne	SHORT $LN9@get_spatia
	mov	r9d, r13d
	mov	r8d, r15d
	mov	edx, esi
	mov	ecx, ebx
	call	is_b0_cand_coded
	test	al, al
	je	SHORT $LN9@get_spatia

; 1057 :         cand_out->b[0] = b0;

	mov	QWORD PTR [rdi+16], r14
$LN9@get_spatia:

; 1058 :       }
; 1059 :     }
; 1060 : 
; 1061 :     const cu_info_t *b1 = kvz_cu_array_at_const(cua, x + width - 1, y - 1);

	lea	edx, DWORD PTR [rbp-1]
	mov	rcx, r12
	lea	r8d, DWORD PTR [rsi-1]
	call	kvz_cu_array_at_const

; 1062 :     // The block to the left is always coded before the current one.
; 1063 :     if (b1->type == CU_INTER) {

	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	jne	SHORT $LN10@get_spatia

; 1064 :       cand_out->b[1] = b1;

	mov	QWORD PTR [rdi+24], rax
$LN10@get_spatia:

; 1065 :     }
; 1066 : 
; 1067 :     if (x != 0) {

	test	ebx, ebx
	je	SHORT $LN12@get_spatia

; 1068 :       const cu_info_t *b2 = kvz_cu_array_at_const(cua, x - 1, y - 1);

	lea	edx, DWORD PTR [rbx-1]
	mov	rcx, r12
	lea	r8d, DWORD PTR [rsi-1]
	call	kvz_cu_array_at_const

; 1069 :       // The block above and to the left is always coded before the current
; 1070 :       // one.
; 1071 :       if (b2->type == CU_INTER) {

	movzx	ecx, BYTE PTR [rax]
	and	cl, 3
	cmp	cl, 2
	jne	SHORT $LN12@get_spatia

; 1072 :         cand_out->b[2] = b2;

	mov	QWORD PTR [rdi+32], rax
$LN12@get_spatia:

; 1073 :       }
; 1074 :     }
; 1075 :   }
; 1076 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
get_spatial_merge_candidates_cua ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
mv$ = 8
scale$ = 16
get_scaled_mv PROC

; 1080 :   int32_t scaled = scale * mv;

	movsx	r8d, cx
	imul	r8d, edx

; 1081 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	eax, r8d
	shr	eax, 31
	lea	ecx, DWORD PTR [r8+127]
	add	ecx, eax
	mov	eax, 32767				; 00007fffH
	sar	ecx, 8
	cmp	ecx, eax
	jg	SHORT $LN9@get_scaled
	mov	eax, -32768				; ffffffffffff8000H
	cmp	ecx, eax
	jl	SHORT $LN9@get_scaled
	movzx	eax, cx
$LN9@get_scaled:

; 1082 : }

	ret	0
get_scaled_mv ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
current_poc$ = 8
current_ref_poc$ = 16
neighbor_poc$ = 24
neighbor_ref_poc$ = 32
mv_cand$ = 40
apply_mv_scaling_pocs PROC

; 1090 :   int32_t diff_current  = current_poc  - current_ref_poc;

	sub	ecx, edx

; 1091 :   int32_t diff_neighbor = neighbor_poc - neighbor_ref_poc;

	sub	r8d, r9d

; 1092 : 
; 1093 :   if (diff_current == diff_neighbor) return;

	cmp	ecx, r8d
	je	$LN1@apply_mv_s

; 1094 : 
; 1095 :   diff_current  = CLIP(-128, 127, diff_current);

	mov	edx, 127				; 0000007fH
	mov	eax, -128				; ffffffffffffff80H
	cmp	ecx, edx

; 1096 :   diff_neighbor = CLIP(-128, 127, diff_neighbor);
; 1097 : 
; 1098 :   int scale = CLIP(-4096, 4095,

	mov	r9d, 4095				; 00000fffH
	cmovg	ecx, edx
	cmp	ecx, eax
	cmovl	ecx, eax
	cmp	r8d, edx
	cmovg	r8d, edx
	cmp	r8d, eax
	cmovl	r8d, eax
	mov	eax, r8d
	cdq
	xor	eax, edx
	sub	eax, edx
	sar	eax, 1
	add	eax, 16384				; 00004000H
	cdq
	idiv	r8d
	imul	eax, ecx
	add	eax, 32					; 00000020H
	sar	eax, 6
	cmp	eax, r9d
	jg	SHORT $LN11@apply_mv_s
	mov	r9d, -4096				; fffffffffffff000H
	cmp	eax, r9d
	jl	SHORT $LN11@apply_mv_s
	mov	r9d, eax
$LN11@apply_mv_s:

; 1080 :   int32_t scaled = scale * mv;

	mov	r10, QWORD PTR mv_cand$[rsp]

; 1081 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	r8d, -32768				; ffffffffffff8000H
	movsx	ecx, WORD PTR [r10]
	imul	ecx, r9d
	mov	eax, ecx
	shr	eax, 31
	lea	edx, DWORD PTR [rcx+127]
	add	edx, eax
	sar	edx, 8
	cmp	edx, 32767				; 00007fffH
	jg	SHORT $LN31@apply_mv_s
	cmp	edx, r8d
	jge	SHORT $LN19@apply_mv_s
	mov	edx, r8d
	jmp	SHORT $LN19@apply_mv_s
$LN31@apply_mv_s:
	mov	edx, 32767				; 00007fffH
$LN19@apply_mv_s:

; 1080 :   int32_t scaled = scale * mv;

	movsx	ecx, WORD PTR [r10+2]
	imul	ecx, r9d

; 1099 :     (diff_current * ((0x4000 + (abs(diff_neighbor) >> 1)) / diff_neighbor) + 32) >> 6);
; 1100 : 
; 1101 :   mv_cand[0] = get_scaled_mv(mv_cand[0], scale);

	mov	WORD PTR [r10], dx

; 1081 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	eax, ecx
	shr	eax, 31
	lea	edx, DWORD PTR [rcx+127]
	add	edx, eax
	sar	edx, 8
	cmp	edx, 32767				; 00007fffH
	jg	SHORT $LN32@apply_mv_s
	cmp	edx, r8d
	jl	SHORT $LN27@apply_mv_s
	mov	r8d, edx

; 1102 :   mv_cand[1] = get_scaled_mv(mv_cand[1], scale);

	mov	WORD PTR [r10+2], r8w

; 1103 : }

	ret	0
$LN32@apply_mv_s:

; 1081 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	r8d, 32767				; 00007fffH
$LN27@apply_mv_s:

; 1102 :   mv_cand[1] = get_scaled_mv(mv_cand[1], scale);

	mov	WORD PTR [r10+2], r8w
$LN1@apply_mv_s:

; 1103 : }

	ret	0
apply_mv_scaling_pocs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
state$ = 16
current_cu$ = 24
neighbor_cu$ = 32
current_reflist$ = 40
neighbor_reflist$ = 48
mv_cand$ = 56
apply_mv_scaling PROC

; 1111 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi

; 1112 :   apply_mv_scaling_pocs(state->frame->poc,

	mov	rbx, QWORD PTR [rcx+40]
	movsx	r10, BYTE PTR neighbor_reflist$[rsp]
	movsx	r11, r9b
	mov	rax, QWORD PTR [rbx+40]
	mov	ecx, DWORD PTR [rbx+12]
	mov	rdi, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [r10+r8+16]
	add	r10, r10
	add	rax, rbx
	movzx	r8d, BYTE PTR [rax+r10*8+49]
	movzx	eax, BYTE PTR [r11+rdx+16]
	add	r11, r11
	add	rax, rbx
	mov	r9d, DWORD PTR [rdi+r8*4]
	mov	r8d, ecx
	movzx	edx, BYTE PTR [rax+r11*8+49]
	mov	rax, QWORD PTR mv_cand$[rsp]
	mov	QWORD PTR neighbor_reflist$[rsp], rax
	mov	edx, DWORD PTR [rdi+rdx*4]

; 1113 :                         state->frame->ref->pocs[
; 1114 :                           state->frame->ref_LX[current_reflist][
; 1115 :                             current_cu->inter.mv_ref[current_reflist]]],
; 1116 :                         state->frame->poc,
; 1117 :                         state->frame->ref->pocs[
; 1118 :                           state->frame->ref_LX[neighbor_reflist][
; 1119 :                             neighbor_cu->inter.mv_ref[neighbor_reflist]]],
; 1120 :                         mv_cand);
; 1121 : }

	mov	rbx, QWORD PTR [rsp+16]
	pop	rdi

; 1112 :   apply_mv_scaling_pocs(state->frame->poc,

	jmp	apply_mv_scaling_pocs
apply_mv_scaling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
state$ = 64
current_ref$ = 72
colocated$ = 80
reflist$ = 88
mv_out$ = 96
add_temporal_candidate PROC

; 1139 : {

	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	movzx	ebp, dl
	mov	r11d, r9d
	mov	rdi, r8
	mov	rsi, rcx

; 1140 :   if (!colocated) return false;

	test	r8, r8
	je	$LN6@add_tempor

; 1141 : 
; 1142 :   int colocated_ref;
; 1143 :   if (state->frame->ref_LX_size[0] > 0) {

	mov	rax, QWORD PTR [rcx+40]
	cmp	BYTE PTR [rax+81], 0
	jbe	$LN6@add_tempor

; 1144 :     // get the first reference from L0 if it exists
; 1145 :     colocated_ref = state->frame->ref_LX[0][0];
; 1146 :   } else {
; 1147 :     // otherwise no candidate added
; 1148 :     return false;
; 1149 :   }
; 1150 : 
; 1151 :   // When there are reference pictures from the future (POC > current POC)
; 1152 :   // in L0 or L1, the primary list for the colocated PU is the inverse of
; 1153 :   // collocated_from_l0_flag. Otherwise it is equal to reflist.
; 1154 :   //
; 1155 :   // Kvazaar always sets collocated_from_l0_flag so the list is L1 when
; 1156 :   // there are future references.
; 1157 :   int col_list = reflist;
; 1158 :   for (int i = 0; i < state->frame->ref->used_size; i++) {

	mov	r8, QWORD PTR [rax+40]
	xor	r9d, r9d
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], r14
	movzx	r14d, BYTE PTR [rax+49]
	mov	edx, DWORD PTR [r8+36]
	lea	r10d, QWORD PTR [r9+1]
	test	edx, edx
	je	SHORT $LN3@add_tempor

; 1159 :     if (state->frame->ref->pocs[i] > state->frame->poc) {

	mov	ecx, DWORD PTR [rax+12]
	mov	rax, QWORD PTR [r8+16]
	npad	5
$LL4@add_tempor:
	cmp	DWORD PTR [rax], ecx
	jg	SHORT $LN12@add_tempor

; 1144 :     // get the first reference from L0 if it exists
; 1145 :     colocated_ref = state->frame->ref_LX[0][0];
; 1146 :   } else {
; 1147 :     // otherwise no candidate added
; 1148 :     return false;
; 1149 :   }
; 1150 : 
; 1151 :   // When there are reference pictures from the future (POC > current POC)
; 1152 :   // in L0 or L1, the primary list for the colocated PU is the inverse of
; 1153 :   // collocated_from_l0_flag. Otherwise it is equal to reflist.
; 1154 :   //
; 1155 :   // Kvazaar always sets collocated_from_l0_flag so the list is L1 when
; 1156 :   // there are future references.
; 1157 :   int col_list = reflist;
; 1158 :   for (int i = 0; i < state->frame->ref->used_size; i++) {

	inc	r9d
	add	rax, 4
	cmp	r9d, edx
	jb	SHORT $LL4@add_tempor

; 1159 :     if (state->frame->ref->pocs[i] > state->frame->poc) {

	jmp	SHORT $LN3@add_tempor
$LN12@add_tempor:

; 1160 :       col_list = 1;

	mov	r11d, r10d
$LN3@add_tempor:

; 1161 :       break;
; 1162 :     }
; 1163 :   }
; 1164 : 
; 1165 :   if ((colocated->inter.mv_dir & (col_list + 1)) == 0) {

	movzx	ecx, BYTE PTR [rdi+18]
	lea	eax, DWORD PTR [r11+1]

; 1166 :     // Use the other list if the colocated PU does not have a MV for the
; 1167 :     // primary list.
; 1168 :     col_list = 1 - col_list;
; 1169 :   }
; 1170 : 
; 1171 :   mv_out[0] = colocated->inter.mv[col_list][0];

	mov	rbx, QWORD PTR mv_out$[rsp]
	sub	r10d, r11d
	shr	ecx, 6
	and	cl, al

; 1172 :   mv_out[1] = colocated->inter.mv[col_list][1];
; 1173 :   apply_mv_scaling_pocs(

	mov	QWORD PTR [rsp+32], rbx
	cmovne	r10d, r11d
	movsxd	r10, r10d
	movzx	eax, WORD PTR [rdi+r10*4+8]
	lea	r9, QWORD PTR [r10+r14*2]
	mov	WORD PTR [rbx], ax
	movzx	eax, WORD PTR [rdi+r10*4+10]
	mov	WORD PTR [rbx+2], ax
	movzx	eax, BYTE PTR [r10+rdi+16]
	mov	rcx, QWORD PTR [rsi+40]
	shl	r9, 4
	add	r9, rax
	mov	r11, QWORD PTR [rcx+40]
	mov	ecx, DWORD PTR [rcx+12]
	mov	rax, QWORD PTR [r11+24]
	mov	rdx, QWORD PTR [r11+16]
	movzx	r10d, BYTE PTR [r9+rax]
	mov	rax, QWORD PTR [r11]
	mov	r8d, DWORD PTR [rdx+r14*4]
	mov	edx, DWORD PTR [rdx+rbp*4]
	mov	r9, QWORD PTR [rax+r14*8]
	mov	r9d, DWORD PTR [r9+r10*4+120]
	call	apply_mv_scaling_pocs

; 1174 :     state->frame->poc,
; 1175 :     state->frame->ref->pocs[current_ref],
; 1176 :     state->frame->ref->pocs[colocated_ref],
; 1177 :     state->frame->ref->images[colocated_ref]->ref_pocs[
; 1178 :       state->frame->ref->ref_LXs[colocated_ref]
; 1179 :         [col_list][colocated->inter.mv_ref[col_list]]],
; 1180 :     mv_out
; 1181 :   );
; 1182 : 
; 1183 :   return true;

	mov	r14, QWORD PTR [rsp+72]
	mov	al, 1
	mov	rbx, QWORD PTR [rsp+64]

; 1184 : }

	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN6@add_tempor:
	mov	rbp, QWORD PTR [rsp+80]
	xor	al, al
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
add_temporal_candidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
state$ = 80
cur_cu$ = 88
cand$ = 96
reflist$ = 104
scaling$ = 112
mv_cand_out$ = 120
add_mvp_candidate PROC

; 1192 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	movsx	rdi, r9b
	mov	rbx, r8
	mov	rbp, rdx
	mov	r14, rcx

; 1193 :   if (!cand) return false;

	test	r8, r8
	je	$LN21@add_mvp_ca

; 1194 : 
; 1195 :   assert(cand->inter.mv_dir != 0);

	movzx	eax, BYTE PTR [r8+18]
	cmp	al, 64					; 00000040H
	jae	SHORT $LN10@add_mvp_ca
	mov	r8d, 1195				; 000004abH
	lea	rdx, OFFSET FLAT:$SG4294943116
	lea	rcx, OFFSET FLAT:$SG4294943115
	call	QWORD PTR __imp__wassert
	movzx	eax, BYTE PTR [rbx+18]
$LN10@add_mvp_ca:

; 1207 :     }
; 1208 : 
; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	mov	rsi, rdi
	movzx	r11d, al
	shl	rsi, 4
	lea	r15, QWORD PTR [rdi+rbp]
	movzx	ebp, BYTE PTR scaling$[rsp]
	xor	r9d, r9d
	shr	r11d, 6
$LL4@add_mvp_ca:

; 1198 :     const int cand_list = i == 0 ? reflist : !reflist;

	test	r9d, r9d
	jne	SHORT $LN11@add_mvp_ca
	mov	eax, edi
	jmp	SHORT $LN12@add_mvp_ca
$LN11@add_mvp_ca:
	xor	eax, eax
	test	dil, dil
	sete	al
$LN12@add_mvp_ca:

; 1199 : 
; 1200 :     if ((cand->inter.mv_dir & (1 << cand_list)) == 0) continue;

	bt	r11d, eax
	jae	SHORT $LN2@add_mvp_ca

; 1201 : 
; 1202 :     if (scaling) {

	movsxd	r10, eax
	test	bpl, bpl
	jne	SHORT $LN16@add_mvp_ca

; 1207 :     }
; 1208 : 
; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	movzx	eax, BYTE PTR [r15+16]
	mov	r8, r10
	add	rax, QWORD PTR [r14+40]
	add	r8, r8
	movzx	ecx, BYTE PTR [r10+rbx+16]
	add	rcx, QWORD PTR [r14+40]
	movzx	eax, BYTE PTR [rax+rsi+49]
	cmp	BYTE PTR [rcx+r8*8+49], al
	je	SHORT $LN17@add_mvp_ca
$LN2@add_mvp_ca:

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	inc	r9d
	cmp	r9d, 2
	jl	SHORT $LL4@add_mvp_ca
$LN21@add_mvp_ca:

; 1216 :     }
; 1217 :   }
; 1218 : 
; 1219 :   return false;

	xor	al, al
$LN1@add_mvp_ca:

; 1220 : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN17@add_mvp_ca:

; 1210 :         state->frame->ref_LX[cand_list][cand->inter.mv_ref[cand_list]] ==
; 1211 :         state->frame->ref_LX[reflist][cur_cu->inter.mv_ref[reflist]])
; 1212 :     {
; 1213 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	movzx	eax, WORD PTR [rbx+r10*4+8]
	mov	rcx, QWORD PTR mv_cand_out$[rsp]
	mov	WORD PTR [rcx], ax

; 1214 :       mv_cand_out[1] = cand->inter.mv[cand_list][1];

	movzx	eax, WORD PTR [rbx+r10*4+10]
	mov	WORD PTR [rcx+2], ax

; 1215 :       return true;

	mov	al, 1
	jmp	SHORT $LN1@add_mvp_ca
$LN16@add_mvp_ca:

; 1203 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	movzx	ecx, WORD PTR [rbx+r10*4+8]
	mov	r11, QWORD PTR mv_cand_out$[rsp]

; 1112 :   apply_mv_scaling_pocs(state->frame->poc,

	movsx	r8, al
	mov	QWORD PTR [rsp+32], r11

; 1203 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	mov	WORD PTR [r11], cx

; 1204 :       mv_cand_out[1] = cand->inter.mv[cand_list][1];

	movzx	ecx, WORD PTR [rbx+r10*4+10]
	mov	WORD PTR [r11+2], cx

; 1112 :   apply_mv_scaling_pocs(state->frame->poc,

	mov	r9, QWORD PTR [r14+40]
	mov	rax, QWORD PTR [r9+40]
	mov	ecx, DWORD PTR [r9+12]
	mov	r10, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [r8+rbx+16]
	add	r8, r8
	add	rax, r9
	movzx	r8d, BYTE PTR [rax+r8*8+49]
	movzx	eax, BYTE PTR [r15+16]
	add	rax, rsi
	movzx	edx, BYTE PTR [rax+r9+49]
	mov	r9d, DWORD PTR [r10+r8*4]
	mov	r8d, ecx
	mov	edx, DWORD PTR [r10+rdx*4]
	call	apply_mv_scaling_pocs

; 1205 :       apply_mv_scaling(state, cur_cu, cand, reflist, cand_list, mv_cand_out);
; 1206 :       return true;

	mov	al, 1
	jmp	$LN1@add_mvp_ca
add_mvp_candidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
c3$1$ = 48
h$1$ = 56
b$1$ = 112
state$ = 112
x$dead$ = 120
y$dead$ = 128
width$dead$ = 136
height$dead$ = 144
tv2414 = 152
merge_cand$ = 152
cur_cu$ = 160
reflist$ = 168
mv_cand$ = 176
get_mv_cand_from_candidates PROC

; 1234 : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 1235 :   const cu_info_t *const *a = merge_cand->a;
; 1236 :   const cu_info_t *const *b = merge_cand->b;

	mov	r15, QWORD PTR merge_cand$[rsp]

; 1239 : 
; 1240 :   uint8_t candidates = 0;

	xor	r13b, r13b

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	movsx	rbx, BYTE PTR reflist$[rsp]

; 1234 : {

	mov	rbp, rcx

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	mov	r14, QWORD PTR cur_cu$[rsp]
	mov	r12, rbx
	add	r14, 16
	add	r12, r12

; 1237 :   const cu_info_t *c3 = merge_cand->c3;

	mov	rcx, QWORD PTR [r15+40]
	lea	rax, QWORD PTR [r15+16]

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	add	r14, rbx

; 1235 :   const cu_info_t *const *a = merge_cand->a;
; 1236 :   const cu_info_t *const *b = merge_cand->b;

	mov	QWORD PTR b$1$[rsp], rax

; 1238 :   const cu_info_t *h  = merge_cand->h;

	mov	rax, QWORD PTR [r15+48]

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	xor	r8d, r8d

; 1238 :   const cu_info_t *h  = merge_cand->h;

	mov	QWORD PTR h$1$[rsp], rax

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	mov	esi, r8d

; 1237 :   const cu_info_t *c3 = merge_cand->c3;

	mov	QWORD PTR c3$1$[rsp], rcx

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	mov	QWORD PTR tv2414[rsp], r14
$LL4@get_mv_can:

; 1245 :     if (add_mvp_candidate(state, cur_cu, a[i], reflist, false, mv_cand[candidates])) {

	mov	rdi, QWORD PTR [r15+rsi*8]

; 1193 :   if (!cand) return false;

	test	rdi, rdi
	je	$LN136@get_mv_can

; 1194 : 
; 1195 :   assert(cand->inter.mv_dir != 0);

	movzx	eax, BYTE PTR [rdi+18]
	cmp	al, 64					; 00000040H
	jae	SHORT $LN41@get_mv_can
	mov	r8d, 1195				; 000004abH
	lea	rdx, OFFSET FLAT:$SG4294943116
	lea	rcx, OFFSET FLAT:$SG4294943115
	call	QWORD PTR __imp__wassert
	movzx	eax, BYTE PTR [rdi+18]
	xor	r8d, r8d
$LN41@get_mv_can:
	movzx	r11d, al

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	mov	r9d, r8d
	shr	r11d, 6
$LL35@get_mv_can:

; 1198 :     const int cand_list = i == 0 ? reflist : !reflist;

	test	r9d, r9d
	jne	SHORT $LN42@get_mv_can
	mov	eax, ebx
	jmp	SHORT $LN43@get_mv_can
$LN42@get_mv_can:
	test	bl, bl
	mov	eax, r8d
	sete	al
$LN43@get_mv_can:

; 1199 : 
; 1200 :     if ((cand->inter.mv_dir & (1 << cand_list)) == 0) continue;

	bt	r11d, eax
	jae	SHORT $LN33@get_mv_can

; 1205 :       apply_mv_scaling(state, cur_cu, cand, reflist, cand_list, mv_cand_out);
; 1206 :       return true;
; 1207 :     }
; 1208 : 
; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	movsxd	r10, eax
	movzx	eax, BYTE PTR [r14]
	mov	r8, r10
	add	rax, QWORD PTR [rbp+40]
	add	r8, r8
	movzx	ecx, BYTE PTR [r10+rdi+16]
	add	rcx, QWORD PTR [rbp+40]
	movzx	eax, BYTE PTR [rax+r12*8+49]
	cmp	BYTE PTR [rcx+r8*8+49], al
	je	SHORT $LN98@get_mv_can
	xor	r8d, r8d
$LN33@get_mv_can:

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	inc	r9d
	cmp	r9d, 2
	jl	SHORT $LL35@get_mv_can
$LN136@get_mv_can:

; 1241 :   uint8_t b_candidates = 0;
; 1242 : 
; 1243 :   // Left predictors without scaling
; 1244 :   for (int i = 0; i < 2; i++) {

	inc	rsi
	cmp	rsi, 2
	jl	$LL4@get_mv_can

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	mov	rdi, r8
	npad	3
$LL7@get_mv_can:

; 1254 :       if (add_mvp_candidate(state, cur_cu, a[i], reflist, true, mv_cand[candidates])) {

	mov	rsi, QWORD PTR [r15+rdi*8]

; 1193 :   if (!cand) return false;

	test	rsi, rsi
	je	SHORT $LN138@get_mv_can

; 1194 : 
; 1195 :   assert(cand->inter.mv_dir != 0);

	movzx	ecx, BYTE PTR [rsi+18]
	cmp	cl, 64					; 00000040H
	jae	SHORT $LN55@get_mv_can
	mov	r8d, 1195				; 000004abH
	lea	rdx, OFFSET FLAT:$SG4294943116
	lea	rcx, OFFSET FLAT:$SG4294943115
	call	QWORD PTR __imp__wassert
	movzx	ecx, BYTE PTR [rsi+18]
	xor	r8d, r8d
$LN55@get_mv_can:
	movzx	ecx, cl

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	mov	eax, r8d
	shr	ecx, 6
	npad	4
$LL49@get_mv_can:

; 1198 :     const int cand_list = i == 0 ? reflist : !reflist;

	test	eax, eax
	jne	SHORT $LN56@get_mv_can
	mov	edx, ebx
	jmp	SHORT $LN57@get_mv_can
$LN98@get_mv_can:

; 1213 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	movzx	eax, WORD PTR [rdi+r10*4+8]

; 1246 :       candidates++;

	mov	r13b, 1

; 1213 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	mov	r11, QWORD PTR mv_cand$[rsp]

; 1247 :       break;
; 1248 :     }
; 1249 :   }
; 1250 : 
; 1251 :   // Left predictors with scaling
; 1252 :   if (candidates == 0) {

	xor	r8d, r8d

; 1213 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	mov	WORD PTR [r11], ax

; 1214 :       mv_cand_out[1] = cand->inter.mv[cand_list][1];

	movzx	eax, WORD PTR [rdi+r10*4+10]
	mov	WORD PTR [r11+2], ax

; 1247 :       break;
; 1248 :     }
; 1249 :   }
; 1250 : 
; 1251 :   // Left predictors with scaling
; 1252 :   if (candidates == 0) {

	jmp	SHORT $LN6@get_mv_can
$LN56@get_mv_can:

; 1198 :     const int cand_list = i == 0 ? reflist : !reflist;

	test	bl, bl
	mov	edx, r8d
	sete	dl
$LN57@get_mv_can:

; 1199 : 
; 1200 :     if ((cand->inter.mv_dir & (1 << cand_list)) == 0) continue;

	bt	ecx, edx
	jb	SHORT $LN143@get_mv_can

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	inc	eax
	cmp	eax, 2
	jl	SHORT $LL49@get_mv_can
$LN138@get_mv_can:

; 1253 :     for (int i = 0; i < 2; i++) {

	inc	rdi
	cmp	rdi, 2
	jl	$LL7@get_mv_can
	mov	r11, QWORD PTR mv_cand$[rsp]
$LN6@get_mv_can:
	movzx	eax, r13b

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	mov	rsi, r8
	lea	r14, QWORD PTR [r11+rax*4]
$LL10@get_mv_can:

; 1263 :     if (add_mvp_candidate(state, cur_cu, b[i], reflist, false, mv_cand[candidates])) {

	mov	rdi, QWORD PTR [r15+rsi*8+16]

; 1193 :   if (!cand) return false;

	test	rdi, rdi
	je	$LN139@get_mv_can

; 1194 : 
; 1195 :   assert(cand->inter.mv_dir != 0);

	movzx	eax, BYTE PTR [rdi+18]
	cmp	al, 64					; 00000040H
	jae	SHORT $LN69@get_mv_can
	mov	r8d, 1195				; 000004abH
	lea	rdx, OFFSET FLAT:$SG4294943116
	lea	rcx, OFFSET FLAT:$SG4294943115
	call	QWORD PTR __imp__wassert
	movzx	eax, BYTE PTR [rdi+18]
	xor	r8d, r8d
$LN69@get_mv_can:
	movzx	r11d, al

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	mov	r9d, r8d
	shr	r11d, 6
$LL63@get_mv_can:

; 1198 :     const int cand_list = i == 0 ? reflist : !reflist;

	test	r9d, r9d
	jne	SHORT $LN70@get_mv_can
	mov	eax, ebx
	jmp	SHORT $LN71@get_mv_can
$LN143@get_mv_can:

; 1203 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	mov	r11, QWORD PTR mv_cand$[rsp]
	movsxd	rcx, edx

; 1112 :   apply_mv_scaling_pocs(state->frame->poc,

	movsx	rdx, dl
	mov	QWORD PTR [rsp+32], r11

; 1203 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	movzx	eax, WORD PTR [rsi+rcx*4+8]
	mov	WORD PTR [r11], ax

; 1204 :       mv_cand_out[1] = cand->inter.mv[cand_list][1];

	movzx	eax, WORD PTR [rsi+rcx*4+10]
	mov	WORD PTR [r11+2], ax

; 1112 :   apply_mv_scaling_pocs(state->frame->poc,

	mov	r9, QWORD PTR [rbp+40]
	mov	rax, QWORD PTR [r9+40]
	mov	ecx, DWORD PTR [r9+12]
	mov	r10, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rdx+rsi+16]
	add	rdx, rdx
	add	rax, r9
	movzx	r8d, BYTE PTR [rax+rdx*8+49]
	movzx	eax, BYTE PTR [r14]
	add	rax, r9
	mov	r9d, DWORD PTR [r10+r8*4]
	mov	r8d, ecx
	movzx	edx, BYTE PTR [rax+r12*8+49]
	mov	edx, DWORD PTR [r10+rdx*4]
	call	apply_mv_scaling_pocs

; 1253 :     for (int i = 0; i < 2; i++) {

	xor	r8d, r8d

; 1255 :         candidates++;

	mov	r13b, 1
	jmp	$LN6@get_mv_can
$LN70@get_mv_can:

; 1198 :     const int cand_list = i == 0 ? reflist : !reflist;

	test	bl, bl
	mov	eax, r8d
	sete	al
$LN71@get_mv_can:

; 1199 : 
; 1200 :     if ((cand->inter.mv_dir & (1 << cand_list)) == 0) continue;

	bt	r11d, eax
	jae	SHORT $LN61@get_mv_can

; 1205 :       apply_mv_scaling(state, cur_cu, cand, reflist, cand_list, mv_cand_out);
; 1206 :       return true;
; 1207 :     }
; 1208 : 
; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	movsxd	r10, eax
	mov	rax, QWORD PTR tv2414[rsp]
	mov	r8, r10
	add	r8, r8
	movzx	ecx, BYTE PTR [r10+rdi+16]
	movzx	eax, BYTE PTR [rax]
	add	rax, QWORD PTR [rbp+40]
	add	rcx, QWORD PTR [rbp+40]
	movzx	eax, BYTE PTR [rax+r12*8+49]
	cmp	BYTE PTR [rcx+r8*8+49], al
	je	$LN104@get_mv_can
	xor	r8d, r8d
$LN61@get_mv_can:

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	inc	r9d
	cmp	r9d, 2
	jl	$LL63@get_mv_can
$LN139@get_mv_can:

; 1256 :         break;
; 1257 :       }
; 1258 :     }
; 1259 :   }
; 1260 : 
; 1261 :   // Top predictors without scaling
; 1262 :   for (int i = 0; i < 3; i++) {

	inc	rsi
	cmp	rsi, 3
	jl	$LL10@get_mv_can
	xor	al, al
$LN9@get_mv_can:

; 1265 :       break;
; 1266 :     }
; 1267 :   }
; 1268 : 
; 1269 :   candidates += b_candidates;

	add	r13b, al

; 1270 : 
; 1271 :   // When a1 or a0 is available, we dont check for secondary B candidates.
; 1272 :   if (a[0] || a[1]) {

	cmp	QWORD PTR [r15], 0
	jne	$LN12@get_mv_can
	cmp	QWORD PTR [r15+8], 0
	jne	$LN12@get_mv_can

; 1273 :     b_candidates = 1;
; 1274 :   } else if (candidates != 2) {

	cmp	r13b, 2
	jne	SHORT $LN140@get_mv_can

; 1275 :     b_candidates = 0;
; 1276 :   }
; 1277 : 
; 1278 :   if (!b_candidates) {

	test	al, al
	jne	$LN150@get_mv_can
$LN140@get_mv_can:
	mov	rcx, QWORD PTR mv_cand$[rsp]

; 1209 :     if (cand->inter.mv_dir & (1 << cand_list) &&

	xor	r15d, r15d
	movzx	eax, r13b
	mov	edi, r15d
	lea	r14, QWORD PTR [rcx+rax*4]
	mov	rax, QWORD PTR b$1$[rsp]
	npad	3
$LL13@get_mv_can:

; 1281 :       if (add_mvp_candidate(state, cur_cu, b[i], reflist, true, mv_cand[candidates])) {

	mov	rsi, QWORD PTR [rax+rdi*8]

; 1193 :   if (!cand) return false;

	test	rsi, rsi
	je	SHORT $LN141@get_mv_can

; 1194 : 
; 1195 :   assert(cand->inter.mv_dir != 0);

	movzx	ecx, BYTE PTR [rsi+18]
	cmp	cl, 64					; 00000040H
	jae	SHORT $LN83@get_mv_can
	mov	r8d, 1195				; 000004abH
	lea	rdx, OFFSET FLAT:$SG4294943116
	lea	rcx, OFFSET FLAT:$SG4294943115
	call	QWORD PTR __imp__wassert
	movzx	ecx, BYTE PTR [rsi+18]
$LN83@get_mv_can:
	movzx	ecx, cl

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	mov	eax, r15d
	shr	ecx, 6
	npad	7
$LL77@get_mv_can:

; 1198 :     const int cand_list = i == 0 ? reflist : !reflist;

	test	eax, eax
	jne	SHORT $LN84@get_mv_can
	mov	edx, ebx
	jmp	SHORT $LN85@get_mv_can
$LN104@get_mv_can:

; 1213 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	movzx	eax, WORD PTR [rdi+r10*4+8]
	mov	WORD PTR [r14], ax

; 1214 :       mv_cand_out[1] = cand->inter.mv[cand_list][1];

	movzx	eax, WORD PTR [rdi+r10*4+10]
	mov	WORD PTR [r14+2], ax

; 1264 :       b_candidates++;

	mov	al, 1
	jmp	$LN9@get_mv_can
$LN84@get_mv_can:

; 1198 :     const int cand_list = i == 0 ? reflist : !reflist;

	test	bl, bl
	mov	edx, r15d
	sete	dl
$LN85@get_mv_can:

; 1199 : 
; 1200 :     if ((cand->inter.mv_dir & (1 << cand_list)) == 0) continue;

	bt	ecx, edx
	jb	SHORT $LN147@get_mv_can

; 1196 : 
; 1197 :   for (int i = 0; i < 2; i++) {

	inc	eax
	cmp	eax, 2
	jl	SHORT $LL77@get_mv_can
	mov	rax, QWORD PTR b$1$[rsp]
$LN141@get_mv_can:

; 1279 :     // Top predictors with scaling
; 1280 :     for (int i = 0; i < 3; i++) {

	inc	rdi
	cmp	rdi, 3
	jl	$LL13@get_mv_can
	jmp	SHORT $LN12@get_mv_can
$LN147@get_mv_can:

; 1203 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	movsxd	rcx, edx

; 1112 :   apply_mv_scaling_pocs(state->frame->poc,

	movsx	rdx, dl
	mov	QWORD PTR [rsp+32], r14

; 1203 :       mv_cand_out[0] = cand->inter.mv[cand_list][0];

	movzx	eax, WORD PTR [rsi+rcx*4+8]
	mov	WORD PTR [r14], ax

; 1204 :       mv_cand_out[1] = cand->inter.mv[cand_list][1];

	movzx	eax, WORD PTR [rsi+rcx*4+10]
	mov	WORD PTR [r14+2], ax

; 1112 :   apply_mv_scaling_pocs(state->frame->poc,

	mov	r9, QWORD PTR [rbp+40]
	mov	rax, QWORD PTR [r9+40]
	mov	ecx, DWORD PTR [r9+12]
	mov	r10, QWORD PTR [rax+16]
	movzx	eax, BYTE PTR [rdx+rsi+16]
	add	rdx, rdx
	add	rax, r9
	movzx	r8d, BYTE PTR [rax+rdx*8+49]
	mov	rax, QWORD PTR tv2414[rsp]
	movzx	eax, BYTE PTR [rax]
	add	rax, r9
	mov	r9d, DWORD PTR [r10+r8*4]
	mov	r8d, ecx
	movzx	edx, BYTE PTR [rax+r12*8+49]
	mov	edx, DWORD PTR [r10+rdx*4]
	call	apply_mv_scaling_pocs

; 1282 :         candidates++;

	inc	r13b
$LN12@get_mv_can:

; 1283 :         break;
; 1284 :       }
; 1285 :     }
; 1286 :   }
; 1287 : 
; 1288 :   // Remove identical candidate
; 1289 :   if (candidates == 2 && mv_cand[0][0] == mv_cand[1][0] && mv_cand[0][1] == mv_cand[1][1]) {

	cmp	r13b, 2
	jne	SHORT $LN156@get_mv_can
$LN150@get_mv_can:
	mov	rdi, QWORD PTR mv_cand$[rsp]
	movzx	eax, WORD PTR [rdi+4]
	cmp	WORD PTR [rdi], ax
	jne	SHORT $LN26@get_mv_can
	movzx	eax, WORD PTR [rdi+6]
	mov	ecx, 1
	cmp	WORD PTR [rdi+2], ax
	movzx	r13d, r13b
	cmove	r13d, ecx
	jmp	SHORT $LN26@get_mv_can
$LN156@get_mv_can:
	mov	rdi, QWORD PTR mv_cand$[rsp]
$LN26@get_mv_can:

; 1290 :     candidates = 1;
; 1291 :   }
; 1292 : 
; 1293 :   // Use Temporal Motion Vector Prediction when enabled.
; 1294 :   // TMVP required at least two sequential P/B-frames.
; 1295 :   bool can_use_tmvp =

	mov	rax, QWORD PTR [rbp]
	cmp	DWORD PTR [rax+2396], 0
	je	SHORT $LN96@get_mv_can
	mov	r10, QWORD PTR [rbp+40]
	cmp	DWORD PTR [r10+12], 1
	jle	SHORT $LN96@get_mv_can
	mov	rax, QWORD PTR [r10+40]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN96@get_mv_can
	cmp	r13b, 2
	jae	$LN15@get_mv_can
	mov	r8, QWORD PTR h$1$[rsp]
	mov	rdx, QWORD PTR c3$1$[rsp]
	test	r8, r8
	jne	SHORT $LN151@get_mv_can
	test	rdx, rdx
	je	SHORT $LN153@get_mv_can
$LN151@get_mv_can:

; 1296 :     state->encoder_control->cfg.tmvp_enable &&
; 1297 :     state->frame->poc > 1 &&
; 1298 :     state->frame->ref->used_size &&
; 1299 :     candidates < AMVP_MAX_NUM_CANDS &&
; 1300 :     (h != NULL || c3 != NULL);
; 1301 : 
; 1302 :   if (can_use_tmvp && add_temporal_candidate(state,

	test	r8, r8
	movzx	eax, r13b
	mov	r9d, ebx
	cmovne	rdx, r8
	mov	r8, rdx
	lea	rcx, QWORD PTR [rdi+rax*4]
	mov	rax, QWORD PTR tv2414[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rbp
	movzx	eax, BYTE PTR [rax]
	add	rax, r10
	movzx	edx, BYTE PTR [rax+r12*8+49]
	call	add_temporal_candidate
	test	al, al
	je	SHORT $LN153@get_mv_can

; 1303 :                                              state->frame->ref_LX[reflist][cur_cu->inter.mv_ref[reflist]],
; 1304 :                                              (h != NULL) ? h : c3,
; 1305 :                                              reflist,
; 1306 :                                              mv_cand[candidates]))
; 1307 :   {
; 1308 :     candidates++;

	inc	r13b
$LN96@get_mv_can:

; 1309 :   }
; 1310 : 
; 1311 :   // Fill with (0,0)
; 1312 :   while (candidates < AMVP_MAX_NUM_CANDS) {

	cmp	r13b, 2
	jae	SHORT $LN15@get_mv_can
$LN153@get_mv_can:
	movzx	eax, r13b
	lea	rcx, QWORD PTR [rdi+rax*4]
	mov	eax, 2
	sub	al, r13b
	movzx	edx, al
	npad	1
$LL14@get_mv_can:

; 1313 :     mv_cand[candidates][0] = 0;

	mov	DWORD PTR [rcx], 0

; 1314 :     mv_cand[candidates][1] = 0;
; 1315 :     candidates++;

	lea	rcx, QWORD PTR [rcx+4]
	sub	rdx, 1
	jne	SHORT $LL14@get_mv_can
$LN15@get_mv_can:

; 1316 :   }
; 1317 : }

	lea	r11, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
get_mv_cand_from_candidates ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
merge_cand$ = 80
state$ = 160
x$ = 168
y$ = 176
width$ = 184
height$ = 192
mv_cand$ = 200
cur_cu$ = 208
lcu$ = 216
reflist$ = 224
kvz_inter_get_mv_cand PROC

; 1341 : {

$LN159:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 144				; 00000090H

; 1342 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };
; 1343 : 
; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	ebx, DWORD PTR height$[rsp]
	mov	esi, r8d
	mov	QWORD PTR [rax-24], 0
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR [rax-72], xmm0
	mov	edi, r9d
	mov	ebp, edx
	movdqu	XMMWORD PTR [rax-40], xmm0
	mov	r14, rcx
	mov	r9d, ebx
	xorps	xmm1, xmm1
	mov	edx, esi
	movdqu	XMMWORD PTR [rax-56], xmm1
	mov	rax, QWORD PTR [rcx+48]
	mov	ecx, ebp
	mov	r8, QWORD PTR [rax]
	lea	rax, QWORD PTR merge_cand$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR lcu$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [r8+20]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r8+16]
	mov	r8d, edi
	mov	DWORD PTR [rsp+32], eax
	call	get_spatial_merge_candidates

; 1345 :                                state->tile->frame->width,
; 1346 :                                state->tile->frame->height,
; 1347 :                                lcu,
; 1348 :                                &merge_cand);
; 1349 :   get_temporal_merge_candidates(state, x, y, width, height, 1, 0, &merge_cand);

	lea	rax, QWORD PTR merge_cand$[rsp]
	mov	r9d, edi
	mov	QWORD PTR [rsp+56], rax
	mov	r8d, esi
	mov	edx, ebp
	mov	DWORD PTR [rsp+32], ebx
	mov	rcx, r14
	call	get_temporal_merge_candidates

; 1350 :   get_mv_cand_from_candidates(state, x, y, width, height, &merge_cand, cur_cu, reflist, mv_cand);

	mov	rax, QWORD PTR mv_cand$[rsp]
	mov	r9d, edi
	mov	QWORD PTR [rsp+64], rax
	mov	r8d, esi
	movzx	eax, BYTE PTR reflist$[rsp]
	mov	edx, ebp
	mov	BYTE PTR [rsp+56], al
	mov	rcx, r14
	mov	rax, QWORD PTR cur_cu$[rsp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR merge_cand$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], ebx
	call	get_mv_cand_from_candidates

; 1351 : }

	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
kvz_inter_get_mv_cand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
cu1$ = 8
cu2$ = 16
is_duplicate_candidate PROC

; 1386 : {

	mov	r10, rdx
	mov	r9, rcx

; 1387 :   if (!cu2) return false;

	test	rdx, rdx
	je	SHORT $LN9@is_duplica

; 1388 :   if (cu1->inter.mv_dir != cu2->inter.mv_dir) return false;

	movzx	ecx, BYTE PTR [rcx+18]
	movzx	eax, BYTE PTR [rdx+18]
	xor	al, cl
	test	al, 192					; 000000c0H
	jne	SHORT $LN9@is_duplica

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	mov	r11d, ecx
	lea	rax, QWORD PTR [r10+8]
	shr	r11d, 6
	xor	r8d, r8d
	add	rdx, 16
	sub	r9, r10
	npad	2
$LL4@is_duplica:

; 1391 :     if (cu1->inter.mv_dir & (1 << reflist)) {

	bt	r11d, r8d
	jae	SHORT $LN2@is_duplica

; 1392 :       if (cu1->inter.mv[reflist][0]  != cu2->inter.mv[reflist][0]  ||
; 1393 :           cu1->inter.mv[reflist][1]  != cu2->inter.mv[reflist][1]  ||

	movzx	ecx, WORD PTR [rax]
	cmp	WORD PTR [r9+rax], cx
	jne	SHORT $LN9@is_duplica
	movzx	ecx, WORD PTR [rax+2]
	cmp	WORD PTR [r9+rax+2], cx
	jne	SHORT $LN9@is_duplica
	movzx	ecx, BYTE PTR [rdx]
	cmp	BYTE PTR [r9+rdx], cl
	jne	SHORT $LN9@is_duplica
$LN2@is_duplica:

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	inc	r8d
	add	rax, 4
	inc	rdx
	cmp	r8d, 2
	jl	SHORT $LL4@is_duplica

; 1396 :       }
; 1397 :     }
; 1398 :   }
; 1399 : 
; 1400 :   return true;

	mov	al, 1

; 1401 : }

	ret	0
$LN9@is_duplica:

; 1394 :           cu1->inter.mv_ref[reflist] != cu2->inter.mv_ref[reflist]) {
; 1395 :         return false;

	xor	al, al

; 1401 : }

	ret	0
is_duplicate_candidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
cand$ = 8
possible_duplicate1$ = 16
possible_duplicate2$ = 24
merge_cand_out$ = 32
candidates$ = 40
max_num_cands$ = 48
add_merge_candidate PROC

; 1409 : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	mov	r14, r9
	mov	rdi, r8
	mov	rbx, rdx
	mov	r11, rcx

; 1410 :   if (!cand ||
; 1411 :       is_duplicate_candidate(cand, possible_duplicate1) ||
; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	test	rcx, rcx
	je	SHORT $LN36@add_merge_

; 1387 :   if (!cu2) return false;

	xor	r10d, r10d
	test	rdx, rdx
	je	SHORT $LN33@add_merge_

; 1388 :   if (cu1->inter.mv_dir != cu2->inter.mv_dir) return false;

	movzx	ecx, BYTE PTR [rcx+18]
	movzx	eax, BYTE PTR [rdx+18]
	xor	al, cl
	test	al, 192					; 000000c0H
	jne	SHORT $LN33@add_merge_
	mov	esi, ecx

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	lea	r8, QWORD PTR [rbx+16]
	shr	esi, 6
	lea	rcx, QWORD PTR [rbx+8]
	mov	r9, r11
	mov	edx, r10d
	sub	r9, rbx
$LL8@add_merge_:

; 1391 :     if (cu1->inter.mv_dir & (1 << reflist)) {

	bt	esi, edx
	jae	SHORT $LN6@add_merge_

; 1392 :       if (cu1->inter.mv[reflist][0]  != cu2->inter.mv[reflist][0]  ||
; 1393 :           cu1->inter.mv[reflist][1]  != cu2->inter.mv[reflist][1]  ||

	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [r9+rcx], ax
	jne	SHORT $LN33@add_merge_
	movzx	eax, WORD PTR [rcx+2]
	cmp	WORD PTR [r9+rcx+2], ax
	jne	SHORT $LN33@add_merge_
	movzx	eax, BYTE PTR [r8]
	cmp	BYTE PTR [r9+r8], al
	jne	SHORT $LN33@add_merge_
$LN6@add_merge_:

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	inc	edx
	add	rcx, 4
	inc	r8
	cmp	edx, 2
	jl	SHORT $LL8@add_merge_
$LN36@add_merge_:

; 1413 :       candidates >= max_num_cands) {
; 1414 :     return false;

	xor	al, al
$LN1@add_merge_:

; 1425 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	mov	r14, QWORD PTR [rsp+32]
	ret	0
$LN33@add_merge_:

; 1387 :   if (!cu2) return false;

	test	rdi, rdi
	je	SHORT $LN34@add_merge_

; 1388 :   if (cu1->inter.mv_dir != cu2->inter.mv_dir) return false;

	movzx	ecx, BYTE PTR [r11+18]
	movzx	eax, BYTE PTR [rdi+18]
	xor	al, cl
	test	al, 192					; 000000c0H
	jne	SHORT $LN34@add_merge_
	mov	r9d, ecx

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	lea	rdx, QWORD PTR [rdi+16]
	shr	r9d, 6
	lea	rcx, QWORD PTR [rdi+8]
	mov	r8, r11
	sub	r8, rdi
$LL18@add_merge_:

; 1391 :     if (cu1->inter.mv_dir & (1 << reflist)) {

	bt	r9d, r10d
	jae	SHORT $LN16@add_merge_

; 1392 :       if (cu1->inter.mv[reflist][0]  != cu2->inter.mv[reflist][0]  ||
; 1393 :           cu1->inter.mv[reflist][1]  != cu2->inter.mv[reflist][1]  ||

	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [r8+rcx], ax
	jne	SHORT $LN34@add_merge_
	movzx	eax, WORD PTR [rcx+2]
	cmp	WORD PTR [r8+rcx+2], ax
	jne	SHORT $LN34@add_merge_
	movzx	eax, BYTE PTR [rdx]
	cmp	BYTE PTR [r8+rdx], al
	jne	SHORT $LN34@add_merge_
$LN16@add_merge_:

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	inc	r10d
	add	rcx, 4
	inc	rdx
	cmp	r10d, 2
	jl	SHORT $LL18@add_merge_
	jmp	SHORT $LN36@add_merge_
$LN34@add_merge_:

; 1410 :   if (!cand ||
; 1411 :       is_duplicate_candidate(cand, possible_duplicate1) ||
; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	movzx	eax, BYTE PTR max_num_cands$[rsp]
	cmp	BYTE PTR candidates$[rsp], al
	jae	$LN36@add_merge_

; 1415 :   }
; 1416 : 
; 1417 :   merge_cand_out->mv[0][0] = cand->inter.mv[0][0];

	movzx	eax, WORD PTR [r11+8]
	mov	WORD PTR [r14+4], ax

; 1418 :   merge_cand_out->mv[0][1] = cand->inter.mv[0][1];

	movzx	eax, WORD PTR [r11+10]
	mov	WORD PTR [r14+6], ax

; 1419 :   merge_cand_out->mv[1][0] = cand->inter.mv[1][0];

	movzx	eax, WORD PTR [r11+12]
	mov	WORD PTR [r14+8], ax

; 1420 :   merge_cand_out->mv[1][1] = cand->inter.mv[1][1];

	movzx	eax, WORD PTR [r11+14]
	mov	WORD PTR [r14+10], ax

; 1421 :   merge_cand_out->ref[0]   = cand->inter.mv_ref[0]; // L0/L1 references

	movzx	eax, BYTE PTR [r11+16]
	mov	BYTE PTR [r14+1], al

; 1422 :   merge_cand_out->ref[1]   = cand->inter.mv_ref[1];

	movzx	eax, BYTE PTR [r11+17]
	mov	BYTE PTR [r14+2], al

; 1423 :   merge_cand_out->dir      = cand->inter.mv_dir;

	movzx	eax, BYTE PTR [r11+18]
	shr	al, 6
	mov	BYTE PTR [r14], al

; 1424 :   return true;

	mov	al, 1
	jmp	$LN1@add_merge_
add_merge_candidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
_TEXT	SEGMENT
tv4167 = 64
merge_cand$ = 72
max_num_cands$1$ = 256
state$ = 256
x$ = 264
y$ = 272
width$ = 280
height$ = 288
tv4419 = 296
use_a1$ = 296
use_b1$ = 304
tv4193 = 312
mv_cand$ = 312
lcu$ = 320
kvz_inter_get_merge_cand PROC

; 1446 : {

$LN230:
	mov	rax, rsp
	mov	DWORD PTR [rax+32], r9d
	mov	DWORD PTR [rax+24], r8d
	mov	DWORD PTR [rax+16], edx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r15
	sub	rsp, 200				; 000000c8H
	mov	QWORD PTR [rax-56], r12
	xorps	xmm0, xmm0
	mov	QWORD PTR [rax-64], r14
	mov	r15, rcx
	mov	r10d, r9d
	mov	r11d, r8d

; 1447 :   uint8_t candidates = 0;
; 1448 :   int8_t zero_idx = 0;
; 1449 : 
; 1450 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };
; 1451 :   const uint8_t max_num_cands = state->encoder_control->cfg.max_merge;
; 1452 :   get_spatial_merge_candidates(x, y, width, height,

	mov	r9d, DWORD PTR height$[rsp]
	mov	ebx, edx
	xorps	xmm1, xmm1
	xor	r12d, r12d
	movdqu	XMMWORD PTR merge_cand$[rsp], xmm0
	mov	r8d, r10d
	mov	edx, r11d
	movdqu	XMMWORD PTR merge_cand$[rsp+16], xmm1
	movdqu	XMMWORD PTR merge_cand$[rsp+32], xmm0
	mov	QWORD PTR [rax-128], r12
	mov	rax, QWORD PTR [rcx]
	movzx	r13d, BYTE PTR [rax+2473]
	mov	rax, QWORD PTR [rcx+48]
	mov	BYTE PTR max_num_cands$1$[rsp], r13b
	mov	rcx, QWORD PTR [rax]
	lea	rax, QWORD PTR merge_cand$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR lcu$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rcx+16]
	mov	ecx, ebx
	mov	DWORD PTR [rsp+32], eax
	call	get_spatial_merge_candidates

; 1453 :                                state->tile->frame->width,
; 1454 :                                state->tile->frame->height,
; 1455 :                                lcu,
; 1456 :                                &merge_cand);
; 1457 : 
; 1458 :   const cu_info_t **a = merge_cand.a;
; 1459 :   const cu_info_t **b = merge_cand.b;
; 1460 : 
; 1461 :   if (!use_a1) a[1] = NULL;

	cmp	BYTE PTR use_a1$[rsp], r12b
	mov	rdx, QWORD PTR merge_cand$[rsp+8]

; 1462 :   if (!use_b1) b[1] = NULL;

	mov	r10, QWORD PTR merge_cand$[rsp+24]
	cmove	rdx, r12
	cmp	BYTE PTR use_b1$[rsp], r12b

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	mov	rdi, QWORD PTR mv_cand$[rsp]

; 1462 :   if (!use_b1) b[1] = NULL;

	cmove	r10, r12

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	test	rdx, rdx
	je	SHORT $LN40@kvz_inter_
	test	r13b, r13b
	je	SHORT $LN40@kvz_inter_

; 1415 :   }
; 1416 : 
; 1417 :   merge_cand_out->mv[0][0] = cand->inter.mv[0][0];

	movzx	eax, WORD PTR [rdx+8]

; 1424 :   return true;

	mov	bpl, 1
	mov	WORD PTR [rdi+4], ax
	movzx	eax, WORD PTR [rdx+10]
	mov	WORD PTR [rdi+6], ax
	movzx	eax, WORD PTR [rdx+12]
	mov	WORD PTR [rdi+8], ax
	movzx	eax, WORD PTR [rdx+14]
	mov	WORD PTR [rdi+10], ax
	movzx	eax, BYTE PTR [rdx+16]
	mov	BYTE PTR [rdi+1], al
	movzx	eax, BYTE PTR [rdx+17]
	mov	BYTE PTR [rdi+2], al
	movzx	eax, BYTE PTR [rdx+18]
	shr	al, 6
	mov	BYTE PTR [rdi], al
	jmp	SHORT $LN38@kvz_inter_
$LN40@kvz_inter_:

; 1413 :       candidates >= max_num_cands) {
; 1414 :     return false;

	xor	bpl, bpl
$LN38@kvz_inter_:

; 1463 : 
; 1464 :   if (add_merge_candidate(a[1], NULL, NULL, &mv_cand[candidates], candidates, max_num_cands)) candidates++;
; 1465 :   if (add_merge_candidate(b[1], a[1], NULL, &mv_cand[candidates], candidates, max_num_cands)) candidates++;

	movzx	eax, bpl
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rbx, QWORD PTR [rdi+rcx*4]

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	test	r10, r10
	je	SHORT $LN218@kvz_inter_

; 1387 :   if (!cu2) return false;

	test	rdx, rdx
	je	$LN208@kvz_inter_

; 1388 :   if (cu1->inter.mv_dir != cu2->inter.mv_dir) return false;

	movzx	ecx, BYTE PTR [r10+18]
	movzx	eax, BYTE PTR [rdx+18]
	xor	al, cl
	test	al, 192					; 000000c0H
	jne	$LN208@kvz_inter_
	mov	esi, ecx

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	lea	r9, QWORD PTR [rdx+16]
	shr	esi, 6
	lea	rcx, QWORD PTR [rdx+8]
	mov	r11, r10
	mov	r8d, r12d
	sub	r11, rdx
	npad	7
$LL69@kvz_inter_:

; 1391 :     if (cu1->inter.mv_dir & (1 << reflist)) {

	bt	esi, r8d
	jae	SHORT $LN67@kvz_inter_

; 1392 :       if (cu1->inter.mv[reflist][0]  != cu2->inter.mv[reflist][0]  ||
; 1393 :           cu1->inter.mv[reflist][1]  != cu2->inter.mv[reflist][1]  ||

	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [r11+rcx], ax
	jne	$LN208@kvz_inter_
	movzx	eax, WORD PTR [rcx+2]
	cmp	WORD PTR [r11+rcx+2], ax
	jne	$LN208@kvz_inter_
	movzx	eax, BYTE PTR [r9]
	cmp	BYTE PTR [r11+r9], al
	jne	$LN208@kvz_inter_
$LN67@kvz_inter_:

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	inc	r8d
	add	rcx, 4
	inc	r9
	cmp	r8d, 2
	jl	SHORT $LL69@kvz_inter_
$LN218@kvz_inter_:

; 1414 :     return false;

	xor	r8b, r8b
$LN62@kvz_inter_:

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	mov	rbx, QWORD PTR merge_cand$[rsp+16]

; 1466 :   if (add_merge_candidate(b[0], b[1], NULL, &mv_cand[candidates], candidates, max_num_cands)) candidates++;

	lea	eax, DWORD PTR [rbp+1]
	movzx	ecx, al
	test	r8b, r8b
	movzx	eax, bpl
	cmove	ecx, eax
	movzx	r14d, cl
	lea	rax, QWORD PTR [r14+r14*2]
	lea	rsi, QWORD PTR [rdi+rax*4]

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	test	rbx, rbx
	je	SHORT $LN219@kvz_inter_

; 1387 :   if (!cu2) return false;

	test	r10, r10
	je	$LN209@kvz_inter_

; 1388 :   if (cu1->inter.mv_dir != cu2->inter.mv_dir) return false;

	movzx	ecx, BYTE PTR [rbx+18]
	movzx	eax, BYTE PTR [r10+18]
	xor	al, cl
	test	al, 192					; 000000c0H
	jne	$LN209@kvz_inter_
	mov	ebp, ecx

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	lea	r9, QWORD PTR [r10+16]
	shr	ebp, 6
	lea	rcx, QWORD PTR [r10+8]
	mov	r11, rbx
	mov	r8d, r12d
	sub	r11, r10
	npad	3
$LL93@kvz_inter_:

; 1391 :     if (cu1->inter.mv_dir & (1 << reflist)) {

	bt	ebp, r8d
	jae	SHORT $LN91@kvz_inter_

; 1392 :       if (cu1->inter.mv[reflist][0]  != cu2->inter.mv[reflist][0]  ||
; 1393 :           cu1->inter.mv[reflist][1]  != cu2->inter.mv[reflist][1]  ||

	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [r11+rcx], ax
	jne	$LN209@kvz_inter_
	movzx	eax, WORD PTR [rcx+2]
	cmp	WORD PTR [r11+rcx+2], ax
	jne	$LN209@kvz_inter_
	movzx	eax, BYTE PTR [r9]
	cmp	BYTE PTR [r11+r9], al
	jne	$LN209@kvz_inter_
$LN91@kvz_inter_:

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	inc	r8d
	add	rcx, 4
	inc	r9
	cmp	r8d, 2
	jl	SHORT $LL93@kvz_inter_
$LN219@kvz_inter_:

; 1414 :     return false;

	xor	r8b, r8b
$LN86@kvz_inter_:

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	mov	rbx, QWORD PTR merge_cand$[rsp]

; 1467 :   if (add_merge_candidate(a[0], a[1], NULL, &mv_cand[candidates], candidates, max_num_cands)) candidates++;

	lea	eax, DWORD PTR [r14+1]
	test	r8b, r8b
	movzx	ecx, al
	cmove	ecx, r14d
	movzx	r14d, cl
	lea	rax, QWORD PTR [r14+r14*2]
	lea	rsi, QWORD PTR [rdi+rax*4]

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	test	rbx, rbx
	je	SHORT $LN220@kvz_inter_

; 1387 :   if (!cu2) return false;

	test	rdx, rdx
	je	$LN210@kvz_inter_

; 1388 :   if (cu1->inter.mv_dir != cu2->inter.mv_dir) return false;

	movzx	ecx, BYTE PTR [rbx+18]
	movzx	eax, BYTE PTR [rdx+18]
	xor	al, cl
	test	al, 192					; 000000c0H
	jne	$LN210@kvz_inter_
	mov	ebp, ecx

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	lea	r9, QWORD PTR [rdx+16]
	shr	ebp, 6
	lea	rcx, QWORD PTR [rdx+8]
	mov	r11, rbx
	mov	r8d, r12d
	sub	r11, rdx
	npad	6
$LL117@kvz_inter_:

; 1391 :     if (cu1->inter.mv_dir & (1 << reflist)) {

	bt	ebp, r8d
	jae	SHORT $LN115@kvz_inter_

; 1392 :       if (cu1->inter.mv[reflist][0]  != cu2->inter.mv[reflist][0]  ||
; 1393 :           cu1->inter.mv[reflist][1]  != cu2->inter.mv[reflist][1]  ||

	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [r11+rcx], ax
	jne	$LN210@kvz_inter_
	movzx	eax, WORD PTR [rcx+2]
	cmp	WORD PTR [r11+rcx+2], ax
	jne	$LN210@kvz_inter_
	movzx	eax, BYTE PTR [r9]
	cmp	BYTE PTR [r9+r11], al
	jne	$LN210@kvz_inter_
$LN115@kvz_inter_:

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	inc	r8d
	add	rcx, 4
	inc	r9
	cmp	r8d, 2
	jl	SHORT $LL117@kvz_inter_
$LN220@kvz_inter_:

; 1414 :     return false;

	xor	cl, cl
$LN110@kvz_inter_:

; 1468 :   if (candidates < 4 &&

	test	cl, cl
	lea	eax, DWORD PTR [r14+1]
	movzx	ebx, al
	cmove	ebx, r14d
	mov	DWORD PTR tv4419[rsp], ebx
	cmp	bl, 4
	jae	$LN19@kvz_inter_

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	mov	rsi, QWORD PTR merge_cand$[rsp+32]

; 1468 :   if (candidates < 4 &&

	movzx	eax, bl
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	r14, QWORD PTR [rdi+rcx*4]

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	test	rsi, rsi
	je	$LN222@kvz_inter_

; 1387 :   if (!cu2) return false;

	test	rdx, rdx
	je	$LN211@kvz_inter_

; 1388 :   if (cu1->inter.mv_dir != cu2->inter.mv_dir) return false;

	movzx	ecx, BYTE PTR [rsi+18]
	movzx	eax, BYTE PTR [rdx+18]
	xor	al, cl
	test	al, 192					; 000000c0H
	jne	$LN211@kvz_inter_
	mov	ebp, ecx

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	lea	r9, QWORD PTR [rdx+16]
	shr	ebp, 6
	lea	rcx, QWORD PTR [rdx+8]
	mov	r11, rsi
	mov	r8d, r12d
	sub	r11, rdx
	npad	5
$LL141@kvz_inter_:

; 1391 :     if (cu1->inter.mv_dir & (1 << reflist)) {

	bt	ebp, r8d
	jae	SHORT $LN139@kvz_inter_

; 1392 :       if (cu1->inter.mv[reflist][0]  != cu2->inter.mv[reflist][0]  ||
; 1393 :           cu1->inter.mv[reflist][1]  != cu2->inter.mv[reflist][1]  ||

	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [r11+rcx], ax
	jne	$LN211@kvz_inter_
	movzx	eax, WORD PTR [rcx+2]
	cmp	WORD PTR [r11+rcx+2], ax
	jne	$LN211@kvz_inter_
	movzx	eax, BYTE PTR [r9]
	cmp	BYTE PTR [r11+r9], al
	jne	$LN211@kvz_inter_
$LN139@kvz_inter_:

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	inc	r8d
	add	rcx, 4
	inc	r9
	cmp	r8d, 2
	jl	SHORT $LL141@kvz_inter_
	jmp	$LN222@kvz_inter_
$LN208@kvz_inter_:

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	cmp	bpl, r13b
	jae	$LN218@kvz_inter_

; 1415 :   }
; 1416 : 
; 1417 :   merge_cand_out->mv[0][0] = cand->inter.mv[0][0];

	movzx	eax, WORD PTR [r10+8]

; 1424 :   return true;

	mov	r8b, 1
	mov	WORD PTR [rbx+4], ax
	movzx	eax, WORD PTR [r10+10]
	mov	WORD PTR [rbx+6], ax
	movzx	eax, WORD PTR [r10+12]
	mov	WORD PTR [rbx+8], ax
	movzx	eax, WORD PTR [r10+14]
	mov	WORD PTR [rbx+10], ax
	movzx	eax, BYTE PTR [r10+16]
	mov	BYTE PTR [rbx+1], al
	movzx	eax, BYTE PTR [r10+17]
	mov	BYTE PTR [rbx+2], al
	movzx	eax, BYTE PTR [r10+18]
	shr	al, 6
	mov	BYTE PTR [rbx], al
	jmp	$LN62@kvz_inter_
$LN209@kvz_inter_:

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	cmp	r14b, r13b
	jae	$LN219@kvz_inter_

; 1415 :   }
; 1416 : 
; 1417 :   merge_cand_out->mv[0][0] = cand->inter.mv[0][0];

	movzx	eax, WORD PTR [rbx+8]

; 1424 :   return true;

	mov	r8b, 1
	mov	WORD PTR [rsi+4], ax
	movzx	eax, WORD PTR [rbx+10]
	mov	WORD PTR [rsi+6], ax
	movzx	eax, WORD PTR [rbx+12]
	mov	WORD PTR [rsi+8], ax
	movzx	eax, WORD PTR [rbx+14]
	mov	WORD PTR [rsi+10], ax
	movzx	eax, BYTE PTR [rbx+16]
	mov	BYTE PTR [rsi+1], al
	movzx	eax, BYTE PTR [rbx+17]
	mov	BYTE PTR [rsi+2], al
	movzx	eax, BYTE PTR [rbx+18]
	shr	al, 6
	mov	BYTE PTR [rsi], al
	jmp	$LN86@kvz_inter_
$LN210@kvz_inter_:

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	cmp	r14b, r13b
	jae	$LN220@kvz_inter_

; 1415 :   }
; 1416 : 
; 1417 :   merge_cand_out->mv[0][0] = cand->inter.mv[0][0];

	movzx	eax, WORD PTR [rbx+8]

; 1424 :   return true;

	mov	cl, 1
	mov	WORD PTR [rsi+4], ax
	movzx	eax, WORD PTR [rbx+10]
	mov	WORD PTR [rsi+6], ax
	movzx	eax, WORD PTR [rbx+12]
	mov	WORD PTR [rsi+8], ax
	movzx	eax, WORD PTR [rbx+14]
	mov	WORD PTR [rsi+10], ax
	movzx	eax, BYTE PTR [rbx+16]
	mov	BYTE PTR [rsi+1], al
	movzx	eax, BYTE PTR [rbx+17]
	mov	BYTE PTR [rsi+2], al
	movzx	eax, BYTE PTR [rbx+18]
	shr	al, 6
	mov	BYTE PTR [rsi], al
	jmp	$LN110@kvz_inter_
$LN211@kvz_inter_:

; 1387 :   if (!cu2) return false;

	test	r10, r10
	je	SHORT $LN212@kvz_inter_

; 1388 :   if (cu1->inter.mv_dir != cu2->inter.mv_dir) return false;

	movzx	ecx, BYTE PTR [rsi+18]
	movzx	eax, BYTE PTR [r10+18]
	xor	al, cl
	test	al, 192					; 000000c0H
	jne	SHORT $LN212@kvz_inter_
	mov	r11d, ecx

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	lea	r8, QWORD PTR [r10+16]
	shr	r11d, 6
	lea	rcx, QWORD PTR [r10+8]
	mov	r9, rsi
	mov	edx, r12d
	sub	r9, r10
$LL151@kvz_inter_:

; 1391 :     if (cu1->inter.mv_dir & (1 << reflist)) {

	bt	r11d, edx
	jae	SHORT $LN149@kvz_inter_

; 1392 :       if (cu1->inter.mv[reflist][0]  != cu2->inter.mv[reflist][0]  ||
; 1393 :           cu1->inter.mv[reflist][1]  != cu2->inter.mv[reflist][1]  ||

	movzx	eax, WORD PTR [rcx]
	cmp	WORD PTR [r9+rcx], ax
	jne	SHORT $LN212@kvz_inter_
	movzx	eax, WORD PTR [rcx+2]
	cmp	WORD PTR [r9+rcx+2], ax
	jne	SHORT $LN212@kvz_inter_
	movzx	eax, BYTE PTR [r8]
	cmp	BYTE PTR [r9+r8], al
	jne	SHORT $LN212@kvz_inter_
$LN149@kvz_inter_:

; 1389 : 
; 1390 :   for (int reflist = 0; reflist < 2; reflist++) {

	inc	edx
	add	rcx, 4
	inc	r8
	cmp	edx, 2
	jl	SHORT $LL151@kvz_inter_
	jmp	SHORT $LN222@kvz_inter_
$LN212@kvz_inter_:

; 1412 :       is_duplicate_candidate(cand, possible_duplicate2) ||

	cmp	bl, r13b
	jae	SHORT $LN222@kvz_inter_

; 1415 :   }
; 1416 : 
; 1417 :   merge_cand_out->mv[0][0] = cand->inter.mv[0][0];

	movzx	eax, WORD PTR [rsi+8]
	mov	WORD PTR [r14+4], ax

; 1418 :   merge_cand_out->mv[0][1] = cand->inter.mv[0][1];

	movzx	eax, WORD PTR [rsi+10]
	mov	WORD PTR [r14+6], ax

; 1419 :   merge_cand_out->mv[1][0] = cand->inter.mv[1][0];

	movzx	eax, WORD PTR [rsi+12]
	mov	WORD PTR [r14+8], ax

; 1420 :   merge_cand_out->mv[1][1] = cand->inter.mv[1][1];

	movzx	eax, WORD PTR [rsi+14]
	mov	WORD PTR [r14+10], ax

; 1421 :   merge_cand_out->ref[0]   = cand->inter.mv_ref[0]; // L0/L1 references

	movzx	eax, BYTE PTR [rsi+16]
	mov	BYTE PTR [r14+1], al

; 1422 :   merge_cand_out->ref[1]   = cand->inter.mv_ref[1];

	movzx	eax, BYTE PTR [rsi+17]
	mov	BYTE PTR [r14+2], al

; 1423 :   merge_cand_out->dir      = cand->inter.mv_dir;

	movzx	eax, BYTE PTR [rsi+18]
	shr	al, 6
	mov	BYTE PTR [r14], al

; 1469 :       add_merge_candidate(b[2], a[1], b[1], &mv_cand[candidates], candidates, max_num_cands)) candidates++;

	inc	bl
$LN222@kvz_inter_:

; 1470 : 
; 1471 :   bool can_use_tmvp =

	mov	DWORD PTR tv4419[rsp], ebx
$LN19@kvz_inter_:
	mov	rax, QWORD PTR [r15]
	cmp	DWORD PTR [rax+2396], r12d
	je	$LN22@kvz_inter_
	cmp	bl, r13b
	jae	$LN226@kvz_inter_
	mov	rax, QWORD PTR [r15+40]
	mov	rcx, QWORD PTR [rax+40]
	cmp	DWORD PTR [rcx+36], r12d
	je	$LN216@kvz_inter_

; 1472 :     state->encoder_control->cfg.tmvp_enable &&
; 1473 :     candidates < max_num_cands &&
; 1474 :     state->frame->ref->used_size;
; 1475 : 
; 1476 :   if (can_use_tmvp) {
; 1477 :     mv_cand[candidates].dir = 0;

	movzx	ecx, bl

; 1478 : 
; 1479 :     const int max_reflist = (state->frame->slicetype == KVZ_SLICE_B ? 1 : 0);
; 1480 :     for (int reflist = 0; reflist <= max_reflist; reflist++) {

	mov	rdx, r12
	mov	esi, r12d
	mov	rbp, r12
	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	r14, QWORD PTR [rdi+rax*4]
	mov	BYTE PTR [r14], r12b
	mov	rax, QWORD PTR [r15+40]
	cmp	DWORD PTR [rax+88], r12d
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	rbx, rax
	sete	dl
	mov	QWORD PTR tv4193[rsp], rdx
	mov	r13, rdx
$LL4@kvz_inter_:

; 1481 :       // Fetch temporal candidates for the current CU
; 1482 :       get_temporal_merge_candidates(state, x, y, width, height, 1, 0, &merge_cand);

	mov	r9d, DWORD PTR width$[rsp]
	lea	rax, QWORD PTR merge_cand$[rsp]
	mov	r8d, DWORD PTR y$[rsp]
	mov	rcx, r15
	mov	edx, DWORD PTR x$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR height$[rsp]
	mov	DWORD PTR [rsp+32], eax
	call	get_temporal_merge_candidates

; 1483 :       // TODO: enable L1 TMVP candidate
; 1484 :       // get_temporal_merge_candidates(state, x, y, width, height, 2, 0, &merge_cand);
; 1485 : 
; 1486 :       const cu_info_t *temporal_cand =

	mov	r8, QWORD PTR merge_cand$[rsp+40]

; 1487 :         (merge_cand.h != NULL) ? merge_cand.h : merge_cand.c3;
; 1488 : 
; 1489 :       if (add_temporal_candidate(state,

	mov	r9d, esi
	movsxd	rax, esi
	inc	rax
	add	rax, rbx
	lea	rcx, QWORD PTR [rdi+rax*4]
	mov	rax, QWORD PTR merge_cand$[rsp+48]
	test	rax, rax
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, r15
	cmovne	r8, rax
	mov	rax, QWORD PTR [r15+40]
	movzx	edx, BYTE PTR [rax+r12+49]
	call	add_temporal_candidate
	test	al, al
	je	SHORT $LN214@kvz_inter_

; 1490 :                                  // Reference index 0 is always used for
; 1491 :                                  // the temporal merge candidate.
; 1492 :                                  state->frame->ref_LX[reflist][0],
; 1493 :                                  temporal_cand,
; 1494 :                                  reflist,
; 1495 :                                  mv_cand[candidates].mv[reflist])) {
; 1496 :         mv_cand[candidates].ref[reflist] = 0;

	mov	BYTE PTR [r14+rbp+1], 0

; 1497 :         mv_cand[candidates].dir |= (1 << reflist);

	movzx	eax, BYTE PTR [r14]
	bts	eax, esi
	mov	BYTE PTR [r14], al
	jmp	SHORT $LN2@kvz_inter_
$LN214@kvz_inter_:
	movzx	eax, BYTE PTR [r14]
$LN2@kvz_inter_:

; 1478 : 
; 1479 :     const int max_reflist = (state->frame->slicetype == KVZ_SLICE_B ? 1 : 0);
; 1480 :     for (int reflist = 0; reflist <= max_reflist; reflist++) {

	inc	esi
	inc	rbp
	add	r12, 16
	cmp	rbp, r13
	jle	$LL4@kvz_inter_

; 1498 :       }
; 1499 :     }
; 1500 : 
; 1501 :     if (mv_cand[candidates].dir != 0) candidates++;

	mov	ebx, DWORD PTR tv4419[rsp]
	movzx	r13d, BYTE PTR max_num_cands$1$[rsp]
	test	al, al
	je	SHORT $LN216@kvz_inter_
	inc	bl
$LN22@kvz_inter_:

; 1502 :   }
; 1503 : 
; 1504 :   if (candidates < max_num_cands && state->frame->slicetype == KVZ_SLICE_B) {

	cmp	bl, r13b
	jae	$LN226@kvz_inter_
$LN216@kvz_inter_:
	mov	rax, QWORD PTR [r15+40]
	xor	ebp, ebp
	cmp	DWORD PTR [rax+88], ebp
	jne	$LN167@kvz_inter_

; 1505 :     #define NUM_PRIORITY_LIST 12;
; 1506 :     static const uint8_t priorityList0[] = { 0, 1, 0, 2, 1, 2, 0, 3, 1, 3, 2, 3 };
; 1507 :     static const uint8_t priorityList1[] = { 1, 0, 2, 0, 2, 1, 3, 0, 3, 1, 3, 2 };
; 1508 :     uint8_t cutoff = candidates;
; 1509 :     for (int32_t idx = 0; idx<cutoff*(cutoff - 1) && candidates != max_num_cands; idx++) {

	movzx	eax, bl
	lea	ecx, DWORD PTR [rax-1]
	imul	ecx, eax
	movsxd	rsi, ecx
	test	ecx, ecx
	jle	$LN167@kvz_inter_

; 1497 :         mv_cand[candidates].dir |= (1 << reflist);

	mov	r11d, ebp
	lea	r14, OFFSET FLAT:__ImageBase
$LL7@kvz_inter_:

; 1505 :     #define NUM_PRIORITY_LIST 12;
; 1506 :     static const uint8_t priorityList0[] = { 0, 1, 0, 2, 1, 2, 0, 3, 1, 3, 2, 3 };
; 1507 :     static const uint8_t priorityList1[] = { 1, 0, 2, 0, 2, 1, 3, 0, 3, 1, 3, 2 };
; 1508 :     uint8_t cutoff = candidates;
; 1509 :     for (int32_t idx = 0; idx<cutoff*(cutoff - 1) && candidates != max_num_cands; idx++) {

	cmp	bl, r13b
	je	$LN167@kvz_inter_

; 1510 :       uint8_t i = priorityList0[idx];

	movzx	eax, BYTE PTR ?priorityList0@?6??kvz_inter_get_merge_cand@@9@9[r11+r14]

; 1511 :       uint8_t j = priorityList1[idx];
; 1512 :       if (i >= candidates || j >= candidates) break;

	cmp	al, bl
	jae	$LN167@kvz_inter_
	movzx	edx, BYTE PTR ?priorityList1@?6??kvz_inter_get_merge_cand@@9@9[r11+r14]
	cmp	dl, bl
	jae	$LN167@kvz_inter_

; 1513 : 
; 1514 :       // Find one L0 and L1 candidate according to the priority list
; 1515 :       if ((mv_cand[i].dir & 0x1) && (mv_cand[j].dir & 0x2)) {

	lea	rcx, QWORD PTR [rax+rax*2]
	test	BYTE PTR [rdi+rcx*4], 1
	lea	r10, QWORD PTR [rdi+rcx*4]
	je	$LN5@kvz_inter_
	lea	rcx, QWORD PTR [rdx+rdx*2]
	test	BYTE PTR [rdi+rcx*4], 2
	lea	r9, QWORD PTR [rdi+rcx*4]
	je	SHORT $LN5@kvz_inter_

; 1516 :         mv_cand[candidates].dir = 3;

	movzx	eax, bl
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	BYTE PTR [rdi+rcx*4], 3

; 1517 : 
; 1518 :         // get Mv from cand[i] and cand[j]
; 1519 :         mv_cand[candidates].mv[0][0]  = mv_cand[i].mv[0][0];

	movzx	eax, WORD PTR [r10+4]
	mov	WORD PTR [rdi+rcx*4+4], ax

; 1520 :         mv_cand[candidates].mv[0][1]  = mv_cand[i].mv[0][1];

	movzx	eax, WORD PTR [r10+6]
	mov	WORD PTR [rdi+rcx*4+6], ax

; 1521 :         mv_cand[candidates].mv[1][0]  = mv_cand[j].mv[1][0];

	movzx	eax, WORD PTR [r9+8]
	mov	WORD PTR [rdi+rcx*4+8], ax

; 1522 :         mv_cand[candidates].mv[1][1]  = mv_cand[j].mv[1][1];

	movzx	eax, WORD PTR [r9+10]
	mov	WORD PTR [rdi+rcx*4+10], ax

; 1523 :         mv_cand[candidates].ref[0]    = mv_cand[i].ref[0];

	movzx	eax, BYTE PTR [r10+1]
	mov	BYTE PTR [rdi+rcx*4+1], al

; 1524 :         mv_cand[candidates].ref[1]    = mv_cand[j].ref[1];

	movzx	eax, BYTE PTR [r9+2]
	mov	BYTE PTR [rdi+rcx*4+2], al

; 1525 : 
; 1526 :         if (state->frame->ref_LX[0][mv_cand[i].ref[0]] ==
; 1527 :             state->frame->ref_LX[1][mv_cand[j].ref[1]]
; 1528 :             &&
; 1529 :             mv_cand[i].mv[0][0] == mv_cand[j].mv[1][0] && 

	mov	r8, QWORD PTR [r15+40]
	movzx	eax, BYTE PTR [r9+2]
	movzx	edx, BYTE PTR [r10+1]
	movzx	ecx, BYTE PTR [rax+r8+65]
	cmp	BYTE PTR [rdx+r8+49], cl
	jne	SHORT $LN27@kvz_inter_
	movzx	eax, WORD PTR [r9+8]
	cmp	WORD PTR [r10+4], ax
	jne	SHORT $LN27@kvz_inter_
	movzx	eax, WORD PTR [r9+10]
	cmp	WORD PTR [r10+6], ax
	je	SHORT $LN5@kvz_inter_
$LN27@kvz_inter_:

; 1530 :             mv_cand[i].mv[0][1] == mv_cand[j].mv[1][1]) {
; 1531 :           // Not a candidate
; 1532 :         } else {
; 1533 :           candidates++;

	inc	bl
$LN5@kvz_inter_:

; 1505 :     #define NUM_PRIORITY_LIST 12;
; 1506 :     static const uint8_t priorityList0[] = { 0, 1, 0, 2, 1, 2, 0, 3, 1, 3, 2, 3 };
; 1507 :     static const uint8_t priorityList1[] = { 1, 0, 2, 0, 2, 1, 3, 0, 3, 1, 3, 2 };
; 1508 :     uint8_t cutoff = candidates;
; 1509 :     for (int32_t idx = 0; idx<cutoff*(cutoff - 1) && candidates != max_num_cands; idx++) {

	inc	r11
	cmp	r11, rsi
	jl	$LL7@kvz_inter_

; 1502 :   }
; 1503 : 
; 1504 :   if (candidates < max_num_cands && state->frame->slicetype == KVZ_SLICE_B) {

	jmp	SHORT $LN167@kvz_inter_
$LN226@kvz_inter_:
	xor	ebp, ebp
$LN167@kvz_inter_:

; 1534 :         }
; 1535 :       }
; 1536 :     }
; 1537 :   }
; 1538 : 
; 1539 :   int num_ref = state->frame->ref->used_size;

	mov	r9, QWORD PTR [r15+40]
	mov	r14, QWORD PTR [rsp+184]
	mov	r12, QWORD PTR [rsp+192]
	mov	rsi, QWORD PTR [r9+40]
	mov	ecx, DWORD PTR [rsi+36]

; 1540 : 
; 1541 :   if (candidates < max_num_cands && state->frame->slicetype == KVZ_SLICE_B) {

	cmp	bl, r13b
	jae	$LN166@kvz_inter_
	cmp	DWORD PTR [r9+88], 0
	jne	$LN215@kvz_inter_

; 1542 :     int j;
; 1543 :     int ref_negative = 0;

	mov	r8d, ebp

; 1544 :     int ref_positive = 0;

	mov	edx, ebp
	mov	r10d, ebp

; 1545 :     for (j = 0; j < state->frame->ref->used_size; j++) {

	test	ecx, ecx
	je	$LN9@kvz_inter_
	cmp	ecx, 8
	jb	$LN180@kvz_inter_

; 1542 :     int j;
; 1543 :     int ref_negative = 0;

	movd	xmm5, DWORD PTR [r9+12]
	mov	eax, ecx

; 1546 :       if (state->frame->ref->pocs[j] < state->frame->poc) {

	mov	r8, QWORD PTR [rsi+16]
	and	eax, 7
	movaps	XMMWORD PTR [rsp+160], xmm6
	mov	edx, ecx
	movaps	XMMWORD PTR [rsp+144], xmm7
	sub	edx, eax
	movaps	XMMWORD PTR [rsp+128], xmm8
	mov	rax, rbp
	movdqa	xmm8, XMMWORD PTR __xmm@00000001000000010000000100000001
	xorps	xmm3, xmm3
	pshufd	xmm5, xmm5, 0
	xorps	xmm7, xmm7
	xorps	xmm6, xmm6
	xorps	xmm4, xmm4
	npad	4
$LL10@kvz_inter_:
	movdqu	xmm0, XMMWORD PTR [rax+r8]
	lea	rax, QWORD PTR [rax+32]
	add	r10d, 8

; 1547 :         ref_negative++;

	movdqa	xmm1, xmm3
	movdqa	xmm2, xmm5
	pcmpgtd	xmm2, xmm0
	paddd	xmm1, xmm8
	pand	xmm1, xmm2
	movdqa	xmm0, xmm2
	pandn	xmm0, xmm3
	movdqa	xmm3, xmm1
	por	xmm3, xmm0

; 1548 :       } else {
; 1549 :         ref_positive++;

	movdqa	xmm0, xmm4
	paddd	xmm0, xmm8
	pand	xmm4, xmm2
	movdqa	xmm1, xmm2
	movdqa	xmm2, xmm5
	pandn	xmm1, xmm0
	movdqa	xmm0, xmm4
	movdqa	xmm4, xmm1
	movdqa	xmm1, xmm7
	por	xmm4, xmm0
	paddd	xmm1, xmm8
	movdqu	xmm0, XMMWORD PTR [r8+rax-16]
	pcmpgtd	xmm2, xmm0
	pand	xmm1, xmm2
	movdqa	xmm0, xmm2
	pandn	xmm0, xmm7
	movdqa	xmm7, xmm1
	por	xmm7, xmm0
	movdqa	xmm0, xmm6
	pand	xmm6, xmm2
	paddd	xmm0, xmm8
	movdqa	xmm1, xmm2
	pandn	xmm1, xmm0
	movdqa	xmm0, xmm6
	movdqa	xmm6, xmm1
	por	xmm6, xmm0
	cmp	r10d, edx
	jb	$LL10@kvz_inter_

; 1542 :     int j;
; 1543 :     int ref_negative = 0;

	movaps	xmm8, XMMWORD PTR [rsp+128]
	paddd	xmm4, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+160]
	paddd	xmm3, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+144]
	movdqa	xmm0, xmm4
	psrldq	xmm0, 8
	paddd	xmm4, xmm0
	movdqa	xmm0, xmm4
	psrldq	xmm0, 4
	paddd	xmm4, xmm0
	movdqa	xmm0, xmm3
	psrldq	xmm0, 8
	paddd	xmm3, xmm0
	movd	edx, xmm4
	movdqa	xmm0, xmm3
	psrldq	xmm0, 4
	paddd	xmm3, xmm0
	movd	r8d, xmm3
$LN180@kvz_inter_:

; 1545 :     for (j = 0; j < state->frame->ref->used_size; j++) {

	cmp	r10d, ecx
	jae	SHORT $LN9@kvz_inter_

; 1546 :       if (state->frame->ref->pocs[j] < state->frame->poc) {

	mov	r11d, DWORD PTR [r9+12]
	sub	ecx, r10d
	mov	rsi, QWORD PTR [rsi+16]
	movsxd	rax, r10d
	mov	r10d, ecx
	lea	r9, QWORD PTR [rax*4]
	npad	10
$LL177@kvz_inter_:

; 1545 :     for (j = 0; j < state->frame->ref->used_size; j++) {

	cmp	DWORD PTR [r9+rsi], r11d
	lea	eax, DWORD PTR [rdx+1]
	lea	r9, QWORD PTR [r9+4]
	cmovge	edx, eax
	lea	eax, DWORD PTR [r8+1]
	cmovge	eax, r8d
	mov	r8d, eax
	sub	r10, 1
	jne	SHORT $LL177@kvz_inter_
$LN9@kvz_inter_:

; 1550 :       }
; 1551 :     }
; 1552 :     num_ref = MIN(ref_negative, ref_positive);

	cmp	r8d, edx
	mov	ecx, edx
	cmovl	ecx, r8d
	jmp	SHORT $LN215@kvz_inter_
$LN166@kvz_inter_:

; 1553 :   }
; 1554 : 
; 1555 :   // Add (0,0) prediction
; 1556 :   while (candidates != max_num_cands) {

	je	SHORT $LN223@kvz_inter_
$LN215@kvz_inter_:
	lea	r9d, DWORD PTR [rcx-1]
	xor	r10b, r10b
$LL11@kvz_inter_:

; 1557 :     mv_cand[candidates].mv[0][0] = 0;

	movzx	eax, bl

; 1558 :     mv_cand[candidates].mv[0][1] = 0;
; 1559 :     mv_cand[candidates].ref[0] = (zero_idx >= num_ref - 1) ? 0 : zero_idx;

	mov	edx, ebp
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	r8, QWORD PTR [rdi+rcx*4]
	movsx	ecx, r10b
	mov	DWORD PTR [r8+4], 0
	cmp	ecx, r9d
	movzx	eax, cl
	cmovl	edx, eax
	mov	BYTE PTR [r8+1], dl

; 1560 :     mv_cand[candidates].ref[1] = mv_cand[candidates].ref[0];

	mov	BYTE PTR [r8+2], dl

; 1561 :     mv_cand[candidates].dir = 1;

	mov	BYTE PTR [r8], 1

; 1562 :     if (state->frame->slicetype == KVZ_SLICE_B) {

	mov	rax, QWORD PTR [r15+40]
	cmp	DWORD PTR [rax+88], 0
	jne	SHORT $LN32@kvz_inter_

; 1563 :       mv_cand[candidates].mv[1][0] = 0;

	mov	DWORD PTR [r8+8], 0

; 1564 :       mv_cand[candidates].mv[1][1] = 0;
; 1565 :       mv_cand[candidates].dir = 3;

	mov	BYTE PTR [r8], 3
$LN32@kvz_inter_:

; 1566 :     }
; 1567 :     zero_idx++;

	inc	r10b

; 1568 :     candidates++;

	inc	bl
	cmp	bl, r13b
	jne	SHORT $LL11@kvz_inter_
$LN223@kvz_inter_:

; 1569 :   }
; 1570 : 
; 1571 :   return candidates;
; 1572 : }

	movzx	eax, bl
	add	rsp, 200				; 000000c8H
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
kvz_inter_get_merge_cand ENDP
_TEXT	ENDS
END
