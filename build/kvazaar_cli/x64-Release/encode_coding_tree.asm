; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
strategies_to_select DQ FLAT:$SG4294944910
	DQ	FLAT:kvz_array_checksum
	DQ	FLAT:$SG4294944909
	DQ	FLAT:kvz_array_md5
	DQ	FLAT:$SG4294944908
	DQ	FLAT:kvz_reg_sad
	DQ	FLAT:$SG4294944907
	DQ	FLAT:kvz_sad_4x4
	DQ	FLAT:$SG4294944906
	DQ	FLAT:kvz_sad_8x8
	DQ	FLAT:$SG4294944905
	DQ	FLAT:kvz_sad_16x16
	DQ	FLAT:$SG4294944904
	DQ	FLAT:kvz_sad_32x32
	DQ	FLAT:$SG4294944903
	DQ	FLAT:kvz_sad_64x64
	DQ	FLAT:$SG4294944902
	DQ	FLAT:kvz_satd_4x4
	DQ	FLAT:$SG4294944901
	DQ	FLAT:kvz_satd_8x8
	DQ	FLAT:$SG4294944900
	DQ	FLAT:kvz_satd_16x16
	DQ	FLAT:$SG4294944899
	DQ	FLAT:kvz_satd_32x32
	DQ	FLAT:$SG4294944898
	DQ	FLAT:kvz_satd_64x64
	DQ	FLAT:$SG4294944897
	DQ	FLAT:kvz_satd_any_size
	DQ	FLAT:$SG4294944896
	DQ	FLAT:kvz_sad_4x4_dual
	DQ	FLAT:$SG4294944895
	DQ	FLAT:kvz_sad_8x8_dual
	DQ	FLAT:$SG4294944894
	DQ	FLAT:kvz_sad_16x16_dual
	DQ	FLAT:$SG4294944893
	DQ	FLAT:kvz_sad_32x32_dual
	DQ	FLAT:$SG4294944892
	DQ	FLAT:kvz_sad_64x64_dual
	DQ	FLAT:$SG4294944891
	DQ	FLAT:kvz_satd_4x4_dual
	DQ	FLAT:$SG4294944890
	DQ	FLAT:kvz_satd_8x8_dual
	DQ	FLAT:$SG4294944889
	DQ	FLAT:kvz_satd_16x16_dual
	DQ	FLAT:$SG4294944888
	DQ	FLAT:kvz_satd_32x32_dual
	DQ	FLAT:$SG4294944887
	DQ	FLAT:kvz_satd_64x64_dual
	DQ	FLAT:$SG4294944886
	DQ	FLAT:kvz_satd_any_size_quad
	DQ	FLAT:$SG4294944885
	DQ	FLAT:kvz_pixels_calc_ssd
	DQ	FLAT:$SG4294944884
	DQ	FLAT:kvz_bipred_average
	DQ	FLAT:$SG4294944883
	DQ	FLAT:kvz_get_optimized_sad
	DQ	FLAT:$SG4294944882
	DQ	FLAT:kvz_ver_sad
	DQ	FLAT:$SG4294944881
	DQ	FLAT:kvz_hor_sad
	DQ	FLAT:$SG4294944880
	DQ	FLAT:kvz_pixel_var
	DQ	FLAT:$SG4294944879
	DQ	FLAT:kvz_fast_forward_dst_4x4
	DQ	FLAT:$SG4294944878
	DQ	FLAT:kvz_dct_4x4
	DQ	FLAT:$SG4294944877
	DQ	FLAT:kvz_dct_8x8
	DQ	FLAT:$SG4294944876
	DQ	FLAT:kvz_dct_16x16
	DQ	FLAT:$SG4294944875
	DQ	FLAT:kvz_dct_32x32
	DQ	FLAT:$SG4294944874
	DQ	FLAT:kvz_fast_inverse_dst_4x4
	DQ	FLAT:$SG4294944873
	DQ	FLAT:kvz_idct_4x4
	DQ	FLAT:$SG4294944872
	DQ	FLAT:kvz_idct_8x8
	DQ	FLAT:$SG4294944871
	DQ	FLAT:kvz_idct_16x16
	DQ	FLAT:$SG4294944870
	DQ	FLAT:kvz_idct_32x32
	DQ	FLAT:$SG4294944869
	DQ	FLAT:kvz_filter_hpel_blocks_hor_ver_luma
	DQ	FLAT:$SG4294944868
	DQ	FLAT:kvz_filter_hpel_blocks_diag_luma
	DQ	FLAT:$SG4294944867
	DQ	FLAT:kvz_filter_qpel_blocks_hor_ver_luma
	DQ	FLAT:$SG4294944866
	DQ	FLAT:kvz_filter_qpel_blocks_diag_luma
	DQ	FLAT:$SG4294944865
	DQ	FLAT:kvz_sample_quarterpel_luma
	DQ	FLAT:$SG4294944864
	DQ	FLAT:kvz_sample_octpel_chroma
	DQ	FLAT:$SG4294944863
	DQ	FLAT:kvz_sample_quarterpel_luma_hi
	DQ	FLAT:$SG4294944862
	DQ	FLAT:kvz_sample_octpel_chroma_hi
	DQ	FLAT:$SG4294944861
	DQ	FLAT:kvz_get_extended_block
	DQ	FLAT:$SG4294944860
	DQ	FLAT:kvz_quant
	DQ	FLAT:$SG4294944859
	DQ	FLAT:kvz_quantize_residual
	DQ	FLAT:$SG4294944858
	DQ	FLAT:kvz_dequant
	DQ	FLAT:$SG4294944857
	DQ	FLAT:kvz_coeff_abs_sum
	DQ	FLAT:$SG4294944856
	DQ	FLAT:kvz_fast_coeff_cost
	DQ	FLAT:$SG4294944855
	DQ	FLAT:kvz_angular_pred
	DQ	FLAT:$SG4294944854
	DQ	FLAT:kvz_intra_pred_planar
	DQ	FLAT:$SG4294944853
	DQ	FLAT:kvz_intra_pred_filtered_dc
	DQ	FLAT:$SG4294944852
	DQ	FLAT:kvz_sao_edge_ddistortion
	DQ	FLAT:$SG4294944851
	DQ	FLAT:kvz_calc_sao_edge_dir
	DQ	FLAT:$SG4294944850
	DQ	FLAT:kvz_sao_reconstruct_color
	DQ	FLAT:$SG4294944849
	DQ	FLAT:kvz_sao_band_ddistortion
	DQ	FLAT:$SG4294944848
	DQ	FLAT:kvz_encode_coeff_nxn
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sao_edge_offsets DD 0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
	ORG $+3
$SG4294944860 DB 'quant', 00H
	ORG $+7
$SG4294944910 DB 'array_checksum', 00H
	ORG $+1
$SG4294944909 DB 'array_md5', 00H
	ORG $+6
$SG4294944908 DB 'reg_sad', 00H
$SG4294944907 DB 'sad_4x4', 00H
$SG4294944906 DB 'sad_8x8', 00H
$SG4294944905 DB 'sad_16x16', 00H
	ORG $+6
$SG4294944904 DB 'sad_32x32', 00H
	ORG $+6
$SG4294944903 DB 'sad_64x64', 00H
	ORG $+6
$SG4294944902 DB 'satd_4x4', 00H
	ORG $+7
$SG4294944901 DB 'satd_8x8', 00H
	ORG $+7
$SG4294944900 DB 'satd_16x16', 00H
	ORG $+5
$SG4294944899 DB 'satd_32x32', 00H
	ORG $+5
$SG4294944898 DB 'satd_64x64', 00H
	ORG $+5
$SG4294944897 DB 'satd_any_size', 00H
	ORG $+2
$SG4294944896 DB 'sad_4x4_dual', 00H
	ORG $+3
$SG4294944895 DB 'sad_8x8_dual', 00H
	ORG $+3
$SG4294944894 DB 'sad_16x16_dual', 00H
	ORG $+1
$SG4294944893 DB 'sad_32x32_dual', 00H
	ORG $+1
$SG4294944892 DB 'sad_64x64_dual', 00H
	ORG $+1
$SG4294944891 DB 'satd_4x4_dual', 00H
	ORG $+2
$SG4294944890 DB 'satd_8x8_dual', 00H
	ORG $+2
$SG4294944889 DB 'satd_16x16_dual', 00H
$SG4294944888 DB 'satd_32x32_dual', 00H
$SG4294944887 DB 'satd_64x64_dual', 00H
$SG4294944886 DB 'satd_any_size_quad', 00H
	ORG $+5
$SG4294944885 DB 'pixels_calc_ssd', 00H
$SG4294944884 DB 'bipred_average', 00H
	ORG $+1
$SG4294944883 DB 'get_optimized_sad', 00H
	ORG $+6
$SG4294944882 DB 'ver_sad', 00H
$SG4294944881 DB 'hor_sad', 00H
$SG4294944880 DB 'pixel_var', 00H
	ORG $+6
$SG4294944879 DB 'fast_forward_dst_4x4', 00H
	ORG $+3
$SG4294944878 DB 'dct_4x4', 00H
$SG4294944877 DB 'dct_8x8', 00H
$SG4294944876 DB 'dct_16x16', 00H
	ORG $+6
$SG4294944875 DB 'dct_32x32', 00H
	ORG $+6
$SG4294944874 DB 'fast_inverse_dst_4x4', 00H
	ORG $+3
$SG4294944873 DB 'idct_4x4', 00H
	ORG $+7
$SG4294944872 DB 'idct_8x8', 00H
	ORG $+7
$SG4294944871 DB 'idct_16x16', 00H
	ORG $+5
$SG4294944870 DB 'idct_32x32', 00H
	ORG $+5
$SG4294944869 DB 'filter_hpel_blocks_hor_ver_luma', 00H
$SG4294944868 DB 'filter_hpel_blocks_diag_luma', 00H
	ORG $+3
$SG4294944867 DB 'filter_qpel_blocks_hor_ver_luma', 00H
$SG4294944866 DB 'filter_qpel_blocks_diag_luma', 00H
	ORG $+3
$SG4294944865 DB 'sample_quarterpel_luma', 00H
	ORG $+1
$SG4294944864 DB 'sample_octpel_chroma', 00H
	ORG $+3
$SG4294944863 DB 'sample_quarterpel_luma_hi', 00H
	ORG $+6
$SG4294944862 DB 'sample_octpel_chroma_hi', 00H
$SG4294944861 DB 'get_extended_block', 00H
	ORG $+5
$SG4294944859 DB 'quantize_residual', 00H
	ORG $+6
$SG4294944858 DB 'dequant', 00H
$SG4294944857 DB 'coeff_abs_sum', 00H
	ORG $+2
$SG4294944856 DB 'fast_coeff_cost', 00H
$SG4294944855 DB 'angular_pred', 00H
	ORG $+3
$SG4294944854 DB 'intra_pred_planar', 00H
	ORG $+6
$SG4294944853 DB 'intra_pred_filtered_dc', 00H
	ORG $+1
$SG4294944852 DB 'sao_edge_ddistortion', 00H
	ORG $+3
$SG4294944851 DB 'calc_sao_edge_dir', 00H
	ORG $+6
$SG4294944850 DB 'sao_reconstruct_color', 00H
	ORG $+2
$SG4294944849 DB 'sao_band_ddistortion', 00H
	ORG $+3
$SG4294944848 DB 'encode_coeff_nxn', 00H
_DATA	ENDS
PUBLIC	kvz_encode_last_significant_xy
PUBLIC	kvz_encode_mvd
PUBLIC	kvz_encode_coding_tree
pdata	SEGMENT
$pdata$encode_part_mode DD imagerel encode_part_mode
	DD	imagerel encode_part_mode+273
	DD	imagerel $unwind$encode_part_mode
$pdata$encode_intra_coding_unit DD imagerel encode_intra_coding_unit
	DD	imagerel encode_intra_coding_unit+1824
	DD	imagerel $unwind$encode_intra_coding_unit
$pdata$intra_mode_encryption DD imagerel intra_mode_encryption
	DD	imagerel intra_mode_encryption+228
	DD	imagerel $unwind$intra_mode_encryption
$pdata$encode_inter_prediction_unit DD imagerel encode_inter_prediction_unit
	DD	imagerel encode_inter_prediction_unit+204
	DD	imagerel $unwind$encode_inter_prediction_unit
$pdata$1$encode_inter_prediction_unit DD imagerel encode_inter_prediction_unit+204
	DD	imagerel encode_inter_prediction_unit+737
	DD	imagerel $chain$1$encode_inter_prediction_unit
$pdata$2$encode_inter_prediction_unit DD imagerel encode_inter_prediction_unit+737
	DD	imagerel encode_inter_prediction_unit+750
	DD	imagerel $chain$2$encode_inter_prediction_unit
$pdata$encode_transform_coeff DD imagerel encode_transform_coeff
	DD	imagerel encode_transform_coeff+1002
	DD	imagerel $unwind$encode_transform_coeff
$pdata$encode_transform_unit DD imagerel encode_transform_unit
	DD	imagerel encode_transform_unit+1092
	DD	imagerel $unwind$encode_transform_unit
$pdata$kvz_math_floor_log2 DD imagerel kvz_math_floor_log2
	DD	imagerel kvz_math_floor_log2+142
	DD	imagerel $unwind$kvz_math_floor_log2
$pdata$is_last_cu_in_qg DD imagerel is_last_cu_in_qg
	DD	imagerel is_last_cu_in_qg+118
	DD	imagerel $unwind$is_last_cu_in_qg
$pdata$xy_to_zorder DD imagerel xy_to_zorder
	DD	imagerel xy_to_zorder+259
	DD	imagerel $unwind$xy_to_zorder
$pdata$kvz_encode_last_significant_xy DD imagerel $LN62
	DD	imagerel $LN62+995
	DD	imagerel $unwind$kvz_encode_last_significant_xy
$pdata$kvz_encode_mvd DD imagerel $LN22
	DD	imagerel $LN22+327
	DD	imagerel $unwind$kvz_encode_mvd
$pdata$kvz_encode_coding_tree DD imagerel $LN334
	DD	imagerel $LN334+1916
	DD	imagerel $unwind$kvz_encode_coding_tree
xdata	SEGMENT
$unwind$encode_part_mode DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
$unwind$encode_intra_coding_unit DD 0a2c01H
	DD	015012cH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
$unwind$intra_mode_encryption DD 020901H
	DD	050027209H
$unwind$encode_inter_prediction_unit DD 071101H
	DD	0f00d8211H
	DD	07009d00bH
	DD	050076008H
	DD	03006H
$chain$1$encode_inter_prediction_unit DD 047021H
	DD	011c470H
	DD	08e405H
	DD	imagerel encode_inter_prediction_unit
	DD	imagerel encode_inter_prediction_unit+204
	DD	imagerel $unwind$encode_inter_prediction_unit
$chain$2$encode_inter_prediction_unit DD 021H
	DD	imagerel encode_inter_prediction_unit
	DD	imagerel encode_inter_prediction_unit+204
	DD	imagerel $unwind$encode_inter_prediction_unit
$unwind$encode_transform_coeff DD 091e01H
	DD	0f01ac21eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
	DD	0300fH
$unwind$encode_transform_unit DD 0a4d01H
	DD	013c44dH
	DD	0f00b920fH
	DD	0d007e009H
	DD	060047005H
	DD	030025003H
$unwind$kvz_math_floor_log2 DD 020601H
	DD	030023206H
$unwind$is_last_cu_in_qg DD 020501H
	DD	013405H
$unwind$xy_to_zorder DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$kvz_encode_last_significant_xy DD 0c2101H
	DD	0106421H
	DD	0f5421H
	DD	0e3421H
	DD	0f01d7221H
	DD	0d019e01bH
	DD	07015c017H
$unwind$kvz_encode_mvd DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$kvz_encode_coding_tree DD 0a2301H
	DD	0130123H
	DD	0e01af01cH
	DD	0c016d018H
	DD	060137014H
	DD	030115012H
	ORG $+2
$SG4294944835 DB '0', 00H, 00H, 00H
	ORG $+6
$SG4294944837 DB 'p', 00H, 'r', 00H, 'e', 00H, 'd', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, '5', 00H, 00H, 00H
	ORG $+2
$SG4294944913 DB 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+6
$SG4294944839 DB 'p', 00H, 'u', 00H, '_', 00H, 'y', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, ' ', 00H, '2', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H
	ORG $+12
$SG4294944836 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+14
$SG4294944838 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+14
$SG4294944840 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+6
$SG4294944841 DB 'p', 00H, 'u', 00H, '_', 00H, 'x', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, ' ', 00H, '2', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H
	ORG $+12
$SG4294944842 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+14
$SG4294944843 DB 'q', 00H, 'p', 00H, '_', 00H, 'd', 00H, 'e', 00H, 'l', 00H
	DB	't', 00H, 'a', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'K'
	DB	00H, 'V', 00H, 'Z', 00H, '_', 00H, 'Q', 00H, 'P', 00H, '_', 00H
	DB	'D', 00H, 'E', 00H, 'L', 00H, 'T', 00H, 'A', 00H, '_', 00H, 'M'
	DB	00H, 'I', 00H, 'N', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'q', 00H, 'p', 00H, '_', 00H, 'd', 00H, 'e', 00H, 'l', 00H, 't'
	DB	00H, 'a', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'K', 00H
	DB	'V', 00H, 'Z', 00H, '_', 00H, 'Q', 00H, 'P', 00H, '_', 00H, 'D'
	DB	00H, 'E', 00H, 'L', 00H, 'T', 00H, 'A', 00H, '_', 00H, 'M', 00H
	DB	'A', 00H, 'X', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"'
	DB	00H, 'Q', 00H, 'P', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'l', 00H
	DB	't', 00H, 'a', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g'
	DB	00H, 'e', 00H, '.', 00H, '"', 00H, 00H, 00H
	ORG $+2
$SG4294944844 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+14
$SG4294944846 DB 'd', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'd', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'M', 00H, 'A', 00H, 'X'
	DB	00H, '_', 00H, 'P', 00H, 'U', 00H, '_', 00H, 'D', 00H, 'E', 00H
	DB	'P', 00H, 'T', 00H, 'H', 00H, 00H, 00H
	ORG $+8
$SG4294944847 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+14
$SG4294944914 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'k', 00H
	DB	'v', 00H, 'z', 00H, '_', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'h'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG4294944915 DB 'y', 00H, ' ', 00H, '%', 00H, ' ', 00H, '4', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'y', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG4294944916 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'c', 00H
	DB	'u', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+6
$SG4294944917 DB 'x', 00H, ' ', 00H, '%', 00H, ' ', 00H, '4', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
	ORG $+8
$SG4294944918 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'c', 00H
	DB	'u', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+14
$SG4294944919 DB 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'%', 00H, ' ', 00H, '4', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '4', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '6', 00H, '4', 00H, 00H, 00H
	ORG $+8
$SG4294944920 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'c', 00H
	DB	'u', 00H, '.', 00H, 'h', 00H, 00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
tv1893 = 64
tv1889 = 68
tv1875 = 68
tv1880 = 72
tv1891 = 76
tv1888 = 80
tv1890 = 84
tv1887 = 88
cu_width$1$ = 92
cur_cu$1$ = 96
tv1886 = 104
left_cu$1$ = 104
$T1 = 112
above_cu$1$ = 112
ctrl$1$ = 120
frame$1$ = 128
tv1873 = 224
$T2 = 224
state$ = 224
x$ = 232
y$ = 240
depth$ = 248
kvz_encode_coding_tree PROC

; 729  : {

$LN334:
	mov	BYTE PTR [rsp+32], r9b
	mov	WORD PTR [rsp+24], r8w
	mov	WORD PTR [rsp+16], dx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 152				; 00000098H
	movzx	r15d, r9b
	lea	rbx, QWORD PTR [rcx+128]
	movzx	r13d, r8w
	movzx	ebp, dx
	mov	r12, rcx
	npad	8
$LL283@kvz_encode:

; 730  :   cabac_data_t * const cabac = &state->cabac;
; 731  :   const encoder_control_t * const ctrl = state->encoder_control;

	mov	rax, QWORD PTR [r12]
	mov	QWORD PTR ctrl$1$[rsp], rax

; 732  :   const videoframe_t * const frame = state->tile->frame;

	mov	rax, QWORD PTR [r12+48]

; 733  :   const cu_info_t *cur_cu   = kvz_cu_array_at_const(frame->cu_array, x, y);

	movzx	r14d, r13w
	movzx	edx, bp
	mov	r8d, r14d
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR frame$1$[rsp], rcx
	mov	rcx, QWORD PTR [rcx+32]
	call	kvz_cu_array_at_const
	mov	rsi, rax
	mov	QWORD PTR cur_cu$1$[rsp], rax

; 734  : 
; 735  :   const int cu_width = LCU_WIDTH >> depth;

	movzx	ecx, r15b
	mov	eax, 64					; 00000040H
	sar	eax, cl

; 736  :   const int half_cu  = cu_width >> 1;

	mov	edi, eax
	mov	DWORD PTR tv1893[rsp], ecx
	sar	edi, 1
	mov	DWORD PTR cu_width$1$[rsp], eax

; 737  : 
; 738  :   const cu_info_t *left_cu  = NULL;

	mov	QWORD PTR left_cu$1$[rsp], 0

; 739  :   if (x > 0) {

	test	bp, bp
	je	SHORT $LN8@kvz_encode

; 740  :     left_cu = kvz_cu_array_at_const(frame->cu_array, x - 1, y);

	mov	rcx, QWORD PTR frame$1$[rsp]
	mov	r8d, r14d
	movzx	edx, bp
	dec	edx
	mov	rcx, QWORD PTR [rcx+32]
	call	kvz_cu_array_at_const
	mov	QWORD PTR left_cu$1$[rsp], rax
$LN8@kvz_encode:

; 741  :   }
; 742  :   const cu_info_t *above_cu = NULL;

	xor	r11d, r11d
	mov	QWORD PTR above_cu$1$[rsp], r11

; 743  :   if (y > 0) {

	test	r13w, r13w
	je	SHORT $LN9@kvz_encode

; 744  :     above_cu = kvz_cu_array_at_const(frame->cu_array, x, y - 1);

	mov	rax, QWORD PTR frame$1$[rsp]
	lea	r8d, DWORD PTR [r14-1]
	movzx	edx, bp
	mov	rcx, QWORD PTR [rax+32]
	call	kvz_cu_array_at_const
	mov	r11, rax
	mov	QWORD PTR above_cu$1$[rsp], rax
$LN9@kvz_encode:

; 745  :   }
; 746  : 
; 747  :   uint8_t split_flag = GET_SPLITDATA(cur_cu, depth);
; 748  :   uint8_t split_model = 0;
; 749  : 
; 750  :   // Absolute coordinates
; 751  :   uint16_t abs_x = x + state->tile->offset_x;

	mov	rdx, QWORD PTR [r12+48]
	xor	r9b, r9b

; 752  :   uint16_t abs_y = y + state->tile->offset_y;
; 753  : 
; 754  :   // Check for slice border
; 755  :   bool border_x = ctrl->in.width  < abs_x + cu_width;

	mov	r10d, DWORD PTR cu_width$1$[rsp]
	movzx	r14d, BYTE PTR [rsi]
	shr	r14b, 2
	movzx	ecx, WORD PTR [rdx+20]
	and	r14b, 7
	add	cx, bp
	movzx	r8d, cx
	lea	eax, DWORD PTR [r8+r10]

; 756  :   bool border_y = ctrl->in.height < abs_y + cu_width;
; 757  :   bool border_split_x = ctrl->in.width  >= abs_x + (LCU_WIDTH >> MAX_DEPTH) + half_cu;

	add	r8d, 8
	mov	DWORD PTR tv1891[rsp], eax
	add	r8d, edi
	mov	rax, QWORD PTR ctrl$1$[rsp]
	mov	DWORD PTR tv1888[rsp], r8d
	mov	eax, DWORD PTR [rax+2528]
	mov	DWORD PTR tv1880[rsp], eax
	movzx	eax, WORD PTR [rdx+24]
	mov	rdx, QWORD PTR ctrl$1$[rsp]
	add	ax, r13w
	movzx	ecx, ax
	add	r10d, ecx
	mov	DWORD PTR tv1889[rsp], r10d
	mov	eax, DWORD PTR [rdx+2532]

; 758  :   bool border_split_y = ctrl->in.height >= abs_y + (LCU_WIDTH >> MAX_DEPTH) + half_cu;

	lea	r8d, DWORD PTR [rcx+8]
	mov	DWORD PTR tv1890[rsp], eax

; 759  :   bool border = border_x || border_y; /*!< are we in any border CU */

	mov	ecx, DWORD PTR tv1891[rsp]
	add	r8d, edi
	mov	DWORD PTR tv1887[rsp], r8d
	cmp	DWORD PTR tv1880[rsp], ecx
	jl	SHORT $LN42@kvz_encode
	cmp	eax, r10d
	jl	SHORT $LN42@kvz_encode
	xor	cl, cl
	jmp	SHORT $LN328@kvz_encode
$LN42@kvz_encode:
	mov	cl, 1
$LN328@kvz_encode:

; 760  : 
; 761  :   if (depth <= ctrl->max_qp_delta_depth) {

	movsx	eax, BYTE PTR [rdx+6520]
	movzx	r8d, r15b
	mov	BYTE PTR $T2[rsp], cl
	cmp	r8d, eax
	jg	SHORT $LN10@kvz_encode

; 762  :     state->must_code_qp_delta = true;

	mov	BYTE PTR [r12+385], 1
$LN10@kvz_encode:

; 763  :   }
; 764  : 
; 765  :   // When not in MAX_DEPTH, insert split flag and split the blocks if needed
; 766  :   if (depth != MAX_DEPTH) {

	cmp	r15b, 3
	je	$LN15@kvz_encode

; 767  :     // Implisit split flag when on border
; 768  :     if (!border) {

	test	cl, cl
	jne	SHORT $LN12@kvz_encode

; 769  :       // Get left and top block split_flags and if they are present and true, increase model number
; 770  :       if (left_cu && GET_SPLITDATA(left_cu, depth) == 1) {

	mov	rax, QWORD PTR left_cu$1$[rsp]
	test	rax, rax
	je	SHORT $LN13@kvz_encode
	movzx	eax, BYTE PTR [rax]
	shr	al, 2
	and	al, 7
	movzx	r9d, r9b
	cmp	al, r15b
	mov	eax, 1
	cmova	r9d, eax
$LN13@kvz_encode:

; 771  :         split_model++;
; 772  :       }
; 773  : 
; 774  :       if (above_cu && GET_SPLITDATA(above_cu, depth) == 1) {

	test	r11, r11
	je	SHORT $LN14@kvz_encode
	movzx	eax, BYTE PTR [r11]
	shr	al, 2
	and	al, 7
	cmp	al, r15b
	jbe	SHORT $LN14@kvz_encode

; 775  :         split_model++;

	inc	r9b
$LN14@kvz_encode:

; 776  :       }
; 777  : 
; 778  :       cabac->cur_ctx = &(cabac->ctx.split_flag_model[split_model]);
; 779  :       CABAC_BIN(cabac, split_flag, "SplitFlag");

	xor	edx, edx
	movzx	eax, r9b
	lea	rcx, QWORD PTR [rbx+42]
	add	rcx, rax
	cmp	r14b, r15b
	mov	QWORD PTR [rbx], rcx
	mov	rcx, rbx
	seta	dl
	call	kvz_cabac_encode_bin
	movzx	ecx, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR ctrl$1$[rsp]
$LN12@kvz_encode:

; 780  :     }
; 781  : 
; 782  :     if (split_flag || border) {

	cmp	r14b, r15b
	ja	SHORT $LN16@kvz_encode
	test	cl, cl
	je	$LN15@kvz_encode
$LN16@kvz_encode:

; 783  :       // Split blocks and remember to change x and y block positions
; 784  :       kvz_encode_coding_tree(state, x, y, depth + 1);

	inc	r15b
	movzx	r8d, r13w
	movzx	r9d, r15b
	mov	BYTE PTR depth$[rsp], r15b
	movzx	edx, bp
	mov	rcx, r12
	call	kvz_encode_coding_tree

; 785  : 
; 786  :       if (!border_x || border_split_x) {

	mov	esi, DWORD PTR tv1880[rsp]
	mov	r14d, DWORD PTR tv1888[rsp]
	cmp	esi, DWORD PTR tv1891[rsp]
	jge	SHORT $LN18@kvz_encode
	cmp	esi, r14d
	jl	SHORT $LN17@kvz_encode
$LN18@kvz_encode:

; 787  :         kvz_encode_coding_tree(state, x + half_cu, y, depth + 1);

	lea	edx, DWORD PTR [rdi+rbp]
	movzx	r9d, r15b
	movzx	r8d, r13w
	mov	rcx, r12
	call	kvz_encode_coding_tree
$LN17@kvz_encode:

; 788  :       }
; 789  :       if (!border_y || border_split_y) {

	mov	eax, DWORD PTR tv1890[rsp]
	cmp	eax, DWORD PTR tv1889[rsp]
	jge	SHORT $LN20@kvz_encode
	mov	ecx, DWORD PTR tv1887[rsp]
	cmp	eax, ecx
	jl	SHORT $LN311@kvz_encode
$LN20@kvz_encode:

; 790  :         kvz_encode_coding_tree(state, x, y + half_cu, depth + 1);

	lea	r8d, DWORD PTR [rdi+r13]
	movzx	r9d, r15b
	movzx	edx, bp
	mov	rcx, r12
	call	kvz_encode_coding_tree
	mov	eax, DWORD PTR tv1890[rsp]
	mov	ecx, DWORD PTR tv1887[rsp]
$LN311@kvz_encode:

; 791  :       }
; 792  :       if (!border || (border_split_x && border_split_y)) {

	cmp	BYTE PTR $T2[rsp], 0
	je	SHORT $LN22@kvz_encode
	cmp	esi, r14d
	jl	$LN40@kvz_encode
	cmp	eax, ecx
	jl	$LN40@kvz_encode
$LN22@kvz_encode:

; 793  :         kvz_encode_coding_tree(state, x + half_cu, y + half_cu, depth + 1);

	add	r13w, di
	add	bp, di
	mov	WORD PTR y$[rsp], r13w
	mov	WORD PTR x$[rsp], bp
	jmp	$LL283@kvz_encode
$LN15@kvz_encode:

; 794  :       }
; 795  :       return;
; 796  :     }
; 797  :   }
; 798  : 
; 799  :   if (ctrl->cfg.lossless) {

	cmp	DWORD PTR [rdx+2392], 0
	mov	r14d, 1
	je	SHORT $LN23@kvz_encode

; 800  :     cabac->cur_ctx = &cabac->ctx.cu_transquant_bypass;

	lea	rax, QWORD PTR [rbx+214]

; 801  :     CABAC_BIN(cabac, 1, "cu_transquant_bypass_flag");

	mov	edx, r14d
	mov	rcx, rbx
	mov	QWORD PTR [rbx], rax
	call	kvz_cabac_encode_bin
$LN23@kvz_encode:

; 802  :   }
; 803  : 
; 804  :   // Encode skip flag
; 805  :   if (state->frame->slicetype != KVZ_SLICE_I) {

	mov	rax, QWORD PTR [r12+40]
	cmp	DWORD PTR [rax+88], 2
	je	$LN313@kvz_encode

; 806  :     // uiCtxSkip = aboveskipped + leftskipped;
; 807  :     int8_t ctx_skip = 0;
; 808  : 
; 809  :     if (left_cu && left_cu->skipped) {

	mov	rax, QWORD PTR left_cu$1$[rsp]
	xor	cl, cl
	test	rax, rax
	je	SHORT $LN25@kvz_encode
	test	BYTE PTR [rax+1], 8
	movzx	ecx, cl
	cmovne	ecx, r14d
$LN25@kvz_encode:

; 810  :       ctx_skip++;
; 811  :     }
; 812  :     if (above_cu && above_cu->skipped) {

	mov	rax, QWORD PTR above_cu$1$[rsp]
	test	rax, rax
	je	SHORT $LN26@kvz_encode
	test	BYTE PTR [rax+1], 8
	je	SHORT $LN26@kvz_encode

; 813  :       ctx_skip++;

	inc	cl
$LN26@kvz_encode:

; 814  :     }
; 815  : 
; 816  :     cabac->cur_ctx = &(cabac->ctx.cu_skip_flag_model[ctx_skip]);

	movzx	eax, cl
	lea	rcx, QWORD PTR [rbx+209]
	add	rcx, rax
	mov	QWORD PTR [rbx], rcx

; 817  :     CABAC_BIN(cabac, cur_cu->skipped, "SkipFlag");

	mov	rcx, rbx
	movzx	edx, BYTE PTR [rsi+1]
	shr	edx, 3
	and	edx, 1
	call	kvz_cabac_encode_bin

; 818  : 
; 819  :     if (cur_cu->skipped) {

	test	BYTE PTR [rsi+1], 8
	je	$LN313@kvz_encode

; 820  :       int16_t num_cand = state->encoder_control->cfg.max_merge;

	mov	rax, QWORD PTR [r12]
	movzx	ecx, BYTE PTR [rax+2473]

; 821  :       if (num_cand > 1) {

	cmp	cl, 1
	jbe	SHORT $LN322@kvz_encode

; 822  :         for (int ui = 0; ui < num_cand - 1; ui++) {

	xor	edi, edi
	lea	r14d, DWORD PTR [rcx-1]
	test	r14d, r14d
	jle	SHORT $LN322@kvz_encode
	npad	6
$LL4@kvz_encode:

; 823  :           int32_t symbol = (ui != cur_cu->merge_idx);

	movzx	esi, BYTE PTR [rsi+1]
	shr	esi, 5

; 824  :           if (ui == 0) {

	test	edi, edi
	jne	SHORT $LN29@kvz_encode

; 825  :             cabac->cur_ctx = &(cabac->ctx.cu_merge_idx_ext_model);

	xor	edx, edx
	lea	rax, QWORD PTR [rbx+212]
	test	esi, esi
	mov	QWORD PTR [rbx], rax

; 826  :             CABAC_BIN(cabac, symbol, "MergeIndex");

	mov	rcx, rbx
	setne	dl
	call	kvz_cabac_encode_bin

; 827  :           } else {

	jmp	SHORT $LN235@kvz_encode
$LN29@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+8], ecx

; 231  :   if (bin_value) {

	cmp	edi, esi
	je	SHORT $LN312@kvz_encode

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rbx+8], ecx
$LN312@kvz_encode:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+24]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN235@kvz_encode

; 237  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
$LN235@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 830  :           if (symbol == 0) {

	cmp	edi, esi
	mov	rsi, QWORD PTR cur_cu$1$[rsp]
	je	SHORT $LN322@kvz_encode

; 822  :         for (int ui = 0; ui < num_cand - 1; ui++) {

	inc	edi
	cmp	edi, r14d
	jl	SHORT $LL4@kvz_encode
$LN322@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h

; 383  :   if (state->encoder_control->max_qp_delta_depth < 0) return false;

	mov	r14d, DWORD PTR tv1893[rsp]
$end$335:
	mov	rax, QWORD PTR [r12]
	movzx	edx, BYTE PTR [rax+6520]
	test	dl, dl
	js	SHORT $LN40@kvz_encode

; 385  :   const int cu_width = LCU_WIDTH >> depth;

	mov	r10d, 64				; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 923  :   if (is_last_cu_in_qg(state, x, y, depth)) {

	movzx	r9d, bp
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h

; 385  :   const int cu_width = LCU_WIDTH >> depth;

	mov	eax, r10d
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 923  :   if (is_last_cu_in_qg(state, x, y, depth)) {

	movzx	r8d, r13w
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h

; 385  :   const int cu_width = LCU_WIDTH >> depth;

	mov	ecx, r14d
	sar	eax, cl

; 386  :   const int qg_width = LCU_WIDTH >> state->encoder_control->max_qp_delta_depth;

	movzx	ecx, dl

; 387  :   const int right  = x + cu_width;

	add	r9d, eax
	sar	r10d, cl

; 388  :   const int bottom = y + cu_width;

	add	r8d, eax

; 389  :   return (right % qg_width == 0 || right >= state->tile->frame->width) &&

	mov	eax, r9d
	cdq
	idiv	r10d
	test	edx, edx
	je	SHORT $LN315@kvz_encode
	mov	rax, QWORD PTR [r12+48]
	mov	rcx, QWORD PTR [rax]
	cmp	r9d, DWORD PTR [rcx+16]
	jl	SHORT $LN40@kvz_encode
$LN315@kvz_encode:
	mov	eax, r8d
	cdq
	idiv	r10d
	test	edx, edx
	je	SHORT $LN280@kvz_encode
	mov	rax, QWORD PTR [r12+48]
	mov	rcx, QWORD PTR [rax]
	cmp	r8d, DWORD PTR [rcx+20]
	jl	SHORT $LN40@kvz_encode
$LN280@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 924  :     state->last_qp = cur_cu->qp;

	movzx	eax, BYTE PTR [rsi+6]
	mov	BYTE PTR [r12+386], al
$LN40@kvz_encode:

; 925  :   }
; 926  : }

	add	rsp, 152				; 00000098H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN313@kvz_encode:

; 831  :             break;
; 832  :           }
; 833  :         }
; 834  :       }
; 835  :       goto end;
; 836  :     }
; 837  :   }
; 838  : 
; 839  :   // Prediction mode
; 840  :   if (state->frame->slicetype != KVZ_SLICE_I) {

	mov	rax, QWORD PTR [r12+40]
	xor	edi, edi
	cmp	DWORD PTR [rax+88], 2
	je	SHORT $LN32@kvz_encode

; 841  :     cabac->cur_ctx = &(cabac->ctx.cu_pred_mode_model);

	lea	rax, QWORD PTR [rbx+208]

; 842  :     CABAC_BIN(cabac, (cur_cu->type == CU_INTRA), "PredMode");

	mov	edx, edi
	mov	QWORD PTR [rbx], rax
	mov	rcx, rbx
	movzx	eax, BYTE PTR [rsi]
	and	al, 3
	cmp	al, 1
	sete	dl
	call	kvz_cabac_encode_bin
$LN32@kvz_encode:

; 678  :   if (cur_cu->type == CU_INTRA) {

	movzx	eax, BYTE PTR [rsi]
	and	al, 3
	cmp	al, 1
	jne	SHORT $LN238@kvz_encode

; 679  :     if (depth == MAX_DEPTH) {

	movzx	r14d, r15b
	cmp	r14d, 3
	jne	$LN264@kvz_encode

; 680  :       cabac->cur_ctx = &(cabac->ctx.part_size_model[0]);

	lea	rax, QWORD PTR [rbx+68]

; 681  :       if (cur_cu->part_size == SIZE_2Nx2N) {

	mov	rcx, rbx
	mov	QWORD PTR [rbx], rax
	cmp	BYTE PTR [rsi], 32			; 00000020H
	jb	$LN331@kvz_encode

; 682  :         CABAC_BIN(cabac, 1, "part_mode 2Nx2N");
; 683  :       } else {
; 684  :         CABAC_BIN(cabac, 0, "part_mode NxN");

	xor	edx, edx

; 685  :       }
; 686  :     }
; 687  :   } else {

	jmp	$LN332@kvz_encode
$LN238@kvz_encode:

; 688  : 
; 689  :     cabac->cur_ctx = &(cabac->ctx.part_size_model[0]);

	lea	rax, QWORD PTR [rbx+68]
	mov	QWORD PTR [rbx], rax

; 690  :     if (cur_cu->part_size == SIZE_2Nx2N) {

	cmp	BYTE PTR [rsi], 32			; 00000020H
	jb	$LN324@kvz_encode

; 691  :       CABAC_BIN(cabac, 1, "part_mode 2Nx2N");
; 692  :       return;
; 693  :     }
; 694  :     CABAC_BIN(cabac, 0, "part_mode split");

	xor	edx, edx
	mov	rcx, rbx
	call	kvz_cabac_encode_bin

; 695  : 
; 696  :     cabac->cur_ctx = &(cabac->ctx.part_size_model[1]);

	lea	rax, QWORD PTR [rbx+69]
	mov	QWORD PTR [rbx], rax

; 697  :     if (cur_cu->part_size == SIZE_2NxN ||
; 698  :         cur_cu->part_size == SIZE_2NxnU ||

	movzx	eax, BYTE PTR [rsi]
	shr	al, 5
	cmp	al, 1
	je	SHORT $LN246@kvz_encode
	sub	al, 4

; 701  :     } else {
; 702  :       CABAC_BIN(cabac, 0, "part_mode horizontal");

	mov	edx, edi
	cmp	al, 1
	ja	SHORT $LN245@kvz_encode
$LN246@kvz_encode:

; 699  :         cur_cu->part_size == SIZE_2NxnD) {
; 700  :       CABAC_BIN(cabac, 1, "part_mode vertical");

	mov	edx, r14d
$LN245@kvz_encode:

; 703  :     }
; 704  : 
; 705  :     if (state->encoder_control->cfg.amp_enable && depth < MAX_DEPTH) {

	mov	rcx, rbx
	call	kvz_cabac_encode_bin
	mov	rax, QWORD PTR [r12]
	movzx	r14d, r15b
	cmp	DWORD PTR [rax+60], 0
	je	SHORT $LN264@kvz_encode
	cmp	r14d, 3
	jae	SHORT $LN264@kvz_encode

; 706  :       cabac->cur_ctx = &(cabac->ctx.part_size_model[3]);

	lea	rax, QWORD PTR [rbx+71]
	mov	QWORD PTR [rbx], rax

; 707  : 
; 708  :       if (cur_cu->part_size == SIZE_2NxN ||

	movzx	eax, BYTE PTR [rsi]
	shr	al, 5
	dec	al
	cmp	al, 1
	jbe	SHORT $LN249@kvz_encode

; 711  :         return;
; 712  :       }
; 713  :       CABAC_BIN(cabac, 0, "part_mode AMP");

	xor	edx, edx
	mov	rcx, rbx
	call	kvz_cabac_encode_bin

; 714  : 
; 715  :       if (cur_cu->part_size == SIZE_2NxnU ||

	movzx	eax, BYTE PTR [rsi]
	dec	DWORD PTR [rbx+24]
	shr	al, 5
	sub	al, 4
	test	al, 253					; 000000fdH
	je	SHORT $LN252@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 261  :   data->low <<= num_bins;

	mov	ecx, DWORD PTR [rbx+8]

; 262  :   data->low += data->range * bin_values;

	mov	eax, DWORD PTR [rbx+12]
	lea	ecx, DWORD PTR [rax+rcx*2]
	mov	DWORD PTR [rbx+8], ecx

; 263  :   data->bits_left -= num_bins;
; 264  : 
; 265  :   if (data->bits_left < 12) {
; 266  :     kvz_cabac_write(data);

	jmp	SHORT $LN329@kvz_encode
$LN252@kvz_encode:

; 262  :   data->low += data->range * bin_values;

	shl	DWORD PTR [rbx+8], 1
$LN329@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 848  :   if (cur_cu->type == CU_INTER) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN264@kvz_encode
	mov	rcx, rbx
	call	kvz_cabac_write
	jmp	SHORT $LN264@kvz_encode
$LN324@kvz_encode:

; 690  :     if (cur_cu->part_size == SIZE_2Nx2N) {

	movzx	r14d, r15b
$LN249@kvz_encode:

; 709  :           cur_cu->part_size == SIZE_Nx2N) {
; 710  :         CABAC_BIN(cabac, 1, "part_mode SMP");

	mov	rcx, rbx
$LN331@kvz_encode:

; 848  :   if (cur_cu->type == CU_INTER) {

	mov	edx, 1
$LN332@kvz_encode:
	call	kvz_cabac_encode_bin
$LN264@kvz_encode:
	movzx	edx, BYTE PTR [rsi]
	movzx	eax, dl
	and	al, 3
	cmp	al, 2
	jne	$LN33@kvz_encode

; 849  :     const int num_pu = kvz_part_mode_num_parts[cur_cu->part_size];

	mov	eax, edx
	lea	r10, OFFSET FLAT:__ImageBase
	shr	rax, 5

; 850  : 
; 851  :     for (int i = 0; i < num_pu; ++i) {

	movzx	eax, BYTE PTR kvz_part_mode_num_parts[rax+r10]
	mov	QWORD PTR tv1886[rsp], rax
	test	rax, rax
	je	$LN6@kvz_encode
	mov	r15d, DWORD PTR cu_width$1$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 232  :     data->low += data->range;

	mov	rcx, rdi
	movzx	r9d, r13w
	mov	r13, QWORD PTR frame$1$[rsp]
	movzx	r8d, bp
	mov	QWORD PTR $T1[rsp], rcx
	mov	DWORD PTR tv1873[rsp], r8d
	mov	DWORD PTR tv1875[rsp], r9d
	npad	4
$LL7@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 852  :       const int pu_x = PU_GET_X(cur_cu->part_size, cu_width, x, i);

	movzx	eax, BYTE PTR [rsi]
	shr	rax, 5
	lea	rax, QWORD PTR [rcx+rax*4]
	lea	rcx, QWORD PTR [rax+rax]
	movzx	eax, BYTE PTR kvz_part_mode_offsets[rcx+r10]
	imul	eax, r15d
	cdq
	and	edx, 3
	lea	r14d, DWORD PTR [rdx+rax]

; 853  :       const int pu_y = PU_GET_Y(cur_cu->part_size, cu_width, y, i);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[rcx+r10+1]
	imul	eax, r15d
	sar	r14d, 2
	add	r14d, r8d
	cdq
	and	edx, 3
	lea	ebp, DWORD PTR [rdx+rax]

; 854  :       const int pu_w = PU_GET_W(cur_cu->part_size, cu_width, i);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[rcx+r10]
	imul	eax, r15d
	sar	ebp, 2
	add	ebp, r9d

; 855  :       const int pu_h = PU_GET_H(cur_cu->part_size, cu_width, i);
; 856  :       const cu_info_t *cur_pu = kvz_cu_array_at_const(frame->cu_array, pu_x, pu_y);

	mov	r8d, ebp
	cdq
	and	edx, 3
	lea	esi, DWORD PTR [rdx+rax]
	movzx	eax, BYTE PTR kvz_part_mode_sizes[rcx+r10+1]
	mov	rcx, QWORD PTR [r13+32]
	imul	eax, r15d
	sar	esi, 2
	cdq
	and	edx, 3
	lea	edi, DWORD PTR [rdx+rax]
	mov	edx, r14d
	sar	edi, 2
	call	kvz_cu_array_at_const

; 857  : 
; 858  :       encode_inter_prediction_unit(state, cabac, cur_pu, pu_x, pu_y, pu_w, pu_h, depth);

	mov	ecx, DWORD PTR tv1893[rsp]
	mov	r9d, r14d
	mov	DWORD PTR [rsp+56], ecx
	mov	r8, rax
	mov	DWORD PTR [rsp+48], edi
	mov	rdx, rbx
	mov	DWORD PTR [rsp+40], esi
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], ebp
	call	encode_inter_prediction_unit
	mov	rcx, QWORD PTR $T1[rsp]
	lea	r10, OFFSET FLAT:__ImageBase
	mov	rsi, QWORD PTR cur_cu$1$[rsp]
	inc	rcx
	mov	r8d, DWORD PTR tv1873[rsp]
	mov	r9d, DWORD PTR tv1875[rsp]
	mov	QWORD PTR $T1[rsp], rcx
	cmp	rcx, QWORD PTR tv1886[rsp]
	jl	$LL7@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 232  :     data->low += data->range;

	movzx	edx, BYTE PTR [rsi]
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	r15d, BYTE PTR depth$[rsp]
	movzx	r13d, WORD PTR y$[rsp]
	movzx	ebp, WORD PTR x$[rsp]
	mov	r14d, DWORD PTR tv1893[rsp]
$LN6@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 862  :       int cbf = cbf_is_set_any(cur_cu->cbf, depth);

	movzx	r8d, WORD PTR [rsi+4]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, r14d
	movzx	ecx, WORD PTR cbf_masks[r10+rax*2]
	test	cx, r8w

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN268@kvz_encode

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, ecx
	shl	ecx, 5
	or	ecx, eax
	shl	ecx, 5
	test	ecx, r8d

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN268@kvz_encode
	xor	edi, edi
	jmp	SHORT $LN269@kvz_encode
$LN268@kvz_encode:
	mov	edi, 1
$LN269@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 865  :       if (cur_cu->part_size != SIZE_2Nx2N || !cur_cu->merged) {

	cmp	dl, 32					; 00000020H
	jae	SHORT $LN36@kvz_encode
	test	BYTE PTR [rsi+1], 16
	jne	SHORT $LN35@kvz_encode
$LN36@kvz_encode:

; 866  :         cabac->cur_ctx = &(cabac->ctx.cu_qt_root_cbf_model);

	lea	rax, QWORD PTR [rbx+221]

; 867  :         CABAC_BIN(cabac, cbf, "rqt_root_cbf");

	mov	edx, edi
	mov	rcx, rbx
	mov	QWORD PTR [rbx], rax
	call	kvz_cabac_encode_bin
$LN35@kvz_encode:

; 868  :       }
; 869  :       // Code (possible) coeffs to bitstream
; 870  : 
; 871  :       if (cbf) {

	test	edi, edi
	je	$end$335

; 872  :         encode_transform_coeff(state, x, y, depth, 0, 0, 0);

	mov	BYTE PTR [rsp+48], 0
	movzx	r9d, r15b
	mov	BYTE PTR [rsp+40], 0
	mov	rcx, r12
	movzx	r8d, r13w
	movzx	edx, bp
	mov	BYTE PTR [rsp+32], 0
	call	encode_transform_coeff
	jmp	$end$335
$LN33@kvz_encode:

; 873  :       }
; 874  :     }
; 875  :   } else if (cur_cu->type == CU_INTRA) {

	cmp	al, 1
	jne	SHORT $LN38@kvz_encode

; 876  :     encode_intra_coding_unit(state, cabac, cur_cu, x, y, depth);

	movzx	eax, r13w
	mov	r8, rsi
	movzx	r9d, bp
	mov	rdx, rbx
	mov	DWORD PTR [rsp+40], r14d
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], eax
	call	encode_intra_coding_unit
	jmp	$end$335
$LN38@kvz_encode:

; 877  :   }
; 878  : 
; 879  : #if ENABLE_PCM
; 880  :   // Code IPCM block
; 881  :   else if (cur_cu->type == CU_PCM) {
; 882  :     kvz_cabac_encode_bin_trm(cabac, 1); // IPCMFlag == 1
; 883  :     kvz_cabac_finish(cabac);
; 884  :     kvz_bitstream_add_rbsp_trailing_bits(cabac.stream);
; 885  : 
; 886  :     // PCM sample
; 887  :     pixel *base_y = &cur_pic->y_data[x     + y * encoder->in.width];
; 888  :     pixel *base_u = &cur_pic->u_data[x / 2 + y / 2 * encoder->in.width / 2];
; 889  :     pixel *base_v = &cur_pic->v_data[x / 2 + y / 2 * encoder->in.width / 2];
; 890  : 
; 891  :     // Luma
; 892  :     for (unsigned y_px = 0; y_px < LCU_WIDTH >> depth; y_px++) {
; 893  :       for (unsigned  x_px = 0; x_px < LCU_WIDTH >> depth; x_px++) {
; 894  :         kvz_bitstream_put(cabac.stream, base_y[x_px + y_px * encoder->in.width], 8);
; 895  :       }
; 896  :     }
; 897  : 
; 898  :     // Chroma
; 899  :     if (encoder->in.video_format != FORMAT_400) {
; 900  :       for (unsigned y_px = 0; y_px < LCU_WIDTH >> (depth + 1); y_px++) {
; 901  :         for (unsigned x_px = 0; x_px < LCU_WIDTH >> (depth + 1); x_px++) {
; 902  :           kvz_bitstream_put(cabac.stream, base_u[x_px + y_px * (encoder->in.width >> 1)], 8);
; 903  :         }
; 904  :       }
; 905  :       for (unsigned y_px = 0; y_px < LCU_WIDTH >> (depth + 1); y_px++) {
; 906  :         for (unsigned x_px = 0; x_px < LCU_WIDTH >> (depth + 1); x_px++) {
; 907  :           kvz_bitstream_put(cabac.stream, base_v[x_px + y_px * (encoder->in.width >> 1)], 8);
; 908  :         }
; 909  :       }
; 910  :     }
; 911  :     kvz_cabac_start(cabac);
; 912  :   }
; 913  : #endif
; 914  : 
; 915  :   else {
; 916  :     // CU type not set. Should not happen.
; 917  :     assert(0);

	mov	r8d, 917				; 00000395H
	lea	rdx, OFFSET FLAT:$SG4294944836
	lea	rcx, OFFSET FLAT:$SG4294944835
	call	QWORD PTR __imp__wassert

; 918  :     exit(1);

	mov	ecx, 1
	call	QWORD PTR __imp_exit
	int	3
$LN327@kvz_encode:
kvz_encode_coding_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
state$ = 64
cabac$ = 72
mvd_hor$ = 80
mvd_ver$ = 88
kvz_encode_mvd PROC

; 933  : {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	r12, rcx

; 934  :   const int8_t hor_abs_gr0 = mvd_hor != 0;
; 935  :   const int8_t ver_abs_gr0 = mvd_ver != 0;
; 936  :   const uint32_t mvd_hor_abs = abs(mvd_hor);

	mov	eax, r8d

; 937  :   const uint32_t mvd_ver_abs = abs(mvd_ver);
; 938  : 
; 939  :   cabac->cur_ctx = &cabac->ctx.cu_mvd_model[0];
; 940  :   CABAC_BIN(cabac, (mvd_hor != 0), "abs_mvd_greater0_flag_hor");

	xor	r14d, r14d
	cdq
	mov	ebp, r9d
	mov	edi, eax
	mov	r15d, r8d
	xor	edi, edx
	lea	rcx, QWORD PTR [rbx+215]
	sub	edi, edx
	mov	QWORD PTR [rbx], rcx
	mov	eax, r9d
	mov	rcx, rbx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	mov	edx, r14d
	test	r8d, r8d
	setne	dl
	call	kvz_cabac_encode_bin

; 941  :   CABAC_BIN(cabac, (mvd_ver != 0), "abs_mvd_greater0_flag_ver");

	mov	edx, r14d
	test	ebp, ebp
	mov	rcx, rbx
	setne	dl
	call	kvz_cabac_encode_bin

; 942  : 
; 943  :   cabac->cur_ctx = &cabac->ctx.cu_mvd_model[1];

	lea	rax, QWORD PTR [rbx+216]
	mov	QWORD PTR [rbx], rax

; 944  :   if (hor_abs_gr0) {

	test	r15d, r15d
	je	SHORT $LN2@kvz_encode

; 945  :     CABAC_BIN(cabac, (mvd_hor_abs>1), "abs_mvd_greater1_flag_hor");

	cmp	edi, 1
	mov	edx, r14d
	mov	rcx, rbx
	seta	dl
	call	kvz_cabac_encode_bin
$LN2@kvz_encode:

; 946  :   }
; 947  :   if (ver_abs_gr0) {

	test	ebp, ebp
	je	SHORT $LN3@kvz_encode

; 948  :     CABAC_BIN(cabac, (mvd_ver_abs>1), "abs_mvd_greater1_flag_ver");

	cmp	esi, 1
	mov	rcx, rbx
	seta	r14b
	mov	edx, r14d
	call	kvz_cabac_encode_bin
$LN3@kvz_encode:

; 949  :   }
; 950  : 
; 951  :   if (hor_abs_gr0) {

	test	r15d, r15d
	je	SHORT $LN13@kvz_encode

; 952  :     if (mvd_hor_abs > 1) {

	cmp	edi, 1
	jbe	SHORT $LN5@kvz_encode

; 953  :       kvz_cabac_write_ep_ex_golomb(state, cabac, mvd_hor_abs - 2, 1);

	lea	r8d, DWORD PTR [rdi-2]
	mov	r9d, 1
	mov	rdx, rbx
	mov	rcx, r12
	call	kvz_cabac_write_ep_ex_golomb
$LN5@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+8], ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 955  :     uint32_t mvd_hor_sign = (mvd_hor > 0) ? 0 : 1;

	test	r15d, r15d
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 231  :   if (bin_value) {

	jg	SHORT $LN20@kvz_encode

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rbx+8], ecx
$LN20@kvz_encode:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+24]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN13@kvz_encode

; 237  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
$LN13@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 963  :   if (ver_abs_gr0) {

	test	ebp, ebp
	je	SHORT $LN17@kvz_encode

; 964  :     if (mvd_ver_abs > 1) {

	cmp	esi, 1
	jbe	SHORT $LN8@kvz_encode

; 965  :       kvz_cabac_write_ep_ex_golomb(state, cabac, mvd_ver_abs - 2, 1);

	lea	r8d, DWORD PTR [rsi-2]
	mov	r9d, 1
	mov	rdx, rbx
	mov	rcx, r12
	call	kvz_cabac_write_ep_ex_golomb
$LN8@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+8], ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 967  :     uint32_t mvd_ver_sign = mvd_ver > 0 ? 0 : 1;

	test	ebp, ebp
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 231  :   if (bin_value) {

	jg	SHORT $LN16@kvz_encode

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rbx+8], ecx
$LN16@kvz_encode:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+24]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN17@kvz_encode

; 237  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
$LN17@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 975  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
kvz_encode_mvd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
tv1394 = 32
tv1767 = 40
tv1765 = 48
cabac$ = 112
lastpos_x$ = 120
lastpos_y$ = 128
width$ = 136
height$ = 144
$T1 = 152
type$ = 152
scan$ = 160
kvz_encode_last_significant_xy PROC

; 67   : {

$LN62:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	BYTE PTR [rsp+32], r9b
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	movzx	esi, r9b
	mov	rbx, rcx
	movzx	ebp, r8b
	movzx	r14d, dl
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h

; 45   :   assert(value > 0);

	test	r9b, r9b
	jne	SHORT $LN27@kvz_encode
	mov	r8d, 45					; 0000002dH
	lea	rdx, OFFSET FLAT:$SG4294944914
	lea	rcx, OFFSET FLAT:$SG4294944913
	call	QWORD PTR __imp__wassert
$LN27@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 69   :   uint8_t ctx_offset = type ? 0 : (index * 3 + (index + 1) / 4);

	movzx	r11d, BYTE PTR type$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h

; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	xor	edi, edi
	mov	r8d, 1
	mov	eax, 1
	rol	r8, 4
	mov	edx, edi
	mov	ecx, r8d
	shl	eax, cl
	cmp	esi, eax
	mov	eax, 4
	cmovae	edx, r8d

; 52   :     result += shift;
; 53   :     value >>= shift;

	mov	ecx, edx
	shr	esi, cl
	mov	ecx, edi
	cmp	esi, 16
	cmovae	ecx, eax
	mov	eax, 2
	add	edx, ecx
	shr	esi, cl
	cmp	esi, 4
	mov	ecx, edi
	cmovae	ecx, eax
	shr	esi, cl
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 68   :   const int index = kvz_math_floor_log2(width) - 2;

	cmp	esi, eax
	sbb	r8d, r8d
	dec	r8d
	add	r8d, ecx
	add	r8d, edx

; 69   :   uint8_t ctx_offset = type ? 0 : (index * 3 + (index + 1) / 4);

	test	r11b, r11b
	je	SHORT $LN14@kvz_encode

; 70   :   uint8_t shift = type ? index : (index + 3) / 4;

	mov	r10d, r8d
	mov	DWORD PTR $T1[rsp], r8d
	mov	r9d, edi
	jmp	SHORT $LN17@kvz_encode
$LN14@kvz_encode:
	lea	eax, DWORD PTR [r8+3]
	cdq
	lea	r9d, DWORD PTR [r8+r8*2]
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	r10d, eax
	mov	DWORD PTR $T1[rsp], eax
	lea	eax, DWORD PTR [r8+1]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	r9d, eax
$LN17@kvz_encode:

; 71   : 
; 72   :   cabac_ctx_t *base_ctx_x = (type ? cabac->ctx.cu_ctx_last_x_chroma : cabac->ctx.cu_ctx_last_x_luma);
; 73   :   cabac_ctx_t *base_ctx_y = (type ? cabac->ctx.cu_ctx_last_y_chroma : cabac->ctx.cu_ctx_last_y_luma);

	test	r11b, r11b

; 74   : 
; 75   :   if (scan == SCAN_VER) {
; 76   :     SWAP(lastpos_x, lastpos_y, uint8_t);
; 77   :   }
; 78   : 
; 79   :   const int group_idx_x = g_group_idx[lastpos_x];

	movzx	r15d, r9b
	mov	eax, 148				; 00000094H
	mov	ecx, ebp
	mov	r13d, 163				; 000000a3H
	mov	r12d, 133				; 00000085H
	cmove	r13d, eax
	mov	esi, edi
	add	r13, rbx
	mov	eax, 118				; 00000076H
	test	r11b, r11b
	lea	r11, OFFSET FLAT:__ImageBase
	cmove	r12d, eax
	add	r12, rbx
	cmp	BYTE PTR scan$[rsp], 2
	mov	QWORD PTR tv1394[rsp], r12
	cmovne	ecx, r14d
	movzx	r8d, cl
	mov	ecx, r14d
	cmovne	ecx, ebp
	mov	QWORD PTR tv1767[rsp], r8
	movzx	eax, cl
	mov	QWORD PTR tv1765[rsp], rax
	movzx	r14d, BYTE PTR g_group_idx[r8+r11]

; 80   :   const int group_idx_y = g_group_idx[lastpos_y];

	movzx	ebp, BYTE PTR g_group_idx[rax+r11]

; 81   : 
; 82   :   // x prefix
; 83   :   for (int last_x = 0; last_x < group_idx_x; last_x++) {

	test	r14d, r14d
	je	SHORT $LN55@kvz_encode

; 84   :     cabac->cur_ctx = &base_ctx_x[ctx_offset + (last_x >> shift)];

	movzx	r12d, r10b
	npad	12
$LL4@kvz_encode:
	mov	eax, esi
	mov	ecx, r12d
	sar	eax, cl

; 85   :     CABAC_BIN(cabac, 1, "last_sig_coeff_x_prefix");

	mov	edx, 1
	add	eax, r15d
	mov	rcx, rbx
	cdqe
	add	rax, r13
	mov	QWORD PTR [rbx], rax
	call	kvz_cabac_encode_bin
	inc	esi
	cmp	esi, r14d
	jl	SHORT $LL4@kvz_encode
	mov	r12, QWORD PTR tv1394[rsp]
	lea	r11, OFFSET FLAT:__ImageBase
$LN55@kvz_encode:

; 86   :   }
; 87   :   if (group_idx_x < g_group_idx[width - 1]) {

	movzx	eax, BYTE PTR width$[rsp]
	movzx	esi, BYTE PTR $T1[rsp]
	cmp	r14b, BYTE PTR g_group_idx[rax+r11-1]
	jae	SHORT $LN56@kvz_encode

; 88   :     cabac->cur_ctx = &base_ctx_x[ctx_offset + (group_idx_x >> shift)];

	mov	eax, r14d
	mov	ecx, esi
	sar	eax, cl

; 89   :     CABAC_BIN(cabac, 0, "last_sig_coeff_x_prefix");

	xor	edx, edx
	add	eax, r15d
	mov	rcx, rbx
	cdqe
	add	rax, r13
	mov	QWORD PTR [rbx], rax
	call	kvz_cabac_encode_bin
	lea	r11, OFFSET FLAT:__ImageBase
$LN56@kvz_encode:

; 93   :   for (int last_y = 0; last_y < group_idx_y; last_y++) {

	test	ebp, ebp
	je	$LN6@kvz_encode
	npad	9
$LL7@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	mov	r8d, DWORD PTR [rbx+12]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 94   :     cabac->cur_ctx = &base_ctx_y[ctx_offset + (last_y >> shift)];

	mov	eax, edi
	mov	ecx, esi
	sar	eax, cl
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	mov	ecx, r8d
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 94   :     cabac->cur_ctx = &base_ctx_y[ctx_offset + (last_y >> shift)];

	add	eax, r15d
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	shr	rcx, 6
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 94   :     cabac->cur_ctx = &base_ctx_y[ctx_offset + (last_y >> shift)];

	movsxd	rdx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	and	ecx, 3
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 94   :     cabac->cur_ctx = &base_ctx_y[ctx_offset + (last_y >> shift)];

	add	rdx, r12
	mov	QWORD PTR [rbx], rdx
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	movzx	eax, BYTE PTR [rdx]
	shr	rax, 1
	lea	rcx, QWORD PTR [rcx+rax*4]
	movzx	r9d, BYTE PTR kvz_g_auc_lpst_table[rcx+r11]

; 109  :   data->range -= lps;

	sub	r8d, r9d
	mov	DWORD PTR [rbx+12], r8d

; 110  : 
; 111  :   // Not the Most Probable Symbol?
; 112  :   if ((bin_value ? 1 : 0) != CTX_MPS(data->cur_ctx)) {

	movzx	eax, BYTE PTR [rdx]
	test	al, 1
	jne	SHORT $LN29@kvz_encode

; 113  :     int num_bits = kvz_g_auc_renorm_table[lps >> 3];

	mov	eax, r9d
	shr	rax, 3
	movzx	ecx, BYTE PTR kvz_g_auc_renorm_table[rax+r11]

; 114  :     data->low = (data->low + data->range) << num_bits;

	mov	eax, DWORD PTR [rbx+8]
	add	eax, r8d

; 115  :     data->range = lps << num_bits;

	shl	r9d, cl
	shl	eax, cl
	mov	DWORD PTR [rbx+8], eax
	mov	DWORD PTR [rbx+12], r9d

; 116  : 
; 117  :     CTX_UPDATE_LPS(data->cur_ctx);

	movzx	eax, BYTE PTR [rdx]
	movzx	eax, BYTE PTR kvz_g_auc_next_state_lps[rax+r11]
	mov	BYTE PTR [rdx], al

; 118  : 
; 119  :     data->bits_left -= num_bits;

	sub	DWORD PTR [rbx+24], ecx

; 120  :   } else {

	jmp	SHORT $LN59@kvz_encode
$LN29@kvz_encode:

; 121  :     CTX_UPDATE_MPS(data->cur_ctx);

	movzx	eax, BYTE PTR kvz_g_auc_next_state_mps[rax+r11]
	mov	BYTE PTR [rdx], al

; 122  :     if (data->range >= 256) return;

	mov	eax, DWORD PTR [rbx+12]
	cmp	eax, 256				; 00000100H
	jae	SHORT $LN5@kvz_encode

; 123  : 
; 124  :     data->low <<= 1;

	shl	DWORD PTR [rbx+8], 1

; 125  :     data->range <<= 1;

	add	eax, eax

; 126  :     data->bits_left--;

	dec	DWORD PTR [rbx+24]
	mov	DWORD PTR [rbx+12], eax
$LN59@kvz_encode:

; 127  :   }
; 128  : 
; 129  :   if (data->bits_left < 12) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 12
	jge	SHORT $LN5@kvz_encode

; 130  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
	lea	r11, OFFSET FLAT:__ImageBase
$LN5@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 93   :   for (int last_y = 0; last_y < group_idx_y; last_y++) {

	inc	edi
	cmp	edi, ebp
	jl	$LL7@kvz_encode
$LN6@kvz_encode:

; 95   :     CABAC_BIN(cabac, 1, "last_sig_coeff_y_prefix");
; 96   :   }
; 97   :   if (group_idx_y < g_group_idx[height - 1]) {

	movzx	eax, BYTE PTR height$[rsp]
	cmp	bpl, BYTE PTR g_group_idx[rax+r11-1]
	jae	$LN38@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	mov	r9d, DWORD PTR [rbx+12]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 98   :     cabac->cur_ctx = &base_ctx_y[ctx_offset + (group_idx_y >> shift)];

	mov	eax, ebp
	mov	ecx, esi
	sar	eax, cl
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	mov	ecx, r9d
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 98   :     cabac->cur_ctx = &base_ctx_y[ctx_offset + (group_idx_y >> shift)];

	add	eax, r15d
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	shr	rcx, 6
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 98   :     cabac->cur_ctx = &base_ctx_y[ctx_offset + (group_idx_y >> shift)];

	movsxd	rdx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	and	ecx, 3
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 98   :     cabac->cur_ctx = &base_ctx_y[ctx_offset + (group_idx_y >> shift)];

	add	rdx, r12
	mov	QWORD PTR [rbx], rdx
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	movzx	eax, BYTE PTR [rdx]
	shr	rax, 1
	lea	rcx, QWORD PTR [rcx+rax*4]
	movzx	r8d, BYTE PTR kvz_g_auc_lpst_table[rcx+r11]

; 109  :   data->range -= lps;

	sub	r9d, r8d
	mov	DWORD PTR [rbx+12], r9d

; 110  : 
; 111  :   // Not the Most Probable Symbol?
; 112  :   if ((bin_value ? 1 : 0) != CTX_MPS(data->cur_ctx)) {

	movzx	eax, BYTE PTR [rdx]
	test	al, 1
	je	SHORT $LN35@kvz_encode

; 113  :     int num_bits = kvz_g_auc_renorm_table[lps >> 3];

	mov	eax, r8d
	shr	rax, 3
	movzx	ecx, BYTE PTR kvz_g_auc_renorm_table[rax+r11]

; 114  :     data->low = (data->low + data->range) << num_bits;

	mov	eax, DWORD PTR [rbx+8]
	add	eax, r9d

; 115  :     data->range = lps << num_bits;

	shl	r8d, cl
	shl	eax, cl
	mov	DWORD PTR [rbx+8], eax
	mov	DWORD PTR [rbx+12], r8d

; 116  : 
; 117  :     CTX_UPDATE_LPS(data->cur_ctx);

	movzx	eax, BYTE PTR [rdx]
	movzx	eax, BYTE PTR kvz_g_auc_next_state_lps[rax+r11]
	mov	BYTE PTR [rdx], al

; 118  : 
; 119  :     data->bits_left -= num_bits;

	sub	DWORD PTR [rbx+24], ecx

; 120  :   } else {

	jmp	SHORT $LN60@kvz_encode
$LN35@kvz_encode:

; 121  :     CTX_UPDATE_MPS(data->cur_ctx);

	movzx	eax, BYTE PTR kvz_g_auc_next_state_mps[rax+r11]
	mov	BYTE PTR [rdx], al

; 122  :     if (data->range >= 256) return;

	mov	eax, DWORD PTR [rbx+12]
	cmp	eax, 256				; 00000100H
	jae	SHORT $LN38@kvz_encode

; 123  : 
; 124  :     data->low <<= 1;

	shl	DWORD PTR [rbx+8], 1

; 125  :     data->range <<= 1;

	add	eax, eax

; 126  :     data->bits_left--;

	dec	DWORD PTR [rbx+24]
	mov	DWORD PTR [rbx+12], eax
$LN60@kvz_encode:

; 127  :   }
; 128  : 
; 129  :   if (data->bits_left < 12) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 12
	jge	SHORT $LN38@kvz_encode

; 130  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
	lea	r11, OFFSET FLAT:__ImageBase
$LN38@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 103  :   if (group_idx_x > 3) {

	cmp	r14b, 3
	jbe	SHORT $LN11@kvz_encode

; 104  :     const int suffix = lastpos_x - g_min_in_group[group_idx_x];
; 105  :     const int bits = (group_idx_x - 2) / 2;

	lea	eax, DWORD PTR [r14-2]

; 106  :     CABAC_BINS_EP(cabac, suffix, bits, "last_sig_coeff_x_suffix");

	mov	rcx, rbx
	cdq
	sub	eax, edx
	movzx	edx, BYTE PTR tv1767[rsp]
	sar	eax, 1
	mov	r8d, eax
	movzx	eax, BYTE PTR g_min_in_group[r14+r11]
	sub	edx, eax
	call	kvz_cabac_encode_bins_ep
$LN11@kvz_encode:

; 107  :   }
; 108  : 
; 109  :   // last_sig_coeff_y_suffix
; 110  :   if (group_idx_y > 3) {

	cmp	bpl, 3
	jbe	SHORT $LN12@kvz_encode

; 111  :     const int suffix = lastpos_y - g_min_in_group[group_idx_y];
; 112  :     const int bits = (group_idx_y - 2) / 2;

	lea	eax, DWORD PTR [rbp-2]
	cdq
	lea	rcx, OFFSET FLAT:__ImageBase
	sub	eax, edx
	movzx	edx, BYTE PTR tv1765[rsp]
	sar	eax, 1
	mov	r8d, eax
	movzx	eax, BYTE PTR g_min_in_group[rbp+rcx]
	sub	edx, eax

; 113  :     CABAC_BINS_EP(cabac, suffix, bits, "last_sig_coeff_y_suffix");

	mov	rcx, rbx
	call	kvz_cabac_encode_bins_ep
$LN12@kvz_encode:

; 114  :   }
; 115  : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
kvz_encode_last_significant_xy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
width$ = 48
x$ = 56
y$ = 64
xy_to_zorder PROC

; 386  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, r8d
	mov	edi, edx
	mov	esi, ecx

; 387  :   assert(width % 4 == 0 && width >= 4 && width <= 64);

	test	cl, 3
	jne	SHORT $LN10@xy_to_zord
	cmp	ecx, 4
	jae	SHORT $LN11@xy_to_zord
$LN10@xy_to_zord:
	mov	r8d, 387				; 00000183H
	lea	rdx, OFFSET FLAT:$SG4294944920
	lea	rcx, OFFSET FLAT:$SG4294944919
	call	QWORD PTR __imp__wassert
$LN11@xy_to_zord:

; 388  :   assert(x % 4 == 0 && x < width);

	test	dil, 3
	jne	SHORT $LN12@xy_to_zord
	cmp	edi, esi
	jb	SHORT $LN13@xy_to_zord
$LN12@xy_to_zord:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944918
	lea	rcx, OFFSET FLAT:$SG4294944917
	call	QWORD PTR __imp__wassert
$LN13@xy_to_zord:

; 389  :   assert(y % 4 == 0 && y < width);

	test	bl, 3
	jne	SHORT $LN14@xy_to_zord
	cmp	ebx, esi
	jb	SHORT $LN15@xy_to_zord
$LN14@xy_to_zord:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944916
	lea	rcx, OFFSET FLAT:$SG4294944915
	call	QWORD PTR __imp__wassert
$LN15@xy_to_zord:

; 390  : 
; 391  :   unsigned result = 0;

	xor	edx, edx

; 392  : 
; 393  :   switch (width) {

	cmp	esi, 32					; 00000020H
	je	SHORT $LN5@xy_to_zord
	cmp	esi, 64					; 00000040H
	jne	SHORT $LN16@xy_to_zord

; 394  :     case 64:
; 395  :       result += x / 32 * (32*32);
; 396  :       result += y / 32 * (64*32);

	mov	ecx, ebx
	mov	eax, edi
	shr	ecx, 5

; 397  :       x %= 32;

	and	edi, 31
	shr	eax, 5
	lea	edx, DWORD PTR [rax+rcx*2]
	shl	edx, 10

; 398  :       y %= 32;

	and	ebx, 31
$LN5@xy_to_zord:

; 399  :       // fallthrough
; 400  :     case 32:
; 401  :       result += x / 16 * (16*16);
; 402  :       result += y / 16 * (32*16);

	mov	ecx, ebx
	mov	eax, edi
	shr	ecx, 4

; 403  :       x %= 16;

	and	edi, 15
	shr	eax, 4

; 404  :       y %= 16;

	and	ebx, 15
	lea	ecx, DWORD PTR [rax+rcx*2]

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);

	mov	eax, edi
	shl	ecx, 8

; 408  :       result += y / 8 * (16*8);
; 409  :       x %= 8;

	and	edi, 7
	add	edx, ecx
	shr	eax, 3
	mov	ecx, ebx

; 410  :       y %= 8;
; 411  :       // fallthrough
; 412  :     case 8:
; 413  :       result += x / 4 * (4*4);

	shr	edi, 2
	shr	ecx, 3
	and	ebx, 7

; 414  :       result += y / 4 * (8*4);

	shr	ebx, 2
	lea	ecx, DWORD PTR [rax+rcx*2]
	shl	ecx, 6
	lea	eax, DWORD PTR [rdi+rbx*2]
	add	edx, ecx
	shl	eax, 4
	add	eax, edx

; 415  :       // fallthrough
; 416  :     case 4:
; 417  :       break;
; 418  :   }
; 419  : 
; 420  :   return result;
; 421  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN16@xy_to_zord:
	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, edx
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
xy_to_zorder ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_is_set PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	movzx	r9d, cx
	lea	rcx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+r8*4]
	shl	edx, cl
	mov	eax, 0
	test	edx, r9d
	setne	al

; 519  : }

	ret	0
cbf_is_set ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
cbf_is_set_any PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rdx+rax*2]
	test	dx, cx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, edx
	shl	edx, 5
	or	edx, eax
	movzx	eax, cx
	shl	edx, 5
	test	edx, eax

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set
	xor	eax, eax

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
$LN3@cbf_is_set:

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	mov	eax, 1

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
cbf_is_set_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\crypto.h
_TEXT	SEGMENT
hdl$dead$ = 8
num_bits$dead$ = 16
kvz_crypto_get_key PROC

; 66   :   return 0;

	xor	eax, eax

; 67   : }

	ret	0
kvz_crypto_get_key ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h
_TEXT	SEGMENT
state$ = 8
x$ = 16
y$ = 24
depth$ = 32
is_last_cu_in_qg PROC

; 382  : {

	mov	QWORD PTR [rsp+8], rbx

; 383  :   if (state->encoder_control->max_qp_delta_depth < 0) return false;

	mov	rax, QWORD PTR [rcx]
	mov	ebx, r9d
	mov	r10, rcx
	movzx	r11d, BYTE PTR [rax+6520]
	test	r11b, r11b
	js	SHORT $LN6@is_last_cu

; 384  : 
; 385  :   const int cu_width = LCU_WIDTH >> depth;

	mov	r9d, 64					; 00000040H
	mov	ecx, ebx
	mov	eax, r9d
	sar	eax, cl

; 386  :   const int qg_width = LCU_WIDTH >> state->encoder_control->max_qp_delta_depth;

	movzx	ecx, r11b

; 387  :   const int right  = x + cu_width;
; 388  :   const int bottom = y + cu_width;

	add	r8d, eax
	sar	r9d, cl
	lea	r11d, DWORD PTR [rax+rdx]

; 389  :   return (right % qg_width == 0 || right >= state->tile->frame->width) &&

	mov	eax, r11d
	cdq
	idiv	r9d
	test	edx, edx
	je	SHORT $LN9@is_last_cu
	mov	rax, QWORD PTR [r10+48]
	mov	rcx, QWORD PTR [rax]
	cmp	r11d, DWORD PTR [rcx+16]
	jl	SHORT $LN6@is_last_cu
$LN9@is_last_cu:
	mov	eax, r8d
	cdq
	idiv	r9d
	test	edx, edx
	je	SHORT $LN5@is_last_cu
	mov	rax, QWORD PTR [r10+48]
	mov	rcx, QWORD PTR [rax]
	cmp	r8d, DWORD PTR [rcx+20]
	jge	SHORT $LN5@is_last_cu
$LN6@is_last_cu:

; 390  :          (bottom % qg_width == 0 || bottom >= state->tile->frame->height);
; 391  : }

	xor	al, al
	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN5@is_last_cu:
	mov	rbx, QWORD PTR [rsp+8]
	mov	al, 1
	ret	0
is_last_cu_in_qg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
_TEXT	SEGMENT
value$ = 48
kvz_math_floor_log2 PROC

; 44   : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx

; 45   :   assert(value > 0);

	test	ecx, ecx
	jne	SHORT $LN6@kvz_math_f
	lea	r8d, QWORD PTR [rcx+45]
	lea	rcx, OFFSET FLAT:$SG4294944913
	lea	rdx, OFFSET FLAT:$SG4294944914
	call	QWORD PTR __imp__wassert
$LN6@kvz_math_f:

; 46   : 
; 47   :   unsigned result = 0;
; 48   : 
; 49   :   for (int i = 4; i >= 0; --i) {
; 50   :     unsigned bits = 1ull << i;
; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	xor	r9d, r9d
	mov	eax, 1
	mov	edx, eax
	mov	r8d, r9d
	rol	rdx, 4
	mov	ecx, edx
	shl	eax, cl
	cmp	ebx, eax
	mov	eax, 8
	cmovae	r8d, edx
	mov	edx, 4

; 52   :     result += shift;
; 53   :     value >>= shift;

	mov	ecx, r8d
	shr	ebx, cl
	mov	ecx, r9d
	cmp	ebx, 256				; 00000100H
	cmovae	ecx, eax
	shr	ebx, cl
	cmp	ebx, 16
	lea	eax, DWORD PTR [r8+rcx]
	mov	ecx, r9d
	cmovae	ecx, edx
	mov	edx, 2
	add	eax, ecx
	shr	ebx, cl
	cmp	ebx, 4
	mov	ecx, r9d
	cmovae	ecx, edx
	add	eax, ecx
	shr	ebx, cl
	cmp	ebx, edx
	setae	r9b
	add	eax, r9d

; 54   :   }
; 55   : 
; 56   :   return result;
; 57   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
kvz_math_floor_log2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
tv1051 = 64
frame$1$ = 72
tv1044 = 144
tv1033 = 144
state$ = 144
x$ = 152
y$ = 160
tv1129 = 168
depth$ = 168
encode_transform_unit PROC

; 119  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	movsxd	rbp, r9d
	mov	edi, r8d
	mov	ebx, edx
	mov	r13, rcx

; 120  :   assert(depth >= 1 && depth <= MAX_PU_DEPTH);

	lea	eax, DWORD PTR [rbp-1]
	cmp	eax, 3
	jbe	SHORT $LN12@encode_tra
	mov	r8d, 120				; 00000078H
	lea	rdx, OFFSET FLAT:$SG4294944847
	lea	rcx, OFFSET FLAT:$SG4294944846
	call	QWORD PTR __imp__wassert
$LN12@encode_tra:

; 121  : 
; 122  :   const videoframe_t * const frame = state->tile->frame;

	mov	rax, QWORD PTR [r13+48]

; 123  :   const uint8_t width = LCU_WIDTH >> depth;

	mov	ecx, ebp

; 124  :   const uint8_t width_c = (depth == MAX_PU_DEPTH ? width : width / 2);
; 125  : 
; 126  :   const cu_info_t *cur_pu = kvz_cu_array_at_const(frame->cu_array, x, y);

	mov	r8d, edi
	mov	QWORD PTR [rsp+152], r12
	mov	edx, ebx
	mov	r14, QWORD PTR [rax]
	mov	eax, 64					; 00000040H
	sar	eax, cl
	movzx	ecx, al
	movzx	eax, cl
	mov	DWORD PTR tv1033[rsp], ecx
	shr	al, 1
	movzx	eax, al
	cmp	ebp, 4
	mov	QWORD PTR frame$1$[rsp], r14
	cmovne	ecx, eax
	mov	DWORD PTR tv1129[rsp], ecx
	mov	rcx, QWORD PTR [r14+32]
	call	kvz_cu_array_at_const
	mov	r15, rax

; 127  : 
; 128  :   int8_t scan_idx = kvz_get_scan_order(cur_pu->type, cur_pu->intra.mode, depth);

	movzx	eax, BYTE PTR [rax+8]
	movzx	ecx, BYTE PTR [r15]
	and	cl, 3
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1585 :   if (cu_type == CU_INTRA && depth >= 3) {

	cmp	cl, 1
	jne	SHORT $LN21@encode_tra
	cmp	ebp, 3
	jl	SHORT $LN21@encode_tra

; 1586 :     if (intra_mode >= 6 && intra_mode <= 14) {

	lea	ecx, DWORD PTR [rax-6]
	cmp	cl, 8
	ja	SHORT $LN19@encode_tra

; 1587 :       return SCAN_VER;

	mov	r12b, 2
	jmp	SHORT $LN17@encode_tra
$LN19@encode_tra:

; 1588 :     } else if (intra_mode >= 22 && intra_mode <= 30) {

	sub	al, 22
	cmp	al, 8
	ja	SHORT $LN21@encode_tra

; 1589 :       return SCAN_HOR;

	mov	r12b, 1
	jmp	SHORT $LN17@encode_tra
$LN21@encode_tra:

; 1590 :     }
; 1591 :   }
; 1592 : 
; 1593 :   return SCAN_DIAG;

	xor	r12b, r12b
$LN17@encode_tra:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR [r15+4]
	lea	rcx, OFFSET FLAT:cbf_masks
	lea	rsi, QWORD PTR [rcx+rbp*2]
	mov	QWORD PTR tv1051[rsp], rsi
	test	ax, WORD PTR [rsi]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 132  :   if (cbf_y) {

	je	$LN2@encode_tra

; 134  :     int y_local = y % LCU_WIDTH;

	mov	esi, edi
	and	esi, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN99@encode_tra
	dec	esi
	or	esi, -64				; ffffffffffffffc0H
	inc	esi
$LN99@encode_tra:

; 133  :     int x_local = x % LCU_WIDTH;

	mov	r14d, ebx
	and	r14d, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN98@encode_tra
	dec	r14d
	or	r14d, -64				; ffffffffffffffc0H
	inc	r14d
$LN98@encode_tra:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	test	r14b, 3
	jne	SHORT $LN36@encode_tra
	cmp	r14d, 64				; 00000040H
	jb	SHORT $LN37@encode_tra
$LN36@encode_tra:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944918
	lea	rcx, OFFSET FLAT:$SG4294944917
	call	QWORD PTR __imp__wassert
$LN37@encode_tra:

; 389  :   assert(y % 4 == 0 && y < width);

	test	sil, 3
	jne	SHORT $LN38@encode_tra
	cmp	esi, 64					; 00000040H
	jb	SHORT $LN39@encode_tra
$LN38@encode_tra:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944916
	lea	rcx, OFFSET FLAT:$SG4294944915
	call	QWORD PTR __imp__wassert
$LN39@encode_tra:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 139  :     kvz_encode_coeff_nxn(state,

	movzx	edx, BYTE PTR [r15+2]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 396  :       result += y / 32 * (64*32);

	mov	ecx, esi
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 139  :     kvz_encode_coeff_nxn(state,

	movzx	r9d, BYTE PTR tv1033[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 395  :       result += x / 32 * (32*32);

	mov	eax, r14d

; 396  :       result += y / 32 * (64*32);

	shr	ecx, 5

; 397  :       x %= 32;

	and	r14d, 31
	shr	eax, 5

; 398  :       y %= 32;

	and	esi, 31
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 139  :     kvz_encode_coeff_nxn(state,

	and	dl, 1
	mov	BYTE PTR [rsp+48], dl
	lea	rdx, QWORD PTR [r13+128]
	mov	BYTE PTR [rsp+40], r12b
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 396  :       result += y / 32 * (64*32);

	lea	r8d, DWORD PTR [rax+rcx*2]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 139  :     kvz_encode_coeff_nxn(state,

	mov	BYTE PTR [rsp+32], 0
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 402  :       result += y / 16 * (32*16);

	mov	ecx, esi
	shl	r8d, 10
	shr	ecx, 4
	mov	eax, r14d
	shr	eax, 4

; 403  :       x %= 16;

	and	r14d, 15

; 404  :       y %= 16;

	and	esi, 15
	lea	ecx, DWORD PTR [rax+rcx*2]

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);

	mov	eax, r14d
	shl	ecx, 8

; 409  :       x %= 8;

	and	r14d, 7
	add	r8d, ecx
	shr	eax, 3
	mov	ecx, esi

; 410  :       y %= 8;
; 411  :       // fallthrough
; 412  :     case 8:
; 413  :       result += x / 4 * (4*4);

	shr	r14d, 2
	shr	ecx, 3
	and	esi, 7

; 414  :       result += y / 4 * (8*4);

	shr	esi, 2
	lea	ecx, DWORD PTR [rax+rcx*2]
	shl	ecx, 6
	lea	eax, DWORD PTR [r14+rsi*2]
	add	r8d, ecx
	shl	eax, 4
	add	r8d, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 139  :     kvz_encode_coeff_nxn(state,

	mov	rcx, r13
	mov	rax, QWORD PTR [r13+392]
	lea	r8, QWORD PTR [rax+r8*2]
	call	QWORD PTR kvz_encode_coeff_nxn
	mov	rsi, QWORD PTR tv1051[rsp]
	mov	r14, QWORD PTR frame$1$[rsp]
$LN2@encode_tra:

; 140  :                          &state->cabac,
; 141  :                          coeff_y,
; 142  :                          width,
; 143  :                          0,
; 144  :                          scan_idx,
; 145  :                          cur_pu->tr_skip);
; 146  :   }
; 147  : 
; 148  :   if (depth == MAX_DEPTH + 1) {

	cmp	ebp, 4
	jne	SHORT $LN5@encode_tra

; 149  :     // For size 4x4 luma transform the corresponding chroma transforms are
; 150  :     // also of size 4x4 covering 8x8 luma pixels. The residual is coded in
; 151  :     // the last transform unit.
; 152  :     if (x % 8 == 0 || y % 8 == 0) {

	mov	eax, ebx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN97@encode_tra
	dec	eax
	or	eax, -8
	inc	eax
$LN97@encode_tra:
	test	eax, eax
	je	$LN9@encode_tra
	mov	eax, edi
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN96@encode_tra
	dec	eax
	or	eax, -8
	inc	eax
$LN96@encode_tra:
	test	eax, eax
	je	$LN9@encode_tra

; 153  :       // Not the last luma transform block so there is nothing more to do.
; 154  :       return;
; 155  :     } else {
; 156  :       // Time to to code the chroma transform blocks. Move to the top-left
; 157  :       // corner of the block.
; 158  :       x -= 4;
; 159  :       y -= 4;
; 160  :       cur_pu = kvz_cu_array_at_const(frame->cu_array, x, y);

	mov	rcx, QWORD PTR [r14+32]
	sub	ebx, 4
	sub	edi, 4
	mov	edx, ebx
	mov	r8d, edi
	call	kvz_cu_array_at_const
	mov	r15, rax
$LN5@encode_tra:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR [rsi]
	mov	ecx, eax
	shl	ecx, 5
	or	ecx, eax
	movzx	eax, WORD PTR [r15+4]
	shl	ecx, 5
	test	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 164  :   bool chroma_cbf_set = cbf_is_set(cur_pu->cbf, depth, COLOR_U) ||

	je	$LN9@encode_tra

; 165  :                         cbf_is_set(cur_pu->cbf, depth, COLOR_V);
; 166  :   if (chroma_cbf_set) {
; 167  :     int x_local = (x >> 1) % LCU_WIDTH_C;

	sar	ebx, 1
	and	ebx, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN95@encode_tra
	dec	ebx
	or	ebx, -32				; ffffffffffffffe0H
	inc	ebx
$LN95@encode_tra:

; 168  :     int y_local = (y >> 1) % LCU_WIDTH_C;

	sar	edi, 1
	and	edi, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN94@encode_tra
	dec	edi
	or	edi, -32				; ffffffffffffffe0H
	inc	edi
$LN94@encode_tra:

; 169  :     scan_idx = kvz_get_scan_order(cur_pu->type, cur_pu->intra.mode_chroma, depth);

	movzx	eax, BYTE PTR [r15]
	movzx	ecx, BYTE PTR [r15+9]
	and	al, 3
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1585 :   if (cu_type == CU_INTRA && depth >= 3) {

	cmp	al, 1
	jne	SHORT $LN48@encode_tra
	cmp	ebp, 3
	jl	SHORT $LN48@encode_tra

; 1586 :     if (intra_mode >= 6 && intra_mode <= 14) {

	lea	eax, DWORD PTR [rcx-6]
	cmp	al, 8
	ja	SHORT $LN46@encode_tra

; 1587 :       return SCAN_VER;

	mov	sil, 2
	jmp	SHORT $LN44@encode_tra
$LN46@encode_tra:

; 1588 :     } else if (intra_mode >= 22 && intra_mode <= 30) {

	sub	cl, 22
	cmp	cl, 8
	ja	SHORT $LN48@encode_tra

; 1589 :       return SCAN_HOR;

	mov	sil, 1
	jmp	SHORT $LN44@encode_tra
$LN48@encode_tra:

; 1590 :     }
; 1591 :   }
; 1592 : 
; 1593 :   return SCAN_DIAG;

	xor	sil, sil
$LN44@encode_tra:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	mov	r14d, ebx
	and	r14d, 3
	jne	SHORT $LN61@encode_tra
	cmp	ebx, 32					; 00000020H
	jb	SHORT $LN62@encode_tra
$LN61@encode_tra:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944918
	lea	rcx, OFFSET FLAT:$SG4294944917
	call	QWORD PTR __imp__wassert
$LN62@encode_tra:

; 389  :   assert(y % 4 == 0 && y < width);

	mov	ebp, edi
	and	ebp, 3
	jne	SHORT $LN63@encode_tra
	cmp	edi, 32					; 00000020H
	jb	SHORT $LN64@encode_tra
$LN63@encode_tra:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944916
	lea	rcx, OFFSET FLAT:$SG4294944915
	call	QWORD PTR __imp__wassert
$LN64@encode_tra:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 171  :     const coeff_t *coeff_u = &state->coeff->u[xy_to_zorder(LCU_WIDTH_C, x_local, y_local)];

	mov	r12, QWORD PTR [r13+392]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 402  :       result += y / 16 * (32*16);

	mov	ecx, edi
	shr	ecx, 4
	mov	eax, ebx
	shr	eax, 4
	lea	r9d, DWORD PTR [rax+rcx*2]

; 403  :       x %= 16;

	mov	ecx, ebx
	and	ecx, 15
	shl	r9d, 8

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);

	shr	ecx, 3
	mov	eax, edi
	and	eax, 15

; 408  :       result += y / 8 * (16*8);

	shr	eax, 3
	lea	eax, DWORD PTR [rcx+rax*2]

; 409  :       x %= 8;

	mov	ecx, ebx
	shl	eax, 6
	and	ecx, 7
	add	r9d, eax

; 410  :       y %= 8;
; 411  :       // fallthrough
; 412  :     case 8:
; 413  :       result += x / 4 * (4*4);

	shr	ecx, 2
	mov	eax, edi
	and	eax, 7

; 414  :       result += y / 4 * (8*4);

	shr	eax, 2
	lea	eax, DWORD PTR [rcx+rax*2]
	shl	eax, 4
	add	r9d, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 171  :     const coeff_t *coeff_u = &state->coeff->u[xy_to_zorder(LCU_WIDTH_C, x_local, y_local)];

	lea	rcx, QWORD PTR [r9+r9]
	add	r12, rcx
	mov	QWORD PTR tv1044[rsp], rcx
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	test	r14d, r14d
	jne	SHORT $LN76@encode_tra
	cmp	ebx, 32					; 00000020H
	jb	SHORT $LN77@encode_tra
$LN76@encode_tra:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944918
	lea	rcx, OFFSET FLAT:$SG4294944917
	call	QWORD PTR __imp__wassert
$LN77@encode_tra:

; 389  :   assert(y % 4 == 0 && y < width);

	test	ebp, ebp
	jne	SHORT $LN78@encode_tra
	cmp	edi, 32					; 00000020H
	jb	SHORT $LN79@encode_tra
$LN78@encode_tra:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944916
	lea	rcx, OFFSET FLAT:$SG4294944915
	call	QWORD PTR __imp__wassert
$LN79@encode_tra:

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	r14, QWORD PTR tv1051[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 172  :     const coeff_t *coeff_v = &state->coeff->v[xy_to_zorder(LCU_WIDTH_C, x_local, y_local)];

	mov	rdi, QWORD PTR tv1044[rsp]
	add	rdi, QWORD PTR [r13+392]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	edx, WORD PTR [r15+4]
	movzx	ecx, WORD PTR [r14]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 174  :     if (cbf_is_set(cur_pu->cbf, depth, COLOR_U)) {

	mov	ebp, DWORD PTR tv1129[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, ecx
	shl	eax, 5
	test	eax, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 174  :     if (cbf_is_set(cur_pu->cbf, depth, COLOR_U)) {

	je	SHORT $LN8@encode_tra

; 175  :       kvz_encode_coeff_nxn(state, &state->cabac, coeff_u, width_c, 2, scan_idx, 0);

	mov	BYTE PTR [rsp+48], 0
	lea	r8, QWORD PTR [r12+8192]
	mov	BYTE PTR [rsp+40], sil
	lea	rdx, QWORD PTR [r13+128]
	movzx	r9d, bpl
	mov	BYTE PTR [rsp+32], 2
	mov	rcx, r13
	call	QWORD PTR kvz_encode_coeff_nxn
	movzx	ecx, WORD PTR [r14]
	movzx	edx, WORD PTR [r15+4]
$LN8@encode_tra:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	ecx, cx
	shl	ecx, 10
	movzx	eax, dx
	test	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 178  :     if (cbf_is_set(cur_pu->cbf, depth, COLOR_V)) {

	je	SHORT $LN9@encode_tra

; 179  :       kvz_encode_coeff_nxn(state, &state->cabac, coeff_v, width_c, 2, scan_idx, 0);

	mov	BYTE PTR [rsp+48], 0
	lea	r8, QWORD PTR [rdi+10240]
	mov	BYTE PTR [rsp+40], sil
	lea	rdx, QWORD PTR [r13+128]
	movzx	r9d, bpl
	mov	BYTE PTR [rsp+32], 2
	mov	rcx, r13
	call	QWORD PTR kvz_encode_coeff_nxn
$LN9@encode_tra:
	mov	r12, QWORD PTR [rsp+152]

; 180  :     }
; 181  :   }
; 182  : }

	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
encode_transform_unit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
tv1100 = 64
tv1099 = 68
y_cu$1$ = 72
x_cu$1$ = 76
cur_cu$1$ = 80
cb_flag_y$1$ = 176
cur_pu$1$ = 176
state$ = 176
x$ = 184
y$ = 192
depth$ = 200
tr_depth$ = 208
parent_coeff_u$ = 216
parent_coeff_v$ = 224
encode_transform_coeff PROC

; 200  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 104				; 00000068H
	movzx	r12d, BYTE PTR parent_coeff_u$[rsp]
	lea	rbx, QWORD PTR [rcx+128]
	movzx	r14d, BYTE PTR tr_depth$[rsp]
	movzx	r13d, r9b
	mov	ebp, edx
	mov	r15, rcx
$LL97@encode_tra:

; 201  :   cabac_data_t * const cabac = &state->cabac;
; 202  :   const encoder_control_t *const ctrl = state->encoder_control;
; 203  :   const videoframe_t * const frame = state->tile->frame;

	mov	rax, QWORD PTR [r15+48]

; 204  : 
; 205  :   const cu_info_t *cur_pu = kvz_cu_array_at_const(frame->cu_array, x, y);

	mov	edx, ebp
	mov	rsi, QWORD PTR [r15]
	mov	rdi, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rdi+32]
	call	kvz_cu_array_at_const
	mov	QWORD PTR cur_pu$1$[rsp], rax

; 206  :   // Round coordinates down to a multiple of 8 to get the location of the
; 207  :   // containing CU.
; 208  :   const int x_cu = 8 * (x / 8);

	mov	eax, ebp
	cdq
	and	edx, 7
	lea	ecx, DWORD PTR [rdx+rax]

; 209  :   const int y_cu = 8 * (y / 8);

	mov	eax, DWORD PTR y$[rsp]
	cdq
	and	ecx, -8
	and	edx, 7
	mov	DWORD PTR x_cu$1$[rsp], ecx
	add	eax, edx

; 210  :   const cu_info_t *cur_cu = kvz_cu_array_at_const(frame->cu_array, x_cu, y_cu);

	mov	edx, ecx
	mov	rcx, QWORD PTR [rdi+32]
	and	eax, -8
	mov	r8d, eax
	mov	DWORD PTR y_cu$1$[rsp], eax
	call	kvz_cu_array_at_const
	mov	r9, rax
	mov	QWORD PTR cur_cu$1$[rsp], rax

; 211  : 
; 212  :   // NxN signifies implicit transform split at the first transform level.
; 213  :   // There is a similar implicit split for inter, but it is only used when
; 214  :   // transform hierarchy is not in use.
; 215  :   int intra_split_flag = (cur_cu->type == CU_INTRA && cur_cu->part_size == SIZE_NxN);

	movzx	ecx, BYTE PTR [rax]
	movzx	edx, cl
	and	dl, 3
	cmp	dl, 1
	jne	SHORT $LN19@encode_tra
	and	cl, 224					; 000000e0H
	cmp	cl, 96					; 00000060H
	jne	SHORT $LN19@encode_tra

; 220  :     max_tr_depth = ctrl->cfg.tr_depth_intra + intra_split_flag;

	mov	edx, DWORD PTR [rsi+76]
	mov	ecx, 1
	add	edx, ecx

; 221  :   } else {

	jmp	SHORT $LN3@encode_tra
$LN19@encode_tra:

; 216  : 
; 217  :   // The implicit split by intra NxN is not counted towards max_tr_depth.
; 218  :   int max_tr_depth;
; 219  :   if (cur_cu->type == CU_INTRA) {

	xor	ecx, ecx
	cmp	dl, 1
	jne	SHORT $LN2@encode_tra

; 220  :     max_tr_depth = ctrl->cfg.tr_depth_intra + intra_split_flag;

	mov	edx, DWORD PTR [rsi+76]
	add	edx, ecx

; 221  :   } else {

	jmp	SHORT $LN3@encode_tra
$LN2@encode_tra:

; 222  :     max_tr_depth = ctrl->tr_depth_inter;

	mov	edx, DWORD PTR [rsi+6524]
$LN3@encode_tra:

; 225  :   int8_t split = (cur_cu->tr_depth > depth);

	movzx	esi, BYTE PTR [rax+1]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	r8, OFFSET FLAT:cbf_masks
	movsx	rax, r13b
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 225  :   int8_t split = (cur_cu->tr_depth > depth);

	and	esi, 7
	movsx	ebp, r13b
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	edi, 0
	mov	r13d, 0
	movzx	r8d, WORD PTR [r8+rax*2]
	mov	rax, QWORD PTR cur_pu$1$[rsp]
	test	WORD PTR [rax+4], r8w
	mov	eax, 0
	setne	al
	mov	DWORD PTR cb_flag_y$1$[rsp], eax
	movzx	eax, WORD PTR [r9+4]
	mov	r9d, r8d
	shl	r9d, 5
	and	r9d, eax
	mov	DWORD PTR tv1100[rsp], r9d
	setne	r13b
	shl	r8d, 10
	and	r8d, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 238  :       tr_depth < max_tr_depth &&

	movzx	eax, BYTE PTR depth$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	DWORD PTR tv1099[rsp], r8d
	setne	dil
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 238  :       tr_depth < max_tr_depth &&

	cmp	al, 4
	jge	SHORT $LN9@encode_tra
	test	al, al
	jle	SHORT $LN4@encode_tra
	movsx	eax, r14b
	cmp	eax, edx
	jge	SHORT $LN4@encode_tra
	test	ecx, ecx
	je	SHORT $LN5@encode_tra
	test	r14b, r14b
	je	SHORT $LN4@encode_tra
$LN5@encode_tra:

; 239  :       !(intra_split_flag && tr_depth == 0))
; 240  :   {
; 241  :     cabac->cur_ctx = &(cabac->ctx.trans_subdiv_model[5 - ((kvz_g_convert_to_bit[LCU_WIDTH] + 2) - depth)]);
; 242  :     CABAC_BIN(cabac, split, "split_transform_flag");

	xor	edx, edx
	lea	eax, DWORD PTR [rbp-1]
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rbx+53]
	add	rax, rcx
	mov	rcx, rbx
	cmp	esi, ebp
	mov	QWORD PTR [rbx], rax
	setg	dl
	call	kvz_cabac_encode_bin
$LN4@encode_tra:

; 243  :   }
; 244  : 
; 245  :   // Chroma cb flags are not signaled when one of the following:
; 246  :   // - transform size is 4 (2x2 chroma transform doesn't exist)
; 247  :   // - they have already been signaled to 0 previously
; 248  :   // When they are not present they are inferred to be 0, except for size 4
; 249  :   // when the flags from previous level are used.
; 250  :   if (depth < MAX_PU_DEPTH && state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r15]
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN9@encode_tra

; 251  :     cabac->cur_ctx = &(cabac->ctx.qt_cbf_model_chroma[tr_depth]);

	movsx	rax, r14b
	lea	rcx, QWORD PTR [rbx+60]
	add	rcx, rax
	mov	QWORD PTR [rbx], rcx

; 252  :     if (tr_depth == 0 || parent_coeff_u) {

	test	r14b, r14b
	je	SHORT $LN8@encode_tra
	test	r12b, r12b
	je	SHORT $LN102@encode_tra
$LN8@encode_tra:

; 253  :       CABAC_BIN(cabac, cb_flag_u, "cbf_cb");

	mov	edx, r13d
	mov	rcx, rbx
	call	kvz_cabac_encode_bin

; 254  :     }
; 255  :     if (tr_depth == 0 || parent_coeff_v) {

	test	r14b, r14b
	je	SHORT $LN10@encode_tra
$LN102@encode_tra:
	cmp	BYTE PTR parent_coeff_v$[rsp], 0
	je	SHORT $LN9@encode_tra
$LN10@encode_tra:

; 256  :       CABAC_BIN(cabac, cb_flag_v, "cbf_cr");

	mov	edx, edi
	mov	rcx, rbx
	call	kvz_cabac_encode_bin
$LN9@encode_tra:

; 257  :     }
; 258  :   }
; 259  : 
; 260  :   if (split) {

	cmp	esi, ebp
	jle	$LN11@encode_tra

; 261  :     uint8_t offset = LCU_WIDTH >> (depth + 1);
; 262  :     int x2 = x + offset;
; 263  :     int y2 = y + offset;

	mov	edx, DWORD PTR y$[rsp]
	lea	ecx, DWORD PTR [rbp+1]
	mov	r10d, DWORD PTR x$[rsp]
	mov	eax, 64					; 00000040H
	sar	eax, cl

; 264  :     encode_transform_coeff(state, x,  y,  depth + 1, tr_depth + 1, cb_flag_u, cb_flag_v);

	mov	r8d, edx
	movzx	ecx, al
	inc	r14b
	movzx	eax, dil
	movzx	r12d, r13b
	movzx	edi, BYTE PTR depth$[rsp]
	mov	BYTE PTR [rsp+48], al
	inc	dil
	lea	esi, DWORD PTR [rcx+rdx]
	mov	BYTE PTR [rsp+40], r13b
	lea	ebp, DWORD PTR [rcx+r10]
	mov	BYTE PTR parent_coeff_v$[rsp], al
	movzx	r9d, dil
	mov	BYTE PTR [rsp+32], r14b
	mov	edx, r10d
	mov	rcx, r15
	call	encode_transform_coeff

; 265  :     encode_transform_coeff(state, x2, y,  depth + 1, tr_depth + 1, cb_flag_u, cb_flag_v);

	movzx	r13d, BYTE PTR parent_coeff_v$[rsp]
	movzx	r9d, dil
	mov	r8d, DWORD PTR y$[rsp]
	mov	edx, ebp
	mov	BYTE PTR [rsp+48], r13b
	mov	rcx, r15
	mov	BYTE PTR [rsp+40], r12b
	mov	BYTE PTR [rsp+32], r14b
	call	encode_transform_coeff

; 266  :     encode_transform_coeff(state, x,  y2, depth + 1, tr_depth + 1, cb_flag_u, cb_flag_v);

	mov	edx, DWORD PTR x$[rsp]
	movzx	r9d, dil
	mov	BYTE PTR [rsp+48], r13b
	mov	r8d, esi
	mov	BYTE PTR [rsp+40], r12b
	mov	rcx, r15
	mov	BYTE PTR [rsp+32], r14b
	call	encode_transform_coeff

; 267  :     encode_transform_coeff(state, x2, y2, depth + 1, tr_depth + 1, cb_flag_u, cb_flag_v);

	movzx	r13d, BYTE PTR depth$[rsp]
	mov	r8d, esi
	inc	r13b
	mov	DWORD PTR y$[rsp], esi
	mov	BYTE PTR depth$[rsp], r13b
	mov	DWORD PTR x$[rsp], ebp
	jmp	$LL97@encode_tra
$LN11@encode_tra:

; 268  :     return;
; 269  :   }
; 270  : 
; 271  :   // Luma coded block flag is signaled when one of the following:
; 272  :   // - prediction mode is intra
; 273  :   // - transform depth > 0
; 274  :   // - we have chroma coefficients at this level
; 275  :   // When it is not present, it is inferred to be 1.
; 276  :   if (cur_cu->type == CU_INTRA || tr_depth > 0 || cb_flag_u || cb_flag_v) {

	mov	rsi, QWORD PTR cur_cu$1$[rsp]
	movzx	eax, BYTE PTR [rsi]
	and	al, 3
	cmp	al, 1
	je	SHORT $LN13@encode_tra
	test	r14b, r14b
	jg	SHORT $LN13@encode_tra
	cmp	DWORD PTR tv1100[rsp], 0
	jne	SHORT $LN13@encode_tra
	cmp	DWORD PTR tv1099[rsp], 0
	je	SHORT $LN104@encode_tra
$LN13@encode_tra:

; 277  :       cabac->cur_ctx = &(cabac->ctx.qt_cbf_model_luma[!tr_depth]);

	neg	r14b

; 278  :       CABAC_BIN(cabac, cb_flag_y, "cbf_luma");

	mov	rcx, rbx
	mov	r14d, DWORD PTR cb_flag_y$1$[rsp]
	mov	edx, r14d
	sbb	rax, rax
	add	rax, 57					; 00000039H
	add	rax, rbx
	mov	QWORD PTR [rbx], rax
	call	kvz_cabac_encode_bin
	jmp	SHORT $LN12@encode_tra
$LN104@encode_tra:

; 268  :     return;
; 269  :   }
; 270  : 
; 271  :   // Luma coded block flag is signaled when one of the following:
; 272  :   // - prediction mode is intra
; 273  :   // - transform depth > 0
; 274  :   // - we have chroma coefficients at this level
; 275  :   // When it is not present, it is inferred to be 1.
; 276  :   if (cur_cu->type == CU_INTRA || tr_depth > 0 || cb_flag_u || cb_flag_v) {

	mov	r14d, DWORD PTR cb_flag_y$1$[rsp]
$LN12@encode_tra:

; 279  :   }
; 280  : 
; 281  :   if (cb_flag_y | cb_flag_u | cb_flag_v) {

	or	edi, r13d
	or	edi, r14d
	je	$LN14@encode_tra

; 282  :     if (state->must_code_qp_delta) {

	cmp	BYTE PTR [r15+385], 0
	je	$LN15@encode_tra

; 283  :       const int qp_pred      = kvz_get_cu_ref_qp(state, x_cu, y_cu, state->last_qp);

	movsx	r9d, BYTE PTR [r15+386]
	mov	rcx, r15
	mov	r8d, DWORD PTR y_cu$1$[rsp]
	mov	edx, DWORD PTR x_cu$1$[rsp]
	call	kvz_get_cu_ref_qp

; 284  :       const int qp_delta     = cur_cu->qp - qp_pred;

	movzx	esi, BYTE PTR [rsi+6]
	sub	esi, eax

; 285  :       // Possible deltaQP range depends on bit depth as stated in HEVC specification.
; 286  :       assert(qp_delta >= KVZ_QP_DELTA_MIN && qp_delta <= KVZ_QP_DELTA_MAX && "QP delta not in valid range.");

	lea	eax, DWORD PTR [rsi+26]
	cmp	eax, 51					; 00000033H
	jbe	SHORT $LN22@encode_tra
	mov	r8d, 286				; 0000011eH
	lea	rdx, OFFSET FLAT:$SG4294944844
	lea	rcx, OFFSET FLAT:$SG4294944843
	call	QWORD PTR __imp__wassert
$LN22@encode_tra:

; 287  : 
; 288  :       const int qp_delta_abs = ABS(qp_delta);
; 289  :       cabac_data_t* cabac    = &state->cabac;
; 290  : 
; 291  :       // cu_qp_delta_abs prefix
; 292  :       cabac->cur_ctx = &cabac->ctx.cu_qp_delta_abs[0];
; 293  :       kvz_cabac_write_unary_max_symbol(cabac, cabac->ctx.cu_qp_delta_abs, MIN(qp_delta_abs, 5), 1, 5);

	mov	r8d, 5
	mov	DWORD PTR [rsp+32], 5
	mov	eax, esi
	mov	rcx, rbx
	cdq
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	lea	rdx, QWORD PTR [rbx+64]
	cmp	edi, r8d
	mov	QWORD PTR [rbx], rdx
	cmovl	r8d, edi
	call	kvz_cabac_write_unary_max_symbol

; 294  : 
; 295  :       if (qp_delta_abs >= 5) {

	cmp	edi, 5
	jl	SHORT $LN16@encode_tra

; 296  :         // cu_qp_delta_abs suffix
; 297  :         kvz_cabac_write_ep_ex_golomb(state, cabac, qp_delta_abs - 5, 0);

	lea	r8d, DWORD PTR [rdi-5]
	xor	r9d, r9d
	mov	rdx, rbx
	mov	rcx, r15
	call	kvz_cabac_write_ep_ex_golomb
$LN16@encode_tra:

; 298  :       }
; 299  : 
; 300  :       if (qp_delta != 0) {

	test	esi, esi
	je	SHORT $LN95@encode_tra
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+8], ecx

; 231  :   if (bin_value) {

	jns	SHORT $LN94@encode_tra

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rbx+8], ecx
$LN94@encode_tra:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+24]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN95@encode_tra

; 237  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
$LN95@encode_tra:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 304  :       state->must_code_qp_delta = false;

	mov	BYTE PTR [r15+385], 0
$LN15@encode_tra:

; 305  :     }
; 306  : 
; 307  :     encode_transform_unit(state, x, y, depth);

	mov	r8d, DWORD PTR y$[rsp]
	mov	r9d, ebp
	mov	edx, DWORD PTR x$[rsp]
	mov	rcx, r15
	call	encode_transform_unit
$LN14@encode_tra:

; 308  :   }
; 309  : }

	add	rsp, 104				; 00000068H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
encode_transform_coeff ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
mv_cand$1 = 128
state$ = 128
cabac$ = 136
cur_cu$ = 144
x$ = 152
y$ = 160
width$ = 168
height$ = 176
depth$ = 184
encode_inter_prediction_unit PROC

; 316  : {

	mov	DWORD PTR [rsp+32], r9d
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r15
	sub	rsp, 72					; 00000048H

; 317  :   // Mergeflag
; 318  :   int16_t num_cand = 0;
; 319  :   cabac->cur_ctx = &(cabac->ctx.cu_merge_flag_ext_model);

	lea	rax, QWORD PTR [rdx+213]
	mov	rbx, rdx
	mov	QWORD PTR [rdx], rax
	mov	r13, rcx

; 320  :   CABAC_BIN(cabac, cur_cu->merged, "MergeFlag");

	movzx	edx, BYTE PTR [r8+1]
	mov	rcx, rbx
	shr	edx, 4
	mov	esi, r9d
	and	edx, 1
	mov	r15, r8
	call	kvz_cabac_encode_bin

; 321  :   num_cand = state->encoder_control->cfg.max_merge;
; 322  :   if (cur_cu->merged) { //merge

	test	BYTE PTR [r15+1], 16
	mov	rax, QWORD PTR [r13]
	movzx	edx, BYTE PTR [rax+2473]
	je	SHORT $LN11@encode_int

; 323  :     if (num_cand > 1) {

	cmp	dl, 1
	jbe	$LN6@encode_int

; 324  :       int32_t ui;
; 325  :       for (ui = 0; ui < num_cand - 1; ui++) {

	xor	edi, edi
	lea	ebp, DWORD PTR [rdx-1]
	test	ebp, ebp
	jle	$LN6@encode_int
$LL4@encode_int:

; 326  :         int32_t symbol = (ui != cur_cu->merge_idx);

	movzx	esi, BYTE PTR [r15+1]
	shr	esi, 5

; 327  :         if (ui == 0) {

	test	edi, edi
	jne	SHORT $LN14@encode_int

; 328  :           cabac->cur_ctx = &(cabac->ctx.cu_merge_idx_ext_model);

	xor	edx, edx
	lea	rax, QWORD PTR [rbx+212]
	test	esi, esi
	mov	QWORD PTR [rbx], rax

; 329  :           CABAC_BIN(cabac, symbol, "MergeIndex");

	mov	rcx, rbx
	setne	dl
	call	kvz_cabac_encode_bin

; 330  :         } else {

	jmp	SHORT $LN36@encode_int
$LN14@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+8], ecx

; 231  :   if (bin_value) {

	cmp	edi, esi
	je	SHORT $LN59@encode_int

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rbx+8], ecx
$LN59@encode_int:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+24]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN36@encode_int

; 237  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
$LN36@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 333  :         if (symbol == 0) break;

	cmp	edi, esi
	je	$LN6@encode_int

; 324  :       int32_t ui;
; 325  :       for (ui = 0; ui < num_cand - 1; ui++) {

	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL4@encode_int

; 402  :                                        cabac->ctx.mvp_idx_model,
; 403  :                                        CU_GET_MV_CAND(cur_cu, ref_list_idx),
; 404  :                                        1,
; 405  :                                        AMVP_MAX_NUM_CANDS - 1);
; 406  : 
; 407  :     } // for ref_list
; 408  :   } // if !merge
; 409  : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN11@encode_int:

; 334  :       }
; 335  :     }
; 336  :   } else {
; 337  :     if (state->frame->slicetype == KVZ_SLICE_B) {

	mov	rax, QWORD PTR [r13+40]
	mov	QWORD PTR [rsp+64], r14
	cmp	DWORD PTR [rax+88], 0
	jne	SHORT $LN20@encode_int

; 338  :       // Code Inter Dir
; 339  :       uint8_t inter_dir = cur_cu->inter.mv_dir-1;

	movzx	edi, BYTE PTR [r15+18]

; 340  : 
; 341  :       if (cur_cu->part_size == SIZE_2Nx2N || (LCU_WIDTH >> depth) != 8) {

	movsxd	rcx, DWORD PTR depth$[rsp]
	shr	dil, 6
	dec	dil
	cmp	BYTE PTR [r15], 32			; 00000020H
	jb	SHORT $LN19@encode_int
	mov	eax, 64					; 00000040H
	sar	eax, cl
	cmp	eax, 8
	je	SHORT $LN18@encode_int
$LN19@encode_int:

; 342  :         cabac->cur_ctx = &(cabac->ctx.inter_dir[depth]);

	add	rcx, 48					; 00000030H

; 343  :         CABAC_BIN(cabac, (inter_dir == 2), "inter_pred_idc");

	xor	edx, edx
	add	rcx, rbx
	cmp	dil, 2
	mov	QWORD PTR [rbx], rcx
	mov	rcx, rbx
	sete	dl
	call	kvz_cabac_encode_bin
$LN18@encode_int:

; 344  :       }
; 345  :       if (inter_dir < 2) {

	cmp	dil, 2
	jae	SHORT $LN20@encode_int

; 346  :         cabac->cur_ctx = &(cabac->ctx.inter_dir[4]);

	lea	rax, QWORD PTR [rbx+52]

; 347  :         CABAC_BIN(cabac, inter_dir, "inter_pred_idc");

	movzx	edx, dil
	mov	rcx, rbx
	mov	QWORD PTR [rbx], rax
	call	kvz_cabac_encode_bin
$LN20@encode_int:

; 348  :       }
; 349  :     }
; 350  : 
; 351  :     for (uint32_t ref_list_idx = 0; ref_list_idx < 2; ref_list_idx++) {

	xor	r14d, r14d
	mov	QWORD PTR [rsp+136], r12
	npad	4
$LL7@encode_int:

; 352  :       if (!(cur_cu->inter.mv_dir & (1 << ref_list_idx))) {

	movzx	edx, BYTE PTR [r15+18]
	mov	ecx, r14d
	mov	eax, 1
	shr	edx, 6
	shl	eax, cl
	test	dl, al
	je	$LN5@encode_int

; 353  :         continue;
; 354  :       }
; 355  : 
; 356  :       // size of the current reference index list (L0/L1)
; 357  :       uint8_t ref_LX_size = state->frame->ref_LX_size[ref_list_idx];

	mov	rax, QWORD PTR [r13+40]
	movzx	edi, BYTE PTR [r14+rax+81]

; 358  : 
; 359  :       if (ref_LX_size > 1) {

	cmp	dil, 1
	jbe	$LN46@encode_int

; 360  :         // parseRefFrmIdx
; 361  :         int32_t ref_frame = cur_cu->inter.mv_ref[ref_list_idx];

	movzx	esi, BYTE PTR [r14+r15+16]

; 362  : 
; 363  :         cabac->cur_ctx = &(cabac->ctx.cu_ref_pic_model[0]);

	lea	rax, QWORD PTR [rbx+217]

; 364  :         CABAC_BIN(cabac, (ref_frame != 0), "ref_idx_lX");

	xor	edx, edx
	mov	QWORD PTR [rbx], rax
	test	esi, esi
	mov	rcx, rbx
	setne	dl
	call	kvz_cabac_encode_bin

; 365  : 
; 366  :         if (ref_frame > 0) {

	test	esi, esi
	je	SHORT $LN64@encode_int

; 367  :           ref_frame--;
; 368  : 
; 369  :           int32_t ref_num = ref_LX_size - 2;

	lea	ebp, DWORD PTR [rdi-2]
	dec	esi

; 370  : 
; 371  :           for (int32_t i = 0; i < ref_num; ++i) {

	xor	edi, edi
	test	ebp, ebp
	jle	SHORT $LN64@encode_int
	npad	4
$LL10@encode_int:

; 372  :             const uint32_t symbol = (i == ref_frame) ? 0 : 1;
; 373  : 
; 374  :             if (i == 0) {

	test	edi, edi
	jne	SHORT $LN24@encode_int

; 375  :               cabac->cur_ctx = &cabac->ctx.cu_ref_pic_model[1];

	xor	edx, edx
	lea	rax, QWORD PTR [rbx+218]
	test	esi, esi
	mov	QWORD PTR [rbx], rax

; 376  :               CABAC_BIN(cabac, symbol, "ref_idx_lX");

	mov	rcx, rbx
	setne	dl
	call	kvz_cabac_encode_bin

; 377  :             } else {

	jmp	SHORT $LN40@encode_int
$LN24@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+8], ecx

; 231  :   if (bin_value) {

	cmp	edi, esi
	je	SHORT $LN60@encode_int

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rbx+8], ecx
$LN60@encode_int:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+24]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN40@encode_int

; 237  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
$LN40@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 380  :             if (symbol == 0) break;

	cmp	edi, esi
	je	SHORT $LN64@encode_int

; 370  : 
; 371  :           for (int32_t i = 0; i < ref_num; ++i) {

	inc	edi
	cmp	edi, ebp
	jl	SHORT $LL10@encode_int
$LN64@encode_int:

; 381  :           }
; 382  :         }
; 383  :       }
; 384  : 
; 385  :       if (state->frame->ref_list != REF_PIC_LIST_1 || cur_cu->inter.mv_dir != 3) {

	mov	esi, DWORD PTR x$[rsp]
$LN46@encode_int:
	mov	rax, QWORD PTR [r13+40]
	cmp	BYTE PTR [rax+48], 1
	jne	SHORT $LN61@encode_int
	movzx	ecx, BYTE PTR [r15+18]
	movzx	eax, cl
	and	al, 192					; 000000c0H
	cmp	al, 192					; 000000c0H
	je	$LN27@encode_int
$LN61@encode_int:

; 386  : 
; 387  :         int16_t mv_cand[2][2];
; 388  :         kvz_inter_get_mv_cand_cua(

	mov	r9d, DWORD PTR width$[rsp]
	lea	rax, QWORD PTR mv_cand$1[rsp]
	mov	r8d, DWORD PTR y$[rsp]
	mov	edx, esi
	mov	BYTE PTR [rsp+56], r14b
	mov	rcx, r13
	mov	QWORD PTR [rsp+48], r15
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR height$[rsp]
	mov	DWORD PTR [rsp+32], eax
	call	kvz_inter_get_mv_cand_cua

; 389  :             state,
; 390  :             x, y, width, height,
; 391  :             mv_cand, cur_cu, ref_list_idx);
; 392  : 
; 393  :         uint8_t cu_mv_cand = CU_GET_MV_CAND(cur_cu, ref_list_idx);

	movzx	ecx, BYTE PTR [r15+18]

; 394  :         const int32_t mvd_hor = cur_cu->inter.mv[ref_list_idx][0] - mv_cand[cu_mv_cand][0];
; 395  :         const int32_t mvd_ver = cur_cu->inter.mv[ref_list_idx][1] - mv_cand[cu_mv_cand][1];

	movsx	r9d, WORD PTR [r15+r14*4+10]
	mov	edx, ecx
	movsx	r8d, WORD PTR [r15+r14*4+8]
	movzx	eax, cl
	shr	al, 3

; 396  : 
; 397  :         kvz_encode_mvd(state, cabac, mvd_hor, mvd_ver);

	mov	rcx, r13
	movzx	eax, al
	test	r14d, r14d
	cmovne	edx, eax
	and	edx, 7
	movsx	eax, WORD PTR mv_cand$1[rsp+rdx*4+2]
	sub	r9d, eax
	movsx	eax, WORD PTR mv_cand$1[rsp+rdx*4]
	sub	r8d, eax
	mov	rdx, rbx
	call	kvz_encode_mvd
	movzx	ecx, BYTE PTR [r15+18]
$LN27@encode_int:

; 398  :       }
; 399  : 
; 400  :       // Signal which candidate MV to use
; 401  :       kvz_cabac_write_unary_max_symbol(cabac,

	movzx	r8d, cl
	lea	rdx, QWORD PTR [rbx+219]
	mov	eax, r8d
	mov	DWORD PTR [rsp+32], 1
	shr	r8d, 3
	and	eax, 7
	and	r8d, 7
	mov	rcx, rbx
	test	r14d, r14d
	cmove	r8d, eax
	call	kvz_cabac_write_unary_max_symbol
$LN5@encode_int:

; 348  :       }
; 349  :     }
; 350  : 
; 351  :     for (uint32_t ref_list_idx = 0; ref_list_idx < 2; ref_list_idx++) {

	inc	r14d
	cmp	r14d, 2
	jb	$LL7@encode_int
	mov	r14, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+136]
$LN6@encode_int:

; 402  :                                        cabac->ctx.mvp_idx_model,
; 403  :                                        CU_GET_MV_CAND(cur_cu, ref_list_idx),
; 404  :                                        1,
; 405  :                                        AMVP_MAX_NUM_CANDS - 1);
; 406  : 
; 407  :     } // for ref_list
; 408  :   } // if !merge
; 409  : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
encode_inter_prediction_unit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
sets$ = 0
state$dead$ = 80
nb_elems$ = 88
intra_pred_mode$ = 88
intra_mode_encryption PROC

; 414  : {

	push	rbp
	mov	rbp, rsp
	sub	rsp, 64					; 00000040H

; 415  :   const uint8_t sets[3][17] =
; 416  :   {
; 417  :     {  0,  1,  2,  3,  4,  5, 15, 16, 17, 18, 19, 20, 21, 31, 32, 33, 34},  /* 17 */
; 418  :     { 22, 23, 24, 25, 27, 28, 29, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1},  /* 9  */
; 419  :     {  6,  7,  8,  9, 11, 12, 13, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1}   /* 9  */
; 420  :   };
; 421  : 
; 422  :   const uint8_t nb_elems[3] = {17, 8, 8};
; 423  : 
; 424  :   if (intra_pred_mode == 26 || intra_pred_mode == 10) {

	lea	eax, DWORD PTR [rdx-10]
	mov	DWORD PTR sets$[rbp-64], 50462976	; 03020100H
	mov	DWORD PTR sets$[rbp-60], 269419780	; 100f0504H
	mov	DWORD PTR sets$[rbp-56], 336794129	; 14131211H
	mov	DWORD PTR sets$[rbp-52], 555753237	; 21201f15H
	mov	DWORD PTR sets$[rbp-48], 404166178	; 18171622H
	mov	DWORD PTR sets$[rbp-44], 488381209	; 1d1c1b19H
	mov	QWORD PTR sets$[rbp-40], -226		; ffffffffffffff1eH
	mov	DWORD PTR sets$[rbp-32], 117899263	; 0706ffffH
	mov	DWORD PTR sets$[rbp-28], 202049800	; 0c0b0908H
	mov	QWORD PTR sets$[rbp-24], -61939		; ffffffffffff0e0dH
	mov	WORD PTR sets$[rbp-16], 65535		; 0000ffffH
	mov	BYTE PTR sets$[rbp-14], 255		; 000000ffH
	mov	WORD PTR nb_elems$[rbp-64], 2065	; 00000811H
	mov	BYTE PTR nb_elems$[rbp-62], 8
	test	al, 239					; 000000efH
	je	SHORT $LN7@intra_mode

; 427  : 
; 428  :   } else {
; 429  :     uint8_t keybits, scan_dir, elem_idx=0;
; 430  : 
; 431  :     keybits = kvz_crypto_get_key(state->crypto_hdl, 5);
; 432  : 
; 433  :     scan_dir = SCAN_DIAG;
; 434  :     if (intra_pred_mode > 5  && intra_pred_mode < 15) {
; 435  :       scan_dir = SCAN_VER;
; 436  :     }
; 437  :     if (intra_pred_mode > 21 && intra_pred_mode < 31) {

	xor	ecx, ecx
	lea	eax, DWORD PTR [rdx-6]
	xor	r11b, r11b
	mov	r8d, 1
	cmp	al, 8
	mov	r10d, 2
	lea	eax, DWORD PTR [rdx-22]
	cmova	r10d, ecx
	cmp	al, 8
	cmovbe	r10d, r8d

; 438  :       scan_dir = SCAN_HOR;
; 439  :     }
; 440  : 
; 441  :     for (int i = 0; i < nb_elems[scan_dir]; i++) {

	movzx	r8d, BYTE PTR nb_elems$[rbp+r10-64]
	test	r8d, r8d
	je	SHORT $LN3@intra_mode
	imul	r9, r10, 17
	npad	2
$LL4@intra_mode:

; 442  :       if (intra_pred_mode == sets[scan_dir][i]) {

	mov	eax, ecx
	add	rax, r9
	cmp	dl, BYTE PTR sets$[rbp+rax-64]
	je	SHORT $LN13@intra_mode

; 438  :       scan_dir = SCAN_HOR;
; 439  :     }
; 440  : 
; 441  :     for (int i = 0; i < nb_elems[scan_dir]; i++) {

	inc	ecx
	cmp	ecx, r8d
	jl	SHORT $LL4@intra_mode

; 442  :       if (intra_pred_mode == sets[scan_dir][i]) {

	jmp	SHORT $LN3@intra_mode
$LN13@intra_mode:

; 443  :         elem_idx = i;

	movzx	r11d, cl
$LN3@intra_mode:

; 444  :         break;
; 445  :       }
; 446  :     }
; 447  : 
; 448  :     keybits = keybits % nb_elems[scan_dir];
; 449  :     keybits = (elem_idx + keybits) % nb_elems[scan_dir];
; 450  : 
; 451  :     return sets[scan_dir][keybits];

	movzx	eax, r11b
	xor	edx, edx
	div	r8d
	imul	rcx, r10, 17
	lea	rax, QWORD PTR sets$[rbp-64]
	movzx	r8d, dl
	add	rax, rcx
	movzx	eax, BYTE PTR [rax+r8]

; 452  :   }
; 453  : }

	add	rsp, 64					; 00000040H
	pop	rbp
	ret	0
$LN7@intra_mode:

; 425  :     // correct chroma intra prediction mode
; 426  :     return intra_pred_mode;

	movzx	eax, dl

; 452  :   }
; 453  : }

	add	rsp, 64					; 00000040H
	pop	rbp
	ret	0
intra_mode_encryption ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
intra_pred_mode_chroma$1$ = 64
mpm_preds$ = 68
intra_preds$ = 72
intra_pred_mode_encry$ = 88
cu_width$1$ = 92
depth$1$ = 96
frame$1$ = 104
$T2 = 112
tv3202 = 120
cur_pu$1$ = 128
tv3246 = 136
flag$ = 144
state$ = 240
cabac$ = 248
cur_cu$ = 256
x$ = 264
y$ = 272
intra_pred_mode_actual$ = 280
depth$ = 280
encode_intra_coding_unit PROC

; 460  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-15]
	sub	rsp, 168				; 000000a8H

; 461  :   const videoframe_t * const frame = state->tile->frame;

	mov	rax, QWORD PTR [rcx+48]

; 462  :   uint8_t intra_pred_mode_actual[4];
; 463  :   uint8_t *intra_pred_mode = intra_pred_mode_actual;
; 464  : 
; 465  : #if KVZ_SEL_ENCRYPTION
; 466  :   const bool do_crypto =
; 467  :     !state->cabac.only_count &&
; 468  :     state->encoder_control->cfg.crypto_features & KVZ_CRYPTO_INTRA_MODE;
; 469  : #else
; 470  :   const bool do_crypto = false;
; 471  : #endif
; 472  : 
; 473  :   uint8_t intra_pred_mode_encry[4] = {-1, -1, -1, -1};
; 474  :   if (do_crypto) {
; 475  :     intra_pred_mode = intra_pred_mode_encry;
; 476  :   }
; 477  : 
; 478  :   uint8_t intra_pred_mode_chroma = cur_cu->intra.mode_chroma;
; 479  :   int8_t intra_preds[4][3] = {{-1, -1, -1},{-1, -1, -1},{-1, -1, -1},{-1, -1, -1}};
; 480  :   int8_t mpm_preds[4] = {-1, -1, -1, -1};
; 481  :   uint32_t flag[4];
; 482  : 
; 483  :   #if ENABLE_PCM == 1
; 484  :   // Code must start after variable initialization
; 485  :   kvz_cabac_encode_bin_trm(cabac, 0); // IPCMFlag == 0
; 486  :   #endif
; 487  : 
; 488  :   // PREDINFO CODING
; 489  :   // If intra prediction mode is found from the predictors,
; 490  :   // it can be signaled with two EP's. Otherwise we can send
; 491  :   // 5 EP bins with the full predmode
; 492  :   const int num_pred_units = kvz_part_mode_num_parts[cur_cu->part_size];

	lea	rdi, OFFSET FLAT:__ImageBase

; 493  :   const int cu_width = LCU_WIDTH >> depth;

	mov	r13d, DWORD PTR depth$[rbp-153]
	mov	rbx, rdx

; 494  : 
; 495  :   for (int j = 0; j < num_pred_units; ++j) {

	mov	esi, DWORD PTR y$[rbp-153]
	mov	r11d, r9d
	mov	r15, rcx
	mov	DWORD PTR intra_pred_mode_encry$[rbp-153], -1 ; ffffffffH
	mov	rdx, QWORD PTR [rax]
	mov	r9d, 64					; 00000040H
	movzx	eax, BYTE PTR [r8]
	mov	ecx, r13d
	shr	rax, 5
	mov	r10, r8
	sar	r9d, cl
	mov	QWORD PTR frame$1$[rbp-153], rdx
	movzx	edx, BYTE PTR [r8+9]
	movzx	r12d, BYTE PTR kvz_part_mode_num_parts[rax+rdi]
	mov	BYTE PTR intra_pred_mode_chroma$1$[rbp-153], dl
	mov	QWORD PTR intra_preds$[rbp-153], -1
	mov	DWORD PTR intra_preds$[rbp-145], -1	; ffffffffH
	mov	DWORD PTR mpm_preds$[rbp-153], -1	; ffffffffH
	mov	DWORD PTR depth$1$[rbp-153], r13d
	mov	DWORD PTR cu_width$1$[rbp-153], r9d
	mov	QWORD PTR tv3246[rbp-153], r12
	test	r12, r12
	je	$LN3@encode_int
	mov	rbx, QWORD PTR frame$1$[rbp-153]
	xor	r14d, r14d
	mov	r8d, r14d
	mov	QWORD PTR $T2[rbp-153], r14
	mov	r15d, r14d
	mov	QWORD PTR tv3202[rbp-153], r14
	npad	3
$LL4@encode_int:

; 496  :     const int pu_x = PU_GET_X(cur_cu->part_size, cu_width, x, j);

	movzx	eax, BYTE PTR [r10]
	shr	rax, 5
	lea	rax, QWORD PTR [r8+rax*4]
	lea	rcx, QWORD PTR [rax+rax]
	movzx	eax, BYTE PTR kvz_part_mode_offsets[rcx+rdi]
	imul	eax, r9d
	cdq
	and	edx, 3
	lea	r13d, DWORD PTR [rdx+rax]

; 497  :     const int pu_y = PU_GET_Y(cur_cu->part_size, cu_width, y, j);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[rcx+rdi+1]
	imul	eax, r9d
	sar	r13d, 2
	add	r13d, r11d
	cdq
	and	edx, 3
	lea	edi, DWORD PTR [rdx+rax]
	sar	edi, 2
	add	edi, esi

; 498  :     const cu_info_t *cur_pu = kvz_cu_array_at_const(frame->cu_array, pu_x, pu_y);

	mov	rsi, QWORD PTR [rbx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r13d, DWORD PTR [rsi+16]
	jb	SHORT $LN53@encode_int
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN53@encode_int:

; 102  :   assert(y_px < cua->height);

	cmp	edi, DWORD PTR [rsi+20]
	jb	SHORT $LN54@encode_int
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN54@encode_int:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rsi+24]
	mov	eax, r13d
	sar	ecx, 2
	mov	r12d, edi
	shr	eax, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 501  :     const cu_info_t *above_pu = NULL;

	mov	r8, r14
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	shr	r12d, 2
	imul	ecx, r12d
	add	ecx, eax
	mov	rax, QWORD PTR [rsi+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 500  :     const cu_info_t *left_pu = NULL;

	mov	rsi, r14
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR cur_pu$1$[rbp-153], rax
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 503  :     if (pu_x > 0) {

	test	r13d, r13d
	jle	$LN24@encode_int

; 504  :       assert(pu_x >> 2 > 0);

	test	r13d, -4
	jg	SHORT $LN46@encode_int
	mov	r8d, 504				; 000001f8H
	lea	rdx, OFFSET FLAT:$SG4294944842
	lea	rcx, OFFSET FLAT:$SG4294944841
	call	QWORD PTR __imp__wassert
$LN46@encode_int:

; 505  :       left_pu = kvz_cu_array_at_const(frame->cu_array, pu_x - 1, pu_y);

	mov	rsi, QWORD PTR [rbx+32]
	lea	r15d, DWORD PTR [r13-1]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r15d, DWORD PTR [rsi+16]
	jb	SHORT $LN57@encode_int
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN57@encode_int:

; 102  :   assert(y_px < cua->height);

	cmp	edi, DWORD PTR [rsi+20]
	jb	SHORT $LN58@encode_int
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN58@encode_int:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rsi+24]
	mov	r8, r14
	sar	eax, 2
	imul	eax, r12d
	shr	r15d, 2
	add	eax, r15d
	mov	r15, QWORD PTR tv3202[rbp-153]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rsi+8]
	lea	rsi, QWORD PTR [rax+rcx*4]
$LN24@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 508  :     if (pu_y % LCU_WIDTH > 0 && pu_y > 0) {

	mov	eax, edi
	and	eax, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN190@encode_int
	dec	eax
	or	eax, -64				; ffffffffffffffc0H
	inc	eax
$LN190@encode_int:
	test	eax, eax
	jle	SHORT $LN183@encode_int
	test	edi, edi
	jle	SHORT $LN183@encode_int

; 509  :       assert(pu_y >> 2 > 0);

	test	edi, -4
	jg	SHORT $LN47@encode_int
	mov	r8d, 509				; 000001fdH
	lea	rdx, OFFSET FLAT:$SG4294944840
	lea	rcx, OFFSET FLAT:$SG4294944839
	call	QWORD PTR __imp__wassert
$LN47@encode_int:

; 510  :       above_pu = kvz_cu_array_at_const(frame->cu_array, pu_x, pu_y - 1);

	mov	rcx, QWORD PTR [rbx+32]
	lea	r8d, DWORD PTR [rdi-1]
	mov	edx, r13d
	call	kvz_cu_array_at_const
	mov	r8, rax
$LN183@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 93   :   int8_t left_intra_dir  = 1;

	mov	dl, 1

; 94   :   if (left_pu && left_pu->type == CU_INTRA) {

	test	rsi, rsi
	je	SHORT $LN60@encode_int
	movzx	ecx, BYTE PTR [rsi]
	and	cl, 3
	cmp	cl, dl
	jne	SHORT $LN60@encode_int

; 95   :     left_intra_dir = left_pu->intra.mode;

	movzx	edx, BYTE PTR [rsi+8]
$LN60@encode_int:

; 96   :   }
; 97   : 
; 98   :   int8_t above_intra_dir = 1;

	mov	cl, 1

; 99   :   if (above_pu && above_pu->type == CU_INTRA && y % LCU_WIDTH != 0) {

	test	r8, r8
	je	SHORT $LN61@encode_int
	movzx	eax, BYTE PTR [r8]
	and	al, 3
	cmp	al, cl
	jne	SHORT $LN61@encode_int
	test	dil, 63					; 0000003fH
	je	SHORT $LN61@encode_int

; 100  :     above_intra_dir = above_pu->intra.mode;

	movzx	ecx, BYTE PTR [r8+8]
$LN61@encode_int:

; 101  :   }
; 102  : 
; 103  :   // If the predictions are the same, add new predictions
; 104  :   if (left_intra_dir == above_intra_dir) {

	cmp	dl, cl
	jne	SHORT $LN62@encode_int

; 105  :     if (left_intra_dir > 1) { // angular modes

	cmp	dl, 1
	jle	SHORT $LN64@encode_int

; 106  :       preds[0] = left_intra_dir;
; 107  :       preds[1] = ((left_intra_dir + 29) % 32) + 2;

	movsx	ecx, dl

; 108  :       preds[2] = ((left_intra_dir - 1 ) % 32) + 2;

	lea	eax, DWORD PTR [rcx-1]
	and	eax, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN189@encode_int
	dec	eax
	or	eax, -32				; ffffffffffffffe0H
	inc	eax
$LN189@encode_int:
	add	al, 2
	add	ecx, 29
	and	ecx, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN188@encode_int

; 106  :       preds[0] = left_intra_dir;
; 107  :       preds[1] = ((left_intra_dir + 29) % 32) + 2;

	dec	ecx
	or	ecx, -32				; ffffffffffffffe0H
	inc	ecx
$LN188@encode_int:
	add	cl, 2

; 109  :     } else { //non-angular

	jmp	SHORT $LN65@encode_int
$LN64@encode_int:

; 110  :       preds[0] = 0;//PLANAR_IDX;
; 111  :       preds[1] = 1;//DC_IDX;
; 112  :       preds[2] = 26;//VER_IDX;

	mov	al, 26
	mov	cl, 1
	xor	dl, dl
$LN65@encode_int:

; 113  :     }
; 114  :   } else { // If we have two distinct predictions

	lea	r8, QWORD PTR intra_preds$[rbp-151]
	add	r8, r15
	mov	BYTE PTR [r8-2], dl
	mov	BYTE PTR [r8-1], cl
	jmp	SHORT $LN67@encode_int
$LN62@encode_int:

; 115  :     preds[0] = left_intra_dir;

	lea	r8, QWORD PTR intra_preds$[rbp-151]
	add	r8, r15
	mov	BYTE PTR [r8-2], dl

; 116  :     preds[1] = above_intra_dir;

	mov	BYTE PTR [r8-1], cl

; 117  : 
; 118  :     // add planar mode if it's not yet present
; 119  :     if (left_intra_dir && above_intra_dir ) {

	test	dl, dl
	je	SHORT $LN66@encode_int
	test	cl, cl
	je	SHORT $LN66@encode_int

; 120  :       preds[2] = 0; // PLANAR_IDX;

	xor	al, al

; 121  :     } else {  // Add DC mode if it's not present, otherwise 26.

	jmp	SHORT $LN67@encode_int
$LN66@encode_int:

; 122  :       preds[2] =  (left_intra_dir+above_intra_dir)<2? 26 : 1;

	movsx	ecx, cl
	movsx	eax, dl
	add	ecx, eax
	mov	eax, 1
	cmp	ecx, 2
	mov	ecx, 26
	cmovl	eax, ecx
$LN67@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 529  :     intra_pred_mode_actual[j] = cur_pu->intra.mode;

	mov	BYTE PTR [r8], al

; 530  :     if (do_crypto) {
; 531  :       intra_pred_mode_encry[j] = intra_mode_encryption(state, cur_pu->intra.mode);
; 532  :     }
; 533  : 
; 534  :     for (int i = 0; i < 3; i++) {

	mov	ecx, r14d
	mov	rax, QWORD PTR cur_pu$1$[rbp-153]
	mov	r8, QWORD PTR $T2[rbp-153]
	movzx	edx, BYTE PTR [rax+8]
	mov	BYTE PTR intra_pred_mode_actual$[rbp+r8-153], dl
$LL7@encode_int:

; 535  :       if (intra_preds[j][i] == intra_pred_mode[j]) {

	mov	eax, ecx
	add	rax, r15
	movsx	eax, BYTE PTR intra_preds$[rbp+rax-153]
	cmp	eax, edx
	je	SHORT $LN123@encode_int

; 530  :     if (do_crypto) {
; 531  :       intra_pred_mode_encry[j] = intra_mode_encryption(state, cur_pu->intra.mode);
; 532  :     }
; 533  : 
; 534  :     for (int i = 0; i < 3; i++) {

	inc	ecx
	cmp	ecx, 3
	jl	SHORT $LL7@encode_int

; 535  :       if (intra_preds[j][i] == intra_pred_mode[j]) {

	jmp	SHORT $LN6@encode_int
$LN123@encode_int:

; 536  :         mpm_preds[j] = (int8_t)i;

	mov	BYTE PTR mpm_preds$[rbp+r8-153], cl
$LN6@encode_int:

; 537  :         break;
; 538  :       }
; 539  :     }
; 540  :     flag[j] = (mpm_preds[j] == -1) ? 0 : 1;

	cmp	BYTE PTR mpm_preds$[rbp+r8-153], -1
	lea	rdi, OFFSET FLAT:__ImageBase
	mov	r12, QWORD PTR tv3246[rbp-153]
	mov	eax, r14d
	mov	r9d, DWORD PTR cu_width$1$[rbp-153]
	setne	al
	mov	r10, QWORD PTR cur_cu$[rbp-153]
	add	r15, 3
	mov	r11d, DWORD PTR x$[rbp-153]
	mov	esi, DWORD PTR y$[rbp-153]
	mov	DWORD PTR flag$[rbp+r8*4-153], eax
	inc	r8
	mov	QWORD PTR $T2[rbp-153], r8
	mov	QWORD PTR tv3202[rbp-153], r15
	cmp	r8, r12
	jl	$LL4@encode_int
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 232  :     data->low += data->range;

	mov	rbx, QWORD PTR cabac$[rbp-153]
	mov	rdi, r14
	lea	rax, QWORD PTR [rbx+45]
	mov	QWORD PTR [rbx], rax
	npad	2
$LL10@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 565  :     CABAC_BIN(cabac, flag[j], "prev_intra_luma_pred_flag");

	mov	edx, DWORD PTR flag$[rbp+rdi*4-153]
	mov	rcx, rbx
	call	kvz_cabac_encode_bin
	inc	rdi
	cmp	rdi, r12
	jl	SHORT $LL10@encode_int
	lea	rdi, QWORD PTR intra_preds$[rbp-153]
$LL13@encode_int:

; 569  :     // Signal index of the prediction mode in the prediction list.
; 570  :     if (flag[j]) {

	cmp	DWORD PTR flag$[rbp+r14*4-153], 0
	je	SHORT $LN30@encode_int
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 571  :       CABAC_BIN_EP(cabac, (mpm_preds[j] == 0 ? 0 : 1), "mpm_idx");

	movzx	esi, BYTE PTR mpm_preds$[rbp+r14-153]
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+8], ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 571  :       CABAC_BIN_EP(cabac, (mpm_preds[j] == 0 ? 0 : 1), "mpm_idx");

	test	sil, sil
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 231  :   if (bin_value) {

	je	SHORT $LN184@encode_int

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rbx+8], ecx
$LN184@encode_int:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+24]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN82@encode_int

; 237  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
$LN82@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 572  :       if (mpm_preds[j] != 0) {

	test	sil, sil
	je	$LN11@encode_int
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+8], ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 573  :         CABAC_BIN_EP(cabac, (mpm_preds[j] == 1 ? 0 : 1), "mpm_idx");

	cmp	sil, 1
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 231  :   if (bin_value) {

	je	SHORT $LN185@encode_int

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+12]
	mov	DWORD PTR [rbx+8], ecx
$LN185@encode_int:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+24]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 575  :     } else {

	jmp	$LN192@encode_int
$LN30@encode_int:

; 576  :       // Signal the actual prediction mode.
; 577  :       int32_t tmp_pred = intra_pred_mode[j];
; 578  : 
; 579  :       // Sort prediction list from lowest to highest.
; 580  :       if (intra_preds[j][0] > intra_preds[j][1]) SWAP(intra_preds[j][0], intra_preds[j][1], int8_t);

	movzx	ecx, BYTE PTR [rdi+1]
	movzx	eax, BYTE PTR [rdi]
	movzx	edx, cl
	movzx	esi, BYTE PTR intra_pred_mode_actual$[rbp+r14-153]
	movzx	r9d, cl
	movzx	r11d, al
	cmp	al, cl
	jle	SHORT $LN33@encode_int
	movzx	edx, al
	mov	BYTE PTR [rdi], cl
	mov	BYTE PTR [rdi+1], dl
	movzx	r9d, dl
	movzx	eax, cl
	movzx	r11d, cl
$LN33@encode_int:

; 581  :       if (intra_preds[j][0] > intra_preds[j][2]) SWAP(intra_preds[j][0], intra_preds[j][2], int8_t);

	movzx	ecx, BYTE PTR [rdi+2]
	movzx	r8d, cl
	movzx	r10d, cl
	cmp	al, cl
	jle	SHORT $LN34@encode_int
	mov	BYTE PTR [rdi], cl
	movzx	r8d, al
	mov	BYTE PTR [rdi+2], al
	movzx	r10d, al
	movzx	r11d, cl
$LN34@encode_int:

; 582  :       if (intra_preds[j][1] > intra_preds[j][2]) SWAP(intra_preds[j][1], intra_preds[j][2], int8_t);

	cmp	dl, r8b
	jle	SHORT $LL174@encode_int
	mov	BYTE PTR [rdi+1], r8b
	movzx	r10d, dl
	mov	BYTE PTR [rdi+2], dl
	movzx	r9d, r8b
	npad	11
$LL174@encode_int:

; 588  :         tmp_pred = (tmp_pred > intra_preds[j][i] ? tmp_pred - 1 : tmp_pred);

	movsx	eax, r10b
	lea	ecx, DWORD PTR [rsi-1]
	cmp	esi, eax
	movsx	eax, r9b
	cmovle	ecx, esi
	cmp	ecx, eax
	movsx	eax, r11b
	lea	edx, DWORD PTR [rcx-1]
	cmovle	edx, ecx
	cmp	edx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 261  :   data->low <<= num_bins;

	mov	eax, DWORD PTR [rbx+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 587  :       for (int i = 2; i >= 0; i--) {

	lea	ecx, DWORD PTR [rdx-1]
	cmovle	ecx, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 262  :   data->low += data->range * bin_values;

	mov	edx, DWORD PTR [rbx+12]
	imul	edx, ecx
	shl	eax, 5
	add	edx, eax

; 263  :   data->bits_left -= num_bins;

	add	DWORD PTR [rbx+24], -5
	mov	DWORD PTR [rbx+8], edx
$LN192@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 568  :   for (int j = 0; j < num_pred_units; ++j) {

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN11@encode_int
	mov	rcx, rbx
	call	kvz_cabac_write
$LN11@encode_int:
	inc	r14
	add	rdi, 3
	cmp	r14, r12
	jl	$LL13@encode_int
	movzx	edx, BYTE PTR intra_pred_mode_chroma$1$[rbp-153]
	lea	rdi, OFFSET FLAT:__ImageBase
	mov	r15, QWORD PTR state$[rbp-153]
	mov	r13d, DWORD PTR depth$1$[rbp-153]
	jmp	SHORT $LN12@encode_int
$LN3@encode_int:

; 541  : 
; 542  : #if KVZ_SEL_ENCRYPTION
; 543  :     // Need to wrap in preprocessor directives because
; 544  :     // cu_info_t.intra.mode_encry is only defined when KVZ_SEL_ENCRYPTION
; 545  :     // is defined.
; 546  :     if (do_crypto) {
; 547  :       // Set the modified intra_pred_mode of the current pu here to make it
; 548  :       // available from its neighbours for mpm decision.
; 549  : 
; 550  :       // FIXME: there might be a more efficient way to propagate mode_encry
; 551  :       // for future use from left and above PUs
; 552  :       const int pu_width = PU_GET_W(cur_cu->part_size, cu_width, j);
; 553  :       for (int y = pu_y; y < pu_y + pu_width; y += 4 ) {
; 554  :         for (int x = pu_x; x < pu_x + pu_width; x += 4) {
; 555  :           cu_info_t *cu = kvz_cu_array_at(frame->cu_array, x, y);
; 556  :           cu->intra.mode_encry = intra_pred_mode_encry[j];
; 557  :         }
; 558  :       }
; 559  :     }
; 560  : #endif
; 561  :   }
; 562  : 
; 563  :   cabac->cur_ctx = &(cabac->ctx.intra_mode_model);

	lea	rax, QWORD PTR [rbx+45]
	mov	QWORD PTR [rbx], rax
$LN12@encode_int:

; 589  :       }
; 590  : 
; 591  :       CABAC_BINS_EP(cabac, tmp_pred, 5, "rem_intra_luma_pred_mode");
; 592  :     }
; 593  :   }
; 594  : 
; 595  :   // Code chroma prediction mode.
; 596  :   if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r15]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN110@encode_int

; 597  :     unsigned pred_mode = 5;
; 598  :     unsigned chroma_pred_modes[4] = {0, 26, 10, 1};
; 599  : 
; 600  :     if (intra_pred_mode_chroma == intra_pred_mode_actual[0]) {

	mov	eax, DWORD PTR intra_pred_mode_actual$[rbp-153]
	cmp	dl, al
	jne	$LN37@encode_int
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	mov	edx, DWORD PTR [rbx+12]
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 601  :       pred_mode = 4;

	lea	r9, QWORD PTR [rbx+46]
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	mov	ecx, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 601  :       pred_mode = 4;

	mov	QWORD PTR [rbx], r9
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	movzx	r10d, BYTE PTR [r9]
	shr	rcx, 6
	mov	eax, r10d
	shr	rax, 1
	and	ecx, 3
	lea	rcx, QWORD PTR [rcx+rax*4]
	movzx	r8d, BYTE PTR kvz_g_auc_lpst_table[rcx+rdi]

; 109  :   data->range -= lps;

	sub	edx, r8d
	mov	DWORD PTR [rbx+12], edx

; 110  : 
; 111  :   // Not the Most Probable Symbol?
; 112  :   if ((bin_value ? 1 : 0) != CTX_MPS(data->cur_ctx)) {

	test	r10b, 1
	je	SHORT $LN95@encode_int

; 113  :     int num_bits = kvz_g_auc_renorm_table[lps >> 3];

	mov	eax, r8d
	shr	rax, 3
	movzx	ecx, BYTE PTR kvz_g_auc_renorm_table[rax+rdi]

; 114  :     data->low = (data->low + data->range) << num_bits;

	mov	eax, DWORD PTR [rbx+8]
	add	eax, edx

; 115  :     data->range = lps << num_bits;

	shl	r8d, cl
	shl	eax, cl
	mov	DWORD PTR [rbx+8], eax

; 116  : 
; 117  :     CTX_UPDATE_LPS(data->cur_ctx);

	movzx	eax, BYTE PTR kvz_g_auc_next_state_lps[r10+rdi]
	mov	DWORD PTR [rbx+12], r8d
	mov	BYTE PTR [r9], al

; 118  : 
; 119  :     data->bits_left -= num_bits;

	sub	DWORD PTR [rbx+24], ecx

; 127  :   }
; 128  : 
; 129  :   if (data->bits_left < 12) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 12
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 633  :     } else {

	jmp	$LN194@encode_int
$LN95@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 121  :     CTX_UPDATE_MPS(data->cur_ctx);

	movzx	eax, BYTE PTR kvz_g_auc_next_state_mps[r10+rdi]
	mov	BYTE PTR [r9], al

; 122  :     if (data->range >= 256) return;

	cmp	edx, 256				; 00000100H
	jae	$LN110@encode_int

; 126  :     data->bits_left--;

	dec	DWORD PTR [rbx+24]
	lea	eax, DWORD PTR [rdx+rdx]
	shl	DWORD PTR [rbx+8], 1
	mov	DWORD PTR [rbx+12], eax

; 127  :   }
; 128  : 
; 129  :   if (data->bits_left < 12) {

	mov	eax, DWORD PTR [rbx+24]
	cmp	eax, 12
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 633  :     } else {

	jmp	$LN194@encode_int
$LN37@encode_int:

; 602  :     } else if (intra_pred_mode_chroma == 34) {

	cmp	dl, 34					; 00000022H
	jne	SHORT $LN39@encode_int

; 603  :       // Angular 34 mode is possible only if intra pred mode is one of the
; 604  :       // possible chroma pred modes, in which case it is signaled with that
; 605  :       // duplicate mode.
; 606  :       for (int i = 0; i < 4; ++i) {
; 607  :         if (intra_pred_mode_actual[0] == chroma_pred_modes[i]) pred_mode = i;

	movzx	ecx, al
	mov	eax, ecx
	neg	eax
	sbb	edi, edi
	and	edi, 5
	cmp	ecx, 26
	jne	SHORT $LN158@encode_int
	lea	edi, QWORD PTR [rcx-25]
	jmp	SHORT $LN50@encode_int
$LN158@encode_int:
	cmp	ecx, 10
	jne	SHORT $LN160@encode_int
	lea	edi, QWORD PTR [rcx-8]
	jmp	SHORT $LN50@encode_int
$LN160@encode_int:
	cmp	ecx, 1
	jne	SHORT $LN171@encode_int
	lea	edi, QWORD PTR [rcx+2]

; 608  :       }
; 609  :     } else {

	jmp	SHORT $LN50@encode_int
$LN39@encode_int:

; 610  :       for (int i = 0; i < 4; ++i) {
; 611  :         if (intra_pred_mode_chroma == chroma_pred_modes[i]) pred_mode = i;

	movzx	eax, dl
	neg	al
	sbb	edi, edi
	and	edi, 5
	cmp	dl, 26
	jne	SHORT $LN167@encode_int
	mov	edi, 1
	jmp	SHORT $LN50@encode_int
$LN167@encode_int:
	cmp	dl, 10
	jne	SHORT $LN169@encode_int
	mov	edi, 2
	jmp	SHORT $LN50@encode_int
$LN169@encode_int:
	cmp	dl, 1
	jne	SHORT $LN171@encode_int
	mov	edi, 3

; 612  :       }
; 613  :     }
; 614  : 
; 615  :     // pred_mode == 5 mean intra_pred_mode_chroma is something that can't
; 616  :     // be coded.
; 617  :     assert(pred_mode != 5);

	jmp	SHORT $LN50@encode_int
$LN171@encode_int:
	cmp	edi, 5
	jne	SHORT $LN50@encode_int
	mov	r8d, 617				; 00000269H
	lea	rdx, OFFSET FLAT:$SG4294944838
	lea	rcx, OFFSET FLAT:$SG4294944837
	call	QWORD PTR __imp__wassert
$LN50@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 108  :   lps = kvz_g_auc_lpst_table[CTX_STATE(data->cur_ctx)][(data->range >> 6) & 3];

	mov	r9d, DWORD PTR [rbx+12]
	lea	r8, QWORD PTR [rbx+12]
	lea	rdx, QWORD PTR [rbx+46]
	mov	ecx, r9d
	shr	rcx, 6
	lea	r12, OFFSET FLAT:__ImageBase
	and	ecx, 3
	mov	QWORD PTR [rbx], rdx
	movzx	r14d, BYTE PTR [rdx]
	mov	rsi, r8
	mov	eax, r14d
	mov	r10, rdx
	shr	rax, 1
	lea	rcx, QWORD PTR [rcx+rax*4]
	movzx	r11d, BYTE PTR kvz_g_auc_lpst_table[rcx+r12]

; 109  :   data->range -= lps;

	sub	r9d, r11d
	mov	DWORD PTR [r8], r9d

; 110  : 
; 111  :   // Not the Most Probable Symbol?
; 112  :   if ((bin_value ? 1 : 0) != CTX_MPS(data->cur_ctx)) {

	test	r14b, 1
	jne	SHORT $LN101@encode_int

; 113  :     int num_bits = kvz_g_auc_renorm_table[lps >> 3];

	mov	eax, r11d
	shr	rax, 3
	movzx	ecx, BYTE PTR kvz_g_auc_renorm_table[rax+r12]

; 114  :     data->low = (data->low + data->range) << num_bits;

	mov	eax, DWORD PTR [rbx+8]
	add	eax, r9d

; 115  :     data->range = lps << num_bits;

	shl	r11d, cl
	shl	eax, cl
	mov	DWORD PTR [rbx+8], eax

; 116  : 
; 117  :     CTX_UPDATE_LPS(data->cur_ctx);

	movzx	eax, BYTE PTR kvz_g_auc_next_state_lps[r14+r12]
	mov	DWORD PTR [r8], r11d
	mov	BYTE PTR [rdx], al

; 118  : 
; 119  :     data->bits_left -= num_bits;

	sub	DWORD PTR [rbx+24], ecx

; 120  :   } else {

	jmp	SHORT $LN195@encode_int
$LN101@encode_int:

; 121  :     CTX_UPDATE_MPS(data->cur_ctx);

	movzx	eax, BYTE PTR kvz_g_auc_next_state_mps[r14+r12]
	mov	BYTE PTR [rdx], al

; 122  :     if (data->range >= 256) return;

	cmp	r9d, 256				; 00000100H
	jae	SHORT $LN104@encode_int

; 123  : 
; 124  :     data->low <<= 1;

	shl	DWORD PTR [rbx+8], 1

; 125  :     data->range <<= 1;

	lea	r11d, DWORD PTR [r9+r9]

; 126  :     data->bits_left--;

	dec	DWORD PTR [rbx+24]
	mov	DWORD PTR [r8], r11d
$LN195@encode_int:

; 127  :   }
; 128  : 
; 129  :   if (data->bits_left < 12) {

	mov	eax, DWORD PTR [rbx+24]
	mov	r9d, r11d
	cmp	eax, 12
	jge	SHORT $LN104@encode_int

; 130  :     kvz_cabac_write(data);

	mov	rcx, rbx
	call	kvz_cabac_write
	mov	r9d, DWORD PTR [rsi]
$LN104@encode_int:

; 261  :   data->low <<= num_bins;

	mov	eax, DWORD PTR [rbx+8]

; 263  :   data->bits_left -= num_bins;

	add	DWORD PTR [rbx+24], -2
	imul	r9d, edi

; 264  : 
; 265  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+24], 12
	lea	ecx, DWORD PTR [r9+rax*4]
	mov	DWORD PTR [rbx+8], ecx
$LN194@encode_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 639  :   encode_transform_coeff(state, x, y, depth, 0, 0, 0);

	jge	SHORT $LN110@encode_int
	mov	rcx, rbx
	call	kvz_cabac_write
$LN110@encode_int:
	mov	r8d, DWORD PTR y$[rbp-153]
	movzx	r9d, r13b
	mov	edx, DWORD PTR x$[rbp-153]
	mov	rcx, r15
	mov	BYTE PTR [rsp+48], 0
	mov	BYTE PTR [rsp+40], 0
	mov	BYTE PTR [rsp+32], 0
	call	encode_transform_coeff

; 640  : }

	add	rsp, 168				; 000000a8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
encode_intra_coding_unit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c
_TEXT	SEGMENT
state$ = 48
cabac$ = 56
cur_cu$ = 64
depth$ = 72
encode_part_mode PROC

; 646  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 647  :   // Binarization from Table 9-34 of the HEVC spec:
; 648  :   //
; 649  :   //                |   log2CbSize >     |    log2CbSize ==
; 650  :   //                |   MinCbLog2SizeY   |    MinCbLog2SizeY
; 651  :   // -------+-------+----------+---------+-----------+----------
; 652  :   //  pred  | part  | AMP      | AMP     |           |
; 653  :   //  mode  | mode  | disabled | enabled | size == 8 | size > 8
; 654  :   // -------+-------+----------+---------+-----------+----------
; 655  :   //  intra | 2Nx2N |        -         - |         1          1
; 656  :   //        |   NxN |        -         - |         0          0
; 657  :   // -------+-------+--------------------+----------------------
; 658  :   //  inter | 2Nx2N |        1         1 |         1          1
; 659  :   //        |  2NxN |       01       011 |        01         01
; 660  :   //        |  Nx2N |       00       001 |        00        001
; 661  :   //        |   NxN |        -         - |         -        000
; 662  :   //        | 2NxnU |        -      0100 |         -          -
; 663  :   //        | 2NxnD |        -      0101 |         -          -
; 664  :   //        | nLx2N |        -      0000 |         -          -
; 665  :   //        | nRx2N |        -      0001 |         -          -
; 666  :   // -------+-------+--------------------+----------------------
; 667  :   //
; 668  :   //
; 669  :   // Context indices from Table 9-37 of the HEVC spec:
; 670  :   //
; 671  :   //                                      binIdx
; 672  :   //                               |  0  1  2       3
; 673  :   // ------------------------------+------------------
; 674  :   //  log2CbSize == MinCbLog2SizeY |  0  1  2  bypass
; 675  :   //  log2CbSize >  MinCbLog2SizeY |  0  1  3  bypass
; 676  :   // ------------------------------+------------------
; 677  : 
; 678  :   if (cur_cu->type == CU_INTRA) {

	movzx	eax, BYTE PTR [r8]
	mov	esi, r9d
	and	al, 3
	mov	rdi, r8
	mov	rbx, rdx
	mov	r14, rcx
	cmp	al, 1
	jne	SHORT $LN2@encode_par

; 679  :     if (depth == MAX_DEPTH) {

	cmp	r9d, 3
	jne	$LN28@encode_par

; 680  :       cabac->cur_ctx = &(cabac->ctx.part_size_model[0]);

	lea	rax, QWORD PTR [rdx+68]

; 681  :       if (cur_cu->part_size == SIZE_2Nx2N) {

	mov	rcx, rdx
	mov	QWORD PTR [rdx], rax
	cmp	BYTE PTR [r8], 32			; 00000020H
	jb	$LN41@encode_par

; 682  :         CABAC_BIN(cabac, 1, "part_mode 2Nx2N");
; 683  :       } else {
; 684  :         CABAC_BIN(cabac, 0, "part_mode NxN");

	xor	edx, edx

; 685  :       }
; 686  :     }
; 687  :   } else {

	jmp	$LN42@encode_par
$LN2@encode_par:

; 688  : 
; 689  :     cabac->cur_ctx = &(cabac->ctx.part_size_model[0]);

	lea	rax, QWORD PTR [rdx+68]
	mov	QWORD PTR [rdx], rax

; 690  :     if (cur_cu->part_size == SIZE_2Nx2N) {

	cmp	BYTE PTR [r8], 32			; 00000020H
	jb	$LN13@encode_par

; 691  :       CABAC_BIN(cabac, 1, "part_mode 2Nx2N");
; 692  :       return;
; 693  :     }
; 694  :     CABAC_BIN(cabac, 0, "part_mode split");

	xor	edx, edx
	mov	rcx, rbx
	call	kvz_cabac_encode_bin

; 695  : 
; 696  :     cabac->cur_ctx = &(cabac->ctx.part_size_model[1]);

	lea	rax, QWORD PTR [rbx+69]
	mov	QWORD PTR [rbx], rax

; 697  :     if (cur_cu->part_size == SIZE_2NxN ||
; 698  :         cur_cu->part_size == SIZE_2NxnU ||

	movzx	eax, BYTE PTR [rdi]
	shr	al, 5
	cmp	al, 1
	je	SHORT $LN10@encode_par
	sub	al, 4
	cmp	al, 1
	jbe	SHORT $LN10@encode_par

; 701  :     } else {
; 702  :       CABAC_BIN(cabac, 0, "part_mode horizontal");

	xor	edx, edx
	jmp	SHORT $LN9@encode_par
$LN10@encode_par:

; 699  :         cur_cu->part_size == SIZE_2NxnD) {
; 700  :       CABAC_BIN(cabac, 1, "part_mode vertical");

	mov	edx, 1
$LN9@encode_par:

; 703  :     }
; 704  : 
; 705  :     if (state->encoder_control->cfg.amp_enable && depth < MAX_DEPTH) {

	mov	rcx, rbx
	call	kvz_cabac_encode_bin
	mov	rax, QWORD PTR [r14]
	cmp	DWORD PTR [rax+60], 0
	je	SHORT $LN28@encode_par
	cmp	esi, 3
	jge	SHORT $LN28@encode_par

; 706  :       cabac->cur_ctx = &(cabac->ctx.part_size_model[3]);

	lea	rax, QWORD PTR [rbx+71]
	mov	QWORD PTR [rbx], rax

; 707  : 
; 708  :       if (cur_cu->part_size == SIZE_2NxN ||

	movzx	eax, BYTE PTR [rdi]
	shr	al, 5
	dec	al
	cmp	al, 1
	jbe	SHORT $LN13@encode_par

; 711  :         return;
; 712  :       }
; 713  :       CABAC_BIN(cabac, 0, "part_mode AMP");

	xor	edx, edx
	mov	rcx, rbx
	call	kvz_cabac_encode_bin

; 714  : 
; 715  :       if (cur_cu->part_size == SIZE_2NxnU ||

	movzx	eax, BYTE PTR [rdi]
	dec	DWORD PTR [rbx+24]
	shr	al, 5
	sub	al, 4
	test	al, 253					; 000000fdH
	je	SHORT $LN16@encode_par
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 261  :   data->low <<= num_bins;

	mov	ecx, DWORD PTR [rbx+8]

; 262  :   data->low += data->range * bin_values;

	mov	eax, DWORD PTR [rbx+12]
	lea	ecx, DWORD PTR [rax+rcx*2]
	mov	DWORD PTR [rbx+8], ecx

; 263  :   data->bits_left -= num_bins;
; 264  : 
; 265  :   if (data->bits_left < 12) {
; 266  :     kvz_cabac_write(data);

	jmp	SHORT $LN43@encode_par
$LN16@encode_par:

; 262  :   data->low += data->range * bin_values;

	shl	DWORD PTR [rbx+8], 1
$LN43@encode_par:
; File F:\open_codec_learn_2021\kvazaar-master\src\encode_coding_tree.c

; 723  : }

	cmp	DWORD PTR [rbx+24], 12
	jge	SHORT $LN28@encode_par
	mov	rcx, rbx
	call	kvz_cabac_write
	jmp	SHORT $LN28@encode_par
$LN13@encode_par:

; 709  :           cur_cu->part_size == SIZE_Nx2N) {
; 710  :         CABAC_BIN(cabac, 1, "part_mode SMP");

	mov	rcx, rbx
$LN41@encode_par:

; 723  : }

	mov	edx, 1
$LN42@encode_par:
	call	kvz_cabac_encode_bin
$LN28@encode_par:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
encode_part_mode ENDP
_TEXT	ENDS
END
