; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sao_edge_offsets DD 0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
PUBLIC	kvz_get_cu_ref_qp
PUBLIC	kvz_get_scan_order
PUBLIC	kvz_encoder_create_ref_lists
PUBLIC	kvz_get_lcu_stats
PUBLIC	kvz_encode_one_frame
PUBLIC	kvz_encoder_prepare
PUBLIC	kvz_encoder_state_match_children_of_previous_frame
pdata	SEGMENT
$pdata$kvz_get_cu_ref_qp DD imagerel $LN10
	DD	imagerel $LN10+238
	DD	imagerel $unwind$kvz_get_cu_ref_qp
$pdata$_encode_one_frame_add_bitstream_deps DD imagerel _encode_one_frame_add_bitstream_deps
	DD	imagerel _encode_one_frame_add_bitstream_deps+32
	DD	imagerel $unwind$_encode_one_frame_add_bitstream_deps
$pdata$0$_encode_one_frame_add_bitstream_deps DD imagerel _encode_one_frame_add_bitstream_deps+32
	DD	imagerel _encode_one_frame_add_bitstream_deps+94
	DD	imagerel $chain$0$_encode_one_frame_add_bitstream_deps
$pdata$1$_encode_one_frame_add_bitstream_deps DD imagerel _encode_one_frame_add_bitstream_deps+94
	DD	imagerel _encode_one_frame_add_bitstream_deps+362
	DD	imagerel $chain$1$_encode_one_frame_add_bitstream_deps
$pdata$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame
	DD	imagerel encoder_state_init_new_frame+31
	DD	imagerel $unwind$encoder_state_init_new_frame
$pdata$1$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+31
	DD	imagerel encoder_state_init_new_frame+47
	DD	imagerel $chain$1$encoder_state_init_new_frame
$pdata$2$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+47
	DD	imagerel encoder_state_init_new_frame+423
	DD	imagerel $chain$2$encoder_state_init_new_frame
$pdata$5$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+423
	DD	imagerel encoder_state_init_new_frame+617
	DD	imagerel $chain$5$encoder_state_init_new_frame
$pdata$9$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+617
	DD	imagerel encoder_state_init_new_frame+2322
	DD	imagerel $chain$9$encoder_state_init_new_frame
$pdata$10$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+2322
	DD	imagerel encoder_state_init_new_frame+2347
	DD	imagerel $chain$10$encoder_state_init_new_frame
$pdata$11$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+2347
	DD	imagerel encoder_state_init_new_frame+2416
	DD	imagerel $chain$11$encoder_state_init_new_frame
$pdata$12$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+2416
	DD	imagerel encoder_state_init_new_frame+2754
	DD	imagerel $chain$12$encoder_state_init_new_frame
$pdata$13$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+2754
	DD	imagerel encoder_state_init_new_frame+2949
	DD	imagerel $chain$13$encoder_state_init_new_frame
$pdata$14$encoder_state_init_new_frame DD imagerel encoder_state_init_new_frame+2949
	DD	imagerel encoder_state_init_new_frame+3049
	DD	imagerel $chain$14$encoder_state_init_new_frame
$pdata$normalize_lcu_weights DD imagerel normalize_lcu_weights
	DD	imagerel normalize_lcu_weights+27
	DD	imagerel $unwind$normalize_lcu_weights
$pdata$0$normalize_lcu_weights DD imagerel normalize_lcu_weights+27
	DD	imagerel normalize_lcu_weights+61
	DD	imagerel $chain$0$normalize_lcu_weights
$pdata$1$normalize_lcu_weights DD imagerel normalize_lcu_weights+61
	DD	imagerel normalize_lcu_weights+341
	DD	imagerel $chain$1$normalize_lcu_weights
$pdata$2$normalize_lcu_weights DD imagerel normalize_lcu_weights+341
	DD	imagerel normalize_lcu_weights+613
	DD	imagerel $chain$2$normalize_lcu_weights
$pdata$3$normalize_lcu_weights DD imagerel normalize_lcu_weights+613
	DD	imagerel normalize_lcu_weights+618
	DD	imagerel $chain$3$normalize_lcu_weights
$pdata$encoder_state_init_children DD imagerel encoder_state_init_children
	DD	imagerel encoder_state_init_children+181
	DD	imagerel $unwind$encoder_state_init_children
$pdata$0$encoder_state_init_children DD imagerel encoder_state_init_children+181
	DD	imagerel encoder_state_init_children+235
	DD	imagerel $chain$0$encoder_state_init_children
$pdata$1$encoder_state_init_children DD imagerel encoder_state_init_children+235
	DD	imagerel encoder_state_init_children+246
	DD	imagerel $chain$1$encoder_state_init_children
$pdata$encoder_set_source_picture DD imagerel encoder_set_source_picture
	DD	imagerel encoder_set_source_picture+268
	DD	imagerel $unwind$encoder_set_source_picture
$pdata$encoder_state_remove_refs DD imagerel encoder_state_remove_refs
	DD	imagerel encoder_state_remove_refs+8
	DD	imagerel $unwind$encoder_state_remove_refs
$pdata$2$encoder_state_remove_refs DD imagerel encoder_state_remove_refs+8
	DD	imagerel encoder_state_remove_refs+121
	DD	imagerel $chain$2$encoder_state_remove_refs
$pdata$5$encoder_state_remove_refs DD imagerel encoder_state_remove_refs+121
	DD	imagerel encoder_state_remove_refs+160
	DD	imagerel $chain$5$encoder_state_remove_refs
$pdata$7$encoder_state_remove_refs DD imagerel encoder_state_remove_refs+160
	DD	imagerel encoder_state_remove_refs+417
	DD	imagerel $chain$7$encoder_state_remove_refs
$pdata$8$encoder_state_remove_refs DD imagerel encoder_state_remove_refs+417
	DD	imagerel encoder_state_remove_refs+434
	DD	imagerel $chain$8$encoder_state_remove_refs
$pdata$9$encoder_state_remove_refs DD imagerel encoder_state_remove_refs+434
	DD	imagerel encoder_state_remove_refs+509
	DD	imagerel $chain$9$encoder_state_remove_refs
$pdata$10$encoder_state_remove_refs DD imagerel encoder_state_remove_refs+509
	DD	imagerel encoder_state_remove_refs+545
	DD	imagerel $chain$10$encoder_state_remove_refs
$pdata$kvz_encoder_create_ref_lists DD imagerel $LN100
	DD	imagerel $LN100+707
	DD	imagerel $unwind$kvz_encoder_create_ref_lists
$pdata$encoder_ref_insertion_sort DD imagerel encoder_ref_insertion_sort
	DD	imagerel encoder_ref_insertion_sort+23
	DD	imagerel $unwind$encoder_ref_insertion_sort
$pdata$0$encoder_ref_insertion_sort DD imagerel encoder_ref_insertion_sort+23
	DD	imagerel encoder_ref_insertion_sort+121
	DD	imagerel $chain$0$encoder_ref_insertion_sort
$pdata$1$encoder_ref_insertion_sort DD imagerel encoder_ref_insertion_sort+121
	DD	imagerel encoder_ref_insertion_sort+128
	DD	imagerel $chain$1$encoder_ref_insertion_sort
$pdata$2$encoder_ref_insertion_sort DD imagerel encoder_ref_insertion_sort+128
	DD	imagerel encoder_ref_insertion_sort+146
	DD	imagerel $chain$2$encoder_ref_insertion_sort
$pdata$encoder_state_encode DD imagerel encoder_state_encode
	DD	imagerel encoder_state_encode+26
	DD	imagerel $unwind$encoder_state_encode
$pdata$5$encoder_state_encode DD imagerel encoder_state_encode+26
	DD	imagerel encoder_state_encode+1506
	DD	imagerel $chain$5$encoder_state_encode
$pdata$7$encoder_state_encode DD imagerel encoder_state_encode+1506
	DD	imagerel encoder_state_encode+1704
	DD	imagerel $chain$7$encoder_state_encode
$pdata$8$encoder_state_encode DD imagerel encoder_state_encode+1704
	DD	imagerel encoder_state_encode+1795
	DD	imagerel $chain$8$encoder_state_encode
$pdata$encoder_state_worker_encode_children DD imagerel encoder_state_worker_encode_children
	DD	imagerel encoder_state_worker_encode_children+34
	DD	imagerel $unwind$encoder_state_worker_encode_children
$pdata$0$encoder_state_worker_encode_children DD imagerel encoder_state_worker_encode_children+34
	DD	imagerel encoder_state_worker_encode_children+112
	DD	imagerel $chain$0$encoder_state_worker_encode_children
$pdata$1$encoder_state_worker_encode_children DD imagerel encoder_state_worker_encode_children+112
	DD	imagerel encoder_state_worker_encode_children+130
	DD	imagerel $chain$1$encoder_state_worker_encode_children
$pdata$encoder_state_encode_leaf DD imagerel encoder_state_encode_leaf
	DD	imagerel encoder_state_encode_leaf+284
	DD	imagerel $unwind$encoder_state_encode_leaf
$pdata$4$encoder_state_encode_leaf DD imagerel encoder_state_encode_leaf+284
	DD	imagerel encoder_state_encode_leaf+974
	DD	imagerel $chain$4$encoder_state_encode_leaf
$pdata$5$encoder_state_encode_leaf DD imagerel encoder_state_encode_leaf+974
	DD	imagerel encoder_state_encode_leaf+1034
	DD	imagerel $chain$5$encoder_state_encode_leaf
$pdata$encoder_state_worker_encode_lcu DD imagerel encoder_state_worker_encode_lcu
	DD	imagerel encoder_state_worker_encode_lcu+1753
	DD	imagerel $unwind$encoder_state_worker_encode_lcu
$pdata$set_cu_qps DD imagerel set_cu_qps
	DD	imagerel set_cu_qps+42
	DD	imagerel $unwind$set_cu_qps
$pdata$3$set_cu_qps DD imagerel set_cu_qps+42
	DD	imagerel set_cu_qps+820
	DD	imagerel $chain$3$set_cu_qps
$pdata$4$set_cu_qps DD imagerel set_cu_qps+820
	DD	imagerel set_cu_qps+831
	DD	imagerel $chain$4$set_cu_qps
$pdata$5$set_cu_qps DD imagerel set_cu_qps+831
	DD	imagerel set_cu_qps+929
	DD	imagerel $chain$5$set_cu_qps
$pdata$encode_sao DD imagerel encode_sao
	DD	imagerel encode_sao+204
	DD	imagerel $unwind$encode_sao
$pdata$encode_sao_merge_flags DD imagerel encode_sao_merge_flags
	DD	imagerel encode_sao_merge_flags+101
	DD	imagerel $unwind$encode_sao_merge_flags
$pdata$encode_sao_color DD imagerel encode_sao_color
	DD	imagerel encode_sao_color+139
	DD	imagerel $unwind$encode_sao_color
$pdata$4$encode_sao_color DD imagerel encode_sao_color+139
	DD	imagerel encode_sao_color+464
	DD	imagerel $chain$4$encode_sao_color
$pdata$5$encode_sao_color DD imagerel encode_sao_color+464
	DD	imagerel encode_sao_color+655
	DD	imagerel $chain$5$encode_sao_color
$pdata$6$encode_sao_color DD imagerel encode_sao_color+655
	DD	imagerel encode_sao_color+663
	DD	imagerel $chain$6$encode_sao_color
$pdata$encoder_sao_reconstruct DD imagerel encoder_sao_reconstruct
	DD	imagerel encoder_sao_reconstruct+1737
	DD	imagerel $unwind$encoder_sao_reconstruct
$pdata$encoder_state_recdata_to_bufs DD imagerel encoder_state_recdata_to_bufs
	DD	imagerel encoder_state_recdata_to_bufs+29
	DD	imagerel $unwind$encoder_state_recdata_to_bufs
$pdata$0$encoder_state_recdata_to_bufs DD imagerel encoder_state_recdata_to_bufs+29
	DD	imagerel encoder_state_recdata_to_bufs+366
	DD	imagerel $chain$0$encoder_state_recdata_to_bufs
$pdata$1$encoder_state_recdata_to_bufs DD imagerel encoder_state_recdata_to_bufs+366
	DD	imagerel encoder_state_recdata_to_bufs+672
	DD	imagerel $chain$1$encoder_state_recdata_to_bufs
$pdata$encoder_state_recdata_before_sao_to_bufs DD imagerel encoder_state_recdata_before_sao_to_bufs
	DD	imagerel encoder_state_recdata_before_sao_to_bufs+714
	DD	imagerel $unwind$encoder_state_recdata_before_sao_to_bufs
$pdata$is_last_cu_in_qg DD imagerel is_last_cu_in_qg
	DD	imagerel is_last_cu_in_qg+118
	DD	imagerel $unwind$is_last_cu_in_qg
$pdata$kvz_encode_one_frame DD imagerel $LN6
	DD	imagerel $LN6+167
	DD	imagerel $unwind$kvz_encode_one_frame
$pdata$kvz_encoder_prepare DD imagerel $LN51
	DD	imagerel $LN51+228
	DD	imagerel $unwind$kvz_encoder_prepare
$pdata$2$kvz_encoder_prepare DD imagerel $LN51+228
	DD	imagerel $LN51+260
	DD	imagerel $chain$2$kvz_encoder_prepare
$pdata$3$kvz_encoder_prepare DD imagerel $LN51+260
	DD	imagerel $LN51+364
	DD	imagerel $chain$3$kvz_encoder_prepare
$pdata$5$kvz_encoder_prepare DD imagerel $LN51+364
	DD	imagerel $LN51+476
	DD	imagerel $chain$5$kvz_encoder_prepare
$pdata$6$kvz_encoder_prepare DD imagerel $LN51+476
	DD	imagerel $LN51+489
	DD	imagerel $chain$6$kvz_encoder_prepare
$pdata$7$kvz_encoder_prepare DD imagerel $LN51+489
	DD	imagerel $LN51+961
	DD	imagerel $chain$7$kvz_encoder_prepare
$pdata$8$kvz_encoder_prepare DD imagerel $LN51+961
	DD	imagerel $LN51+979
	DD	imagerel $chain$8$kvz_encoder_prepare
$pdata$kvz_encoder_state_match_children_of_previous_frame DD imagerel $LN74
	DD	imagerel $LN74+28
	DD	imagerel $unwind$kvz_encoder_state_match_children_of_previous_frame
$pdata$1$kvz_encoder_state_match_children_of_previous_frame DD imagerel $LN74+28
	DD	imagerel $LN74+164
	DD	imagerel $chain$1$kvz_encoder_state_match_children_of_previous_frame
$pdata$2$kvz_encoder_state_match_children_of_previous_frame DD imagerel $LN74+164
	DD	imagerel $LN74+180
	DD	imagerel $chain$2$kvz_encoder_state_match_children_of_previous_frame
xdata	SEGMENT
$unwind$kvz_get_cu_ref_qp DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
$unwind$_encode_one_frame_add_bitstream_deps DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
$chain$0$_encode_one_frame_add_bitstream_deps DD 020521H
	DD	066405H
	DD	imagerel _encode_one_frame_add_bitstream_deps
	DD	imagerel _encode_one_frame_add_bitstream_deps+32
	DD	imagerel $unwind$_encode_one_frame_add_bitstream_deps
$chain$1$_encode_one_frame_add_bitstream_deps DD 021H
	DD	imagerel _encode_one_frame_add_bitstream_deps
	DD	imagerel _encode_one_frame_add_bitstream_deps+32
	DD	imagerel $unwind$_encode_one_frame_add_bitstream_deps
$unwind$encoder_state_init_new_frame DD 031801H
	DD	031a0118H
	DD	0700bH
$chain$1$encoder_state_init_new_frame DD 041021H
	DD	03176410H
	DD	03193408H
	DD	imagerel encoder_state_init_new_frame
	DD	imagerel encoder_state_init_new_frame+31
	DD	imagerel $unwind$encoder_state_init_new_frame
$chain$2$encoder_state_init_new_frame DD 020821H
	DD	0314e408H
	DD	imagerel encoder_state_init_new_frame+31
	DD	imagerel encoder_state_init_new_frame+47
	DD	imagerel $chain$1$encoder_state_init_new_frame
$chain$5$encoder_state_init_new_frame DD 061921H
	DD	01868819H
	DD	01877810H
	DD	03185408H
	DD	imagerel encoder_state_init_new_frame+47
	DD	imagerel encoder_state_init_new_frame+423
	DD	imagerel $chain$2$encoder_state_init_new_frame
$chain$9$encoder_state_init_new_frame DD 082021H
	DD	01886820H
	DD	0313f418H
	DD	0315d410H
	DD	0316c408H
	DD	imagerel encoder_state_init_new_frame+423
	DD	imagerel encoder_state_init_new_frame+617
	DD	imagerel $chain$5$encoder_state_init_new_frame
$chain$10$encoder_state_init_new_frame DD 021H
	DD	imagerel encoder_state_init_new_frame+423
	DD	imagerel encoder_state_init_new_frame+617
	DD	imagerel $chain$5$encoder_state_init_new_frame
$chain$11$encoder_state_init_new_frame DD 021H
	DD	imagerel encoder_state_init_new_frame+47
	DD	imagerel encoder_state_init_new_frame+423
	DD	imagerel $chain$2$encoder_state_init_new_frame
$chain$12$encoder_state_init_new_frame DD 021H
	DD	imagerel encoder_state_init_new_frame+31
	DD	imagerel encoder_state_init_new_frame+47
	DD	imagerel $chain$1$encoder_state_init_new_frame
$chain$13$encoder_state_init_new_frame DD 020021H
	DD	03176400H
	DD	imagerel encoder_state_init_new_frame
	DD	imagerel encoder_state_init_new_frame+31
	DD	imagerel $unwind$encoder_state_init_new_frame
$chain$14$encoder_state_init_new_frame DD 021H
	DD	imagerel encoder_state_init_new_frame
	DD	imagerel encoder_state_init_new_frame+31
	DD	imagerel $unwind$encoder_state_init_new_frame
$unwind$normalize_lcu_weights DD 010401H
	DD	0204H
$chain$0$normalize_lcu_weights DD 020521H
	DD	023405H
	DD	imagerel normalize_lcu_weights
	DD	imagerel normalize_lcu_weights+27
	DD	imagerel $unwind$normalize_lcu_weights
$chain$1$normalize_lcu_weights DD 020421H
	DD	07404H
	DD	imagerel normalize_lcu_weights+27
	DD	imagerel normalize_lcu_weights+61
	DD	imagerel $chain$0$normalize_lcu_weights
$chain$2$normalize_lcu_weights DD 021H
	DD	imagerel normalize_lcu_weights+27
	DD	imagerel normalize_lcu_weights+61
	DD	imagerel $chain$0$normalize_lcu_weights
$chain$3$normalize_lcu_weights DD 021H
	DD	imagerel normalize_lcu_weights
	DD	imagerel normalize_lcu_weights+27
	DD	imagerel $unwind$normalize_lcu_weights
$unwind$encoder_state_init_children DD 040a01H
	DD	07340aH
	DD	07006320aH
$chain$0$encoder_state_init_children DD 020521H
	DD	066405H
	DD	imagerel encoder_state_init_children
	DD	imagerel encoder_state_init_children+181
	DD	imagerel $unwind$encoder_state_init_children
$chain$1$encoder_state_init_children DD 021H
	DD	imagerel encoder_state_init_children
	DD	imagerel encoder_state_init_children+181
	DD	imagerel $unwind$encoder_state_init_children
$unwind$encoder_set_source_picture DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$encoder_state_remove_refs DD 010401H
	DD	08204H
$chain$2$encoder_state_remove_refs DD 062621H
	DD	04f426H
	DD	05e40dH
	DD	06d405H
	DD	imagerel encoder_state_remove_refs
	DD	imagerel encoder_state_remove_refs+8
	DD	imagerel $unwind$encoder_state_remove_refs
$chain$5$encoder_state_remove_refs DD 061521H
	DD	087415H
	DD	0d640dH
	DD	0c5405H
	DD	imagerel encoder_state_remove_refs+8
	DD	imagerel encoder_state_remove_refs+121
	DD	imagerel $chain$2$encoder_state_remove_refs
$chain$7$encoder_state_remove_refs DD 040d21H
	DD	07c40dH
	DD	0b3405H
	DD	imagerel encoder_state_remove_refs+121
	DD	imagerel encoder_state_remove_refs+160
	DD	imagerel $chain$5$encoder_state_remove_refs
$chain$8$encoder_state_remove_refs DD 021H
	DD	imagerel encoder_state_remove_refs+121
	DD	imagerel encoder_state_remove_refs+160
	DD	imagerel $chain$5$encoder_state_remove_refs
$chain$9$encoder_state_remove_refs DD 021H
	DD	imagerel encoder_state_remove_refs+8
	DD	imagerel encoder_state_remove_refs+121
	DD	imagerel $chain$2$encoder_state_remove_refs
$chain$10$encoder_state_remove_refs DD 021H
	DD	imagerel encoder_state_remove_refs
	DD	imagerel encoder_state_remove_refs+8
	DD	imagerel $unwind$encoder_state_remove_refs
$unwind$kvz_encoder_create_ref_lists DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
$unwind$encoder_ref_insertion_sort DD 030601H
	DD	033406H
	DD	06006H
$chain$0$encoder_ref_insertion_sort DD 020521H
	DD	027405H
	DD	imagerel encoder_ref_insertion_sort
	DD	imagerel encoder_ref_insertion_sort+23
	DD	imagerel $unwind$encoder_ref_insertion_sort
$chain$1$encoder_ref_insertion_sort DD 021H
	DD	imagerel encoder_ref_insertion_sort
	DD	imagerel encoder_ref_insertion_sort+23
	DD	imagerel $unwind$encoder_ref_insertion_sort
$chain$2$encoder_ref_insertion_sort DD 020021H
	DD	027400H
	DD	imagerel encoder_ref_insertion_sort
	DD	imagerel encoder_ref_insertion_sort+23
	DD	imagerel $unwind$encoder_ref_insertion_sort
$unwind$encoder_state_encode DD 030701H
	DD	06003e207H
	DD	03002H
$chain$5$encoder_state_encode DD 0c4a21H
	DD	09f44aH
	DD	0ae42dH
	DD	0cc425H
	DD	0e541cH
	DD	0bd414H
	DD	0d7405H
	DD	imagerel encoder_state_encode
	DD	imagerel encoder_state_encode+26
	DD	imagerel $unwind$encoder_state_encode
$chain$7$encoder_state_encode DD 0c0021H
	DD	09f400H
	DD	0ae400H
	DD	0bd400H
	DD	0cc400H
	DD	0d7400H
	DD	0e5400H
	DD	imagerel encoder_state_encode
	DD	imagerel encoder_state_encode+26
	DD	imagerel $unwind$encoder_state_encode
$chain$8$encoder_state_encode DD 021H
	DD	imagerel encoder_state_encode
	DD	imagerel encoder_state_encode+26
	DD	imagerel $unwind$encoder_state_encode
$unwind$encoder_state_worker_encode_children DD 020601H
	DD	030023206H
$chain$0$encoder_state_worker_encode_children DD 020521H
	DD	067405H
	DD	imagerel encoder_state_worker_encode_children
	DD	imagerel encoder_state_worker_encode_children+34
	DD	imagerel $unwind$encoder_state_worker_encode_children
$chain$1$encoder_state_worker_encode_children DD 021H
	DD	imagerel encoder_state_worker_encode_children
	DD	imagerel encoder_state_worker_encode_children+34
	DD	imagerel $unwind$encoder_state_worker_encode_children
$unwind$encoder_state_encode_leaf DD 089101H
	DD	0dc491H
	DD	0c748cH
	DD	0d0055209H
	DD	030025003H
$chain$4$encoder_state_encode_leaf DD 061221H
	DD	04f412H
	DD	05e40dH
	DD	0b6405H
	DD	imagerel encoder_state_encode_leaf
	DD	imagerel encoder_state_encode_leaf+284
	DD	imagerel $unwind$encoder_state_encode_leaf
$chain$5$encoder_state_encode_leaf DD 021H
	DD	imagerel encoder_state_encode_leaf
	DD	imagerel encoder_state_encode_leaf+284
	DD	imagerel $unwind$encoder_state_encode_leaf
$unwind$encoder_state_worker_encode_lcu DD 0b1d01H
	DD	0610341dH
	DD	0606011dH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
$unwind$set_cu_qps DD 050d01H
	DD	0d009a20dH
	DD	07005c007H
	DD	06004H
$chain$3$set_cu_qps DD 082521H
	DD	09e425H
	DD	08f419H
	DD	0a540dH
	DD	0123404H
	DD	imagerel set_cu_qps
	DD	imagerel set_cu_qps+42
	DD	imagerel $unwind$set_cu_qps
$chain$4$set_cu_qps DD 021H
	DD	imagerel set_cu_qps
	DD	imagerel set_cu_qps+42
	DD	imagerel $unwind$set_cu_qps
$chain$5$set_cu_qps DD 080021H
	DD	08f400H
	DD	09e400H
	DD	0a5400H
	DD	0123400H
	DD	imagerel set_cu_qps
	DD	imagerel set_cu_qps+42
	DD	imagerel $unwind$set_cu_qps
$unwind$encode_sao DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
$unwind$encode_sao_merge_flags DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$encode_sao_color DD 041101H
	DD	0700d7211H
	DD	0300b600cH
$chain$4$encode_sao_color DD 0a2c21H
	DD	04f42cH
	DD	05e41dH
	DD	06d418H
	DD	07c40eH
	DD	0c5405H
	DD	imagerel encode_sao_color
	DD	imagerel encode_sao_color+139
	DD	imagerel $unwind$encode_sao_color
$chain$5$encode_sao_color DD 040021H
	DD	04f400H
	DD	05e400H
	DD	imagerel encode_sao_color
	DD	imagerel encode_sao_color+139
	DD	imagerel $unwind$encode_sao_color
$chain$6$encode_sao_color DD 021H
	DD	imagerel encode_sao_color
	DD	imagerel encode_sao_color+139
	DD	imagerel $unwind$encode_sao_color
$unwind$encoder_sao_reconstruct DD 0a1e01H
	DD	0441011eH
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	030065007H
$unwind$encoder_state_recdata_to_bufs DD 0a1601H
	DD	0e5416H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
$chain$0$encoder_state_recdata_to_bufs DD 020521H
	DD	0cd405H
	DD	imagerel encoder_state_recdata_to_bufs
	DD	imagerel encoder_state_recdata_to_bufs+29
	DD	imagerel $unwind$encoder_state_recdata_to_bufs
$chain$1$encoder_state_recdata_to_bufs DD 021H
	DD	imagerel encoder_state_recdata_to_bufs
	DD	imagerel encoder_state_recdata_to_bufs+29
	DD	imagerel $unwind$encoder_state_recdata_to_bufs
$unwind$encoder_state_recdata_before_sao_to_bufs DD 0c1c01H
	DD	0f641cH
	DD	0e541cH
	DD	0d341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
$unwind$is_last_cu_in_qg DD 020501H
	DD	013405H
$unwind$kvz_encode_one_frame DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$kvz_encoder_prepare DD 030701H
	DD	070038207H
	DD	03002H
$chain$2$kvz_encoder_prepare DD 060f21H
	DD	08d40fH
	DD	0e640aH
	DD	0d5405H
	DD	imagerel $LN51
	DD	imagerel $LN51+228
	DD	imagerel $unwind$kvz_encoder_prepare
$chain$3$kvz_encoder_prepare DD 020521H
	DD	07e405H
	DD	imagerel $LN51+228
	DD	imagerel $LN51+260
	DD	imagerel $chain$2$kvz_encoder_prepare
$chain$5$kvz_encoder_prepare DD 040a21H
	DD	06f40aH
	DD	0fc405H
	DD	imagerel $LN51+260
	DD	imagerel $LN51+364
	DD	imagerel $chain$3$kvz_encoder_prepare
$chain$6$kvz_encoder_prepare DD 021H
	DD	imagerel $LN51+260
	DD	imagerel $LN51+364
	DD	imagerel $chain$3$kvz_encoder_prepare
$chain$7$kvz_encoder_prepare DD 021H
	DD	imagerel $LN51+228
	DD	imagerel $LN51+260
	DD	imagerel $chain$2$kvz_encoder_prepare
$chain$8$kvz_encoder_prepare DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+228
	DD	imagerel $unwind$kvz_encoder_prepare
$unwind$kvz_encoder_state_match_children_of_previous_frame DD 040a01H
	DD	08340aH
	DD	06006320aH
$chain$1$kvz_encoder_state_match_children_of_previous_frame DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN74
	DD	imagerel $LN74+28
	DD	imagerel $unwind$kvz_encoder_state_match_children_of_previous_frame
$chain$2$kvz_encoder_state_match_children_of_previous_frame DD 021H
	DD	imagerel $LN74
	DD	imagerel $LN74+28
	DD	imagerel $unwind$kvz_encoder_state_match_children_of_previous_frame
	ORG $+1
$SG4294952889 DB '0', 00H, 00H, 00H
	ORG $+2
$SG4294952901 DB '0', 00H, 00H, 00H
	ORG $+1
$SG4294952912 DB '0', 00H, 00H, 00H
	ORG $+2
$SG4294952879 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'a', 00H, 'r'
	DB	00H, 'r', 00H, 'a', 00H, 'y', 00H, 00H, 00H
	ORG $+4
$SG4294952880 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952881 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 00H, 00H
	ORG $+6
$SG4294952882 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952883 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c'
	DB	00H, 'e', 00H, 00H, 00H
$SG4294952884 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952885 DB 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'd', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294952886 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952887 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'q', 00H, 'j', 00H, '_', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'm', 00H, '_', 00H, 'w', 00H, 'r', 00H, 'i', 00H, 't'
	DB	00H, 't', 00H, 'e', 00H, 'n', 00H, 00H, 00H
	ORG $+7
$SG4294952888 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952895 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 00H, 00H
	ORG $+6
$SG4294952890 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952891 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'a', 00H, 'r'
	DB	00H, 'r', 00H, 'a', 00H, 'y', 00H, 00H, 00H
	ORG $+7
$SG4294952892 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952897 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c'
	DB	00H, 'e', 00H, 00H, 00H
$SG4294952893 DB 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'E', 00H, 'N', 00H, 'C', 00H, 'O', 00H
	DB	'D', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'A'
	DB	00H, 'T', 00H, 'E', 00H, '_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H
	DB	'E', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'I', 00H, 'N', 00H, 00H
	DB	00H
	ORG $+2
$SG4294952894 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952908 DB 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'l', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'o', 00H, 'r'
	DB	00H, 'd', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294952896 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294952898 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294952899 DB 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'r', 00H, 'e', 00H, 'f', 00H, '-', 00H, '>', 00H
	DB	'u', 00H, 's', 00H, 'e', 00H, 'd', 00H, '_', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, '_'
	DB	00H, 'r', 00H, 'e', 00H, 'f', 00H, '_', 00H, 'n', 00H, 'u', 00H
	DB	'm', 00H, 00H, 00H
	ORG $+2
$SG4294952900 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294952902 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952903 DB 'Unsupported leaf type %c!', 0aH, 00H
	ORG $+5
$SG4294952906 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'q', 00H, 'j', 00H, '_', 00H, 'r'
	DB	00H, 'e', 00H, 'c', 00H, 'o', 00H, 'n', 00H, '_', 00H, 'd', 00H
	DB	'o', 00H, 'n', 00H, 'e', 00H, 00H, 00H
$SG4294952904 DB '!', 00H, 's', 00H, 'u', 00H, 'b', 00H, '_', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>', 00H, 't'
	DB	00H, 'q', 00H, 'j', 00H, '_', 00H, 'b', 00H, 'i', 00H, 't', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, '_'
	DB	00H, 'w', 00H, 'r', 00H, 'i', 00H, 't', 00H, 't', 00H, 'e', 00H
	DB	'n', 00H, 00H, 00H
	ORG $+7
$SG4294952905 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+3
$SG4294952907 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294952909 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294952910 DB 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'i', 00H, 's', 00H, '_', 00H, 'l', 00H, 'e', 00H, 'a'
	DB	00H, 'f', 00H, 00H, 00H
$SG4294952911 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294952913 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294952914 DB 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'o'
	DB	00H, 'u', 00H, 's', 00H, '_', 00H, 'e', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_', 00H, 's', 00H, 't'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>', 00H, 'c', 00H
	DB	'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 'n'
	DB	00H, '[', 00H, 'i', 00H, ']', 00H, '.', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H
	DB	00H, 00H
$SG4294952915 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 48
kvz_encoder_state_match_children_of_previous_frame PROC

; 55   : int kvz_encoder_state_match_children_of_previous_frame(encoder_state_t * const state) {

$LN74:
	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 56   :   int i;
; 57   :   for (i = 0; state->children[i].encoder_control; ++i) {

	mov	rax, QWORD PTR [rcx+16]
	xor	esi, esi
	mov	rbx, rcx
	cmp	QWORD PTR [rax], rsi
	je	$LN72@kvz_encode
	mov	QWORD PTR [rsp+48], rbp
	mov	ebp, esi
	mov	QWORD PTR [rsp+56], rdi
	mov	edi, esi
	npad	6
$LL4@kvz_encode:

; 58   :     //Child should also exist for previous encoder
; 59   :     assert(state->previous_encoder_state->children[i].encoder_control);

	mov	rcx, QWORD PTR [rbx+32]
	mov	rax, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LN71@kvz_encode
	mov	r8d, 59					; 0000003bH
	lea	rdx, OFFSET FLAT:$SG4294952915
	lea	rcx, OFFSET FLAT:$SG4294952914
	call	QWORD PTR __imp__wassert
	mov	rcx, QWORD PTR [rbx+32]
$LN71@kvz_encode:

; 60   :     state->children[i].previous_encoder_state = &state->previous_encoder_state->children[i];

	mov	rcx, QWORD PTR [rcx+16]
	movsxd	rax, esi
	imul	rdx, rax, 424				; 000001a8H
	mov	rax, QWORD PTR [rbx+16]
	add	rcx, rdx
	mov	QWORD PTR [rdi+rax+32], rcx

; 61   :     kvz_encoder_state_match_children_of_previous_frame(&state->children[i]);

	mov	rcx, QWORD PTR [rbx+16]
	add	rcx, rdx
	call	kvz_encoder_state_match_children_of_previous_frame
	mov	rax, QWORD PTR [rbx+16]
	inc	rbp
	imul	rdi, rbp, 424				; 000001a8H
	inc	esi
	cmp	QWORD PTR [rdi+rax], 0
	jne	SHORT $LL4@kvz_encode

; 62   :   }
; 63   :   return 1;

	mov	rdi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+48]
$LN72@kvz_encode:

; 64   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	eax, 1
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
kvz_encoder_state_match_children_of_previous_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
encoder$1$ = 96
state$ = 96
kvz_encoder_prepare PROC

; 1510 : {

$LN51:
	push	rbx
	push	rdi
	sub	rsp, 72					; 00000048H

; 1511 :   const encoder_control_t * const encoder = state->encoder_control;
; 1512 : 
; 1513 :   // The previous frame must be done before the next one is started.
; 1514 :   assert(state->frame->done);

	mov	rax, QWORD PTR [rcx+40]
	mov	rdi, rcx
	mov	rbx, QWORD PTR [rcx]
	mov	QWORD PTR encoder$1$[rsp], rbx
	cmp	BYTE PTR [rax+153], 0
	jne	SHORT $LN7@kvz_encode
	mov	r8d, 1514				; 000005eaH
	lea	rdx, OFFSET FLAT:$SG4294952886
	lea	rcx, OFFSET FLAT:$SG4294952885
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rdi+40]
$LN7@kvz_encode:

; 1515 : 
; 1516 :   if (state->frame->num == -1) {

	cmp	DWORD PTR [rax+8], -1
	jne	$LN2@kvz_encode

; 1517 :     // We're at the first frame, so don't care about all this stuff.
; 1518 :     state->frame->num = 0;

	xor	ebx, ebx
	mov	DWORD PTR [rax+8], ebx

; 1519 :     state->frame->poc = 0;

	mov	rax, QWORD PTR [rdi+40]
	mov	DWORD PTR [rax+12], ebx

; 1520 :     state->frame->irap_poc = 0;

	mov	rax, QWORD PTR [rdi+40]
	mov	DWORD PTR [rax+20], ebx

; 1521 :     assert(!state->tile->frame->source);

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	cmp	QWORD PTR [rcx], rbx
	je	SHORT $LN8@kvz_encode
	mov	r8d, 1521				; 000005f1H
	lea	rdx, OFFSET FLAT:$SG4294952884
	lea	rcx, OFFSET FLAT:$SG4294952883
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
$LN8@kvz_encode:

; 1522 :     assert(!state->tile->frame->rec);

	cmp	QWORD PTR [rcx+8], rbx
	je	SHORT $LN9@kvz_encode
	mov	r8d, 1522				; 000005f2H
	lea	rdx, OFFSET FLAT:$SG4294952882
	lea	rcx, OFFSET FLAT:$SG4294952881
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
$LN9@kvz_encode:

; 1523 :     assert(!state->tile->frame->cu_array);

	cmp	QWORD PTR [rcx+32], rbx
	je	$LN10@kvz_encode
	mov	r8d, 1523				; 000005f3H
	lea	rdx, OFFSET FLAT:$SG4294952880
	lea	rcx, OFFSET FLAT:$SG4294952879
	call	QWORD PTR __imp__wassert

; 1576 : 
; 1577 : 
; 1578 : }

	mov	rax, QWORD PTR [rdi+40]
	mov	BYTE PTR [rax+152], 1
	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rbx
	ret	0
$LN2@kvz_encode:
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+112], rsi
	mov	QWORD PTR [rsp+64], r13

; 1524 :     state->frame->prepared = 1;
; 1525 : 
; 1526 :     return;
; 1527 :   }
; 1528 : 
; 1529 :   // NOTE: prev_state is equal to state when OWF is zero
; 1530 :   encoder_state_t *prev_state = state->previous_encoder_state;

	mov	r13, QWORD PTR [rdi+32]

; 1531 : 
; 1532 :   if (state->previous_encoder_state != state) {

	cmp	r13, rdi
	je	$LN3@kvz_encode

; 1533 :     kvz_cu_array_free(&state->tile->frame->cu_array);

	mov	rax, QWORD PTR [rdi+48]
	mov	QWORD PTR [rsp+56], r14
	mov	rcx, QWORD PTR [rax]
	add	rcx, 32					; 00000020H
	call	kvz_cu_array_free

; 1534 :     unsigned width  = state->tile->frame->width_in_lcu  * LCU_WIDTH;

	mov	rax, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rax]
	mov	ecx, DWORD PTR [rdx+28]

; 1535 :     unsigned height = state->tile->frame->height_in_lcu * LCU_WIDTH;

	mov	edx, DWORD PTR [rdx+24]
	shl	edx, 6
	shl	ecx, 6

; 1536 :     state->tile->frame->cu_array = kvz_cu_array_alloc(width, height);

	call	kvz_cu_array_alloc
	mov	rcx, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rdx+32], rax

; 1537 : 
; 1538 :     kvz_image_list_copy_contents(state->frame->ref, prev_state->frame->ref);

	mov	rax, QWORD PTR [r13+40]
	mov	r14, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rdi+40]
	mov	rsi, QWORD PTR [rax+40]
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c

; 215  :   while (target->used_size > 0) {

	cmp	DWORD PTR [rsi+36], 0
	jbe	SHORT $LN13@kvz_encode
	npad	2
$LL12@kvz_encode:

; 216  :     kvz_image_list_rem(target, 0);

	xor	edx, edx
	mov	rcx, rsi
	call	kvz_image_list_rem
	cmp	DWORD PTR [rsi+36], 0
	ja	SHORT $LL12@kvz_encode
$LN13@kvz_encode:

; 217  :   }
; 218  :   
; 219  :   for (i = source->used_size - 1; i >= 0; --i) {

	mov	ebp, DWORD PTR [r14+36]
	sub	ebp, 1
	js	SHORT $LN15@kvz_encode
	movsxd	rbx, ebp
	mov	QWORD PTR [rsp+120], r12
	mov	QWORD PTR [rsp+48], r15
	lea	r15, QWORD PTR [rbx*8]
	lea	r12, QWORD PTR [rbx*4]
	shl	rbx, 5
	npad	6
$LL16@kvz_encode:

; 220  :     kvz_image_list_add(target, source->images[i], source->cu_arrays[i], source->pocs[i], source->ref_LXs[i]);

	mov	rcx, QWORD PTR [r14+24]
	mov	rax, QWORD PTR [r14+16]
	add	rcx, rbx
	mov	r8, QWORD PTR [r14+8]
	mov	rdx, QWORD PTR [r14]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rsi
	mov	r9d, DWORD PTR [r12+rax]
	mov	r8, QWORD PTR [r8+r15]
	mov	rdx, QWORD PTR [r15+rdx]
	call	kvz_image_list_add
	add	rbx, -32				; ffffffffffffffe0H
	lea	r12, QWORD PTR [r12-4]
	sub	ebp, 1
	lea	r15, QWORD PTR [r15-8]
	jns	SHORT $LL16@kvz_encode
	mov	rbx, QWORD PTR encoder$1$[rsp]
	mov	r15, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+120]
$LN15@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1539 :     kvz_encoder_create_ref_lists(state);

	mov	rcx, rdi
	call	kvz_encoder_create_ref_lists
	mov	r14, QWORD PTR [rsp+56]
$LN3@kvz_encode:

; 1540 :   }
; 1541 : 
; 1542 :   if (!encoder->cfg.gop_len ||
; 1543 :       !prev_state->frame->poc ||

	cmp	BYTE PTR [rbx+300], 0
	je	SHORT $LN5@kvz_encode
	mov	rax, QWORD PTR [r13+40]
	cmp	DWORD PTR [rax+12], 0
	je	SHORT $LN5@kvz_encode
	movsx	rax, BYTE PTR [rax+16]
	shl	rax, 6
	cmp	BYTE PTR [rax+rbx+315], 0
	je	$LN4@kvz_encode
$LN5@kvz_encode:

; 1544 :       encoder->cfg.gop[prev_state->frame->gop_offset].is_ref) {
; 1545 : 
; 1546 :     // Store current list of POCs for use in TMVP derivation
; 1547 :     memcpy(prev_state->tile->frame->rec->ref_pocs, state->frame->ref->pocs, sizeof(int32_t)*state->frame->ref->used_size);

	mov	rax, QWORD PTR [rdi+40]
	mov	rdx, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [r13+48]
	mov	r8d, DWORD PTR [rdx+36]
	mov	rcx, QWORD PTR [rax]
	mov	rdx, QWORD PTR [rdx+16]
	shl	r8, 2
	mov	rcx, QWORD PTR [rcx+8]
	add	rcx, 120				; 00000078H
	call	memcpy

; 1548 : 
; 1549 :     // Add previous reconstructed picture as a reference
; 1550 :     kvz_image_list_add(state->frame->ref,

	mov	r8, QWORD PTR [r13+40]
	mov	rax, QWORD PTR [r13+48]
	mov	rcx, QWORD PTR [rdi+40]
	mov	r9d, DWORD PTR [r8+12]
	mov	rdx, QWORD PTR [rax]
	lea	rax, QWORD PTR [r8+49]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rsp+32], rax
	mov	r8, QWORD PTR [rdx+32]
	mov	rdx, QWORD PTR [rdx+8]
	call	kvz_image_list_add

; 1551 :                    prev_state->tile->frame->rec,
; 1552 :                    prev_state->tile->frame->cu_array,
; 1553 :                    prev_state->frame->poc,
; 1554 :                    prev_state->frame->ref_LX);
; 1555 :     kvz_cu_array_free(&state->tile->frame->cu_array);

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	add	rcx, 32					; 00000020H
	call	kvz_cu_array_free

; 1556 :     unsigned height = state->tile->frame->height_in_lcu * LCU_WIDTH;

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	mov	edx, DWORD PTR [rcx+24]

; 1557 :     unsigned width  = state->tile->frame->width_in_lcu  * LCU_WIDTH;

	mov	ecx, DWORD PTR [rcx+28]
	shl	ecx, 6
	shl	edx, 6

; 1558 :     state->tile->frame->cu_array = kvz_cu_array_alloc(width, height);

	call	kvz_cu_array_alloc
	mov	rcx, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rdx+32], rax
$LN4@kvz_encode:

; 1562 :   kvz_image_free(state->tile->frame->source);

	mov	rax, QWORD PTR [rdi+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	xor	ebx, ebx
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1562 :   kvz_image_free(state->tile->frame->source);

	mov	rcx, QWORD PTR [rax]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	lea	ebp, QWORD PTR [rbx-1]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1562 :   kvz_image_free(state->tile->frame->source);

	mov	rsi, QWORD PTR [rcx]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	test	rsi, rsi
	je	SHORT $LN18@kvz_encode

; 117  : 
; 118  :   int32_t new_refcount = KVZ_ATOMIC_DEC(&(im->refcount));

	mov	eax, ebp
	lock xadd DWORD PTR [rsi+88], eax
	sub	eax, 1

; 119  :   if (new_refcount > 0) {

	jg	SHORT $LN18@kvz_encode

; 120  :     // There are still references so we don't free the data yet.
; 121  :     return;
; 122  :   }
; 123  : 
; 124  :   if (im->base_image != im) {

	mov	rcx, QWORD PTR [rsi+80]
	cmp	rcx, rsi
	je	SHORT $LN21@kvz_encode

; 125  :     // Free our reference to the base image.
; 126  :     kvz_image_free(im->base_image);

	call	kvz_image_free

; 127  :   } else {

	jmp	SHORT $LN22@kvz_encode
$LN21@kvz_encode:

; 128  :     free(im->fulldata_buf);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_free
$LN22@kvz_encode:

; 129  :   }
; 130  : 
; 131  :   // Make sure freed data won't be used.
; 132  :   im->base_image = NULL;
; 133  :   im->fulldata_buf = NULL;
; 134  :   im->fulldata = NULL;
; 135  :   im->y = im->u = im->v = NULL;
; 136  :   im->data[COLOR_Y] = im->data[COLOR_U] = im->data[COLOR_V] = NULL;
; 137  :   free(im);

	mov	rcx, rsi
	mov	QWORD PTR [rsi+80], rbx
	mov	QWORD PTR [rsi], rbx
	mov	QWORD PTR [rsi+8], rbx
	mov	QWORD PTR [rsi+32], rbx
	mov	QWORD PTR [rsi+24], rbx
	mov	QWORD PTR [rsi+16], rbx
	mov	QWORD PTR [rsi+56], rbx
	mov	QWORD PTR [rsi+48], rbx
	mov	QWORD PTR [rsi+40], rbx
	call	QWORD PTR __imp_free
$LN18@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1563 :   state->tile->frame->source = NULL;

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rbx

; 1564 : 
; 1565 :   kvz_image_free(state->tile->frame->rec);

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	mov	rsi, QWORD PTR [rcx+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	test	rsi, rsi
	je	SHORT $LN30@kvz_encode

; 117  : 
; 118  :   int32_t new_refcount = KVZ_ATOMIC_DEC(&(im->refcount));

	lock xadd DWORD PTR [rsi+88], ebp
	sub	ebp, 1

; 119  :   if (new_refcount > 0) {

	jg	SHORT $LN30@kvz_encode

; 120  :     // There are still references so we don't free the data yet.
; 121  :     return;
; 122  :   }
; 123  : 
; 124  :   if (im->base_image != im) {

	mov	rcx, QWORD PTR [rsi+80]
	cmp	rcx, rsi
	je	SHORT $LN33@kvz_encode

; 125  :     // Free our reference to the base image.
; 126  :     kvz_image_free(im->base_image);

	call	kvz_image_free

; 127  :   } else {

	jmp	SHORT $LN34@kvz_encode
$LN33@kvz_encode:

; 128  :     free(im->fulldata_buf);

	mov	rcx, QWORD PTR [rsi]
	call	QWORD PTR __imp_free
$LN34@kvz_encode:

; 129  :   }
; 130  : 
; 131  :   // Make sure freed data won't be used.
; 132  :   im->base_image = NULL;
; 133  :   im->fulldata_buf = NULL;
; 134  :   im->fulldata = NULL;
; 135  :   im->y = im->u = im->v = NULL;
; 136  :   im->data[COLOR_Y] = im->data[COLOR_U] = im->data[COLOR_V] = NULL;
; 137  :   free(im);

	mov	rcx, rsi
	mov	QWORD PTR [rsi+80], rbx
	mov	QWORD PTR [rsi], rbx
	mov	QWORD PTR [rsi+8], rbx
	mov	QWORD PTR [rsi+32], rbx
	mov	QWORD PTR [rsi+24], rbx
	mov	QWORD PTR [rsi+16], rbx
	mov	QWORD PTR [rsi+56], rbx
	mov	QWORD PTR [rsi+48], rbx
	mov	QWORD PTR [rsi+40], rbx
	call	QWORD PTR __imp_free
$LN30@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1566 :   state->tile->frame->rec = NULL;

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], rbx

; 1567 : 
; 1568 :   kvz_cu_array_free(&state->tile->frame->cu_array);

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	add	rcx, 32					; 00000020H
	call	kvz_cu_array_free

; 1569 : 
; 1570 :   // Update POC and frame count.
; 1571 :   state->frame->num = prev_state->frame->num + 1;

	mov	rax, QWORD PTR [r13+40]

; 1572 :   state->frame->poc = prev_state->frame->poc + 1;
; 1573 :   state->frame->irap_poc = prev_state->frame->irap_poc;
; 1574 : 
; 1575 :   state->frame->prepared = 1;

	mov	rsi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+104]
	mov	ecx, DWORD PTR [rax+8]
	mov	rax, QWORD PTR [rdi+40]
	inc	ecx
	mov	DWORD PTR [rax+8], ecx
	mov	rax, QWORD PTR [r13+40]
	mov	ecx, DWORD PTR [rax+12]
	mov	rax, QWORD PTR [rdi+40]
	inc	ecx
	mov	DWORD PTR [rax+12], ecx
	mov	rax, QWORD PTR [r13+40]
	mov	rcx, QWORD PTR [rdi+40]
	mov	r13, QWORD PTR [rsp+64]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR [rcx+20], eax
$LN10@kvz_encode:

; 1576 : 
; 1577 : 
; 1578 : }

	mov	rax, QWORD PTR [rdi+40]
	mov	BYTE PTR [rax+152], 1
	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rbx
	ret	0
kvz_encoder_prepare ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 48
frame$ = 56
kvz_encode_one_frame PROC

; 1481 : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1482 :   encoder_state_init_new_frame(state, frame);

	call	encoder_state_init_new_frame

; 1483 :   encoder_state_encode(state);

	mov	rcx, rbx
	call	encoder_state_encode

; 1484 : 
; 1485 :   threadqueue_job_t *job =

	mov	rdx, rbx
	lea	rcx, OFFSET FLAT:kvz_encoder_state_worker_write_bitstream
	call	kvz_threadqueue_job_create

; 1486 :     kvz_threadqueue_job_create(kvz_encoder_state_worker_write_bitstream, state);
; 1487 : 
; 1488 :   _encode_one_frame_add_bitstream_deps(state, job);

	mov	rdx, rax
	mov	rcx, rbx
	mov	rdi, rax
	call	_encode_one_frame_add_bitstream_deps

; 1489 :   if (state->previous_encoder_state != state && state->previous_encoder_state->tqj_bitstream_written) {

	mov	rdx, QWORD PTR [rbx+32]
	cmp	rdx, rbx
	je	SHORT $LN2@kvz_encode
	mov	rdx, QWORD PTR [rdx+408]
	test	rdx, rdx
	je	SHORT $LN2@kvz_encode

; 1490 :     //We need to depend on previous bitstream generation
; 1491 :     kvz_threadqueue_job_dep_add(job, state->previous_encoder_state->tqj_bitstream_written);

	mov	rcx, rdi
	call	kvz_threadqueue_job_dep_add
$LN2@kvz_encode:

; 1492 :   }
; 1493 :   kvz_threadqueue_submit(state->encoder_control->threadqueue, job);

	mov	rcx, QWORD PTR [rbx]
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rcx+6448]
	call	kvz_threadqueue_submit

; 1494 :   assert(!state->tqj_bitstream_written);

	cmp	QWORD PTR [rbx+408], 0
	je	SHORT $LN4@kvz_encode
	mov	r8d, 1494				; 000005d6H
	lea	rdx, OFFSET FLAT:$SG4294952888
	lea	rcx, OFFSET FLAT:$SG4294952887
	call	QWORD PTR __imp__wassert
$LN4@kvz_encode:

; 1495 :   state->tqj_bitstream_written = job;
; 1496 : 
; 1497 :   state->frame->done = 0;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rbx+408], rdi

; 1498 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rax+153], 0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
kvz_encode_one_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 8
lcu_x$ = 16
lcu_y$ = 24
kvz_get_lcu_stats PROC

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	rax, QWORD PTR [rcx]
	mov	r9, QWORD PTR [rcx+48]
	mov	r10d, DWORD PTR [r9+16]
	add	r10d, r8d
	imul	r10d, DWORD PTR [rax+2536]
	add	r10d, DWORD PTR [r9+12]
	lea	eax, DWORD PTR [rdx+r10]

; 1599 :                     (lcu_y + state->tile->lcu_offset_y) *
; 1600 :                     state->encoder_control->in.width_in_lcu;
; 1601 :   return &state->frame->lcu_stats[index];

	cdqe
	lea	rdx, QWORD PTR [rax+rax*8]
	mov	rax, QWORD PTR [rcx+40]
	mov	rcx, QWORD PTR [rax+160]
	lea	rax, QWORD PTR [rcx+rdx*8]

; 1602 : }

	ret	0
kvz_get_lcu_stats ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_is_set PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	movzx	r9d, cx
	lea	rcx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+r8*4]
	shl	edx, cl
	mov	eax, 0
	test	edx, r9d
	setne	al

; 519  : }

	ret	0
cbf_is_set ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
cbf_is_set_any PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rdx+rax*2]
	test	dx, cx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, edx
	shl	edx, 5
	or	edx, eax
	movzx	eax, cx
	shl	edx, 5
	test	edx, eax

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set
	xor	eax, eax

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
$LN3@cbf_is_set:

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	mov	eax, 1

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
cbf_is_set_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\crypto.h
_TEXT	SEGMENT
cfg$dead$ = 8
kvz_crypto_create PROC

; 51   :   return NULL;

	xor	eax, eax

; 52   : }

	ret	0
kvz_crypto_create ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\crypto.h
_TEXT	SEGMENT
hdl$dead$ = 8
kvz_crypto_delete PROC

; 61   : {}

	ret	0
kvz_crypto_delete ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h
_TEXT	SEGMENT
state$ = 8
x$ = 16
y$ = 24
depth$ = 32
is_last_cu_in_qg PROC

; 382  : {

	mov	QWORD PTR [rsp+8], rbx

; 383  :   if (state->encoder_control->max_qp_delta_depth < 0) return false;

	mov	rax, QWORD PTR [rcx]
	mov	ebx, r9d
	mov	r10, rcx
	movzx	r11d, BYTE PTR [rax+6520]
	test	r11b, r11b
	js	SHORT $LN6@is_last_cu

; 384  : 
; 385  :   const int cu_width = LCU_WIDTH >> depth;

	mov	r9d, 64					; 00000040H
	mov	ecx, ebx
	mov	eax, r9d
	sar	eax, cl

; 386  :   const int qg_width = LCU_WIDTH >> state->encoder_control->max_qp_delta_depth;

	movzx	ecx, r11b

; 387  :   const int right  = x + cu_width;
; 388  :   const int bottom = y + cu_width;

	add	r8d, eax
	sar	r9d, cl
	lea	r11d, DWORD PTR [rax+rdx]

; 389  :   return (right % qg_width == 0 || right >= state->tile->frame->width) &&

	mov	eax, r11d
	cdq
	idiv	r9d
	test	edx, edx
	je	SHORT $LN9@is_last_cu
	mov	rax, QWORD PTR [r10+48]
	mov	rcx, QWORD PTR [rax]
	cmp	r11d, DWORD PTR [rcx+16]
	jl	SHORT $LN6@is_last_cu
$LN9@is_last_cu:
	mov	eax, r8d
	cdq
	idiv	r9d
	test	edx, edx
	je	SHORT $LN5@is_last_cu
	mov	rax, QWORD PTR [r10+48]
	mov	rcx, QWORD PTR [rax]
	cmp	r8d, DWORD PTR [rcx+20]
	jge	SHORT $LN5@is_last_cu
$LN6@is_last_cu:

; 390  :          (bottom % qg_width == 0 || bottom >= state->tile->frame->height);
; 391  : }

	xor	al, al
	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN5@is_last_cu:
	mov	rbx, QWORD PTR [rsp+8]
	mov	al, 1
	ret	0
is_last_cu_in_qg ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
tv975 = 96
state$ = 96
lcu$ = 104
hor_buf$ = 112
ver_buf$ = 120
encoder_state_recdata_before_sao_to_bufs PROC

; 81   : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 82   :   videoframe_t* const frame = state->tile->frame;

	mov	rax, QWORD PTR [rcx+48]
	mov	r15, r9
	mov	r13, r8
	mov	rbp, rdx
	mov	r12, rcx
	mov	r14, QWORD PTR [rax]

; 83   : 
; 84   :   if (hor_buf && lcu->below) {

	test	r8, r8
	je	$LN5@encoder_st
	cmp	QWORD PTR [rdx+64], 0
	je	$LN5@encoder_st

; 85   :     // Copy the bottommost row that will be filtered with SAO to the
; 86   :     // horizontal buffer.
; 87   :     vector2d_t pos = {
; 88   :       .x = lcu->position_px.x,
; 89   :       .y = lcu->position_px.y + LCU_WIDTH - SAO_DELAY_PX - 1,
; 90   :     };
; 91   :     // Copy all pixels that have been deblocked.
; 92   :     int length = lcu->size.x - DEBLOCK_DELAY_PX;

	mov	ecx, DWORD PTR [rdx+32]
	mov	r10d, DWORD PTR [rdx+24]
	mov	r11d, DWORD PTR [rdx+28]

; 93   : 
; 94   :     if (!lcu->right) {
; 95   :       // If there is no LCU to the right, the last pixels will be
; 96   :       // filtered too.
; 97   :       length += DEBLOCK_DELAY_PX;
; 98   :     }
; 99   : 
; 100  :     if (lcu->left) {
; 101  :       // The rightmost pixels of the CTU to the left will also be filtered.
; 102  :       pos.x -= DEBLOCK_DELAY_PX;
; 103  :       length += DEBLOCK_DELAY_PX;
; 104  :     }
; 105  : 
; 106  :     const unsigned from_index = pos.x + pos.y * frame->rec->stride;
; 107  :     // NOTE: The horizontal buffer is indexed by
; 108  :     //    x_px + y_lcu * frame->width
; 109  :     // where x_px is in pixels and y_lcu in number of LCUs.
; 110  :     const unsigned to_index = pos.x + lcu->position.y * frame->width;
; 111  : 
; 112  :     kvz_pixels_blit(&frame->rec->y[from_index],

	mov	r8, QWORD PTR [r14+8]
	add	r11d, 53				; 00000035H
	cmp	QWORD PTR [rdx+80], 0
	lea	eax, DWORD PTR [rcx-8]
	lea	ebx, DWORD PTR [r10-8]
	mov	DWORD PTR tv975[rsp], r11d
	cmovne	ecx, eax
	mov	rax, QWORD PTR [rdx+72]
	mov	r9d, DWORD PTR [r8+72]
	test	rax, rax
	cmove	ebx, r10d
	mov	r10d, DWORD PTR [r14+16]
	lea	edi, DWORD PTR [rcx+8]
	mov	DWORD PTR [rsp+40], r10d
	cmove	edi, ecx
	mov	DWORD PTR [rsp+32], r9d
	mov	ecx, r9d
	mov	edx, r10d
	imul	edx, DWORD PTR [rbp+20]
	mov	r9d, 1
	imul	ecx, r11d
	add	edx, ebx
	add	rdx, QWORD PTR [r13+8]
	add	ecx, ebx
	add	rcx, QWORD PTR [r8+16]
	mov	r8d, edi
	call	kvz_pixels_blit

; 113  :                     &hor_buf->y[to_index],
; 114  :                     length, 1,
; 115  :                     frame->rec->stride,
; 116  :                     frame->width);
; 117  : 
; 118  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r12]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN5@encoder_st

; 119  :       const unsigned from_index_c = (pos.x / 2) + (pos.y / 2) * frame->rec->stride / 2;

	mov	r10, QWORD PTR [r14+8]
	mov	eax, ebx
	cdq

; 120  :       const unsigned to_index_c = (pos.x / 2) + lcu->position.y * frame->width / 2;
; 121  : 
; 122  :       kvz_pixels_blit(&frame->rec->u[from_index_c],

	mov	r9d, 1
	sub	eax, edx
	sar	eax, 1
	mov	ecx, eax
	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	mov	eax, DWORD PTR [r14+16]
	imul	eax, DWORD PTR [rbp+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [rcx+rax]
	mov	eax, DWORD PTR tv975[rsp]
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, DWORD PTR [r10+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ebx, DWORD PTR [rcx+rax]
	mov	eax, DWORD PTR [r14+16]
	mov	rcx, QWORD PTR [r10+24]
	cdq
	sub	eax, edx
	add	rcx, rbx
	sar	eax, 1
	mov	r8d, eax
	mov	eax, DWORD PTR [r10+72]
	cdq
	mov	DWORD PTR [rsp+40], r8d
	sub	eax, edx
	mov	r8d, esi
	mov	rdx, QWORD PTR [r13+16]
	sar	eax, 1
	add	rdx, rdi
	mov	DWORD PTR [rsp+32], eax
	call	kvz_pixels_blit

; 123  :                       &hor_buf->u[to_index_c],
; 124  :                       length / 2, 1,
; 125  :                       frame->rec->stride / 2,
; 126  :                       frame->width / 2);
; 127  :       kvz_pixels_blit(&frame->rec->v[from_index_c],

	mov	r9, QWORD PTR [r14+8]
	mov	eax, DWORD PTR [r14+16]
	cdq
	sub	eax, edx
	mov	rcx, QWORD PTR [r9+32]
	sar	eax, 1
	add	rcx, rbx
	mov	r8d, eax
	mov	eax, DWORD PTR [r9+72]
	cdq
	mov	DWORD PTR [rsp+40], r8d
	sub	eax, edx
	mov	r9d, 1
	mov	rdx, QWORD PTR [r13+24]
	mov	r8d, esi
	sar	eax, 1
	add	rdx, rdi
	mov	DWORD PTR [rsp+32], eax
	call	kvz_pixels_blit
$LN5@encoder_st:

; 128  :                       &hor_buf->v[to_index_c],
; 129  :                       length / 2, 1,
; 130  :                       frame->rec->stride / 2,
; 131  :                       frame->width / 2);
; 132  :     }
; 133  :   }
; 134  : 
; 135  :   if (ver_buf && lcu->right) {

	test	r15, r15
	je	$LN9@encoder_st
	cmp	QWORD PTR [rbp+80], 0
	je	$LN9@encoder_st

; 136  :     // Copy the rightmost column that will be filtered with SAO to the
; 137  :     // vertical buffer.
; 138  :     vector2d_t pos = {

	mov	edx, DWORD PTR [rbp+28]

; 139  :       .x = lcu->position_px.x + LCU_WIDTH - SAO_DELAY_PX - 1,
; 140  :       .y = lcu->position_px.y,
; 141  :     };
; 142  :     int length = lcu->size.y - DEBLOCK_DELAY_PX;

	mov	ecx, DWORD PTR [rbp+36]

; 143  : 
; 144  :     if (!lcu->below) {
; 145  :       // If there is no LCU below, the last pixels will be filtered too.
; 146  :       length += DEBLOCK_DELAY_PX;
; 147  :     }
; 148  : 
; 149  :     if (lcu->above) {
; 150  :       // The bottommost pixels of the CTU above will also be filtered.
; 151  :       pos.y -= DEBLOCK_DELAY_PX;
; 152  :       length += DEBLOCK_DELAY_PX;
; 153  :     }
; 154  : 
; 155  :     const unsigned from_index = pos.x + pos.y * frame->rec->stride;
; 156  :     // NOTE: The vertical buffer is indexed by
; 157  :     //    x_lcu * frame->height + y_px
; 158  :     // where x_lcu is in number of LCUs and y_px in pixels.
; 159  :     const unsigned to_index = lcu->position.x * frame->height + pos.y;
; 160  : 
; 161  :     kvz_pixels_blit(&frame->rec->y[from_index],

	mov	r8, QWORD PTR [r14+8]
	mov	r13d, DWORD PTR [rbp+24]
	lea	ebx, DWORD PTR [rdx-8]
	mov	DWORD PTR [rsp+40], 1
	lea	eax, DWORD PTR [rcx-8]
	add	r13d, 53				; 00000035H
	mov	r9d, DWORD PTR [r8+72]
	cmp	QWORD PTR [rbp+64], 0
	mov	DWORD PTR [rsp+32], r9d
	cmovne	ecx, eax
	mov	rax, QWORD PTR [rbp+56]
	test	rax, rax
	cmove	ebx, edx
	mov	edx, DWORD PTR [rbp+16]
	lea	edi, DWORD PTR [rcx+8]
	cmove	edi, ecx
	imul	edx, DWORD PTR [r14+20]
	mov	ecx, r9d
	mov	r9d, edi
	imul	ecx, ebx
	add	edx, ebx
	add	rdx, QWORD PTR [r15+8]
	add	ecx, r13d
	add	rcx, QWORD PTR [r8+16]
	mov	r8d, 1
	call	kvz_pixels_blit

; 162  :                     &ver_buf->y[to_index],
; 163  :                     1, length,
; 164  :                     frame->rec->stride, 1);
; 165  : 
; 166  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rcx, QWORD PTR [r12]
	cmp	DWORD PTR [rcx+2596], 0
	je	$LN9@encoder_st

; 167  :       const unsigned from_index_c = (pos.x / 2) + (pos.y / 2) * frame->rec->stride / 2;

	mov	r9, QWORD PTR [r14+8]
	mov	eax, ebx
	cdq

; 168  :       const unsigned to_index_c = lcu->position.x * frame->height / 2 + pos.y / 2;
; 169  : 
; 170  :       kvz_pixels_blit(&frame->rec->u[from_index_c],

	mov	DWORD PTR [rsp+40], 1
	sub	eax, edx
	mov	r8d, 1
	sar	eax, 1
	mov	ecx, eax
	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	mov	eax, DWORD PTR [rbp+16]
	imul	eax, DWORD PTR [r14+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edi, DWORD PTR [rcx+rax]
	mov	eax, DWORD PTR [r9+72]
	imul	eax, ecx
	mov	rcx, QWORD PTR [r9+24]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ebx, eax
	mov	eax, r13d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ebx, eax
	mov	eax, DWORD PTR [r9+72]
	cdq
	add	rcx, rbx
	sub	eax, edx
	mov	r9d, esi
	mov	rdx, QWORD PTR [r15+16]
	sar	eax, 1
	add	rdx, rdi
	mov	DWORD PTR [rsp+32], eax
	call	kvz_pixels_blit

; 171  :                       &ver_buf->u[to_index_c],
; 172  :                       1, length / 2,
; 173  :                       frame->rec->stride / 2, 1);
; 174  :       kvz_pixels_blit(&frame->rec->v[from_index_c],

	mov	r9, QWORD PTR [r14+8]
	mov	r8d, 1
	mov	DWORD PTR [rsp+40], 1
	mov	eax, DWORD PTR [r9+72]
	mov	rcx, QWORD PTR [r9+32]
	cdq
	sub	eax, edx
	add	rcx, rbx
	mov	rdx, QWORD PTR [r15+24]
	mov	r9d, esi
	sar	eax, 1
	add	rdx, rdi
	mov	DWORD PTR [rsp+32], eax
	call	kvz_pixels_blit
$LN9@encoder_st:

; 175  :                       &ver_buf->v[to_index_c],
; 176  :                       1, length / 2,
; 177  :                       frame->rec->stride / 2, 1);
; 178  :     }
; 179  :   }
; 180  : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
encoder_state_recdata_before_sao_to_bufs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 96
lcu$ = 104
hor_buf$ = 112
ver_buf$ = 120
encoder_state_recdata_to_bufs PROC

; 186  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 187  :   videoframe_t* const frame = state->tile->frame;

	mov	rax, QWORD PTR [rcx+48]
	mov	r15, r9
	mov	QWORD PTR [rsp+96], r13
	mov	r13, r8
	mov	rsi, rdx
	mov	r14, rcx
	mov	rbp, QWORD PTR [rax]

; 188  :   
; 189  :   if (hor_buf) {

	test	r8, r8
	je	$LN3@encoder_st

; 190  :     //Copy the bottom row of this LCU to the horizontal buffer
; 191  :     vector2d_t bottom = { lcu->position_px.x, lcu->position_px.y + lcu->size.y - 1 };

	mov	r10d, DWORD PTR [rdx+36]
	mov	r12d, DWORD PTR [rdx+28]
	dec	r10d
	mov	ebx, DWORD PTR [rdx+24]
	add	r12d, r10d

; 192  :     const int lcu_row = lcu->position.y;

	mov	edi, DWORD PTR [rdx+20]

; 193  : 
; 194  :     unsigned from_index = bottom.y * frame->rec->stride + bottom.x;
; 195  :     unsigned to_index = lcu->position_px.x + lcu_row * frame->width;
; 196  :     
; 197  :     kvz_pixels_blit(&frame->rec->y[from_index],

	mov	r8, QWORD PTR [rbp+8]
	mov	r10d, DWORD PTR [rbp+16]
	mov	edx, r10d
	imul	edx, edi
	mov	DWORD PTR [rsp+40], r10d
	mov	r9d, DWORD PTR [r8+72]
	mov	ecx, r9d
	imul	ecx, r12d
	mov	DWORD PTR [rsp+32], r9d
	mov	r9d, 1
	add	edx, ebx
	add	rdx, QWORD PTR [r13+8]
	add	ecx, ebx
	add	rcx, QWORD PTR [r8+16]
	mov	r8d, DWORD PTR [rsi+32]
	call	kvz_pixels_blit

; 198  :                     &hor_buf->y[to_index],
; 199  :                     lcu->size.x, 1,
; 200  :                     frame->rec->stride, frame->width);
; 201  : 
; 202  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r14]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN3@encoder_st

; 203  :       unsigned from_index_c = (bottom.y / 2) * frame->rec->stride / 2 + (bottom.x / 2);

	mov	r11, QWORD PTR [rbp+8]

; 204  :       unsigned to_index_c = lcu->position_px.x / 2 + lcu_row * frame->width / 2;

	mov	eax, DWORD PTR [rbp+16]
	imul	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
	mov	eax, DWORD PTR [rsi+24]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	edi, eax
	mov	eax, r12d
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, DWORD PTR [r11+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ebx, DWORD PTR [rax+rcx]

; 205  : 
; 206  :       kvz_pixels_blit(&frame->rec->u[from_index_c],

	mov	eax, DWORD PTR [rbp+16]
	mov	rcx, QWORD PTR [r11+24]
	cdq
	sub	eax, edx
	add	rcx, rbx
	sar	eax, 1
	mov	r10d, eax
	mov	eax, DWORD PTR [r11+72]
	cdq
	mov	DWORD PTR [rsp+40], r10d
	sub	eax, edx
	sar	eax, 1
	mov	r9d, eax
	mov	eax, DWORD PTR [rsi+32]
	cdq
	mov	DWORD PTR [rsp+32], r9d
	sub	eax, edx
	mov	r9d, 1
	mov	rdx, QWORD PTR [r13+16]
	sar	eax, 1
	add	rdx, rdi
	mov	r8d, eax
	call	kvz_pixels_blit

; 207  :                       &hor_buf->u[to_index_c],
; 208  :                       lcu->size.x / 2, 1, 
; 209  :                       frame->rec->stride / 2, frame->width / 2);
; 210  :       kvz_pixels_blit(&frame->rec->v[from_index_c],

	mov	r11, QWORD PTR [rbp+8]
	mov	eax, DWORD PTR [rbp+16]
	cdq
	sub	eax, edx
	mov	rcx, QWORD PTR [r11+32]
	sar	eax, 1
	add	rcx, rbx
	mov	r10d, eax
	mov	eax, DWORD PTR [r11+72]
	cdq
	mov	DWORD PTR [rsp+40], r10d
	sub	eax, edx
	sar	eax, 1
	mov	r9d, eax
	mov	eax, DWORD PTR [rsi+32]
	cdq
	mov	DWORD PTR [rsp+32], r9d
	sub	eax, edx
	mov	r9d, 1
	mov	rdx, QWORD PTR [r13+24]
	sar	eax, 1
	add	rdx, rdi
	mov	r8d, eax
	call	kvz_pixels_blit
$LN3@encoder_st:

; 211  :                       &hor_buf->v[to_index_c],
; 212  :                       lcu->size.x / 2, 1,
; 213  :                       frame->rec->stride / 2, frame->width / 2);
; 214  :     }
; 215  :   }
; 216  :   
; 217  :   if (ver_buf) {

	mov	r13, QWORD PTR [rsp+96]
	test	r15, r15
	je	$LN5@encoder_st

; 218  :     //Copy the right row of this LCU to the vertical buffer.
; 219  :     
; 220  :     const int lcu_col = lcu->position.x;
; 221  :     vector2d_t left = { lcu->position_px.x + lcu->size.x - 1, lcu->position_px.y };
; 222  :     
; 223  :     kvz_pixels_blit(&frame->rec->y[left.y * frame->rec->stride + left.x],

	mov	r8, QWORD PTR [rbp+8]
	mov	ebx, DWORD PTR [rsi+28]
	mov	ecx, DWORD PTR [rsi+32]
	mov	eax, DWORD PTR [rbp+20]
	dec	ecx
	mov	r9d, DWORD PTR [r8+72]
	mov	edi, DWORD PTR [rsi+16]
	mov	r12d, DWORD PTR [rsi+24]
	imul	eax, edi
	add	r12d, ecx
	mov	DWORD PTR [rsp+40], 1
	mov	DWORD PTR [rsp+32], r9d
	add	eax, ebx
	movsxd	rdx, eax
	mov	eax, r9d
	add	rdx, QWORD PTR [r15+8]
	mov	r9d, DWORD PTR [rsi+36]
	imul	eax, ebx
	add	eax, r12d
	movsxd	rcx, eax
	add	rcx, QWORD PTR [r8+16]
	mov	r8d, 1
	call	kvz_pixels_blit

; 224  :                     &ver_buf->y[lcu->position_px.y + lcu_col * frame->height],
; 225  :                     1, lcu->size.y,
; 226  :                     frame->rec->stride, 1);
; 227  : 
; 228  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r14]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN5@encoder_st

; 229  :       unsigned from_index = (left.y / 2) * frame->rec->stride / 2 + (left.x / 2);

	mov	r10, QWORD PTR [rbp+8]

; 230  :       unsigned to_index = lcu->position_px.y / 2 + lcu_col * frame->height / 2;

	mov	eax, DWORD PTR [rbp+20]
	imul	eax, edi

; 231  : 
; 232  :       kvz_pixels_blit(&frame->rec->u[from_index],

	mov	DWORD PTR [rsp+40], 1
	mov	rcx, QWORD PTR [r10+24]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
	mov	eax, DWORD PTR [rsi+28]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	edi, eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, DWORD PTR [r10+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ebx, eax
	mov	eax, r12d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ebx, eax
	mov	eax, DWORD PTR [r10+72]
	cdq
	add	rcx, rbx
	sub	eax, edx
	sar	eax, 1
	mov	r8d, eax
	mov	eax, DWORD PTR [rsi+36]
	cdq
	mov	DWORD PTR [rsp+32], r8d
	sub	eax, edx
	mov	r8d, 1
	mov	rdx, QWORD PTR [r15+16]
	sar	eax, 1
	add	rdx, rdi
	mov	r9d, eax
	call	kvz_pixels_blit

; 233  :                       &ver_buf->u[to_index],
; 234  :                       1, lcu->size.y / 2,
; 235  :                       frame->rec->stride / 2, 1);
; 236  :       kvz_pixels_blit(&frame->rec->v[from_index],

	mov	r11, QWORD PTR [rbp+8]
	mov	r8d, 1
	mov	DWORD PTR [rsp+40], 1
	mov	eax, DWORD PTR [r11+72]
	mov	rcx, QWORD PTR [r11+32]
	cdq
	sub	eax, edx
	add	rcx, rbx
	sar	eax, 1
	mov	r10d, eax
	mov	eax, DWORD PTR [rsi+36]
	cdq
	mov	DWORD PTR [rsp+32], r10d
	sub	eax, edx
	mov	rdx, QWORD PTR [r15+24]
	sar	eax, 1
	add	rdx, rdi
	mov	r9d, eax
	call	kvz_pixels_blit
$LN5@encoder_st:

; 237  :                       &ver_buf->v[to_index],
; 238  :                       1, lcu->size.y / 2,
; 239  :                       frame->rec->stride / 2, 1);
; 240  :     }
; 241  :   }
; 242  :   
; 243  : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
encoder_state_recdata_to_bufs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
border_index_c$1$ = 80
border_above$1$ = 84
height$1$ = 88
frame$1$ = 96
border_left$1$ = 104
width$1$ = 108
tv1405 = 112
tv1404 = 116
y_offsets$ = 120
x_offsets$ = 136
sao_buf_u_array$ = 160
sao_buf_v_array$ = 1616
sao_buf_y_array$ = 3072
state$ = 8784
y$1$ = 8792
border_below$1$ = 8792
lcu$ = 8792
sao_chroma$1$ = 8800
border_right$1$ = 8800
$T1 = 8808
border_index$1$ = 8808
encoder_sao_reconstruct PROC

; 261  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	eax, 8712				; 00002208H
	call	__chkstk
	sub	rsp, rax

; 262  :   videoframe_t *const frame = state->tile->frame;

	mov	rax, QWORD PTR [rcx+48]
	mov	r14, rcx

; 263  : 
; 264  : 
; 265  :   // Temporary buffers for SAO input pixels. The buffers cover the pixels
; 266  :   // inside the LCU (LCU_WIDTH x LCU_WIDTH), SAO_DELAY_PX wide bands to the
; 267  :   // left and above the LCU, and one pixel border on the left and top
; 268  :   // sides. We add two extra pixels to the buffers because the AVX2 SAO
; 269  :   // reconstruction reads up to two extra bytes when using edge SAO in the
; 270  :   // horizontal direction.
; 271  : #define SAO_BUF_WIDTH   (1 + SAO_DELAY_PX   + LCU_WIDTH)
; 272  : #define SAO_BUF_WIDTH_C (1 + SAO_DELAY_PX/2 + LCU_WIDTH_C)
; 273  :   kvz_pixel sao_buf_y_array[SAO_BUF_WIDTH   * SAO_BUF_WIDTH   + 2];
; 274  :   kvz_pixel sao_buf_u_array[SAO_BUF_WIDTH_C * SAO_BUF_WIDTH_C + 2];
; 275  :   kvz_pixel sao_buf_v_array[SAO_BUF_WIDTH_C * SAO_BUF_WIDTH_C + 2];
; 276  : 
; 277  :   // Pointers to the top-left pixel of the LCU in the buffers.
; 278  :   kvz_pixel *const sao_buf_y = &sao_buf_y_array[(SAO_DELAY_PX + 1) * (SAO_BUF_WIDTH + 1)];
; 279  :   kvz_pixel *const sao_buf_u = &sao_buf_u_array[(SAO_DELAY_PX/2 + 1) * (SAO_BUF_WIDTH_C + 1)];
; 280  :   kvz_pixel *const sao_buf_v = &sao_buf_v_array[(SAO_DELAY_PX/2 + 1) * (SAO_BUF_WIDTH_C + 1)];
; 281  : 
; 282  :   const int x_offsets[3] = {

	mov	r9, QWORD PTR [rdx+72]
	mov	r13, rdx
	mov	r8, QWORD PTR [rdx+80]

; 283  :     // If there is an lcu to the left, we need to filter its rightmost
; 284  :     // pixels.
; 285  :     lcu->left ? -SAO_DELAY_PX : 0,
; 286  :     0,
; 287  :     // If there is an lcu to the right, the rightmost pixels of this LCU
; 288  :     // are filtered when filtering that LCU. Otherwise we filter them now.
; 289  :     lcu->size.x - (lcu->right ? SAO_DELAY_PX : 0),
; 290  :   };
; 291  : 
; 292  :   const int y_offsets[3] = {

	mov	r10, QWORD PTR [rdx+56]
	mov	rbp, QWORD PTR [rax]
	mov	rax, r9
	mov	edi, DWORD PTR [rdx+32]
	neg	rax
	mov	rdx, QWORD PTR [rdx+64]
	mov	rax, r8
	sbb	r12d, r12d
	mov	ebx, DWORD PTR [r13+36]
	xor	esi, esi
	mov	QWORD PTR frame$1$[rsp], rbp
	and	r12d, -10
	mov	DWORD PTR x_offsets$[rsp+4], esi
	neg	rax
	mov	DWORD PTR y_offsets$[rsp+4], esi

; 293  :     // If there is an lcu above, we need to filter its bottommost pixels.
; 294  :     lcu->above ? -SAO_DELAY_PX : 0,
; 295  :     0,
; 296  :     // If there is an lcu below, the bottommost pixels of this LCU are
; 297  :     // filtered when filtering that LCU. Otherwise we filter them now.
; 298  :     lcu->size.y - (lcu->below ? SAO_DELAY_PX : 0),
; 299  :   };
; 300  : 
; 301  :   // Number of pixels around the block that need to be copied to the
; 302  :   // buffers.
; 303  :   const int border_left  = lcu->left  ? 1 : 0;

	mov	r11d, esi
	mov	DWORD PTR x_offsets$[rsp], r12d
	sbb	ecx, ecx
	mov	rax, r10
	and	ecx, 10
	sub	edi, ecx
	neg	rax
	mov	DWORD PTR x_offsets$[rsp+8], edi
	mov	rax, rdx
	sbb	r15d, r15d
	and	r15d, -10
	neg	rax
	mov	DWORD PTR y_offsets$[rsp], r15d

; 304  :   const int border_right = lcu->right ? 1 : 0;

	mov	eax, esi
	sbb	ecx, ecx
	and	ecx, 10
	sub	ebx, ecx
	test	r9, r9
	mov	DWORD PTR y_offsets$[rsp+8], ebx
	setne	r11b
	test	r8, r8
	mov	DWORD PTR border_left$1$[rsp], r11d
	setne	al

; 305  :   const int border_above = lcu->above ? 1 : 0;

	test	r10, r10
	mov	DWORD PTR border_right$1$[rsp], eax

; 306  :   const int border_below = lcu->below ? 1 : 0;
; 307  : 
; 308  :   // Index of the pixel at the intersection of the top and left borders.
; 309  :   const int border_index = (x_offsets[0] - border_left) +

	mov	eax, r15d
	setne	sil
	xor	r9d, r9d
	test	rdx, rdx
	mov	DWORD PTR border_above$1$[rsp], esi
	setne	r9b
	sub	eax, esi
	imul	r8d, eax, 75				; 0000004bH

; 310  :                            (y_offsets[0] - border_above) * SAO_BUF_WIDTH;
; 311  :   const int border_index_c = (x_offsets[0]/2 - border_left) +

	sub	edi, r12d

; 312  :                              (y_offsets[0]/2 - border_above) * SAO_BUF_WIDTH_C;
; 313  :   // Width and height of the whole area to filter.
; 314  :   const int width  = x_offsets[2] - x_offsets[0];

	sub	ebx, r15d
	mov	DWORD PTR border_below$1$[rsp], r9d
	mov	eax, r15d
	mov	DWORD PTR width$1$[rsp], edi
	cdq
	mov	DWORD PTR height$1$[rsp], ebx
	sub	eax, edx
	sar	eax, 1
	sub	r8d, r11d
	mov	ecx, eax
	mov	DWORD PTR tv1405[rsp], eax
	sub	ecx, esi
	add	r8d, r12d
	mov	eax, r12d
	mov	DWORD PTR border_index$1$[rsp], r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, eax
	mov	DWORD PTR tv1404[rsp], eax
	imul	eax, ecx, 38				; 00000026H
	sub	eax, r11d
	add	eax, edx
	mov	DWORD PTR border_index_c$1$[rsp], eax

; 315  :   const int height = y_offsets[2] - y_offsets[0];
; 316  : 
; 317  :   // Copy bordering pixels from above and left to buffers.
; 318  :   if (lcu->above) {

	test	r10, r10
	je	$LN9@encoder_sa

; 319  :     const int from_index = (lcu->position_px.x + x_offsets[0] - border_left) +
; 320  :                            (lcu->position.y - 1) * frame->width;
; 321  :     kvz_pixels_blit(&state->tile->hor_buf_before_sao->y[from_index],

	mov	r9d, DWORD PTR [rbp+16]
	lea	rdx, QWORD PTR sao_buf_y_array$[rsp+836]
	movsxd	rax, DWORD PTR border_index$1$[rsp]
	mov	r8d, DWORD PTR border_right$1$[rsp]
	add	rdx, rax
	mov	eax, DWORD PTR [r13+20]
	add	r8d, edi
	dec	eax
	mov	DWORD PTR [rsp+40], 75			; 0000004bH
	imul	eax, r9d
	add	r8d, r11d
	mov	DWORD PTR [rsp+32], r9d
	mov	r9d, 1
	sub	eax, r11d
	add	eax, DWORD PTR [r13+24]
	add	eax, r12d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r14+48]
	mov	rax, QWORD PTR [rax+48]
	add	rcx, QWORD PTR [rax+8]
	call	kvz_pixels_blit

; 322  :                     &sao_buf_y[border_index],
; 323  :                     width + border_left + border_right,
; 324  :                     1,
; 325  :                     frame->width,
; 326  :                     SAO_BUF_WIDTH);
; 327  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r14]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN25@encoder_sa

; 328  :       const int from_index_c = (lcu->position_px.x + x_offsets[0])/2 - border_left +
; 329  :                                (lcu->position.y - 1) * frame->width/2;
; 330  :       kvz_pixels_blit(&state->tile->hor_buf_before_sao->u[from_index_c],

	mov	rcx, QWORD PTR [r14+48]
	mov	eax, edi
	mov	esi, DWORD PTR border_right$1$[rsp]
	cdq
	movsxd	rdi, DWORD PTR border_index_c$1$[rsp]
	sub	eax, edx
	sar	eax, 1
	mov	r9d, 1
	add	esi, eax
	mov	DWORD PTR [rsp+40], 38			; 00000026H
	mov	eax, DWORD PTR [r13+20]
	add	esi, DWORD PTR border_left$1$[rsp]
	dec	eax
	imul	eax, DWORD PTR [rbp+16]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r8d, eax
	mov	eax, DWORD PTR [r13+24]
	add	eax, r12d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	r8d, eax
	mov	eax, DWORD PTR [rbp+16]
	sub	r8d, DWORD PTR border_left$1$[rsp]
	cdq
	movsxd	rbx, r8d
	sub	eax, edx
	mov	r8, QWORD PTR [rcx+48]
	lea	rdx, QWORD PTR sao_buf_u_array$[rsp+234]
	sar	eax, 1
	add	rdx, rdi
	mov	DWORD PTR [rsp+32], eax
	mov	rcx, QWORD PTR [r8+16]
	mov	r8d, esi
	add	rcx, rbx
	call	kvz_pixels_blit

; 331  :                       &sao_buf_u[border_index_c],
; 332  :                       width/2 + border_left + border_right,
; 333  :                       1,
; 334  :                       frame->width/2,
; 335  :                       SAO_BUF_WIDTH_C);
; 336  :       kvz_pixels_blit(&state->tile->hor_buf_before_sao->v[from_index_c],

	mov	rcx, QWORD PTR [r14+48]
	mov	r8d, esi
	mov	eax, DWORD PTR [rbp+16]
	cdq
	mov	DWORD PTR [rsp+40], 38			; 00000026H
	sub	eax, edx
	lea	rdx, QWORD PTR sao_buf_v_array$[rsp+234]
	mov	r9, QWORD PTR [rcx+48]
	add	rdx, rdi
	sar	eax, 1
	mov	DWORD PTR [rsp+32], eax
	mov	rcx, QWORD PTR [r9+24]
	mov	r9d, 1
	add	rcx, rbx
	call	kvz_pixels_blit
	mov	ebx, DWORD PTR height$1$[rsp]
	mov	esi, DWORD PTR border_above$1$[rsp]
$LN25@encoder_sa:

; 337  :                       &sao_buf_v[border_index_c],
; 338  :                       width/2 + border_left + border_right,
; 339  :                       1,
; 340  :                       frame->width/2,
; 341  :                       SAO_BUF_WIDTH_C);
; 342  :     }
; 343  :   }
; 344  :   if (lcu->left) {

	mov	r9d, DWORD PTR border_below$1$[rsp]
	mov	r8d, DWORD PTR border_index$1$[rsp]
$LN9@encoder_sa:
	cmp	QWORD PTR [r13+72], 0
	je	$LN11@encoder_sa

; 345  :     const int from_index = (lcu->position.x - 1) * frame->height +
; 346  :                            (lcu->position_px.y + y_offsets[0] - border_above);
; 347  :     kvz_pixels_blit(&state->tile->ver_buf_before_sao->y[from_index],

	movsxd	rax, r8d
	lea	rdx, QWORD PTR sao_buf_y_array$[rsp+836]
	add	rdx, rax
	mov	DWORD PTR [rsp+40], 75			; 0000004bH
	mov	eax, DWORD PTR [r13+16]
	add	r9d, ebx
	dec	eax
	mov	DWORD PTR [rsp+32], 1
	imul	eax, DWORD PTR [rbp+20]
	add	r9d, esi
	sub	eax, esi
	add	eax, r15d
	add	eax, DWORD PTR [r13+28]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r14+48]
	mov	r8, QWORD PTR [rax+56]
	add	rcx, QWORD PTR [r8+8]
	mov	r8d, 1
	call	kvz_pixels_blit

; 348  :                     &sao_buf_y[border_index],
; 349  :                     1,
; 350  :                     height + border_above + border_below,
; 351  :                     1,
; 352  :                     SAO_BUF_WIDTH);
; 353  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r14]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN11@encoder_sa

; 354  :       const int from_index_c = (lcu->position.x - 1) * frame->height/2 +
; 355  :                                (lcu->position_px.y + y_offsets[0])/2 - border_above;
; 356  :       kvz_pixels_blit(&state->tile->ver_buf_before_sao->u[from_index_c],

	movsxd	rdi, DWORD PTR border_index_c$1$[rsp]
	mov	eax, ebx
	cdq
	mov	DWORD PTR [rsp+40], 38			; 00000026H
	sub	eax, edx
	mov	DWORD PTR [rsp+32], 1
	sar	eax, 1
	add	eax, DWORD PTR border_below$1$[rsp]
	add	esi, eax
	mov	eax, DWORD PTR [r13+16]
	dec	eax
	mov	r9d, esi
	imul	eax, DWORD PTR [rbp+20]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r8d, eax
	mov	eax, DWORD PTR [r13+28]
	add	eax, r15d
	cdq
	sub	eax, edx
	lea	rdx, QWORD PTR sao_buf_u_array$[rsp+234]
	sar	eax, 1
	add	rdx, rdi
	add	r8d, eax
	mov	rax, QWORD PTR [r14+48]
	sub	r8d, DWORD PTR border_above$1$[rsp]
	movsxd	rbx, r8d
	mov	r8d, 1
	mov	rcx, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR [rcx+16]
	add	rcx, rbx
	call	kvz_pixels_blit

; 357  :                       &sao_buf_u[border_index_c],
; 358  :                       1,
; 359  :                       height/2 + border_above + border_below,
; 360  :                       1,
; 361  :                       SAO_BUF_WIDTH_C);
; 362  :       kvz_pixels_blit(&state->tile->ver_buf_before_sao->v[from_index_c],

	mov	rax, QWORD PTR [r14+48]
	lea	rdx, QWORD PTR sao_buf_v_array$[rsp+234]
	add	rdx, rdi
	mov	DWORD PTR [rsp+40], 38			; 00000026H
	mov	r9d, esi
	mov	DWORD PTR [rsp+32], 1
	mov	r8d, 1
	mov	rcx, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR [rcx+24]
	add	rcx, rbx
	call	kvz_pixels_blit
$LN11@encoder_sa:

; 363  :                       &sao_buf_v[border_index_c],
; 364  :                       1,
; 365  :                       height/2 + border_above + border_below,
; 366  :                       1,
; 367  :                       SAO_BUF_WIDTH_C);
; 368  :     }
; 369  :   }
; 370  :   // Copy pixels that will be filtered and bordering pixels from right and
; 371  :   // below.
; 372  :   const int from_index = (lcu->position_px.x + x_offsets[0]) +
; 373  :                          (lcu->position_px.y + y_offsets[0]) * frame->rec->stride;
; 374  :   const int to_index = x_offsets[0] + y_offsets[0] * SAO_BUF_WIDTH;
; 375  :   kvz_pixels_blit(&frame->rec->y[from_index],

	mov	r10, QWORD PTR [rbp+8]
	lea	rdx, QWORD PTR sao_buf_y_array$[rsp+836]
	mov	ecx, DWORD PTR [r13+28]
	mov	r8d, DWORD PTR border_right$1$[rsp]
	add	ecx, r15d
	mov	ebx, DWORD PTR height$1$[rsp]
	mov	r11d, DWORD PTR [r10+72]
	mov	esi, DWORD PTR border_below$1$[rsp]
	mov	edi, DWORD PTR width$1$[rsp]
	add	r8d, edi
	imul	ecx, r11d
	imul	eax, r15d, 75				; 0000004bH
	lea	r9d, DWORD PTR [rbx+rsi]
	mov	DWORD PTR [rsp+40], 75			; 0000004bH
	mov	DWORD PTR [rsp+32], r11d
	add	ecx, r12d
	add	ecx, DWORD PTR [r13+24]
	add	eax, r12d
	movsxd	rcx, ecx
	add	rcx, QWORD PTR [r10+16]
	cdqe
	add	rdx, rax
	call	kvz_pixels_blit

; 376  :                   &sao_buf_y[to_index],
; 377  :                   width + border_right,
; 378  :                   height + border_below,
; 379  :                   frame->rec->stride,
; 380  :                   SAO_BUF_WIDTH);
; 381  :   if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rcx, QWORD PTR [r14]
	cmp	DWORD PTR [rcx+2596], 0
	je	$LN12@encoder_sa

; 382  :     const int from_index_c = (lcu->position_px.x + x_offsets[0])/2 +

	mov	r10, QWORD PTR [rbp+8]

; 383  :                              (lcu->position_px.y + y_offsets[0])/2 * frame->rec->stride/2;
; 384  :     const int to_index_c = x_offsets[0]/2 + y_offsets[0]/2 * SAO_BUF_WIDTH_C;
; 385  :     kvz_pixels_blit(&frame->rec->u[from_index_c],

	mov	eax, ebx
	cdq
	mov	DWORD PTR [rsp+40], 38			; 00000026H
	sub	eax, edx
	sar	eax, 1
	mov	rcx, QWORD PTR [r10+24]
	lea	ebp, DWORD PTR [rax+rsi]
	mov	esi, DWORD PTR border_right$1$[rsp]
	mov	eax, edi
	mov	r9d, ebp
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	imul	eax, DWORD PTR tv1405[rsp], 38		; 00000026H
	add	eax, DWORD PTR tv1404[rsp]
	movsxd	rdi, eax
	mov	eax, DWORD PTR [r13+28]
	add	eax, r15d
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, DWORD PTR [r10+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r8d, eax
	mov	eax, DWORD PTR [r13+24]
	add	eax, r12d
	cdq
	sub	eax, edx
	sar	eax, 1
	add	r8d, eax
	mov	eax, DWORD PTR [r10+72]
	cdq
	movsxd	rbx, r8d
	sub	eax, edx
	add	rcx, rbx
	sar	eax, 1
	lea	rdx, QWORD PTR sao_buf_u_array$[rsp+234]
	add	rdx, rdi
	mov	DWORD PTR [rsp+32], eax
	mov	r8d, esi
	call	kvz_pixels_blit

; 386  :                     &sao_buf_u[to_index_c],
; 387  :                     width/2 + border_right,
; 388  :                     height/2 + border_below,
; 389  :                     frame->rec->stride/2,
; 390  :                     SAO_BUF_WIDTH_C);
; 391  :     kvz_pixels_blit(&frame->rec->v[from_index_c],

	mov	rax, QWORD PTR frame$1$[rsp]
	mov	r9d, ebp
	mov	DWORD PTR [rsp+40], 38			; 00000026H
	mov	r8d, esi
	mov	rcx, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rcx+72]
	mov	rcx, QWORD PTR [rcx+32]
	cdq
	sub	eax, edx
	add	rcx, rbx
	sar	eax, 1
	lea	rdx, QWORD PTR sao_buf_v_array$[rsp+234]
	add	rdx, rdi
	mov	DWORD PTR [rsp+32], eax
	call	kvz_pixels_blit
	mov	rbp, QWORD PTR frame$1$[rsp]
$LN12@encoder_sa:
	xor	eax, eax
	mov	QWORD PTR $T1[rsp], rax
	npad	9
$LL4@encoder_sa:

; 406  :       const int x = x_offsets[x_offset_index];
; 407  :       const int y = y_offsets[y_offset_index];

	mov	esi, DWORD PTR y_offsets$[rsp+rax*4]
	xor	r15d, r15d
	mov	r12d, DWORD PTR y_offsets$[rsp+rax*4+4]
	sub	r12d, esi
	mov	DWORD PTR y$1$[rsp], esi
	npad	10
$LL7@encoder_sa:

; 408  :       const int width = x_offsets[x_offset_index + 1] - x;

	mov	edi, DWORD PTR x_offsets$[rsp+r15*4+4]
	mov	ebx, DWORD PTR x_offsets$[rsp+r15*4]
	sub	edi, ebx

; 409  :       const int height = y_offsets[y_offset_index + 1] - y;
; 410  : 
; 411  :       if (width == 0 || height == 0) continue;

	je	$LN5@encoder_sa
	test	r12d, r12d
	je	$LN5@encoder_sa

; 412  : 
; 413  :       const int lcu_x = (lcu->position_px.x + x) >> LOG2_LCU_WIDTH;
; 414  :       const int lcu_y = (lcu->position_px.y + y) >> LOG2_LCU_WIDTH;

	mov	r10d, DWORD PTR [r13+28]

; 415  :       const int lcu_index = lcu_x + lcu_y * frame->width_in_lcu;
; 416  :       const sao_info_t *sao_luma   = &frame->sao_luma[lcu_index];
; 417  :       const sao_info_t *sao_chroma = &frame->sao_chroma[lcu_index];
; 418  : 
; 419  :       kvz_sao_reconstruct(state,

	lea	rdx, QWORD PTR sao_buf_y_array$[rsp+836]
	mov	r9d, DWORD PTR [r13+24]
	add	r10d, esi
	mov	r8, QWORD PTR [rbp+40]
	mov	ecx, r10d
	sar	ecx, 6
	add	r9d, ebx
	imul	ecx, DWORD PTR [rbp+28]
	mov	eax, r9d
	sar	eax, 6
	mov	DWORD PTR [rsp+64], 0
	add	eax, ecx
	cdqe
	imul	rcx, rax, 68				; 00000044H
	mov	rax, QWORD PTR [rbp+48]
	add	rax, rcx
	add	r8, rcx
	mov	QWORD PTR [rsp+56], r8
	mov	rcx, r14
	mov	QWORD PTR sao_chroma$1$[rsp], rax
	mov	r8d, 75					; 0000004bH
	imul	eax, esi, 75				; 0000004bH
	mov	DWORD PTR [rsp+48], r12d
	mov	DWORD PTR [rsp+40], edi
	mov	DWORD PTR [rsp+32], r10d
	add	eax, ebx
	cdqe
	add	rdx, rax
	call	kvz_sao_reconstruct

; 420  :                           &sao_buf_y[x + y * SAO_BUF_WIDTH],
; 421  :                           SAO_BUF_WIDTH,
; 422  :                           lcu->position_px.x + x,
; 423  :                           lcu->position_px.y + y,
; 424  :                           width,
; 425  :                           height,
; 426  :                           sao_luma,
; 427  :                           COLOR_Y);
; 428  : 
; 429  :       if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rcx, QWORD PTR [r14]
	cmp	DWORD PTR [rcx+2596], 0
	je	$LN5@encoder_sa

; 430  :         // Coordinates in chroma pixels.
; 431  :         int x_c = x >> 1;
; 432  :         int y_c = y >> 1;
; 433  : 
; 434  :         kvz_sao_reconstruct(state,

	mov	r8, QWORD PTR sao_chroma$1$[rsp]
	mov	eax, r12d
	cdq
	mov	DWORD PTR [rsp+64], 1
	sub	eax, edx
	mov	QWORD PTR [rsp+56], r8
	sar	eax, 1
	mov	ebp, esi
	mov	r14d, eax
	sar	ebp, 1
	mov	eax, edi
	imul	ecx, ebp, 38				; 00000026H
	cdq
	sar	ebx, 1
	sub	eax, edx
	mov	DWORD PTR [rsp+48], r14d
	sar	eax, 1
	mov	r8d, 38					; 00000026H
	mov	esi, eax
	mov	eax, DWORD PTR [r13+28]
	cdq
	mov	DWORD PTR [rsp+40], esi
	sub	eax, edx
	add	ecx, ebx
	sar	eax, 1
	movsxd	rdi, ecx
	lea	ecx, DWORD PTR [rax+rbp]
	mov	eax, DWORD PTR [r13+24]
	cdq
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, QWORD PTR state$[rsp]
	sub	eax, edx
	sar	eax, 1
	lea	rdx, QWORD PTR sao_buf_u_array$[rsp+234]
	add	rdx, rdi
	lea	r9d, DWORD PTR [rbx+rax]
	call	kvz_sao_reconstruct

; 435  :                             &sao_buf_u[x_c + y_c * SAO_BUF_WIDTH_C],
; 436  :                             SAO_BUF_WIDTH_C,
; 437  :                             lcu->position_px.x / 2 + x_c,
; 438  :                             lcu->position_px.y / 2 + y_c,
; 439  :                             width / 2,
; 440  :                             height / 2,
; 441  :                             sao_chroma,
; 442  :                             COLOR_U);
; 443  :         kvz_sao_reconstruct(state,

	mov	eax, DWORD PTR [r13+28]
	mov	r8, QWORD PTR sao_chroma$1$[rsp]
	cdq
	sub	eax, edx
	mov	DWORD PTR [rsp+64], 2
	sar	eax, 1
	mov	QWORD PTR [rsp+56], r8
	mov	r8d, 38					; 00000026H
	mov	DWORD PTR [rsp+48], r14d
	mov	r14, QWORD PTR state$[rsp]
	lea	ecx, DWORD PTR [rax+rbp]
	mov	DWORD PTR [rsp+40], esi
	mov	eax, DWORD PTR [r13+24]
	cdq
	mov	DWORD PTR [rsp+32], ecx
	sub	eax, edx
	mov	rcx, r14
	sar	eax, 1
	lea	rdx, QWORD PTR sao_buf_v_array$[rsp+234]
	add	rdx, rdi
	lea	r9d, DWORD PTR [rbx+rax]
	call	kvz_sao_reconstruct
	mov	esi, DWORD PTR y$1$[rsp]
$LN5@encoder_sa:

; 405  :     for (int x_offset_index = 0; x_offset_index < 2; x_offset_index++) {

	mov	rbp, QWORD PTR frame$1$[rsp]
	inc	r15
	cmp	r15, 2
	jl	$LL7@encoder_sa

; 392  :                     &sao_buf_v[to_index_c],
; 393  :                     width/2 + border_right,
; 394  :                     height/2 + border_below,
; 395  :                     frame->rec->stride/2,
; 396  :                     SAO_BUF_WIDTH_C);
; 397  :   }
; 398  : 
; 399  :   // We filter the pixels in four parts:
; 400  :   //  1. Pixels that belong to the LCU above and to the left
; 401  :   //  2. Pixels that belong to the LCU above
; 402  :   //  3. Pixels that belong to the LCU to the left
; 403  :   //  4. Pixels that belong to the current LCU
; 404  :   for (int y_offset_index = 0; y_offset_index < 2; y_offset_index++) {

	mov	rax, QWORD PTR $T1[rsp]
	inc	rax
	mov	QWORD PTR $T1[rsp], rax
	cmp	rax, 2
	jl	$LL4@encoder_sa

; 444  :                             &sao_buf_v[x_c + y_c * SAO_BUF_WIDTH_C],
; 445  :                             SAO_BUF_WIDTH_C,
; 446  :                             lcu->position_px.x / 2 + x_c,
; 447  :                             lcu->position_px.y / 2 + y_c,
; 448  :                             width / 2,
; 449  :                             height / 2,
; 450  :                             sao_chroma,
; 451  :                             COLOR_V);
; 452  :       }
; 453  :     }
; 454  :   }
; 455  : }

	add	rsp, 8712				; 00002208H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
encoder_sao_reconstruct ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 96
sao$ = 104
color_i$ = 112
encode_sao_color PROC

; 459  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 460  :   cabac_data_t * const cabac = &state->cabac;

	lea	rsi, QWORD PTR [rcx+128]
	mov	rdi, rdx
	mov	rbx, rcx

; 461  :   sao_eo_cat i;
; 462  :   int offset_index = (color_i == COLOR_V) ? 5 : 0;
; 463  : 
; 464  :   // Skip colors with no SAO.
; 465  :   //FIXME: for now, we always have SAO for all channels
; 466  :   if (color_i == COLOR_Y && 0) return;
; 467  :   if (color_i != COLOR_Y && 0) return;
; 468  : 
; 469  :   /// sao_type_idx_luma:   TR, cMax = 2, cRiceParam = 0, bins = {0, bypass}
; 470  :   /// sao_type_idx_chroma: TR, cMax = 2, cRiceParam = 0, bins = {0, bypass}
; 471  :   // Encode sao_type_idx for Y and U+V.
; 472  :   if (color_i != COLOR_V) {

	cmp	r8d, 2
	je	SHORT $LN26@encode_sao

; 473  :     cabac->cur_ctx = &(cabac->ctx.sao_type_idx_model);

	lea	rax, QWORD PTR [rcx+169]

; 474  :     CABAC_BIN(cabac, sao->type != SAO_TYPE_NONE, "sao_type_idx");

	xor	edx, edx
	mov	QWORD PTR [rsi], rax
	mov	rcx, rsi
	cmp	DWORD PTR [rdi], edx
	setne	dl
	call	kvz_cabac_encode_bin

; 475  :     if (sao->type == SAO_TYPE_BAND) {

	mov	eax, DWORD PTR [rdi]
	cmp	eax, 1
	jne	SHORT $LN11@encode_sao
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	shl	DWORD PTR [rbx+136], 1

; 238  :   }
; 239  : }

	jmp	SHORT $LN95@encode_sao
$LN11@encode_sao:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 477  :     } else if (sao->type == SAO_TYPE_EDGE) {

	cmp	eax, 2
	jne	SHORT $LN89@encode_sao
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	ecx, DWORD PTR [rbx+136]

; 232  :     data->low += data->range;

	mov	eax, DWORD PTR [rbx+140]
	lea	ecx, DWORD PTR [rax+rcx*2]
	mov	DWORD PTR [rbx+136], ecx
$LN95@encode_sao:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 482  :   if (sao->type == SAO_TYPE_NONE) return;

	dec	DWORD PTR [rbx+152]
	cmp	DWORD PTR [rbx+152], 12
	jge	SHORT $LN89@encode_sao
	mov	rcx, rsi
	call	kvz_cabac_write
$LN89@encode_sao:
	mov	r8d, DWORD PTR color_i$[rsp]
$LN26@encode_sao:
	cmp	DWORD PTR [rdi], 0
	je	$LN61@encode_sao

; 486  :   for (i = SAO_EO_CAT1; i <= SAO_EO_CAT4; ++i) {

	mov	QWORD PTR [rsp+96], rbp
	cmp	r8d, 2
	mov	QWORD PTR [rsp+56], r12
	mov	ecx, 52					; 00000034H
	mov	QWORD PTR [rsp+48], r13
	mov	QWORD PTR [rsp+40], r14
	mov	r14d, 32				; 00000020H
	cmove	r14d, ecx
	mov	QWORD PTR [rsp+32], r15
	add	r14, rdi
	mov	r15d, 4
	mov	r12, r14
	mov	r13d, r15d
	npad	10
$LL4@encode_sao:

; 487  :     kvz_cabac_write_unary_max_symbol_ep(cabac, abs(sao->offsets[i + offset_index]), SAO_ABS_OFFSET_MAX);

	mov	eax, DWORD PTR [r12]
	cdq
	mov	ebp, eax
	xor	ebp, edx
	sub	ebp, edx
	mov	edi, ebp
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 530  :   assert(symbol <= max_symbol);

	cmp	ebp, 7
	jbe	SHORT $LN34@encode_sao
	mov	r8d, 530				; 00000212H
	lea	rdx, OFFSET FLAT:$SG4294944611
	lea	rcx, OFFSET FLAT:$SG4294944610
	call	QWORD PTR __imp__wassert
	mov	ecx, DWORD PTR [rbx+136]
	add	ecx, ecx

; 232  :     data->low += data->range;

	jmp	SHORT $LN86@encode_sao
$LN34@encode_sao:

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+136]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+136], ecx

; 532  :   CABAC_BIN_EP(data, symbol ? 1 : 0, "ums_ep");

	test	edi, edi

; 231  :   if (bin_value) {

	je	SHORT $LN84@encode_sao
$LN86@encode_sao:

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR [rbx+140]
	mov	DWORD PTR [rbx+136], ecx
$LN84@encode_sao:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+152]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+152], 12
	jge	SHORT $LN37@encode_sao

; 237  :     kvz_cabac_write(data);

	mov	rcx, rsi
	call	kvz_cabac_write
$LN37@encode_sao:

; 534  :   if (!symbol) return;

	test	edi, edi
	je	SHORT $LN2@encode_sao

; 535  : 
; 536  :   while (--symbol) {

	add	edi, -1					; ffffffffH
	je	SHORT $LN30@encode_sao
	npad	11
$LL29@encode_sao:

; 230  :   data->low <<= 1;

	mov	ecx, DWORD PTR [rbx+136]

; 232  :     data->low += data->range;

	mov	eax, DWORD PTR [rbx+140]

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+152]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+152], 12
	lea	ecx, DWORD PTR [rax+rcx*2]
	mov	DWORD PTR [rbx+136], ecx
	jge	SHORT $LN41@encode_sao

; 237  :     kvz_cabac_write(data);

	mov	rcx, rsi
	call	kvz_cabac_write
$LN41@encode_sao:

; 536  :   while (--symbol) {

	add	edi, -1					; ffffffffH
	jne	SHORT $LL29@encode_sao
$LN30@encode_sao:

; 537  :     CABAC_BIN_EP(data, 1, "ums_ep");
; 538  :   }
; 539  :   if (code_last) {

	cmp	ebp, 7
	jae	SHORT $LN2@encode_sao

; 230  :   data->low <<= 1;

	shl	DWORD PTR [rbx+136], 1

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+152]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+152], 12
	jge	SHORT $LN2@encode_sao

; 237  :     kvz_cabac_write(data);

	mov	rcx, rsi
	call	kvz_cabac_write
$LN2@encode_sao:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 486  :   for (i = SAO_EO_CAT1; i <= SAO_EO_CAT4; ++i) {

	add	r12, r15
	sub	r13, 1
	jne	$LL4@encode_sao

; 488  :   }
; 489  : 
; 490  :   /// sao_offset_sign[][][][]: FL, cMax = 1, bins = {bypass}
; 491  :   /// sao_band_position[][][]: FL, cMax = 31, bins = {bypass x N}
; 492  :   /// sao_eo_class_luma:       FL, cMax = 3, bins = {bypass x 3}
; 493  :   /// sao_eo_class_chroma:     FL, cMax = 3, bins = {bypass x 3}
; 494  :   if (sao->type == SAO_TYPE_BAND) {

	mov	rdi, QWORD PTR sao$[rsp]
	mov	r13, QWORD PTR [rsp+48]
	mov	r12, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+96]
	cmp	DWORD PTR [rdi], 1
	jne	$LN15@encode_sao
	npad	3
$LL7@encode_sao:

; 496  :       // Positive sign is coded as 0.
; 497  :       if (sao->offsets[i + offset_index] != 0) {

	mov	ecx, DWORD PTR [r14]
	test	ecx, ecx
	je	SHORT $LN5@encode_sao
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR [rbx+136]
	lea	edx, DWORD PTR [rax+rax]
	mov	DWORD PTR [rbx+136], edx

; 231  :   if (bin_value) {

	jns	SHORT $LN85@encode_sao

; 232  :     data->low += data->range;

	mov	ecx, DWORD PTR [rbx+140]
	add	ecx, edx
	mov	DWORD PTR [rbx+136], ecx
$LN85@encode_sao:

; 233  :   }
; 234  :   data->bits_left--;

	dec	DWORD PTR [rbx+152]

; 235  : 
; 236  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+152], 12
	jge	SHORT $LN5@encode_sao

; 237  :     kvz_cabac_write(data);

	mov	rcx, rsi
	call	kvz_cabac_write
$LN5@encode_sao:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 495  :     for (i = SAO_EO_CAT1; i <= SAO_EO_CAT4; ++i) {

	add	r14, 4
	sub	r15, 1
	jne	SHORT $LL7@encode_sao

; 503  :     CABAC_BINS_EP(cabac, sao->band_position[color_i == COLOR_V ? 1:0], 5, "sao_band_position");

	cmp	DWORD PTR color_i$[rsp], 2
	mov	eax, 20
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 262  :   data->low += data->range * bin_values;

	mov	edx, DWORD PTR [rbx+140]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 503  :     CABAC_BINS_EP(cabac, sao->band_position[color_i == COLOR_V ? 1:0], 5, "sao_band_position");

	mov	ecx, 24
	cmove	eax, ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 262  :   data->low += data->range * bin_values;

	imul	edx, DWORD PTR [rax+rdi]
	mov	eax, DWORD PTR [rbx+136]
	shl	eax, 5
	add	edx, eax

; 263  :   data->bits_left -= num_bins;

	add	DWORD PTR [rbx+152], -5
	mov	DWORD PTR [rbx+136], edx

; 267  :   }
; 268  : }

	jmp	SHORT $LN93@encode_sao
$LN15@encode_sao:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 504  :   } else if (color_i != COLOR_V) {

	cmp	DWORD PTR color_i$[rsp], 2
	je	SHORT $LN91@encode_sao
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 261  :   data->low <<= num_bins;

	mov	eax, DWORD PTR [rbx+136]

; 262  :   data->low += data->range * bin_values;

	mov	ecx, DWORD PTR [rbx+140]
	imul	ecx, DWORD PTR [rdi+4]

; 263  :   data->bits_left -= num_bins;

	add	DWORD PTR [rbx+152], -2
	lea	ecx, DWORD PTR [rcx+rax*4]
	mov	DWORD PTR [rbx+136], ecx
$LN93@encode_sao:

; 264  : 
; 265  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+152], 12
	jge	SHORT $LN91@encode_sao

; 266  :     kvz_cabac_write(data);

	mov	rcx, rsi
	call	kvz_cabac_write
$LN91@encode_sao:
	mov	r14, QWORD PTR [rsp+40]
	mov	r15, QWORD PTR [rsp+32]
$LN61@encode_sao:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 507  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
encode_sao_color ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 48
sao$ = 56
x_ctb$ = 64
y_ctb$ = 72
encode_sao_merge_flags PROC

; 510  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 511  :   cabac_data_t * const cabac = &state->cabac;

	lea	rbx, QWORD PTR [rcx+128]
	mov	ebp, r9d
	lea	rsi, QWORD PTR [rbx+40]
	mov	rdi, rdx

; 512  :   // SAO merge flags are not present for the first row and column.
; 513  :   if (x_ctb > 0) {

	test	r8d, r8d
	je	SHORT $LN5@encode_sao

; 514  :     cabac->cur_ctx = &(cabac->ctx.sao_merge_flag_model);

	mov	QWORD PTR [rbx], rsi

; 515  :     CABAC_BIN(cabac, sao->merge_left_flag, "sao_merge_left_flag");

	mov	rcx, rbx
	mov	edx, DWORD PTR [rdx+12]
	call	kvz_cabac_encode_bin
$LN5@encode_sao:

; 516  :   }
; 517  :   if (y_ctb > 0 && !sao->merge_left_flag) {

	test	ebp, ebp
	je	SHORT $LN3@encode_sao
	cmp	DWORD PTR [rdi+12], 0
	jne	SHORT $LN3@encode_sao

; 518  :     cabac->cur_ctx = &(cabac->ctx.sao_merge_flag_model);

	mov	QWORD PTR [rbx], rsi

; 519  :     CABAC_BIN(cabac, sao->merge_up_flag, "sao_merge_up_flag");

	mov	rcx, rbx
	mov	edx, DWORD PTR [rdi+16]
	call	kvz_cabac_encode_bin
$LN3@encode_sao:

; 520  :   }
; 521  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
encode_sao_merge_flags ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 48
x_lcu$ = 56
y_lcu$ = 64
sao_luma$ = 72
sao_chroma$ = 80
encode_sao PROC

; 530  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 511  :   cabac_data_t * const cabac = &state->cabac;

	lea	rbp, QWORD PTR [rcx+168]

; 530  : {

	mov	rbx, r9
	movzx	r14d, r8w
	mov	rsi, rcx

; 513  :   if (x_ctb > 0) {

	test	edx, edx
	je	SHORT $LN9@encode_sao

; 514  :     cabac->cur_ctx = &(cabac->ctx.sao_merge_flag_model);

	mov	QWORD PTR [rcx+128], rbp

; 515  :     CABAC_BIN(cabac, sao->merge_left_flag, "sao_merge_left_flag");

	sub	rcx, -128				; ffffffffffffff80H
	mov	edx, DWORD PTR [r9+12]
	call	kvz_cabac_encode_bin
$LN9@encode_sao:

; 516  :   }
; 517  :   if (y_ctb > 0 && !sao->merge_left_flag) {

	test	r14w, r14w
	je	SHORT $LN7@encode_sao
	cmp	DWORD PTR [rbx+12], 0
	jne	SHORT $LN3@encode_sao

; 518  :     cabac->cur_ctx = &(cabac->ctx.sao_merge_flag_model);

	mov	QWORD PTR [rsi+128], rbp

; 519  :     CABAC_BIN(cabac, sao->merge_up_flag, "sao_merge_up_flag");

	lea	rcx, QWORD PTR [rsi+128]
	mov	edx, DWORD PTR [rbx+16]
	call	kvz_cabac_encode_bin
$LN7@encode_sao:

; 531  :   // TODO: transmit merge flags outside sao_info
; 532  :   encode_sao_merge_flags(state, sao_luma, x_lcu, y_lcu);
; 533  : 
; 534  :   // If SAO is merged, nothing else needs to be coded.
; 535  :   if (!sao_luma->merge_left_flag && !sao_luma->merge_up_flag) {

	cmp	DWORD PTR [rbx+12], 0
	jne	SHORT $LN3@encode_sao
	cmp	DWORD PTR [rbx+16], 0
	jne	SHORT $LN3@encode_sao

; 536  :     encode_sao_color(state, sao_luma, COLOR_Y);

	xor	r8d, r8d
	mov	rdx, rbx
	mov	rcx, rsi
	call	encode_sao_color

; 537  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [rsi]
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN3@encode_sao

; 538  :       encode_sao_color(state, sao_chroma, COLOR_U);

	mov	rdx, QWORD PTR sao_chroma$[rsp]
	mov	r8d, 1
	mov	rcx, rsi
	call	encode_sao_color

; 539  :       encode_sao_color(state, sao_chroma, COLOR_V);

	mov	rdx, QWORD PTR sao_chroma$[rsp]
	mov	r8d, 2
	mov	rcx, rsi
	call	encode_sao_color
$LN3@encode_sao:

; 540  :     }
; 541  :   }
; 542  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
encode_sao ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
cu$1$ = 48
tv941 = 128
bottom$1$ = 128
state$ = 128
d$1$ = 136
x$ = 136
y$ = 144
depth$ = 152
last_qp$ = 160
prev_qp$ = 168
set_cu_qps PROC

; 565  : {

	mov	r11, rsp
	push	rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 88					; 00000058H

; 566  : 
; 567  :   // Stop recursion if the CU is completely outside the frame.
; 568  :   if (x >= state->tile->frame->width || y >= state->tile->frame->height) return;

	mov	rax, QWORD PTR [rcx+48]
	mov	edi, r9d
	mov	esi, r8d
	mov	r13d, edx
	mov	r12, rcx
	mov	r9, QWORD PTR [rax]
	cmp	edx, DWORD PTR [r9+16]
	jge	$LN15@set_cu_qps
	mov	QWORD PTR [r11+24], rbx
	mov	ebx, 64					; 00000040H
	mov	QWORD PTR [r11-40], rbp
	mov	rbp, QWORD PTR last_qp$[rsp]
	mov	QWORD PTR [r11-56], r15
	mov	r15, QWORD PTR prev_qp$[rsp]
	mov	QWORD PTR [r11-48], r14
	npad	1
$LL190@set_cu_qps:
	cmp	esi, DWORD PTR [r9+20]
	jge	$LN230@set_cu_qps
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 95   :   return (cu_info_t*) kvz_cu_array_at_const(cua, x_px, y_px);

	mov	rcx, QWORD PTR [r9+32]
	mov	r8d, esi
	mov	edx, r13d
	call	kvz_cu_array_at_const
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 571  :   const int cu_width = LCU_WIDTH >> depth;

	mov	ecx, edi
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 95   :   return (cu_info_t*) kvz_cu_array_at_const(cua, x_px, y_px);

	mov	QWORD PTR cu$1$[rsp], rax
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 571  :   const int cu_width = LCU_WIDTH >> depth;

	mov	r14d, ebx
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 95   :   return (cu_info_t*) kvz_cu_array_at_const(cua, x_px, y_px);

	mov	r9, rax
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 571  :   const int cu_width = LCU_WIDTH >> depth;

	sar	r14d, cl

; 572  : 
; 573  :   if (depth <= state->encoder_control->max_qp_delta_depth) {

	mov	rcx, QWORD PTR [r12]
	mov	DWORD PTR d$1$[rsp], r14d
	movsx	edx, BYTE PTR [rcx+6520]
	cmp	edi, edx
	jg	SHORT $LN218@set_cu_qps

; 574  :     *prev_qp = -1;

	mov	DWORD PTR [r15], -1
$LN218@set_cu_qps:

; 575  :   }
; 576  : 
; 577  :   if (cu->depth > depth) {

	movzx	ecx, BYTE PTR [rax]
	shr	ecx, 2
	and	ecx, 7
	cmp	ecx, edi
	jle	SHORT $LN17@set_cu_qps

; 578  :     // Recursively process sub-CUs.
; 579  :     const int d = cu_width >> 1;

	sar	r14d, 1

; 580  :     set_cu_qps(state, x,     y,     depth + 1, last_qp, prev_qp);

	mov	r8d, esi
	inc	edi
	mov	QWORD PTR [rsp+40], r15
	mov	r9d, edi
	mov	QWORD PTR [rsp+32], rbp
	mov	edx, r13d
	mov	rcx, r12
	call	set_cu_qps

; 581  :     set_cu_qps(state, x + d, y,     depth + 1, last_qp, prev_qp);

	lea	ebx, DWORD PTR [r14+r13]
	mov	QWORD PTR [rsp+40], r15
	mov	edx, ebx
	mov	QWORD PTR [rsp+32], rbp
	mov	r9d, edi
	mov	r8d, esi
	mov	rcx, r12
	call	set_cu_qps

; 582  :     set_cu_qps(state, x,     y + d, depth + 1, last_qp, prev_qp);

	add	esi, r14d
	mov	QWORD PTR [rsp+40], r15
	mov	r8d, esi
	mov	QWORD PTR [rsp+32], rbp
	mov	r9d, edi
	mov	edx, r13d
	mov	rcx, r12
	call	set_cu_qps
	mov	rax, QWORD PTR [r12+48]

; 583  :     set_cu_qps(state, x + d, y + d, depth + 1, last_qp, prev_qp);

	mov	r13d, ebx
	mov	r9, QWORD PTR [rax]
	cmp	ebx, DWORD PTR [r9+16]
	mov	ebx, 64					; 00000040H
	jl	$LL190@set_cu_qps

; 566  : 
; 567  :   // Stop recursion if the CU is completely outside the frame.
; 568  :   if (x >= state->tile->frame->width || y >= state->tile->frame->height) return;

	jmp	$LN230@set_cu_qps
$LN17@set_cu_qps:

; 584  : 
; 585  :   } else {
; 586  :     bool cbf_found = *prev_qp >= 0;

	mov	edx, DWORD PTR [r15]

; 587  : 
; 588  :     if (cu->tr_depth > depth) {

	movzx	eax, BYTE PTR [rax+1]
	shr	edx, 31
	and	eax, 7
	xor	dl, 1
	cmp	eax, edi
	jle	$LN19@set_cu_qps

; 589  :       // The CU is split into smaller transform units. Check whether coded
; 590  :       // block flag is set for any of the TUs.
; 591  :       const int tu_width = LCU_WIDTH >> cu->tr_depth;

	mov	ebp, ebx
	mov	ecx, eax
	sar	ebp, cl

; 592  :       for (int y_scu = y; !cbf_found && y_scu < y + cu_width; y_scu += tu_width) {

	mov	r14d, esi
	test	dl, dl
	jne	$LN225@set_cu_qps
	mov	ecx, DWORD PTR d$1$[rsp]
	lea	eax, DWORD PTR [rcx+rsi]
	mov	DWORD PTR tv941[rsp], eax
	npad	7
$LL4@set_cu_qps:
	cmp	r14d, eax
	jge	$LN226@set_cu_qps

; 593  :         for (int x_scu = x; !cbf_found && x_scu < x + cu_width; x_scu += tu_width) {

	mov	ebx, r13d
	test	dl, dl
	jne	SHORT $LN2@set_cu_qps
	lea	r15d, DWORD PTR [rcx+r13]
$LL7@set_cu_qps:
	movzx	edi, dl
	cmp	ebx, r15d
	jge	SHORT $LN222@set_cu_qps

; 594  :           cu_info_t *tu = kvz_cu_array_at(state->tile->frame->cu_array, x_scu, y_scu);

	mov	rax, QWORD PTR [r12+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 95   :   return (cu_info_t*) kvz_cu_array_at_const(cua, x_px, y_px);

	mov	r8d, r14d
	mov	edx, ebx
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 594  :           cu_info_t *tu = kvz_cu_array_at(state->tile->frame->cu_array, x_scu, y_scu);

	mov	rcx, QWORD PTR [rax]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 95   :   return (cu_info_t*) kvz_cu_array_at_const(cua, x_px, y_px);

	mov	rcx, QWORD PTR [rcx+32]
	call	kvz_cu_array_at_const
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 595  :           if (cbf_is_set_any(tu->cbf, cu->depth)) {

	mov	r9, QWORD PTR cu$1$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	rcx, OFFSET FLAT:cbf_masks
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 595  :           if (cbf_is_set_any(tu->cbf, cu->depth)) {

	movzx	edx, WORD PTR [rax+4]
	movzx	eax, BYTE PTR [r9]
	shr	rax, 2
	and	eax, 7
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	ecx, WORD PTR [rcx+rax*2]
	test	cx, dx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN225@set_cu_qps

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, ecx
	shl	ecx, 5
	or	ecx, eax
	shl	ecx, 5
	test	ecx, edx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN225@set_cu_qps
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 593  :         for (int x_scu = x; !cbf_found && x_scu < x + cu_width; x_scu += tu_width) {

	add	ebx, ebp
	movzx	edx, dil
	test	dil, dil
	je	SHORT $LL7@set_cu_qps
$LN222@set_cu_qps:

; 592  :       for (int y_scu = y; !cbf_found && y_scu < y + cu_width; y_scu += tu_width) {

	mov	ecx, DWORD PTR d$1$[rsp]
	mov	eax, DWORD PTR tv941[rsp]
$LN2@set_cu_qps:
	add	r14d, ebp
	test	dl, dl
	je	$LL4@set_cu_qps
$LN225@set_cu_qps:

; 606  :       *prev_qp = qp = cu->qp;

	mov	r14d, DWORD PTR d$1$[rsp]
$LN214@set_cu_qps:
	mov	rcx, QWORD PTR prev_qp$[rsp]
	movsx	r15d, BYTE PTR [r9+6]
	mov	DWORD PTR [rcx], r15d
$LN24@set_cu_qps:

; 609  :     }
; 610  : 
; 611  :     // Set the correct QP for all state->tile->frame->cu_array elements in
; 612  :     // the area covered by the CU.
; 613  :     for (int y_scu = y; y_scu < y + cu_width; y_scu += SCU_WIDTH) {

	lea	r9d, DWORD PTR [r14+rsi]
	mov	DWORD PTR bottom$1$[rsp], r9d
	cmp	esi, r9d
	jge	$LN9@set_cu_qps
	add	r14d, r13d
	npad	8
$LL10@set_cu_qps:

; 614  :       for (int x_scu = x; x_scu < x + cu_width; x_scu += SCU_WIDTH) {

	mov	edi, r13d
	cmp	r13d, r14d
	jge	$LN8@set_cu_qps
	mov	ebp, esi
	shr	ebp, 2
$LL13@set_cu_qps:

; 615  :         kvz_cu_array_at(state->tile->frame->cu_array, x_scu, y_scu)->qp = qp;

	mov	rax, QWORD PTR [r12+48]
	mov	rcx, QWORD PTR [rax]
	mov	rbx, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	edi, DWORD PTR [rbx+16]
	jb	SHORT $LN181@set_cu_qps
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN181@set_cu_qps:

; 102  :   assert(y_px < cua->height);

	cmp	esi, DWORD PTR [rbx+20]
	jb	SHORT $LN182@set_cu_qps
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN182@set_cu_qps:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rbx+24]
	mov	eax, edi
	sar	ecx, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 614  :       for (int x_scu = x; x_scu < x + cu_width; x_scu += SCU_WIDTH) {

	add	edi, 4
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	imul	ecx, ebp
	shr	eax, 2
	add	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 615  :         kvz_cu_array_at(state->tile->frame->cu_array, x_scu, y_scu)->qp = qp;

	mov	rax, QWORD PTR [rbx+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	lea	rcx, QWORD PTR [rcx+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 615  :         kvz_cu_array_at(state->tile->frame->cu_array, x_scu, y_scu)->qp = qp;

	mov	BYTE PTR [rax+rcx*4+6], r15b
	cmp	edi, r14d
	jl	SHORT $LL13@set_cu_qps
	mov	r9d, DWORD PTR bottom$1$[rsp]
$LN8@set_cu_qps:

; 609  :     }
; 610  : 
; 611  :     // Set the correct QP for all state->tile->frame->cu_array elements in
; 612  :     // the area covered by the CU.
; 613  :     for (int y_scu = y; y_scu < y + cu_width; y_scu += SCU_WIDTH) {

	add	esi, 4
	cmp	esi, r9d
	jl	$LL10@set_cu_qps
	mov	r14d, DWORD PTR d$1$[rsp]
$LN9@set_cu_qps:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.h

; 383  :   if (state->encoder_control->max_qp_delta_depth < 0) return false;

	mov	rax, QWORD PTR [r12]
	movzx	ecx, BYTE PTR [rax+6520]
	test	cl, cl
	js	SHORT $LN230@set_cu_qps

; 384  : 
; 385  :   const int cu_width = LCU_WIDTH >> depth;
; 386  :   const int qg_width = LCU_WIDTH >> state->encoder_control->max_qp_delta_depth;
; 387  :   const int right  = x + cu_width;

	lea	r8d, DWORD PTR [r14+r13]
	mov	r10d, 64				; 00000040H
	sar	r10d, cl

; 388  :   const int bottom = y + cu_width;
; 389  :   return (right % qg_width == 0 || right >= state->tile->frame->width) &&

	mov	eax, r8d
	cdq
	idiv	r10d
	test	edx, edx
	je	SHORT $LN220@set_cu_qps
	mov	rax, QWORD PTR [r12+48]
	mov	rcx, QWORD PTR [rax]
	cmp	r8d, DWORD PTR [rcx+16]
	jl	SHORT $LN230@set_cu_qps
$LN220@set_cu_qps:
	mov	eax, r9d
	cdq
	idiv	r10d
	test	edx, edx
	je	SHORT $LN187@set_cu_qps
	mov	rax, QWORD PTR [r12+48]
	mov	rcx, QWORD PTR [rax]
	cmp	r9d, DWORD PTR [rcx+20]
	jl	SHORT $LN230@set_cu_qps
$LN187@set_cu_qps:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 620  :       *last_qp = cu->qp;

	mov	rax, QWORD PTR cu$1$[rsp]
	mov	rcx, QWORD PTR last_qp$[rsp]
	movzx	eax, BYTE PTR [rax+6]
	mov	DWORD PTR [rcx], eax
$LN230@set_cu_qps:
	mov	r14, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+144]
	mov	r15, QWORD PTR [rsp+64]
$LN15@set_cu_qps:

; 621  :     }
; 622  :   }
; 623  : }

	add	rsp, 88					; 00000058H
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN19@set_cu_qps:

; 596  :             cbf_found = true;
; 597  :           }
; 598  :         }
; 599  :       }
; 600  :     } else if (cbf_is_set_any(cu->cbf, cu->depth)) {

	movzx	r8d, WORD PTR [r9+4]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, ecx
	lea	rcx, OFFSET FLAT:cbf_masks
	movzx	ecx, WORD PTR [rcx+rax*2]
	test	cx, r8w

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	$LN214@set_cu_qps

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, ecx
	shl	ecx, 5
	or	ecx, eax
	shl	ecx, 5
	test	ecx, r8d

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	$LN214@set_cu_qps
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 605  :     if (cbf_found) {

	test	dl, dl
	jne	$LN214@set_cu_qps

; 592  :       for (int y_scu = y; !cbf_found && y_scu < y + cu_width; y_scu += tu_width) {

	jmp	SHORT $LN23@set_cu_qps
$LN226@set_cu_qps:
	mov	r14d, DWORD PTR d$1$[rsp]
$LN23@set_cu_qps:

; 607  :     } else {
; 608  :       qp = kvz_get_cu_ref_qp(state, x, y, *last_qp);

	mov	rax, QWORD PTR last_qp$[rsp]
	mov	r8d, esi
	mov	edx, r13d
	mov	rcx, r12
	mov	r9d, DWORD PTR [rax]
	call	kvz_get_cu_ref_qp
	mov	r15d, eax
	jmp	$LN24@set_cu_qps
set_cu_qps ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
coeff$ = 48
tv2284 = 12400
prev_qp$1 = 12400
opaque$ = 12400
tv2086 = 12408
last_qp$2 = 12408
encoder_state_worker_encode_lcu PROC

; 627  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	eax, 12336				; 00003030H
	call	__chkstk
	sub	rsp, rax

; 628  :   const lcu_order_element_t * const lcu = opaque;
; 629  :   encoder_state_t *state = lcu->encoder_state;

	mov	rbx, QWORD PTR [rcx+8]
	mov	rsi, rcx

; 630  :   const encoder_control_t * const encoder = state->encoder_control;
; 631  :   videoframe_t* const frame = state->tile->frame;

	mov	rax, QWORD PTR [rbx+48]
	mov	rbp, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rax]

; 632  : 
; 633  :   switch (encoder->cfg.rc_algorithm) {

	movzx	eax, BYTE PTR [rbp+2484]
	test	al, al
	js	SHORT $LN15@encoder_st
	cmp	al, 1
	jle	SHORT $LN13@encoder_st
	cmp	al, 2
	jne	SHORT $LN15@encoder_st

; 638  :     case KVZ_OBA:
; 639  :       kvz_set_ctu_qp_lambda(state, lcu->position);

	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, rbx
	call	kvz_set_ctu_qp_lambda

; 640  :       break;

	jmp	SHORT $LN30@encoder_st
$LN13@encoder_st:

; 634  :     case KVZ_NO_RC:
; 635  :     case KVZ_LAMBDA:
; 636  :       kvz_set_lcu_lambda_and_qp(state, lcu->position);

	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, rbx
	call	kvz_set_lcu_lambda_and_qp

; 637  :       break;

	jmp	SHORT $LN30@encoder_st
$LN15@encoder_st:

; 641  :     default:
; 642  :       assert(0);

	mov	r8d, 642				; 00000282H
	lea	rdx, OFFSET FLAT:$SG4294952913
	lea	rcx, OFFSET FLAT:$SG4294952912
	call	QWORD PTR __imp__wassert
$LN30@encoder_st:

; 643  :   }
; 644  : 
; 645  :   lcu_coeff_t coeff;
; 646  :   state->coeff = &coeff;
; 647  : 
; 648  :   //This part doesn't write to bitstream, it's only search, deblock and sao
; 649  :   kvz_search_lcu(state, lcu->position_px.x, lcu->position_px.y, state->tile->hor_buf_search, state->tile->ver_buf_search);

	mov	r9, QWORD PTR [rbx+48]
	lea	rax, QWORD PTR coeff$[rsp]
	mov	QWORD PTR [rbx+392], rax
	mov	rcx, rbx
	mov	r8d, DWORD PTR [rsi+28]
	mov	edx, DWORD PTR [rsi+24]
	mov	rax, QWORD PTR [r9+40]
	mov	r9, QWORD PTR [r9+32]
	mov	QWORD PTR [rsp+32], rax
	call	kvz_search_lcu

; 650  : 
; 651  :   encoder_state_recdata_to_bufs(state, lcu, state->tile->hor_buf_search, state->tile->ver_buf_search);

	mov	r8, QWORD PTR [rbx+48]
	mov	rdx, rsi
	mov	rcx, rbx
	mov	r9, QWORD PTR [r8+40]
	mov	r8, QWORD PTR [r8+32]
	call	encoder_state_recdata_to_bufs

; 652  : 
; 653  :   if (encoder->max_qp_delta_depth >= 0) {

	cmp	BYTE PTR [rbp+6520], 0
	jl	SHORT $LN16@encoder_st

; 654  :     int last_qp = state->last_qp;

	movsx	eax, BYTE PTR [rbx+386]

; 655  :     int prev_qp = -1;
; 656  :     set_cu_qps(state, lcu->position_px.x, lcu->position_px.y, 0, &last_qp, &prev_qp);

	xor	r9d, r9d
	mov	r8d, DWORD PTR [rsi+28]
	mov	rcx, rbx
	mov	edx, DWORD PTR [rsi+24]
	mov	DWORD PTR last_qp$2[rsp], eax
	lea	rax, QWORD PTR prev_qp$1[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR last_qp$2[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	DWORD PTR prev_qp$1[rsp], -1
	call	set_cu_qps
$LN16@encoder_st:

; 657  :   }
; 658  : 
; 659  :   if (encoder->cfg.deblock_enable) {

	cmp	DWORD PTR [rbp+40], 0
	je	SHORT $LN17@encoder_st

; 660  :     kvz_filter_deblock_lcu(state, lcu->position_px.x, lcu->position_px.y);

	mov	r8d, DWORD PTR [rsi+28]
	mov	rcx, rbx
	mov	edx, DWORD PTR [rsi+24]
	call	kvz_filter_deblock_lcu
$LN17@encoder_st:

; 661  :   }
; 662  : 
; 663  :   if (encoder->cfg.sao_type) {

	mov	eax, DWORD PTR [rbp+44]
	test	eax, eax
	je	SHORT $LN18@encoder_st

; 664  :     // Save the post-deblocking but pre-SAO pixels of the LCU to a buffer
; 665  :     // so that they can be used in SAO reconstruction later.
; 666  :     encoder_state_recdata_before_sao_to_bufs(state,

	mov	r8, QWORD PTR [rbx+48]
	mov	rdx, rsi
	mov	rcx, rbx
	mov	r9, QWORD PTR [r8+56]
	mov	r8, QWORD PTR [r8+48]
	call	encoder_state_recdata_before_sao_to_bufs

; 667  :                                              lcu,
; 668  :                                              state->tile->hor_buf_before_sao,
; 669  :                                              state->tile->ver_buf_before_sao);
; 670  :     kvz_sao_search_lcu(state, lcu->position.x, lcu->position.y);

	mov	r8d, DWORD PTR [rsi+20]
	mov	rcx, rbx
	mov	edx, DWORD PTR [rsi+16]
	call	kvz_sao_search_lcu

; 671  :     encoder_sao_reconstruct(state, lcu);

	mov	rdx, rsi
	mov	rcx, rbx
	call	encoder_sao_reconstruct
	mov	eax, DWORD PTR [rbp+44]
$LN18@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 136  :   return position * 8 + stream->cur_bit;

	movzx	r12d, BYTE PTR [rbx+121]
	mov	r15d, DWORD PTR [rbx+96]
	mov	BYTE PTR tv2284[rsp], r12b
	mov	DWORD PTR tv2086[rsp], r15d
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 678  :   if (encoder->cfg.sao_type) {

	test	eax, eax
	je	$LN161@encoder_st

; 679  :     encode_sao(state, lcu->position.x, lcu->position.y, &frame->sao_luma[lcu->position.y * frame->width_in_lcu + lcu->position.x], &frame->sao_chroma[lcu->position.y * frame->width_in_lcu + lcu->position.x]);

	mov	eax, DWORD PTR [rdi+28]

; 511  :   cabac_data_t * const cabac = &state->cabac;

	lea	r15, QWORD PTR [rbx+168]

; 679  :     encode_sao(state, lcu->position.x, lcu->position.y, &frame->sao_luma[lcu->position.y * frame->width_in_lcu + lcu->position.x], &frame->sao_chroma[lcu->position.y * frame->width_in_lcu + lcu->position.x]);

	mov	r13, QWORD PTR [rdi+48]
	mov	edx, DWORD PTR [rsi+16]
	mov	r12d, DWORD PTR [rsi+20]
	mov	rdi, QWORD PTR [rdi+40]
	imul	eax, r12d
	add	eax, edx
	cdqe
	imul	rcx, rax, 68				; 00000044H
	add	r13, rcx
	add	rdi, rcx

; 513  :   if (x_ctb > 0) {

	test	edx, edx
	je	SHORT $LN229@encoder_st

; 514  :     cabac->cur_ctx = &(cabac->ctx.sao_merge_flag_model);

	mov	QWORD PTR [rbx+128], r15

; 515  :     CABAC_BIN(cabac, sao->merge_left_flag, "sao_merge_left_flag");

	lea	rcx, QWORD PTR [rbx+128]
	mov	edx, DWORD PTR [rdi+12]
	call	kvz_cabac_encode_bin
$LN229@encoder_st:

; 516  :   }
; 517  :   if (y_ctb > 0 && !sao->merge_left_flag) {

	test	r12w, r12w
	je	SHORT $LN165@encoder_st
	cmp	DWORD PTR [rdi+12], 0
	jne	SHORT $LN237@encoder_st

; 518  :     cabac->cur_ctx = &(cabac->ctx.sao_merge_flag_model);

	mov	QWORD PTR [rbx+128], r15

; 519  :     CABAC_BIN(cabac, sao->merge_up_flag, "sao_merge_up_flag");

	lea	rcx, QWORD PTR [rbx+128]
	mov	edx, DWORD PTR [rdi+16]
	call	kvz_cabac_encode_bin
$LN165@encoder_st:

; 535  :   if (!sao_luma->merge_left_flag && !sao_luma->merge_up_flag) {

	cmp	DWORD PTR [rdi+12], 0
	jne	SHORT $LN237@encoder_st
	cmp	DWORD PTR [rdi+16], 0
	jne	SHORT $LN237@encoder_st

; 536  :     encode_sao_color(state, sao_luma, COLOR_Y);

	xor	r8d, r8d
	mov	rdx, rdi
	mov	rcx, rbx
	call	encode_sao_color

; 537  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN237@encoder_st

; 538  :       encode_sao_color(state, sao_chroma, COLOR_U);

	mov	r8d, 1
	mov	rdx, r13
	mov	rcx, rbx
	call	encode_sao_color

; 539  :       encode_sao_color(state, sao_chroma, COLOR_V);

	mov	r8d, 2
	mov	rdx, r13
	mov	rcx, rbx
	call	encode_sao_color
$LN237@encoder_st:

; 680  :   }
; 681  : 
; 682  :   //Encode coding tree
; 683  :   kvz_encode_coding_tree(state, lcu->position.x * LCU_WIDTH, lcu->position.y * LCU_WIDTH, 0);

	movzx	r12d, BYTE PTR tv2284[rsp]
	mov	r15d, DWORD PTR tv2086[rsp]
$LN161@encoder_st:
	movzx	r8d, WORD PTR [rsi+20]
	xor	r9d, r9d
	movzx	edx, WORD PTR [rsi+16]
	mov	rcx, rbx
	shl	r8w, 6
	shl	dx, 6
	call	kvz_encode_coding_tree

; 684  : 
; 685  :   // Coeffs are not needed anymore.
; 686  :   state->coeff = NULL;
; 687  : 
; 688  :   bool end_of_slice_segment_flag;
; 689  :   if (state->encoder_control->cfg.slices & KVZ_SLICES_WPP) {

	mov	rax, QWORD PTR [rbx]
	xor	r13d, r13d
	mov	QWORD PTR [rbx+392], r13
	mov	ecx, DWORD PTR [rax+2440]
	test	cl, 2
	je	SHORT $LN20@encoder_st

; 690  :     // Slice segments end after each WPP row.
; 691  :     end_of_slice_segment_flag = lcu->last_column;

	cmp	DWORD PTR [rsi+48], r13d
	setne	dil
	jmp	SHORT $LN34@encoder_st
$LN20@encoder_st:

; 692  :   } else if (state->encoder_control->cfg.slices & KVZ_SLICES_TILES) {

	test	cl, 1
	jne	SHORT $LN243@encoder_st

; 693  :     // Slices end after each tile.
; 694  :     end_of_slice_segment_flag = lcu->last_column && lcu->last_row;
; 695  :   } else {
; 696  :     // Slice ends after the last row of the last tile.
; 697  :     int last_tile_id = -1 + encoder->cfg.tiles_width_count * encoder->cfg.tiles_height_count;

	mov	ecx, DWORD PTR [rbp+148]
	imul	ecx, DWORD PTR [rbp+144]

; 698  :     bool is_last_tile = state->tile->id == last_tile_id;

	mov	rax, QWORD PTR [rbx+48]
	dec	ecx
	cmp	DWORD PTR [rax+8], ecx

; 699  :     end_of_slice_segment_flag = is_last_tile && lcu->last_column && lcu->last_row;

	jne	SHORT $LN33@encoder_st
$LN243@encoder_st:

; 700  :   }
; 701  :   kvz_cabac_encode_bin_trm(&state->cabac, end_of_slice_segment_flag);

	cmp	DWORD PTR [rsi+48], r13d
	je	SHORT $LN33@encoder_st
	cmp	DWORD PTR [rsi+52], r13d
	je	SHORT $LN33@encoder_st
	mov	dil, 1
	jmp	SHORT $LN34@encoder_st
$LN33@encoder_st:
	xor	dil, dil
$LN34@encoder_st:
	lea	r14, QWORD PTR [rbx+128]
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 206  :   data->range -= 2;

	mov	ecx, DWORD PTR [r14+12]
	sub	ecx, 2
	mov	DWORD PTR [r14+12], ecx

; 207  :   if(bin_value) {

	test	dil, dil
	je	SHORT $LN168@encoder_st

; 208  :     data->low += data->range;
; 209  :     data->low <<= 7;

	mov	eax, DWORD PTR [r14+8]
	add	eax, ecx

; 210  :     data->range = 2 << 7;
; 211  :     data->bits_left -= 7;

	mov	ecx, 256				; 00000100H
	shl	eax, 7
	add	DWORD PTR [r14+24], -7
	mov	DWORD PTR [r14+8], eax
	jmp	SHORT $LN244@encoder_st
$LN168@encoder_st:

; 212  :   } else if (data->range >= 256) {

	cmp	ecx, 256				; 00000100H
	jae	SHORT $LN172@encoder_st

; 213  :     return;
; 214  :   } else {
; 215  :     data->low <<= 1;

	shl	DWORD PTR [r14+8], 1

; 216  :     data->range <<= 1;
; 217  :     data->bits_left--;

	dec	DWORD PTR [r14+24]
	add	ecx, ecx
$LN244@encoder_st:

; 218  :   }
; 219  : 
; 220  :   if (data->bits_left < 12) {

	mov	eax, DWORD PTR [r14+24]
	mov	DWORD PTR [r14+12], ecx
	cmp	eax, 12
	jge	SHORT $LN172@encoder_st

; 221  :     kvz_cabac_write(data);

	mov	rcx, r14
	call	kvz_cabac_write
$LN172@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 704  :     const bool end_of_tile = lcu->last_column && lcu->last_row;

	mov	eax, DWORD PTR [rsi+48]
	test	eax, eax
	je	SHORT $LN35@encoder_st
	cmp	DWORD PTR [rsi+52], r13d
	je	SHORT $LN35@encoder_st
	mov	cl, 1
	jmp	SHORT $LN36@encoder_st
$LN35@encoder_st:
	xor	cl, cl
$LN36@encoder_st:

; 705  :     const bool end_of_wpp_row = encoder->cfg.wpp && lcu->last_column;

	cmp	DWORD PTR [rbp+168], r13d
	je	SHORT $LN37@encoder_st
	test	eax, eax
	mov	eax, 1
	jne	SHORT $LN38@encoder_st
$LN37@encoder_st:
	mov	eax, r13d
$LN38@encoder_st:

; 706  : 
; 707  : 
; 708  :     if (end_of_tile || end_of_wpp_row) {

	test	cl, cl
	jne	SHORT $LN25@encoder_st
	test	eax, eax
	je	$LN184@encoder_st
$LN25@encoder_st:

; 709  :       if (!end_of_slice_segment_flag) {

	test	dil, dil
	jne	SHORT $LN179@encoder_st
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 206  :   data->range -= 2;

	mov	ecx, DWORD PTR [rbx+140]

; 210  :     data->range = 2 << 7;
; 211  :     data->bits_left -= 7;

	add	DWORD PTR [rbx+152], -7
	sub	ecx, 2
	add	ecx, DWORD PTR [rbx+136]
	shl	ecx, 7

; 218  :   }
; 219  : 
; 220  :   if (data->bits_left < 12) {

	cmp	DWORD PTR [rbx+152], 12
	mov	DWORD PTR [rbx+136], ecx
	mov	DWORD PTR [rbx+140], 256		; 00000100H
	jge	SHORT $LN179@encoder_st

; 221  :     kvz_cabac_write(data);

	mov	rcx, r14
	call	kvz_cabac_write
$LN179@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 715  :       kvz_cabac_finish(&state->cabac);

	mov	rcx, r14
	call	kvz_cabac_finish

; 716  : 
; 717  :       // Write a rbsp_trailing_bits or a byte_alignment. The first one is used
; 718  :       // for ending a slice_segment_layer_rbsp and the second one for ending
; 719  :       // a substream. They are identical and align the byte stream.
; 720  :       kvz_bitstream_put(state->cabac.stream, 1, 1);

	mov	rcx, QWORD PTR [rbx+160]
	mov	r8b, 1
	mov	edx, 1
	call	kvz_bitstream_put

; 721  :       kvz_bitstream_align_zero(state->cabac.stream);

	mov	rcx, QWORD PTR [rbx+160]
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 299  :   if ((stream->cur_bit & 7) != 0) {

	movzx	edx, BYTE PTR [rcx+25]
	and	dl, 7
	je	SHORT $LN182@encoder_st

; 300  :     kvz_bitstream_put(stream, 0, 8 - (stream->cur_bit & 7));

	mov	r8d, 8
	sub	r8b, dl
	xor	edx, edx
	call	kvz_bitstream_put
$LN182@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 92   :   data->low = 0;

	mov	DWORD PTR [rbx+136], r13d

; 93   :   data->range = 510;

	mov	DWORD PTR [rbx+140], 510		; 000001feH

; 94   :   data->bits_left = 23;

	mov	DWORD PTR [rbx+152], 23

; 95   :   data->num_buffered_bytes = 0;
; 96   :   data->buffered_byte = 0xff;

	mov	QWORD PTR [rbx+144], 255		; 000000ffH

; 97   :   data->only_count = 0; // By default, write bits out

	mov	BYTE PTR [rbx+156], r13b
$LN184@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 86   :     static_cast<std::mutex*>(*mutex)->lock();

	mov	rax, QWORD PTR [rbx+40]
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	rcx, QWORD PTR [rax+168]
	call	QWORD PTR __imp__Mtx_lock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN191@encoder_st

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN191@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 136  :   return position * 8 + stream->cur_bit;

	movzx	eax, BYTE PTR [rbx+121]
	mov	ecx, DWORD PTR [rbx+96]
	sub	ecx, r15d
	lea	edi, DWORD PTR [rax+rcx*8]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 731  :   state->frame->cur_frame_bits_coded += bits;

	mov	rcx, QWORD PTR [rbx+40]
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 136  :   return position * 8 + stream->cur_bit;

	movzx	eax, r12b
	sub	edi, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 731  :   state->frame->cur_frame_bits_coded += bits;

	mov	eax, edi
	add	QWORD PTR [rcx+112], rax

; 732  :   // This variable is used differently by intra and inter frames and shouldn't
; 733  :   // be touched in intra frames here
; 734  :   state->frame->remaining_weight -= !state->frame->is_irap ?

	mov	r8, QWORD PTR [rbx+40]
	cmp	BYTE PTR [r8+83], r13b
	jne	SHORT $LN39@encoder_st

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	rcx, QWORD PTR [rbx+48]
	mov	rax, QWORD PTR [rbx]
	mov	edx, DWORD PTR [rcx+16]
	add	edx, DWORD PTR [rsi+20]
	imul	edx, DWORD PTR [rax+2536]
	add	edx, DWORD PTR [rcx+12]
	add	edx, DWORD PTR [rsi+16]

; 1599 :                     (lcu_y + state->tile->lcu_offset_y) *
; 1600 :                     state->encoder_control->in.width_in_lcu;
; 1601 :   return &state->frame->lcu_stats[index];

	movsxd	rax, edx
	lea	rcx, QWORD PTR [rax+rax*8]

; 732  :   // This variable is used differently by intra and inter frames and shouldn't
; 733  :   // be touched in intra frames here
; 734  :   state->frame->remaining_weight -= !state->frame->is_irap ?

	mov	rax, QWORD PTR [r8+160]
	movsd	xmm1, QWORD PTR [rax+rcx*8+16]
	jmp	SHORT $LN40@encoder_st
$LN39@encoder_st:
	xorps	xmm1, xmm1
$LN40@encoder_st:
	movsd	xmm0, QWORD PTR [r8+216]
	subsd	xmm0, xmm1
	movsd	QWORD PTR [r8+216], xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 91   :     static_cast<std::mutex*>(*mutex)->unlock();

	mov	rax, QWORD PTR [rbx+40]
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	rcx, QWORD PTR [rax+168]
	call	QWORD PTR __imp__Mtx_unlock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN205@encoder_st

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN205@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	rcx, QWORD PTR [rbx+48]

; 741  :   for(int y = 0; y < 64 && !not_skip; y+=8) {

	mov	r12d, r13d

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	rax, QWORD PTR [rbx]
	mov	edx, DWORD PTR [rcx+16]
	add	edx, DWORD PTR [rsi+20]
	imul	edx, DWORD PTR [rax+2536]
	add	edx, DWORD PTR [rcx+12]
	add	edx, DWORD PTR [rsi+16]

; 1599 :                     (lcu_y + state->tile->lcu_offset_y) *
; 1600 :                     state->encoder_control->in.width_in_lcu;
; 1601 :   return &state->frame->lcu_stats[index];

	movsxd	rax, edx
	lea	rdx, QWORD PTR [rax+rax*8]

; 735  :     kvz_get_lcu_stats(state, lcu->position.x, lcu->position.y)->original_weight :
; 736  :     0;
; 737  :   pthread_mutex_unlock(&state->frame->rc_lock);
; 738  :   kvz_get_lcu_stats(state, lcu->position.x, lcu->position.y)->bits = bits;

	mov	rax, QWORD PTR [rbx+40]
	mov	rcx, QWORD PTR [rax+160]

; 739  : 
; 740  :   uint8_t not_skip = false;

	xor	al, al
	mov	DWORD PTR [rcx+rdx*8], edi
	npad	4
$LL6@encoder_st:

; 741  :   for(int y = 0; y < 64 && !not_skip; y+=8) {

	test	al, al
	jne	$LN5@encoder_st

; 742  :     for(int x = 0; x < 64 && !not_skip; x+=8) {

	mov	r15d, r13d
	npad	5
$LL9@encoder_st:
	test	al, al
	jne	$LN4@encoder_st

; 743  :       not_skip |= !kvz_cu_array_at_const(state->tile->frame->cu_array,

	mov	rax, QWORD PTR [rbx+48]
	mov	ebp, DWORD PTR [rsi+28]
	mov	r14d, DWORD PTR [rsi+24]
	add	ebp, r12d
	add	r14d, r15d
	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r14d, DWORD PTR [rdi+16]
	jb	SHORT $LN213@encoder_st
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN213@encoder_st:

; 102  :   assert(y_px < cua->height);

	cmp	ebp, DWORD PTR [rdi+20]
	jb	SHORT $LN214@encoder_st
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN214@encoder_st:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 742  :     for(int x = 0; x < 64 && !not_skip; x+=8) {

	add	r15d, 8
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	sar	eax, 2
	shr	ebp, 2
	imul	eax, ebp
	shr	r14d, 2
	add	eax, r14d
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 743  :       not_skip |= !kvz_cu_array_at_const(state->tile->frame->cu_array,

	mov	rax, QWORD PTR [rdi+8]
	movzx	eax, BYTE PTR [rax+rcx*4+1]
	shr	al, 3
	not	al
	and	al, 1
	cmp	r15d, 64				; 00000040H
	jl	$LL9@encoder_st
$LN4@encoder_st:

; 741  :   for(int y = 0; y < 64 && !not_skip; y+=8) {

	add	r12d, 8
	cmp	r12d, 64				; 00000040H
	jl	$LL6@encoder_st
$LN5@encoder_st:

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	rcx, QWORD PTR [rbx+48]

; 744  :         lcu->position_px.x + x,
; 745  :         lcu->position_px.y + y)->skipped;
; 746  :     }
; 747  :   }
; 748  :   kvz_get_lcu_stats(state, lcu->position.x, lcu->position.y)->skipped = !not_skip;

	test	al, al

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	rax, QWORD PTR [rbx]

; 744  :         lcu->position_px.x + x,
; 745  :         lcu->position_px.y + y)->skipped;
; 746  :     }
; 747  :   }
; 748  :   kvz_get_lcu_stats(state, lcu->position.x, lcu->position.y)->skipped = !not_skip;

	sete	r8b

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	edx, DWORD PTR [rcx+16]
	add	edx, DWORD PTR [rsi+20]
	imul	edx, DWORD PTR [rax+2536]
	add	edx, DWORD PTR [rcx+12]
	add	edx, DWORD PTR [rsi+16]

; 1599 :                     (lcu_y + state->tile->lcu_offset_y) *
; 1600 :                     state->encoder_control->in.width_in_lcu;
; 1601 :   return &state->frame->lcu_stats[index];

	movsxd	rax, edx
	lea	rdx, QWORD PTR [rax+rax*8]

; 744  :         lcu->position_px.x + x,
; 745  :         lcu->position_px.y + y)->skipped;
; 746  :     }
; 747  :   }
; 748  :   kvz_get_lcu_stats(state, lcu->position.x, lcu->position.y)->skipped = !not_skip;

	mov	rax, QWORD PTR [rbx+40]
	mov	rcx, QWORD PTR [rax+160]
	mov	BYTE PTR [rcx+rdx*8+70], r8b

; 749  : 
; 750  :   //Wavefronts need the context to be copied to the next row
; 751  :   if (state->type == ENCODER_STATE_TYPE_WAVEFRONT_ROW && lcu->index == 1) {

	cmp	DWORD PTR [rbx+8], 87			; 00000057H
	jne	$LN11@encoder_st
	cmp	DWORD PTR [rsi+4], 1
	jne	$LN11@encoder_st

; 754  :     for (j=0; state->parent->children[j].encoder_control; ++j) {

	mov	r8, QWORD PTR [rbx+24]
	mov	rax, QWORD PTR [r8+16]
	cmp	QWORD PTR [rax], r13
	je	$LN11@encoder_st
	mov	r9, r13

; 515  :     CABAC_BIN(cabac, sao->merge_left_flag, "sao_merge_left_flag");

	lea	r14, QWORD PTR [rbx+128]
	npad	8
$LL12@encoder_st:

; 755  :       if (state->parent->children[j].wfrow->lcu_offset_y == state->wfrow->lcu_offset_y + 1) {

	mov	rax, QWORD PTR [rbx+64]
	mov	rdx, r8
	mov	r10, QWORD PTR [r8+16]
	mov	ecx, DWORD PTR [rax]
	mov	rax, QWORD PTR [r10+r9+64]
	inc	ecx
	cmp	DWORD PTR [rax], ecx
	jne	$LN10@encoder_st
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 306  :   cabac_data_t * const target_cabac = &target_state->cabac;

	lea	rcx, QWORD PTR [r9+128]
	add	rcx, r10

; 307  :   const cabac_data_t * const source_cabac = &source_state->cabac;
; 308  :   
; 309  :   if (target_cabac == source_cabac) return;

	cmp	rcx, r14
	je	$LN10@encoder_st

; 310  : 
; 311  :   target_cabac->ctx = source_cabac->ctx;

	movups	xmm0, XMMWORD PTR [r14+40]
	movups	XMMWORD PTR [rcx+40], xmm0
	movups	xmm1, XMMWORD PTR [r14+56]
	movups	XMMWORD PTR [rcx+56], xmm1
	movups	xmm0, XMMWORD PTR [r14+72]
	movups	XMMWORD PTR [rcx+72], xmm0
	movups	xmm1, XMMWORD PTR [r14+88]
	movups	XMMWORD PTR [rcx+88], xmm1
	movups	xmm0, XMMWORD PTR [r14+104]
	movups	XMMWORD PTR [rcx+104], xmm0
	movups	xmm1, XMMWORD PTR [r14+120]
	movups	XMMWORD PTR [rcx+120], xmm1
	movups	xmm0, XMMWORD PTR [r14+136]
	movups	XMMWORD PTR [rcx+136], xmm0
	movups	xmm1, XMMWORD PTR [r14+152]
	movups	XMMWORD PTR [rcx+152], xmm1
	movups	xmm0, XMMWORD PTR [r14+168]
	movups	XMMWORD PTR [rcx+168], xmm0
	movups	xmm1, XMMWORD PTR [r14+184]
	movups	XMMWORD PTR [rcx+184], xmm1
	movups	xmm0, XMMWORD PTR [r14+200]
	movups	XMMWORD PTR [rcx+200], xmm0
	mov	rax, QWORD PTR [r14+216]
	mov	QWORD PTR [rcx+216], rax
	mov	rdx, QWORD PTR [rbx+24]
$LN10@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 754  :     for (j=0; state->parent->children[j].encoder_control; ++j) {

	mov	rax, QWORD PTR [rdx+16]
	inc	r13
	imul	r9, r13, 424				; 000001a8H
	mov	r8, rdx
	cmp	QWORD PTR [r9+rax], 0
	jne	$LL12@encoder_st
$LN11@encoder_st:

; 756  :         //And copy context
; 757  :         kvz_context_copy(&state->parent->children[j], state);
; 758  :       }
; 759  :     }
; 760  :   }
; 761  : }

	mov	rbx, QWORD PTR [rsp+12416]
	add	rsp, 12336				; 00003030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN238@encoder_st:
encoder_state_worker_encode_lcu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
tv1096 = 80
state$ = 80
encoder_state_encode_leaf PROC

; 764  : {

	push	rbx
	push	rbp
	push	r13
	sub	rsp, 48					; 00000030H

; 765  :   assert(state->is_leaf);

	cmp	DWORD PTR [rcx+72], 0
	mov	rbx, rcx
	jne	SHORT $LN37@encoder_st
	mov	r8d, 765				; 000002fdH
	lea	rdx, OFFSET FLAT:$SG4294952911
	lea	rcx, OFFSET FLAT:$SG4294952910
	call	QWORD PTR __imp__wassert
$LN37@encoder_st:

; 766  :   assert(state->lcu_order_count > 0);

	cmp	DWORD PTR [rbx+88], 0
	ja	SHORT $LN38@encoder_st
	mov	r8d, 766				; 000002feH
	lea	rdx, OFFSET FLAT:$SG4294952909
	lea	rcx, OFFSET FLAT:$SG4294952908
	call	QWORD PTR __imp__wassert
$LN38@encoder_st:

; 767  : 
; 768  :   const encoder_control_t *ctrl = state->encoder_control;

	mov	r13, QWORD PTR [rbx]

; 769  :   const kvz_config *cfg = &ctrl->cfg;
; 770  : 
; 771  :   // Signaled slice QP may be different to frame QP with set-qp-in-cu enabled.
; 772  :   state->last_qp = ctrl->cfg.set_qp_in_cu ? 26 : state->frame->QP;

	cmp	BYTE PTR [r13+2463], 0
	je	SHORT $LN39@encoder_st
	mov	al, 26
	jmp	SHORT $LN40@encoder_st
$LN39@encoder_st:
	mov	rax, QWORD PTR [rbx+40]
	movzx	eax, BYTE PTR [rax+24]
$LN40@encoder_st:

; 773  : 
; 774  :   if (cfg->crypto_features) {

	xor	ebp, ebp
	mov	BYTE PTR [rbx+386], al
	cmp	DWORD PTR [r13+2372], ebp
	je	SHORT $LN18@encoder_st

; 775  :     state->crypto_hdl = kvz_crypto_create(cfg);

	mov	QWORD PTR [rbx+352], rbp

; 776  :     state->crypto_prev_pos = 0;

	mov	DWORD PTR [rbx+360], ebp
$LN18@encoder_st:

; 777  :   }
; 778  : 
; 779  :   // Select whether to encode the frame/tile in current thread or to define
; 780  :   // wavefront jobs for other threads to handle.
; 781  :   bool wavefront = state->type == ENCODER_STATE_TYPE_WAVEFRONT_ROW;

	cmp	DWORD PTR [rbx+8], 87			; 00000057H
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+104], r12

; 782  :   bool use_parallel_encoding = (wavefront && state->parent->children[1].encoder_control);

	jne	$LN41@encoder_st
	mov	rax, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [rax+16]
	cmp	QWORD PTR [rcx+424], rbp
	je	$LN41@encoder_st

; 789  :     }
; 790  :   } else {
; 791  :     // Add each LCU in the wavefront row as it's own job to the queue.
; 792  : 
; 793  :     // Select which frame dependancies should be set to.
; 794  :     const encoder_state_t * ref_state = NULL;
; 795  : 
; 796  :     if (state->frame->slicetype == KVZ_SLICE_I) {

	mov	rax, QWORD PTR [rbx+40]
	cmp	DWORD PTR [rax+88], 2
	jne	SHORT $LN21@encoder_st

; 797  :       // I-frames have no references.
; 798  :       ref_state = NULL;

	mov	rdi, rbp

; 799  :     } else if (cfg->gop_lowdelay &&

	jmp	SHORT $LN24@encoder_st
$LN21@encoder_st:

; 800  :                cfg->gop_len > 0 &&

	cmp	BYTE PTR [r13+301], bpl
	je	SHORT $LN23@encoder_st
	cmp	BYTE PTR [r13+300], bpl
	jle	SHORT $LN23@encoder_st
	mov	rdi, QWORD PTR [rbx+32]
	cmp	rdi, rbx
	je	SHORT $LN23@encoder_st

; 801  :                state->previous_encoder_state != state)
; 802  :     {
; 803  :       // For LP-gop, depend on the state of the first reference.
; 804  :       int ref_neg = cfg->gop[state->frame->gop_offset].ref_neg[0];

	movsx	rax, BYTE PTR [rax+16]
	shl	rax, 6
	movsx	eax, BYTE PTR [rax+r13+334]

; 805  :       if (ref_neg > cfg->owf) {

	cmp	eax, DWORD PTR [r13+172]
	jle	SHORT $LN25@encoder_st

; 806  :         // If frame is not within OWF range, it's already done.
; 807  :         ref_state = NULL;

	mov	rdi, rbp

; 808  :       } else {

	jmp	SHORT $LN24@encoder_st
$LN25@encoder_st:

; 810  :         while (ref_neg > 1) {

	cmp	eax, 1
	jle	SHORT $LN24@encoder_st

; 809  :         ref_state = state->previous_encoder_state;

	lea	ecx, DWORD PTR [rax-1]
	npad	2
$LL5@encoder_st:

; 811  :           ref_neg -= 1;
; 812  :           ref_state = ref_state->previous_encoder_state;

	mov	rdi, QWORD PTR [rdi+32]
	sub	rcx, 1
	jne	SHORT $LL5@encoder_st

; 813  :         }
; 814  :       }
; 815  :     } else {

	jmp	SHORT $LN24@encoder_st
$LN23@encoder_st:

; 816  :       // Otherwise, depend on the previous frame.
; 817  :       ref_state = state->previous_encoder_state;

	mov	rdi, QWORD PTR [rbx+32]
$LN24@encoder_st:

; 818  :     }
; 819  : 
; 820  :     for (int i = 0; i < state->lcu_order_count; ++i) {

	mov	r12d, ebp
	cmp	DWORD PTR [rbx+88], ebp
	jbe	$LN8@encoder_st

; 842  :           }
; 843  :           for (int i = 0; dep_lcu->right && i < ctrl->max_inter_ref_lcu.right; i++) {

	mov	QWORD PTR [rsp+88], rsi
	mov	rcx, rbp
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15
	mov	QWORD PTR tv1096[rsp], rcx
	npad	13
$LL9@encoder_st:

; 821  :       const lcu_order_element_t * const lcu = &state->lcu_order[i];
; 822  : 
; 823  :       kvz_threadqueue_free_job(&state->tile->wf_jobs[lcu->id]);

	mov	r15, QWORD PTR [rbx+80]
	mov	rax, QWORD PTR [rbx+48]
	add	r15, rcx
	movsxd	rdx, DWORD PTR [r15]
	mov	rcx, QWORD PTR [rax+64]
	lea	rcx, QWORD PTR [rcx+rdx*8]
	call	kvz_threadqueue_free_job

; 824  :       state->tile->wf_jobs[lcu->id] = kvz_threadqueue_job_create(encoder_state_worker_encode_lcu, (void*)lcu);

	mov	rdx, r15
	lea	rcx, OFFSET FLAT:encoder_state_worker_encode_lcu
	call	kvz_threadqueue_job_create
	mov	rcx, QWORD PTR [rbx+48]
	movsxd	r8, DWORD PTR [r15]
	mov	rdx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rdx+r8*8], rax

; 825  :       threadqueue_job_t **job = &state->tile->wf_jobs[lcu->id];

	mov	rax, QWORD PTR [rbx+48]
	movsxd	rdx, DWORD PTR [r15]
	mov	rcx, QWORD PTR [rax+64]

; 826  : 
; 827  :       // If job object was returned, add dependancies and allow it to run.
; 828  :       if (job[0]) {

	mov	r9, QWORD PTR [rcx+rdx*8]
	lea	r14, QWORD PTR [rcx+rdx*8]
	test	r9, r9
	je	$LN7@encoder_st

; 829  :         // Add inter frame dependancies when ecoding more than one frame at
; 830  :         // once. The added dependancy is for the first LCU of each wavefront
; 831  :         // row to depend on the reconstruction status of the row below in the
; 832  :         // previous frame.
; 833  :         if (ref_state != NULL &&
; 834  :             state->previous_encoder_state->tqj_recon_done &&

	test	rdi, rdi
	je	$LN30@encoder_st
	mov	rax, QWORD PTR [rbx+32]
	cmp	QWORD PTR [rax+400], rbp
	je	$LN30@encoder_st
	mov	rax, QWORD PTR [rbx+40]
	cmp	DWORD PTR [rax+88], 2
	je	$LN30@encoder_st

; 835  :             state->frame->slicetype != KVZ_SLICE_I)
; 836  :         {
; 837  :           // We need to wait until the CTUs whose pixels we refer to are
; 838  :           // done before we can start this CTU.
; 839  :           const lcu_order_element_t *dep_lcu = lcu;
; 840  :           for (int i = 0; dep_lcu->below && i < ctrl->max_inter_ref_lcu.down; i++) {

	mov	eax, ebp
	lea	rcx, QWORD PTR [r15+64]
	mov	rsi, r15
	cmp	QWORD PTR [rcx], rax
	je	SHORT $LN72@encoder_st
	mov	edx, DWORD PTR [r13+6536]
$LL12@encoder_st:
	cmp	eax, edx
	jge	SHORT $LN72@encoder_st

; 841  :             dep_lcu = dep_lcu->below;

	mov	rsi, QWORD PTR [rcx]
	inc	eax
	cmp	QWORD PTR [rsi+64], rbp
	lea	rcx, QWORD PTR [rsi+64]
	jne	SHORT $LL12@encoder_st
$LN72@encoder_st:

; 842  :           }
; 843  :           for (int i = 0; dep_lcu->right && i < ctrl->max_inter_ref_lcu.right; i++) {

	mov	rdx, QWORD PTR [rsi+80]
	mov	eax, ebp
	test	rdx, rdx
	je	SHORT $LN73@encoder_st
	mov	r8d, DWORD PTR [r13+6532]
$LL15@encoder_st:
	cmp	eax, r8d
	jge	SHORT $LN73@encoder_st

; 844  :             dep_lcu = dep_lcu->right;

	mov	rsi, rdx
	inc	eax
	mov	rdx, QWORD PTR [rdx+80]
	test	rdx, rdx
	jne	SHORT $LL15@encoder_st
$LN73@encoder_st:

; 845  :           }
; 846  :           kvz_threadqueue_job_dep_add(job[0], ref_state->tile->wf_jobs[dep_lcu->id]);

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, r9
	movsxd	r8, DWORD PTR [rsi]
	mov	rdx, QWORD PTR [rax+64]
	mov	rdx, QWORD PTR [rdx+r8*8]
	call	kvz_threadqueue_job_dep_add

; 847  : 
; 848  :           //TODO: Preparation for the lock free implementation of the new rc
; 849  :           if (ref_state->frame->slicetype == KVZ_SLICE_I && ref_state->frame->num != 0 && state->encoder_control->cfg.owf > 1 && true) {

	mov	rax, QWORD PTR [rdi+40]
	cmp	DWORD PTR [rax+88], 2
	jne	SHORT $LN29@encoder_st
	cmp	DWORD PTR [rax+8], ebp
	je	SHORT $LN29@encoder_st
	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [rax+172], 1
	jle	SHORT $LN29@encoder_st

; 850  :             kvz_threadqueue_job_dep_add(job[0], ref_state->previous_encoder_state->tile->wf_jobs[dep_lcu->id]);

	mov	rax, QWORD PTR [rdi+32]
	mov	rcx, QWORD PTR [r14]
	mov	rdx, QWORD PTR [rax+48]
	movsxd	rax, DWORD PTR [rsi]
	mov	rdx, QWORD PTR [rdx+64]
	mov	rdx, QWORD PTR [rdx+rax*8]
	call	kvz_threadqueue_job_dep_add
$LN29@encoder_st:

; 851  :           }
; 852  : 
; 853  :           // Very spesific bug that happens when owf length is longer than the
; 854  :           // gop length. Takes care of that.
; 855  :           if(!state->encoder_control->cfg.gop_lowdelay &&
; 856  :              state->encoder_control->cfg.open_gop &&
; 857  :              state->encoder_control->cfg.gop_len != 0 &&
; 858  :              state->encoder_control->cfg.owf > state->encoder_control->cfg.gop_len &&
; 859  :              ref_state->frame->slicetype == KVZ_SLICE_I &&

	mov	rax, QWORD PTR [rbx]
	cmp	BYTE PTR [rax+301], bpl
	jne	SHORT $LN30@encoder_st
	cmp	BYTE PTR [rax+2464], bpl
	je	SHORT $LN30@encoder_st
	movsx	ecx, BYTE PTR [rax+300]
	test	cl, cl
	je	SHORT $LN30@encoder_st
	mov	r8d, ecx
	cmp	DWORD PTR [rax+172], ecx
	jle	SHORT $LN30@encoder_st
	mov	rdx, QWORD PTR [rdi+40]
	cmp	DWORD PTR [rdx+88], 2
	jne	SHORT $LN30@encoder_st
	cmp	DWORD PTR [rdx+8], ebp
	je	SHORT $LN30@encoder_st

; 860  :              ref_state->frame->num != 0){
; 861  : 
; 862  :             while (ref_state->frame->poc != state->frame->poc - state->encoder_control->cfg.gop_len){

	mov	rax, QWORD PTR [rbx+40]
	mov	ecx, DWORD PTR [rax+12]
	sub	ecx, r8d
	cmp	DWORD PTR [rdx+12], ecx
	je	SHORT $LN17@encoder_st
$LL16@encoder_st:

; 863  :               ref_state = ref_state->previous_encoder_state;

	mov	rdi, QWORD PTR [rdi+32]
	mov	rax, QWORD PTR [rdi+40]
	cmp	DWORD PTR [rax+12], ecx
	jne	SHORT $LL16@encoder_st
$LN17@encoder_st:

; 864  :             }
; 865  :             kvz_threadqueue_job_dep_add(job[0], ref_state->tile->wf_jobs[dep_lcu->id]);

	movsxd	rcx, DWORD PTR [rsi]
	mov	rax, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rax+64]
	mov	rdx, QWORD PTR [rdx+rcx*8]
	mov	rcx, QWORD PTR [r14]
	call	kvz_threadqueue_job_dep_add
$LN30@encoder_st:

; 866  :           }
; 867  :         }
; 868  : 
; 869  :         // Add local WPP dependancy to the LCU on the left.
; 870  :         if (lcu->left) {

	cmp	QWORD PTR [r15+72], rbp
	je	SHORT $LN31@encoder_st

; 871  :           kvz_threadqueue_job_dep_add(job[0], job[-1]);

	mov	rdx, QWORD PTR [r14-8]
	mov	rcx, QWORD PTR [r14]
	call	kvz_threadqueue_job_dep_add
$LN31@encoder_st:

; 872  :         }
; 873  :         // Add local WPP dependancy to the LCU on the top right.
; 874  :         if (lcu->above) {

	mov	rax, QWORD PTR [r15+56]
	test	rax, rax
	je	SHORT $LN34@encoder_st

; 875  :           if (lcu->above->right) {

	mov	rdx, QWORD PTR [rbx+48]
	cmp	QWORD PTR [rax+80], rbp
	mov	rax, QWORD PTR [rdx]
	je	SHORT $LN33@encoder_st

; 876  :             kvz_threadqueue_job_dep_add(job[0], job[-state->tile->frame->width_in_lcu + 1]);

	mov	edx, 1
	sub	edx, DWORD PTR [rax+28]
	movsxd	rdx, edx
	mov	rdx, QWORD PTR [r14+rdx*8]

; 877  :           } else {

	jmp	SHORT $LN74@encoder_st
$LN33@encoder_st:

; 878  :             kvz_threadqueue_job_dep_add(job[0], job[-state->tile->frame->width_in_lcu]);

	movsxd	rcx, DWORD PTR [rax+28]
	mov	rdx, r14
	shl	rcx, 3
	sub	rdx, rcx
	mov	rdx, QWORD PTR [rdx]
$LN74@encoder_st:

; 879  :           }
; 880  :         }
; 881  : 
; 882  :         kvz_threadqueue_submit(state->encoder_control->threadqueue, state->tile->wf_jobs[lcu->id]);

	mov	rcx, QWORD PTR [r14]
	call	kvz_threadqueue_job_dep_add
$LN34@encoder_st:
	mov	rax, QWORD PTR [rbx+48]
	movsxd	r8, DWORD PTR [r15]
	mov	rcx, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR [rcx+6448]
	mov	rdx, QWORD PTR [rdx+r8*8]
	call	kvz_threadqueue_submit

; 883  : 
; 884  :         // The wavefront row is done when the last LCU in the row is done.
; 885  :         if (i + 1 == state->lcu_order_count) {

	lea	eax, DWORD PTR [r12+1]
	cmp	eax, DWORD PTR [rbx+88]
	jne	SHORT $LN7@encoder_st

; 886  :           assert(!state->tqj_recon_done);

	cmp	QWORD PTR [rbx+400], rbp
	je	SHORT $LN43@encoder_st
	mov	r8d, 886				; 00000376H
	lea	rdx, OFFSET FLAT:$SG4294952907
	lea	rcx, OFFSET FLAT:$SG4294952906
	call	QWORD PTR __imp__wassert
$LN43@encoder_st:

; 887  :           state->tqj_recon_done =

	mov	rax, QWORD PTR [rbx+48]
	movsxd	rdx, DWORD PTR [r15]
	mov	rcx, QWORD PTR [rax+64]
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 523  :   int32_t new_refcount = KVZ_ATOMIC_INC(&job->refcount);

	mov	eax, 1
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 887  :           state->tqj_recon_done =

	mov	rsi, QWORD PTR [rcx+rdx*8]
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 523  :   int32_t new_refcount = KVZ_ATOMIC_INC(&job->refcount);

	lock xadd DWORD PTR [rsi+32], eax
	inc	eax

; 524  :   // The caller should have had another reference and we added one
; 525  :   // reference so refcount should be at least 2.
; 526  :   assert(new_refcount >= 2);

	cmp	eax, 2
	jge	SHORT $LN46@encoder_st
	mov	r8d, 526				; 0000020eH
	lea	rdx, OFFSET FLAT:$SG4294956574
	lea	rcx, OFFSET FLAT:$SG4294956573
	call	QWORD PTR __imp__wassert
$LN46@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 887  :           state->tqj_recon_done =

	mov	QWORD PTR [rbx+400], rsi
$LN7@encoder_st:

; 818  :     }
; 819  : 
; 820  :     for (int i = 0; i < state->lcu_order_count; ++i) {

	mov	rcx, QWORD PTR tv1096[rsp]
	inc	r12d
	add	rcx, 88					; 00000058H
	mov	QWORD PTR tv1096[rsp], rcx
	cmp	r12d, DWORD PTR [rbx+88]
	jb	$LL9@encoder_st
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
	mov	rsi, QWORD PTR [rsp+88]
	jmp	SHORT $LN8@encoder_st
$LN41@encoder_st:

; 783  :   if (!use_parallel_encoding) {
; 784  :     // Encode every LCU in order and perform SAO reconstruction after every
; 785  :     // frame is encoded. Deblocking and SAO search is done during LCU encoding.
; 786  : 
; 787  :     for (int i = 0; i < state->lcu_order_count; ++i) {

	cmp	DWORD PTR [rbx+88], ebp
	jbe	SHORT $LN8@encoder_st
	npad	13
$LL4@encoder_st:

; 788  :       encoder_state_worker_encode_lcu(&state->lcu_order[i]);

	movsxd	rax, ebp
	imul	rcx, rax, 88				; 00000058H
	add	rcx, QWORD PTR [rbx+80]
	call	encoder_state_worker_encode_lcu
	inc	ebp
	cmp	ebp, DWORD PTR [rbx+88]
	jb	SHORT $LL4@encoder_st
$LN8@encoder_st:
	mov	r12, QWORD PTR [rsp+104]

; 888  :             kvz_threadqueue_copy_ref(state->tile->wf_jobs[lcu->id]);
; 889  :         }
; 890  :       }
; 891  :     }
; 892  :   }
; 893  : }

	mov	rdi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r13
	pop	rbp
	pop	rbx
	ret	0
encoder_state_encode_leaf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
opaque$ = 48
encoder_state_worker_encode_children PROC

; 898  : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 899  :   encoder_state_t *sub_state = opaque;
; 900  :   encoder_state_encode(sub_state);

	call	encoder_state_encode

; 901  : 
; 902  :   if (sub_state->is_leaf && sub_state->type == ENCODER_STATE_TYPE_WAVEFRONT_ROW) {

	cmp	DWORD PTR [rbx+72], 0
	je	SHORT $LN3@encoder_st
	cmp	DWORD PTR [rbx+8], 87			; 00000057H
	jne	SHORT $LN3@encoder_st

; 903  :     // Set the last wavefront job of this row as the job that completes
; 904  :     // the bitstream for this wavefront row state.
; 905  : 
; 906  :     int wpp_row = sub_state->wfrow->lcu_offset_y;

	mov	rax, QWORD PTR [rbx+64]

; 907  :     int tile_width = sub_state->tile->frame->width_in_lcu;

	mov	rdx, QWORD PTR [rbx+48]
	mov	QWORD PTR [rsp+48], rdi

; 908  :     int end_of_row = (wpp_row + 1) * tile_width - 1;

	mov	edi, DWORD PTR [rax]
	mov	rax, QWORD PTR [rdx]
	inc	edi
	imul	edi, DWORD PTR [rax+28]

; 909  :     assert(!sub_state->tqj_bitstream_written);

	cmp	QWORD PTR [rbx+408], 0
	je	SHORT $LN5@encoder_st
	mov	r8d, 909				; 0000038dH
	lea	rdx, OFFSET FLAT:$SG4294952905
	lea	rcx, OFFSET FLAT:$SG4294952904
	call	QWORD PTR __imp__wassert
	mov	rdx, QWORD PTR [rbx+48]
$LN5@encoder_st:

; 910  :     if (sub_state->tile->wf_jobs[end_of_row]) {

	mov	rax, QWORD PTR [rdx+64]
	movsxd	rcx, edi
	mov	rdi, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR [rax+rcx*8-8]
	test	rcx, rcx
	je	SHORT $LN3@encoder_st

; 911  :       sub_state->tqj_bitstream_written =

	call	kvz_threadqueue_copy_ref
	mov	QWORD PTR [rbx+408], rax
$LN3@encoder_st:

; 912  :         kvz_threadqueue_copy_ref(sub_state->tile->wf_jobs[end_of_row]);
; 913  :     }
; 914  :   }
; 915  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
encoder_state_worker_encode_children ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 8
encoder_state_tree_is_a_chain PROC

; 918  :   if (!state->children[0].encoder_control) return 1;

	mov	rax, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN80@encoder_st
	npad	6
$LL77@encoder_st:

; 919  :   if (state->children[1].encoder_control) return 0;

	cmp	QWORD PTR [rax+424], 0
	jne	SHORT $LN81@encoder_st

; 918  :   if (!state->children[0].encoder_control) return 1;

	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LL77@encoder_st
$LN80@encoder_st:
	mov	eax, 1

; 920  :   return encoder_state_tree_is_a_chain(&state->children[0]);
; 921  : }

	ret	0
$LN81@encoder_st:

; 919  :   if (state->children[1].encoder_control) return 0;

	xor	eax, eax

; 920  :   return encoder_state_tree_is_a_chain(&state->children[0]);
; 921  : }

	ret	0
encoder_state_tree_is_a_chain ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
tv1370 = 48
i$1$ = 144
node_is_the_last_split_in_tree$1$ = 144
main_state$ = 144
offset_x$1$ = 152
width$1$ = 160
$T1 = 168
encoder_state_encode PROC

; 923  : static void encoder_state_encode(encoder_state_t * const main_state) {

	push	rbx
	push	rsi
	sub	rsp, 120				; 00000078H

; 924  :   //If we have children, encode at child level
; 925  :   if (main_state->children[0].encoder_control) {

	mov	rdx, QWORD PTR [rcx+16]
	mov	rsi, rcx
	cmp	QWORD PTR [rdx], 0
	je	$LN16@encoder_st

; 926  :     //If we have only one child, than it cannot be the last split in tree
; 927  :     int node_is_the_last_split_in_tree = (main_state->children[1].encoder_control != 0);

	xor	ebx, ebx
	mov	QWORD PTR [rsp+104], rdi
	cmp	QWORD PTR [rdx+424], rbx
	mov	r10d, ebx
	mov	QWORD PTR [rsp+88], r13
	mov	r11d, ebx
	mov	QWORD PTR [rsp+112], rbp
	setne	r10b
	mov	QWORD PTR [rsp+96], r12
	mov	r9d, ebx
	mov	QWORD PTR [rsp+80], r14
	mov	rax, rdx
	mov	DWORD PTR node_is_the_last_split_in_tree$1$[rsp], r10d
	mov	QWORD PTR $T1[rsp], rbx
	mov	QWORD PTR tv1370[rsp], rbx
	mov	QWORD PTR [rsp+72], r15
	npad	12
$LL4@encoder_st:

; 930  :       encoder_state_t *sub_state = &(main_state->children[i]);
; 931  : 
; 932  :       if (sub_state->tile != main_state->tile) {

	mov	r8, QWORD PTR [r9+rdx+48]
	lea	r13, QWORD PTR [r9+rdx]
	mov	rcx, QWORD PTR [rsi+48]
	mov	rdx, rax
	cmp	r8, rcx
	je	$LN18@encoder_st

; 933  :         const int offset_x = sub_state->tile->offset_x;
; 934  :         const int offset_y = sub_state->tile->offset_y;
; 935  :         const int width = MIN(sub_state->tile->frame->width_in_lcu * LCU_WIDTH, main_state->tile->frame->width - offset_x);

	mov	rdx, QWORD PTR [r8]
	mov	rcx, QWORD PTR [rcx]
	mov	r15d, DWORD PTR [r8+20]
	mov	r12d, DWORD PTR [r8+24]
	mov	ebp, DWORD PTR [rdx+28]
	mov	eax, DWORD PTR [rcx+16]

; 936  :         const int height = MIN(sub_state->tile->frame->height_in_lcu * LCU_WIDTH, main_state->tile->frame->height - offset_y);

	mov	r14d, DWORD PTR [rdx+24]
	sub	eax, r15d

; 937  : 
; 938  :         kvz_image_free(sub_state->tile->frame->source);

	mov	rdi, QWORD PTR [rdx]
	shl	ebp, 6
	cmp	ebp, eax
	mov	DWORD PTR offset_x$1$[rsp], r15d
	cmovge	ebp, eax
	mov	eax, DWORD PTR [rcx+20]
	sub	eax, r12d
	shl	r14d, 6
	cmp	r14d, eax
	cmovge	r14d, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	test	rdi, rdi
	je	SHORT $LN34@encoder_st

; 117  : 
; 118  :   int32_t new_refcount = KVZ_ATOMIC_DEC(&(im->refcount));

	mov	eax, -1
	lock xadd DWORD PTR [rdi+88], eax
	sub	eax, 1

; 119  :   if (new_refcount > 0) {

	jg	SHORT $LN34@encoder_st

; 120  :     // There are still references so we don't free the data yet.
; 121  :     return;
; 122  :   }
; 123  : 
; 124  :   if (im->base_image != im) {

	mov	rcx, QWORD PTR [rdi+80]
	cmp	rcx, rdi
	je	SHORT $LN37@encoder_st

; 125  :     // Free our reference to the base image.
; 126  :     kvz_image_free(im->base_image);

	call	kvz_image_free

; 127  :   } else {

	jmp	SHORT $LN38@encoder_st
$LN37@encoder_st:

; 128  :     free(im->fulldata_buf);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
$LN38@encoder_st:

; 129  :   }
; 130  : 
; 131  :   // Make sure freed data won't be used.
; 132  :   im->base_image = NULL;
; 133  :   im->fulldata_buf = NULL;
; 134  :   im->fulldata = NULL;
; 135  :   im->y = im->u = im->v = NULL;
; 136  :   im->data[COLOR_Y] = im->data[COLOR_U] = im->data[COLOR_V] = NULL;
; 137  :   free(im);

	mov	rcx, rdi
	mov	QWORD PTR [rdi+80], rbx
	mov	QWORD PTR [rdi], rbx
	mov	QWORD PTR [rdi+8], rbx
	mov	QWORD PTR [rdi+32], rbx
	mov	QWORD PTR [rdi+24], rbx
	mov	QWORD PTR [rdi+16], rbx
	mov	QWORD PTR [rdi+56], rbx
	mov	QWORD PTR [rdi+48], rbx
	mov	QWORD PTR [rdi+40], rbx
	call	QWORD PTR __imp_free
$LN34@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 939  :         sub_state->tile->frame->source = NULL;

	mov	rax, QWORD PTR [r13+48]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rbx

; 940  : 
; 941  :         kvz_image_free(sub_state->tile->frame->rec);

	mov	rax, QWORD PTR [r13+48]
	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	test	rdi, rdi
	je	SHORT $LN40@encoder_st

; 117  : 
; 118  :   int32_t new_refcount = KVZ_ATOMIC_DEC(&(im->refcount));

	mov	eax, -1
	lock xadd DWORD PTR [rdi+88], eax
	sub	eax, 1

; 119  :   if (new_refcount > 0) {

	jg	SHORT $LN40@encoder_st

; 120  :     // There are still references so we don't free the data yet.
; 121  :     return;
; 122  :   }
; 123  : 
; 124  :   if (im->base_image != im) {

	mov	rcx, QWORD PTR [rdi+80]
	cmp	rcx, rdi
	je	SHORT $LN43@encoder_st

; 125  :     // Free our reference to the base image.
; 126  :     kvz_image_free(im->base_image);

	call	kvz_image_free

; 127  :   } else {

	jmp	SHORT $LN44@encoder_st
$LN43@encoder_st:

; 128  :     free(im->fulldata_buf);

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_free
$LN44@encoder_st:

; 129  :   }
; 130  : 
; 131  :   // Make sure freed data won't be used.
; 132  :   im->base_image = NULL;
; 133  :   im->fulldata_buf = NULL;
; 134  :   im->fulldata = NULL;
; 135  :   im->y = im->u = im->v = NULL;
; 136  :   im->data[COLOR_Y] = im->data[COLOR_U] = im->data[COLOR_V] = NULL;
; 137  :   free(im);

	mov	rcx, rdi
	mov	QWORD PTR [rdi+80], rbx
	mov	QWORD PTR [rdi], rbx
	mov	QWORD PTR [rdi+8], rbx
	mov	QWORD PTR [rdi+32], rbx
	mov	QWORD PTR [rdi+24], rbx
	mov	QWORD PTR [rdi+16], rbx
	mov	QWORD PTR [rdi+56], rbx
	mov	QWORD PTR [rdi+48], rbx
	mov	QWORD PTR [rdi+40], rbx
	call	QWORD PTR __imp_free
$LN40@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 942  :         sub_state->tile->frame->rec = NULL;

	mov	rax, QWORD PTR [r13+48]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], rbx

; 943  : 
; 944  :         kvz_cu_array_free(&sub_state->tile->frame->cu_array);

	mov	rax, QWORD PTR [r13+48]
	mov	rcx, QWORD PTR [rax]
	add	rcx, 32					; 00000020H
	call	kvz_cu_array_free

; 945  : 
; 946  :         sub_state->tile->frame->source = kvz_image_make_subimage(

	mov	rax, QWORD PTR [rsi+48]
	mov	r9d, ebp
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], r14d
	mov	edx, r15d
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx]
	call	kvz_image_make_subimage
	mov	rcx, QWORD PTR [r13+48]

; 953  :         sub_state->tile->frame->rec = kvz_image_make_subimage(

	mov	r9d, ebp
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], r14d
	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax
	mov	edx, r15d
	mov	rax, QWORD PTR [rsi+48]
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx+8]
	call	kvz_image_make_subimage
	mov	rcx, QWORD PTR [r13+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 139  :   assert(x_offset + width <= base->width);

	mov	edi, DWORD PTR offset_x$1$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 953  :         sub_state->tile->frame->rec = kvz_image_make_subimage(

	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rdx+8], rax

; 960  :         sub_state->tile->frame->cu_array = kvz_cu_subarray(

	mov	rax, QWORD PTR [r13+48]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rsi+48]
	mov	ebp, DWORD PTR [rcx+24]
	mov	r14d, DWORD PTR [rcx+28]
	mov	rcx, QWORD PTR [rax]
	shl	r14d, 6
	shl	ebp, 6
	mov	DWORD PTR width$1$[rsp], r14d
	mov	r15, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 139  :   assert(x_offset + width <= base->width);

	lea	eax, DWORD PTR [r14+rdi]
	cmp	eax, DWORD PTR [r15+16]
	jbe	SHORT $LN51@encoder_st
	mov	r8d, 139				; 0000008bH
	lea	rdx, OFFSET FLAT:$SG4294944404
	lea	rcx, OFFSET FLAT:$SG4294944403
	call	QWORD PTR __imp__wassert
$LN51@encoder_st:

; 140  :   assert(y_offset + height <= base->height);

	lea	eax, DWORD PTR [r12+rbp]
	cmp	eax, DWORD PTR [r15+20]
	jbe	SHORT $LN52@encoder_st
	mov	r8d, 140				; 0000008cH
	lea	rdx, OFFSET FLAT:$SG4294944402
	lea	rcx, OFFSET FLAT:$SG4294944401
	call	QWORD PTR __imp__wassert
$LN52@encoder_st:

; 141  : 
; 142  :   if (x_offset == 0 &&
; 143  :       y_offset == 0 &&
; 144  :       width == base->width &&

	test	edi, edi
	jne	SHORT $LN49@encoder_st
	test	r12d, r12d
	jne	SHORT $LN49@encoder_st
	cmp	r14d, DWORD PTR [r15+16]
	jne	SHORT $LN49@encoder_st
	cmp	ebp, DWORD PTR [r15+20]
	jne	SHORT $LN49@encoder_st

; 145  :       height == base->height)
; 146  :   {
; 147  :     return kvz_cu_array_copy_ref(base);

	mov	rcx, r15
	call	kvz_cu_array_copy_ref
	mov	r14, rax
	jmp	$LN46@encoder_st
$LN49@encoder_st:

; 148  :   }
; 149  : 
; 150  :   cu_array_t *cua = MALLOC(cu_array_t, 1);

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	r14, rax

; 151  : 
; 152  :   // Find the real base array.
; 153  :   cu_array_t *real_base = base;

	mov	rdi, r15

; 154  :   while (real_base->base) {

	mov	rax, QWORD PTR [r15]
	test	rax, rax
	je	SHORT $LN48@encoder_st
	npad	1
$LL47@encoder_st:

; 155  :     real_base = real_base->base;

	mov	rdi, rax
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	jne	SHORT $LL47@encoder_st
$LN48@encoder_st:

; 199  :   int32_t new_refcount = KVZ_ATOMIC_INC(&cua->refcount);

	mov	eax, 1
	lock xadd DWORD PTR [rdi+28], eax
	inc	eax

; 200  :   // The caller should have had another reference and we added one
; 201  :   // reference so refcount should be at least 2.
; 202  :   assert(new_refcount >= 2);

	cmp	eax, 2
	jge	SHORT $LN55@encoder_st
	mov	r8d, 202				; 000000caH
	lea	rdx, OFFSET FLAT:$SG4294944398
	lea	rcx, OFFSET FLAT:$SG4294944397
	call	QWORD PTR __imp__wassert
$LN55@encoder_st:

; 95   :   return (cu_info_t*) kvz_cu_array_at_const(cua, x_px, y_px);

	mov	edx, DWORD PTR offset_x$1$[rsp]
	mov	r8d, r12d
	mov	rcx, r15

; 157  :   cua->base     = kvz_cu_array_copy_ref(real_base);

	mov	QWORD PTR [r14], rdi

; 95   :   return (cu_info_t*) kvz_cu_array_at_const(cua, x_px, y_px);

	call	kvz_cu_array_at_const

; 158  :   cua->data     = kvz_cu_array_at(base, x_offset, y_offset);

	mov	QWORD PTR [r14+8], rax

; 159  :   cua->width    = width;

	mov	eax, DWORD PTR width$1$[rsp]
	mov	DWORD PTR [r14+16], eax

; 160  :   cua->height   = height;

	mov	DWORD PTR [r14+20], ebp

; 161  :   cua->stride   = base->stride;

	mov	eax, DWORD PTR [r15+24]
	mov	DWORD PTR [r14+24], eax

; 162  :   cua->refcount = 1;

	mov	DWORD PTR [r14+28], 1
$LN46@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 960  :         sub_state->tile->frame->cu_array = kvz_cu_subarray(

	mov	rax, QWORD PTR [r13+48]
	mov	r9, QWORD PTR tv1370[rsp]
	mov	r10d, DWORD PTR node_is_the_last_split_in_tree$1$[rsp]
	mov	r11, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx+32], r14
	mov	rdx, QWORD PTR [rsi+16]
$LN18@encoder_st:

; 961  :             main_state->tile->frame->cu_array,
; 962  :             offset_x,
; 963  :             offset_y,
; 964  :             sub_state->tile->frame->width_in_lcu * LCU_WIDTH,
; 965  :             sub_state->tile->frame->height_in_lcu * LCU_WIDTH
; 966  :         );
; 967  :       }
; 968  : 
; 969  :       //To be the last split, we require that every child is a chain
; 970  :       node_is_the_last_split_in_tree =

	test	r10d, r10d
	je	SHORT $LN31@encoder_st

; 918  :   if (!state->children[0].encoder_control) return 1;

	mov	rcx, QWORD PTR [r9+rdx+16]
	cmp	QWORD PTR [rcx], rbx
	je	SHORT $LN183@encoder_st

; 919  :   if (state->children[1].encoder_control) return 0;

	cmp	QWORD PTR [rcx+424], rbx
	jne	SHORT $LN31@encoder_st

; 920  :   return encoder_state_tree_is_a_chain(&state->children[0]);

	call	encoder_state_tree_is_a_chain

; 961  :             main_state->tile->frame->cu_array,
; 962  :             offset_x,
; 963  :             offset_y,
; 964  :             sub_state->tile->frame->width_in_lcu * LCU_WIDTH,
; 965  :             sub_state->tile->frame->height_in_lcu * LCU_WIDTH
; 966  :         );
; 967  :       }
; 968  : 
; 969  :       //To be the last split, we require that every child is a chain
; 970  :       node_is_the_last_split_in_tree =

	test	eax, eax
	je	SHORT $LN31@encoder_st
$LN183@encoder_st:
	mov	r10d, 1
	mov	DWORD PTR node_is_the_last_split_in_tree$1$[rsp], r10d
	jmp	SHORT $LN32@encoder_st
$LN31@encoder_st:
	mov	r10d, ebx
	mov	DWORD PTR node_is_the_last_split_in_tree$1$[rsp], ebx
$LN32@encoder_st:

; 928  : 
; 929  :     for (int i = 0; main_state->children[i].encoder_control; ++i) {

	inc	r11
	mov	rax, rdx
	imul	r9, r11, 424				; 000001a8H
	mov	QWORD PTR $T1[rsp], r11
	mov	QWORD PTR tv1370[rsp], r9
	cmp	QWORD PTR [r9+rdx], rbx
	jne	$LL4@encoder_st

; 971  :         node_is_the_last_split_in_tree &&
; 972  :         encoder_state_tree_is_a_chain(&main_state->children[i]);
; 973  :     }
; 974  :     //If it's the latest split point
; 975  :     if (node_is_the_last_split_in_tree) {

	test	r10d, r10d
	je	$LN19@encoder_st

; 976  :       for (int i = 0; main_state->children[i].encoder_control; ++i) {

	mov	eax, ebx
	mov	DWORD PTR i$1$[rsp], ebx
	cmp	QWORD PTR [rdx], rax
	je	$LN190@encoder_st
	mov	r13, rbx
	mov	r15, rbx
	npad	14
$LL7@encoder_st:

; 977  :         //If we don't have wavefronts, parallelize encoding of children.
; 978  :         if (main_state->children[i].type != ENCODER_STATE_TYPE_WAVEFRONT_ROW) {

	cmp	DWORD PTR [r15+rdx+8], 87		; 00000057H
	lea	rdi, QWORD PTR [r15+rdx]
	je	$LN21@encoder_st

; 979  :           kvz_threadqueue_free_job(&main_state->children[i].tqj_recon_done);

	cdqe
	lea	rcx, QWORD PTR [rdx+400]
	imul	r12, rax, 424				; 000001a8H
	add	rcx, r12
	call	kvz_threadqueue_free_job

; 980  :           main_state->children[i].tqj_recon_done =

	mov	rbp, QWORD PTR [rsi+16]
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 425  :   threadqueue_job_t *job = MALLOC(threadqueue_job_t, 1);

	mov	ecx, 64					; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 980  :           main_state->children[i].tqj_recon_done =

	add	rbp, r12
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 425  :   threadqueue_job_t *job = MALLOC(threadqueue_job_t, 1);

	call	QWORD PTR __imp_malloc
	mov	r14, rax

; 426  :   if (!job) {

	test	rax, rax
	jne	SHORT $LN135@encoder_st

; 427  :     fprintf(stderr, "Could not alloc job!\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956614
	call	fprintf

; 428  :     return NULL;

	mov	r14, rbx
	jmp	SHORT $LN134@encoder_st
$LN135@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	ecx, 80					; 00000050H
	call	??2@YAPEAX_K@Z				; operator new
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	mov	edx, 2
	mov	rcx, rax
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	rdi, rax
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	call	QWORD PTR __imp__Mtx_init_in_situ
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 442  :   job->fptr           = fptr;

	lea	rax, OFFSET FLAT:encoder_state_worker_encode_children
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	QWORD PTR [r14], rdi
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 442  :   job->fptr           = fptr;

	mov	QWORD PTR [r14+40], rax
	mov	QWORD PTR [r14+8], rbx
	mov	QWORD PTR [r14+16], rbx
	mov	QWORD PTR [r14+24], rbx
	mov	DWORD PTR [r14+32], 1

; 443  :   job->arg            = arg;

	mov	QWORD PTR [r14+48], rbp
$LN134@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 980  :           main_state->children[i].tqj_recon_done =

	mov	rax, QWORD PTR [rsi+16]
	mov	QWORD PTR [r15+rax+400], r14

; 981  :             kvz_threadqueue_job_create(encoder_state_worker_encode_children, &main_state->children[i]);
; 982  :           if (main_state->children[i].previous_encoder_state != &main_state->children[i] &&
; 983  :               main_state->children[i].previous_encoder_state->tqj_recon_done &&

	mov	rcx, QWORD PTR [rsi+16]
	mov	rdx, rcx
	mov	r8, QWORD PTR [r15+rcx+32]
	lea	rax, QWORD PTR [r12+rcx]
	cmp	r8, rax
	je	SHORT $LN9@encoder_st
	cmp	QWORD PTR [r8+400], rbx
	je	SHORT $LN9@encoder_st
	mov	rax, QWORD PTR [r15+rcx+40]
	cmp	BYTE PTR [rax+83], bl
	jne	SHORT $LN9@encoder_st

; 984  :               !main_state->children[i].frame->is_irap)
; 985  :           {
; 986  : #if 0
; 987  :             // Disabled due to non-determinism.
; 988  :             if (main_state->encoder_control->cfg->mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN)
; 989  :             {
; 990  :               // When MV's don't cross tile boundaries, add dependancy only to the same tile.
; 991  :               kvz_threadqueue_job_dep_add(main_state->children[i].tqj_recon_done, main_state->children[i].previous_encoder_state->tqj_recon_done);
; 992  :             } else 
; 993  : #endif      
; 994  :             {
; 995  :               // Add dependancy to each child in the previous frame.
; 996  :               for (int child_id = 0; main_state->children[child_id].encoder_control; ++child_id) {

	mov	rdi, rbx
	cmp	QWORD PTR [rcx], rbx
	je	SHORT $LN9@encoder_st
	mov	rax, rbx
	npad	1
$LL10@encoder_st:

; 997  :                 kvz_threadqueue_job_dep_add(main_state->children[i].tqj_recon_done, main_state->children[child_id].previous_encoder_state->tqj_recon_done);

	mov	rcx, QWORD PTR [rsi+16]
	mov	rdx, QWORD PTR [rcx+rax+32]
	mov	rcx, QWORD PTR [r15+rcx+400]
	mov	rdx, QWORD PTR [rdx+400]
	call	kvz_threadqueue_job_dep_add
	mov	rdx, QWORD PTR [rsi+16]
	inc	rdi
	imul	rax, rdi, 424				; 000001a8H
	cmp	QWORD PTR [rdx+rax], rbx
	jne	SHORT $LL10@encoder_st
$LN9@encoder_st:

; 998  :               }
; 999  :             }
; 1000 :           }
; 1001 :           kvz_threadqueue_submit(main_state->encoder_control->threadqueue, main_state->children[i].tqj_recon_done);

	mov	rcx, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [r15+rdx+400]
	mov	rcx, QWORD PTR [rcx+6448]
	call	kvz_threadqueue_submit

; 1002 :         } else {

	jmp	$LN5@encoder_st
$LN21@encoder_st:

; 900  :   encoder_state_encode(sub_state);

	mov	rcx, rdi
	call	encoder_state_encode

; 901  : 
; 902  :   if (sub_state->is_leaf && sub_state->type == ENCODER_STATE_TYPE_WAVEFRONT_ROW) {

	cmp	DWORD PTR [rdi+72], ebx
	je	$LN5@encoder_st
	cmp	DWORD PTR [rdi+8], 87			; 00000057H
	jne	$LN5@encoder_st

; 903  :     // Set the last wavefront job of this row as the job that completes
; 904  :     // the bitstream for this wavefront row state.
; 905  : 
; 906  :     int wpp_row = sub_state->wfrow->lcu_offset_y;

	mov	rax, QWORD PTR [rdi+64]

; 907  :     int tile_width = sub_state->tile->frame->width_in_lcu;

	mov	rdx, QWORD PTR [rdi+48]

; 908  :     int end_of_row = (wpp_row + 1) * tile_width - 1;

	mov	ebp, DWORD PTR [rax]
	mov	rax, QWORD PTR [rdx]
	inc	ebp
	imul	ebp, DWORD PTR [rax+28]

; 909  :     assert(!sub_state->tqj_bitstream_written);

	cmp	QWORD PTR [rdi+408], rbx
	je	SHORT $LN151@encoder_st
	mov	r8d, 909				; 0000038dH
	lea	rdx, OFFSET FLAT:$SG4294952905
	lea	rcx, OFFSET FLAT:$SG4294952904
	call	QWORD PTR __imp__wassert
	mov	rdx, QWORD PTR [rdi+48]
$LN151@encoder_st:

; 910  :     if (sub_state->tile->wf_jobs[end_of_row]) {

	mov	rax, QWORD PTR [rdx+64]
	movsxd	rcx, ebp
	mov	rbp, QWORD PTR [rax+rcx*8-8]
	test	rbp, rbp
	je	SHORT $LN5@encoder_st
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 523  :   int32_t new_refcount = KVZ_ATOMIC_INC(&job->refcount);

	mov	eax, 1
	lock xadd DWORD PTR [rbp+32], eax
	inc	eax

; 524  :   // The caller should have had another reference and we added one
; 525  :   // reference so refcount should be at least 2.
; 526  :   assert(new_refcount >= 2);

	cmp	eax, 2
	jge	SHORT $LN154@encoder_st
	mov	r8d, 526				; 0000020eH
	lea	rdx, OFFSET FLAT:$SG4294956574
	lea	rcx, OFFSET FLAT:$SG4294956573
	call	QWORD PTR __imp__wassert
$LN154@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 911  :       sub_state->tqj_bitstream_written =

	mov	QWORD PTR [rdi+408], rbp
$LN5@encoder_st:

; 976  :       for (int i = 0; main_state->children[i].encoder_control; ++i) {

	mov	eax, DWORD PTR i$1$[rsp]
	inc	r13
	mov	rdx, QWORD PTR [rsi+16]
	inc	eax
	imul	r15, r13, 424				; 000001a8H
	mov	DWORD PTR i$1$[rsp], eax
	cmp	QWORD PTR [r15+rdx], rbx
	jne	$LL7@encoder_st
$LN190@encoder_st:
	mov	r14, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+112]
	mov	r12, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+104]
	mov	r13, QWORD PTR [rsp+88]

; 1023 :     }
; 1024 :   }
; 1025 : }

	add	rsp, 120				; 00000078H
	pop	rsi
	pop	rbx
	ret	0
$LN19@encoder_st:

; 1003 :           //Wavefront rows have parallelism at LCU level, so we should not launch multiple threads here!
; 1004 :           //FIXME: add an assert: we can only have wavefront children
; 1005 :           encoder_state_worker_encode_children(&(main_state->children[i]));
; 1006 :         }
; 1007 :       }
; 1008 :     } else {
; 1009 :       for (int i = 0; main_state->children[i].encoder_control; ++i) {

	cmp	QWORD PTR [rdx], rbx
	je	SHORT $LN190@encoder_st
	mov	rax, rbx
	npad	6
$LL13@encoder_st:

; 1010 :         encoder_state_worker_encode_children(&(main_state->children[i]));

	lea	rdi, QWORD PTR [rdx+rax]

; 900  :   encoder_state_encode(sub_state);

	mov	rcx, rdi
	call	encoder_state_encode

; 901  : 
; 902  :   if (sub_state->is_leaf && sub_state->type == ENCODER_STATE_TYPE_WAVEFRONT_ROW) {

	cmp	DWORD PTR [rdi+72], 0
	je	$LN11@encoder_st
	cmp	DWORD PTR [rdi+8], 87			; 00000057H
	jne	SHORT $LN11@encoder_st

; 903  :     // Set the last wavefront job of this row as the job that completes
; 904  :     // the bitstream for this wavefront row state.
; 905  : 
; 906  :     int wpp_row = sub_state->wfrow->lcu_offset_y;

	mov	rax, QWORD PTR [rdi+64]

; 907  :     int tile_width = sub_state->tile->frame->width_in_lcu;

	mov	rdx, QWORD PTR [rdi+48]

; 908  :     int end_of_row = (wpp_row + 1) * tile_width - 1;

	mov	ebp, DWORD PTR [rax]
	mov	rax, QWORD PTR [rdx]
	inc	ebp
	imul	ebp, DWORD PTR [rax+28]

; 909  :     assert(!sub_state->tqj_bitstream_written);

	cmp	QWORD PTR [rdi+408], 0
	je	SHORT $LN159@encoder_st
	mov	r8d, 909				; 0000038dH
	lea	rdx, OFFSET FLAT:$SG4294952905
	lea	rcx, OFFSET FLAT:$SG4294952904
	call	QWORD PTR __imp__wassert
	mov	rdx, QWORD PTR [rdi+48]
$LN159@encoder_st:

; 910  :     if (sub_state->tile->wf_jobs[end_of_row]) {

	mov	rax, QWORD PTR [rdx+64]
	movsxd	rcx, ebp
	mov	rbp, QWORD PTR [rax+rcx*8-8]
	test	rbp, rbp
	je	SHORT $LN11@encoder_st
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 523  :   int32_t new_refcount = KVZ_ATOMIC_INC(&job->refcount);

	mov	eax, 1
	lock xadd DWORD PTR [rbp+32], eax
	inc	eax

; 524  :   // The caller should have had another reference and we added one
; 525  :   // reference so refcount should be at least 2.
; 526  :   assert(new_refcount >= 2);

	cmp	eax, 2
	jge	SHORT $LN162@encoder_st
	mov	r8d, 526				; 0000020eH
	lea	rdx, OFFSET FLAT:$SG4294956574
	lea	rcx, OFFSET FLAT:$SG4294956573
	call	QWORD PTR __imp__wassert
$LN162@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 911  :       sub_state->tqj_bitstream_written =

	mov	QWORD PTR [rdi+408], rbp
$LN11@encoder_st:

; 1003 :           //Wavefront rows have parallelism at LCU level, so we should not launch multiple threads here!
; 1004 :           //FIXME: add an assert: we can only have wavefront children
; 1005 :           encoder_state_worker_encode_children(&(main_state->children[i]));
; 1006 :         }
; 1007 :       }
; 1008 :     } else {
; 1009 :       for (int i = 0; main_state->children[i].encoder_control; ++i) {

	mov	rdx, QWORD PTR [rsi+16]
	inc	rbx
	imul	rax, rbx, 424				; 000001a8H
	cmp	QWORD PTR [rdx+rax], 0
	jne	$LL13@encoder_st

; 1011 :       }
; 1012 :     }
; 1013 :   } else {

	jmp	$LN190@encoder_st
$LN16@encoder_st:

; 1014 :     switch (main_state->type) {

	mov	ebx, DWORD PTR [rcx+8]
	lea	eax, DWORD PTR [rbx-83]
	test	eax, -6					; fffffffaH
	jne	SHORT $LN25@encoder_st
	cmp	ebx, 88					; 00000058H
	je	SHORT $LN25@encoder_st

; 1023 :     }
; 1024 :   }
; 1025 : }

	add	rsp, 120				; 00000078H
	pop	rsi
	pop	rbx

; 1015 :       case ENCODER_STATE_TYPE_TILE:
; 1016 :       case ENCODER_STATE_TYPE_SLICE:
; 1017 :       case ENCODER_STATE_TYPE_WAVEFRONT_ROW:
; 1018 :         encoder_state_encode_leaf(main_state);

	jmp	encoder_state_encode_leaf
$LN25@encoder_st:

; 1019 :         break;
; 1020 :       default:
; 1021 :         fprintf(stderr, "Unsupported leaf type %c!\n", main_state->type);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, ebx
	lea	rdx, OFFSET FLAT:$SG4294952903
	mov	rcx, rax
	call	fprintf

; 1022 :         assert(0);

	mov	r8d, 1022				; 000003feH
	lea	rdx, OFFSET FLAT:$SG4294952902
	lea	rcx, OFFSET FLAT:$SG4294952901

; 1023 :     }
; 1024 :   }
; 1025 : }

	add	rsp, 120				; 00000078H
	pop	rsi
	pop	rbx

; 1022 :         assert(0);

	rex_jmp	QWORD PTR __imp__wassert
encoder_state_encode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 16
reflist$ = 24
length$ = 32
reverse$ = 40
encoder_ref_insertion_sort PROC

; 1032 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rsi

; 1033 : 
; 1034 :   for (uint8_t i = 1; i < length; ++i) {

	mov	bl, 1
	movzx	esi, r8b
	mov	r10, rdx
	mov	r11, rcx
	cmp	r8b, bl
	jbe	SHORT $LN3@encoder_re
	mov	QWORD PTR [rsp+16], rdi
	npad	4
$LL4@encoder_re:

; 1035 :     const uint8_t cur_idx = reflist[i];

	movzx	eax, bl
	movzx	edi, BYTE PTR [rax+r10]

; 1036 :     const int32_t cur_poc = state->frame->ref->pocs[cur_idx];

	mov	rax, QWORD PTR [r11+40]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+16]
	mov	r8d, DWORD PTR [rax+rdi*4]

; 1037 :     int8_t j = i;

	movzx	eax, bl
	npad	5
$LL5@encoder_re:

; 1038 :     while ((j > 0 && !reverse && cur_poc > state->frame->ref->pocs[reflist[j - 1]]) ||

	test	al, al
	jle	SHORT $LN19@encoder_re
	mov	rcx, QWORD PTR [r11+40]
	movsx	rdx, al
	mov	rcx, QWORD PTR [rcx+40]
	movzx	edx, BYTE PTR [rdx+r10-1]
	mov	rcx, QWORD PTR [rcx+16]
	test	r9b, r9b
	jne	SHORT $LN18@encoder_re
	cmp	r8d, DWORD PTR [rcx+rdx*4]
	jg	SHORT $LN7@encoder_re
$LN19@encoder_re:

; 1044 :     reflist[j] = cur_idx;

	movsx	rcx, al
	inc	bl
	mov	BYTE PTR [rcx+r10], dil
	cmp	bl, sil
	jb	SHORT $LL4@encoder_re

; 1033 : 
; 1034 :   for (uint8_t i = 1; i < length; ++i) {

	mov	rdi, QWORD PTR [rsp+16]
$LN3@encoder_re:

; 1045 :   }
; 1046 : }

	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
$LN18@encoder_re:

; 1038 :     while ((j > 0 && !reverse && cur_poc > state->frame->ref->pocs[reflist[j - 1]]) ||

	cmp	r8d, DWORD PTR [rcx+rdx*4]
	jge	SHORT $LN19@encoder_re
$LN7@encoder_re:

; 1039 :            (j > 0 &&  reverse && cur_poc < state->frame->ref->pocs[reflist[j - 1]]))
; 1040 :     {
; 1041 :       reflist[j] = reflist[j - 1];

	movsx	rcx, al

; 1042 :       --j;

	dec	al
	mov	BYTE PTR [rcx+r10], dl

; 1043 :     }

	jmp	SHORT $LL5@encoder_re
encoder_ref_insertion_sort ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 8
kvz_encoder_create_ref_lists PROC

; 1054 : {

$LN100:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi

; 1055 :   const kvz_config *cfg = &state->encoder_control->cfg;
; 1056 : 
; 1057 :   FILL_ARRAY(state->frame->ref_LX_size, 0, 2);

	mov	rax, QWORD PTR [rcx+40]

; 1058 : 
; 1059 :   int num_negative = 0;

	xor	edi, edi
	mov	rbx, QWORD PTR [rcx]
	mov	r8, rcx
	xor	ecx, ecx

; 1060 :   int num_positive = 0;

	mov	esi, edi

; 1061 : 
; 1062 :   // Add positive references to L1 list
; 1063 :   for (int i = 0; i < state->frame->ref->used_size; i++) {

	mov	r11d, edi
	mov	WORD PTR [rax+81], cx
	mov	r9, QWORD PTR [r8+40]
	mov	rax, QWORD PTR [r9+40]
	cmp	DWORD PTR [rax+36], ecx
	jbe	SHORT $LN3@kvz_encode
	mov	r10, r9
	npad	5
$LL4@kvz_encode:

; 1064 :     if (state->frame->ref->pocs[i] > state->frame->poc) {

	mov	rax, QWORD PTR [r10+40]
	mov	r9, r10
	movsxd	rdx, r11d
	mov	rcx, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [r10+12]
	cmp	DWORD PTR [rcx+rdx*4], eax
	jle	SHORT $LN2@kvz_encode

; 1065 :       state->frame->ref_LX[1][state->frame->ref_LX_size[1]] = i;

	movzx	eax, BYTE PTR [r10+82]
	mov	BYTE PTR [rax+r10+65], r11b

; 1066 :       state->frame->ref_LX_size[1] += 1;

	mov	rax, QWORD PTR [r8+40]
	inc	BYTE PTR [rax+82]

; 1067 :       num_positive++;

	mov	r9, QWORD PTR [r8+40]
	inc	esi
$LN2@kvz_encode:

; 1061 : 
; 1062 :   // Add positive references to L1 list
; 1063 :   for (int i = 0; i < state->frame->ref->used_size; i++) {

	mov	rax, QWORD PTR [r9+40]
	inc	r11d
	mov	r10, r9
	cmp	r11d, DWORD PTR [rax+36]
	jb	SHORT $LL4@kvz_encode
$LN3@kvz_encode:

; 1068 :     }
; 1069 :   }
; 1070 : 
; 1071 :   // Add negative references to L1 list when bipred is enabled and GOP is
; 1072 :   // either disabled or does not use picture reordering.
; 1073 :   bool l1_negative_refs =

	cmp	DWORD PTR [rbx+92], edi
	je	SHORT $LN20@kvz_encode
	cmp	BYTE PTR [rbx+300], dil
	je	SHORT $LN19@kvz_encode
	cmp	BYTE PTR [rbx+301], dil
	je	SHORT $LN20@kvz_encode
$LN19@kvz_encode:
	mov	bpl, 1
	jmp	SHORT $LN21@kvz_encode
$LN20@kvz_encode:
	xor	bpl, bpl
$LN21@kvz_encode:

; 1074 :     (cfg->bipred && (cfg->gop_len == 0 || cfg->gop_lowdelay));
; 1075 : 
; 1076 :   // Add negative references to L0 and L1 lists.
; 1077 :   for (int i = 0; i < state->frame->ref->used_size; i++) {

	mov	rax, QWORD PTR [r9+40]
	mov	r10d, edi
	cmp	DWORD PTR [rax+36], edi
	jbe	SHORT $LN6@kvz_encode
	mov	r11, r9
	npad	4
$LL7@kvz_encode:

; 1078 :     if (state->frame->ref->pocs[i] < state->frame->poc) {

	mov	rax, QWORD PTR [r11+40]
	mov	r9, r11
	movsxd	rdx, r10d
	mov	rcx, QWORD PTR [rax+16]
	mov	eax, DWORD PTR [r11+12]
	cmp	DWORD PTR [rcx+rdx*4], eax
	jge	SHORT $LN5@kvz_encode

; 1079 :       state->frame->ref_LX[0][state->frame->ref_LX_size[0]] = i;

	movzx	eax, BYTE PTR [r11+81]
	mov	BYTE PTR [rax+r11+49], r10b

; 1080 :       state->frame->ref_LX_size[0] += 1;

	mov	rax, QWORD PTR [r8+40]
	inc	BYTE PTR [rax+81]

; 1081 :       if (l1_negative_refs) {

	test	bpl, bpl
	je	SHORT $LN16@kvz_encode

; 1082 :         state->frame->ref_LX[1][state->frame->ref_LX_size[1]] = i;

	mov	rcx, QWORD PTR [r8+40]
	movzx	eax, BYTE PTR [rcx+82]
	mov	BYTE PTR [rax+rcx+65], r10b

; 1083 :         state->frame->ref_LX_size[1] += 1;

	mov	rax, QWORD PTR [r8+40]
	inc	BYTE PTR [rax+82]
$LN16@kvz_encode:

; 1084 :       }
; 1085 :       num_negative++;

	mov	r9, QWORD PTR [r8+40]
	inc	edi
$LN5@kvz_encode:

; 1074 :     (cfg->bipred && (cfg->gop_len == 0 || cfg->gop_lowdelay));
; 1075 : 
; 1076 :   // Add negative references to L0 and L1 lists.
; 1077 :   for (int i = 0; i < state->frame->ref->used_size; i++) {

	mov	rax, QWORD PTR [r9+40]
	inc	r10d
	mov	r11, r9
	cmp	r10d, DWORD PTR [rax+36]
	jb	SHORT $LL7@kvz_encode
$LN6@kvz_encode:

; 1086 :     }
; 1087 :   }
; 1088 : 
; 1089 :   // Fill the rest with -1.
; 1090 :   for (int i = state->frame->ref_LX_size[0]; i < 16; i++) {

	movzx	ecx, BYTE PTR [r9+81]
	cmp	rcx, 16
	jae	SHORT $LN93@kvz_encode
	npad	14
$LL10@kvz_encode:

; 1091 :     state->frame->ref_LX[0][i] = 0xff;

	mov	rax, QWORD PTR [r8+40]
	mov	BYTE PTR [rax+rcx+49], 255		; 000000ffH
	inc	rcx
	cmp	rcx, 16
	jl	SHORT $LL10@kvz_encode
	mov	r9, QWORD PTR [r8+40]
$LN93@kvz_encode:

; 1092 :   }
; 1093 :   for (int i = state->frame->ref_LX_size[1]; i < 16; i++) {

	movzx	ecx, BYTE PTR [r9+82]
	cmp	rcx, 16
	jae	SHORT $LN94@kvz_encode
	npad	15
$LL13@kvz_encode:

; 1094 :     state->frame->ref_LX[1][i] = 0xff;

	mov	rax, QWORD PTR [r8+40]
	mov	BYTE PTR [rax+rcx+65], 255		; 000000ffH
	inc	rcx
	cmp	rcx, 16
	jl	SHORT $LL13@kvz_encode
	mov	r9, QWORD PTR [r8+40]
$LN94@kvz_encode:

; 1034 :   for (uint8_t i = 1; i < length; ++i) {

	mov	r11b, 1

; 1095 :   }
; 1096 : 
; 1097 :   // Sort reference lists.
; 1098 :   encoder_ref_insertion_sort(state, state->frame->ref_LX[0], num_negative, false);

	lea	r10, QWORD PTR [r9+49]

; 1034 :   for (uint8_t i = 1; i < length; ++i) {

	cmp	dil, r11b
	jbe	SHORT $LN96@kvz_encode
$LL25@kvz_encode:

; 1035 :     const uint8_t cur_idx = reflist[i];

	movzx	eax, r11b

; 1037 :     int8_t j = i;

	movzx	ecx, r11b
	movzx	ebx, BYTE PTR [rax+r10]
	mov	rax, QWORD PTR [r8+40]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+16]
	mov	r9d, DWORD PTR [rax+rbx*4]
	npad	1
$LL26@kvz_encode:

; 1038 :     while ((j > 0 && !reverse && cur_poc > state->frame->ref->pocs[reflist[j - 1]]) ||

	test	cl, cl
	jle	SHORT $LN95@kvz_encode
	movsx	rax, cl
	movzx	edx, BYTE PTR [rax+r10-1]
	mov	rax, QWORD PTR [r8+40]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+16]
	cmp	r9d, DWORD PTR [rax+rdx*4]
	jle	SHORT $LN95@kvz_encode

; 1039 :            (j > 0 &&  reverse && cur_poc < state->frame->ref->pocs[reflist[j - 1]]))
; 1040 :     {
; 1041 :       reflist[j] = reflist[j - 1];

	movsx	rax, cl

; 1042 :       --j;

	dec	cl
	mov	BYTE PTR [rax+r10], dl

; 1043 :     }

	jmp	SHORT $LL26@kvz_encode
$LN95@kvz_encode:

; 1044 :     reflist[j] = cur_idx;

	movsx	rax, cl
	inc	r11b
	mov	BYTE PTR [rax+r10], bl
	cmp	r11b, dil
	jb	SHORT $LL25@kvz_encode

; 1038 :     while ((j > 0 && !reverse && cur_poc > state->frame->ref->pocs[reflist[j - 1]]) ||

	mov	r9, QWORD PTR [r8+40]
$LN96@kvz_encode:

; 1034 :   for (uint8_t i = 1; i < length; ++i) {

	mov	r10b, 1
	cmp	sil, r10b
	jbe	SHORT $LN33@kvz_encode
	npad	8
$LL34@kvz_encode:

; 1035 :     const uint8_t cur_idx = reflist[i];

	movzx	eax, r10b

; 1037 :     int8_t j = i;

	movzx	ecx, r10b
	movzx	ebx, BYTE PTR [rax+r9+65]
	mov	rax, QWORD PTR [r8+40]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+16]
	mov	r11d, DWORD PTR [rax+rbx*4]
	npad	2
$LL35@kvz_encode:

; 1038 :     while ((j > 0 && !reverse && cur_poc > state->frame->ref->pocs[reflist[j - 1]]) ||

	test	cl, cl
	jle	SHORT $LN97@kvz_encode
	movsx	rax, cl
	movzx	edx, BYTE PTR [rax+r9+64]
	mov	rax, QWORD PTR [r8+40]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+16]
	cmp	r11d, DWORD PTR [rax+rdx*4]
	jge	SHORT $LN97@kvz_encode

; 1039 :            (j > 0 &&  reverse && cur_poc < state->frame->ref->pocs[reflist[j - 1]]))
; 1040 :     {
; 1041 :       reflist[j] = reflist[j - 1];

	movsx	rax, cl

; 1042 :       --j;

	dec	cl
	mov	BYTE PTR [rax+r9+65], dl

; 1043 :     }

	jmp	SHORT $LL35@kvz_encode
$LN97@kvz_encode:

; 1044 :     reflist[j] = cur_idx;

	movsx	rax, cl
	inc	r10b
	mov	BYTE PTR [rax+r9+65], bl
	cmp	r10b, sil
	jb	SHORT $LL34@kvz_encode
$LN33@kvz_encode:

; 1099 :   encoder_ref_insertion_sort(state, state->frame->ref_LX[1], num_positive, true);
; 1100 :   if (l1_negative_refs) {

	test	bpl, bpl
	je	SHORT $LN42@kvz_encode

; 1101 :     encoder_ref_insertion_sort(state, state->frame->ref_LX[1] + num_positive, num_negative, false);

	movsxd	r9, esi

; 1034 :   for (uint8_t i = 1; i < length; ++i) {

	mov	r10b, 1

; 1101 :     encoder_ref_insertion_sort(state, state->frame->ref_LX[1] + num_positive, num_negative, false);

	add	r9, QWORD PTR [r8+40]

; 1034 :   for (uint8_t i = 1; i < length; ++i) {

	cmp	dil, r10b
	jbe	SHORT $LN42@kvz_encode
$LL43@kvz_encode:

; 1035 :     const uint8_t cur_idx = reflist[i];

	movzx	eax, r10b
	movzx	ebx, BYTE PTR [rax+r9+65]

; 1036 :     const int32_t cur_poc = state->frame->ref->pocs[cur_idx];

	mov	rax, QWORD PTR [r8+40]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+16]
	mov	r11d, DWORD PTR [rax+rbx*4]

; 1037 :     int8_t j = i;

	movzx	eax, r10b
$LL44@kvz_encode:

; 1038 :     while ((j > 0 && !reverse && cur_poc > state->frame->ref->pocs[reflist[j - 1]]) ||

	test	al, al
	jle	SHORT $LN98@kvz_encode
	movsx	rcx, al
	movzx	edx, BYTE PTR [rcx+r9+64]
	mov	rcx, QWORD PTR [r8+40]
	mov	rcx, QWORD PTR [rcx+40]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	r11d, DWORD PTR [rcx+rdx*4]
	jle	SHORT $LN98@kvz_encode

; 1039 :            (j > 0 &&  reverse && cur_poc < state->frame->ref->pocs[reflist[j - 1]]))
; 1040 :     {
; 1041 :       reflist[j] = reflist[j - 1];

	movsx	rcx, al

; 1042 :       --j;

	dec	al
	mov	BYTE PTR [rcx+r9+65], dl

; 1043 :     }

	jmp	SHORT $LL44@kvz_encode
$LN98@kvz_encode:

; 1044 :     reflist[j] = cur_idx;

	movsx	rcx, al
	inc	r10b
	mov	BYTE PTR [rcx+r9+65], bl
	cmp	r10b, dil
	jb	SHORT $LL43@kvz_encode
$LN42@kvz_encode:

; 1102 :   }
; 1103 : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rbp, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+24]
	mov	rdi, QWORD PTR [rsp+32]
	ret	0
kvz_encoder_create_ref_lists ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
target_ref_num$2$ = 80
state$ = 80
encoder_state_remove_refs PROC

; 1108 : static void encoder_state_remove_refs(encoder_state_t *state) {

	sub	rsp, 72					; 00000048H

; 1109 :   const encoder_control_t * const encoder = state->encoder_control;
; 1110 : 
; 1111 :   int neg_refs = encoder->cfg.gop[state->frame->gop_offset].ref_neg_count;

	mov	rdx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rsp+48], r13
	mov	r13, QWORD PTR [rcx]
	mov	QWORD PTR [rsp+40], r14
	mov	r14, rcx
	movsx	rax, BYTE PTR [rdx+16]
	shl	rax, 6

; 1112 :   int pos_refs = encoder->cfg.gop[state->frame->gop_offset].ref_pos_count;
; 1113 : 
; 1114 :   unsigned target_ref_num;
; 1115 :   if (encoder->cfg.gop_len) {

	movzx	r10d, BYTE PTR [r13+300]
	mov	QWORD PTR [rsp+32], r15
	movsx	r8, BYTE PTR [rax+r13+333]
	movsx	r9, BYTE PTR [rax+r13+316]

; 1116 :     target_ref_num = neg_refs + pos_refs;

	lea	r15d, DWORD PTR [r9+r8]
	test	r10b, r10b
	jne	SHORT $LN14@encoder_st

; 1117 :   } else {
; 1118 :     target_ref_num = encoder->cfg.ref_frames;

	mov	r15d, DWORD PTR [r13+128]
$LN14@encoder_st:

; 1119 :   }
; 1120 : 
; 1121 :   if (state->frame->pictype == KVZ_NAL_IDR_W_RADL ||

	movzx	eax, BYTE PTR [rdx+84]
	xor	ecx, ecx
	sub	al, 19
	cmp	al, 1
	cmovbe	r15d, ecx
	mov	DWORD PTR target_ref_num$2$[rsp], r15d

; 1122 :       state->frame->pictype == KVZ_NAL_IDR_N_LP)
; 1123 :   {
; 1124 :     target_ref_num = 0;
; 1125 :   }
; 1126 : 
; 1127 :   if (encoder->cfg.gop_len && target_ref_num > 0) {

	test	r10b, r10b
	je	$LN29@encoder_st
	test	r15d, r15d
	je	$LN29@encoder_st

; 1128 :     // With GOP in use, go through all the existing reference pictures and
; 1129 :     // remove any picture that is not referenced by the current picture.
; 1130 : 
; 1131 :     for (int ref = state->frame->ref->used_size - 1; ref >= 0; --ref) {

	mov	rax, QWORD PTR [rdx+40]
	mov	QWORD PTR [rsp+96], rbp
	mov	rbp, r8
	mov	QWORD PTR [rsp+104], rsi
	mov	rsi, r9
	mov	QWORD PTR [rsp+64], rdi
	mov	edi, DWORD PTR [rax+36]
	sub	edi, 1
	js	$LN3@encoder_st

; 1145 :         int ref_relative_poc = encoder->cfg.gop[state->frame->gop_offset].ref_pos[i];

	movsxd	rax, edi
	mov	r10, rdx
	mov	QWORD PTR [rsp+88], rbx
	xor	r15d, r15d
	mov	QWORD PTR [rsp+56], r12
	lea	r12, QWORD PTR [rax*4]
	npad	11
$LL4@encoder_st:

; 1132 :       bool is_referenced = false;

	mov	r11, QWORD PTR [r10+40]
	xor	bl, bl

; 1133 : 
; 1134 :       int ref_poc = state->frame->ref->pocs[ref];
; 1135 : 
; 1136 :       for (int i = 0; i < neg_refs; i++) {

	mov	r8, r15
	mov	rax, QWORD PTR [r11+16]
	mov	r9d, DWORD PTR [r12+rax]
	test	rbp, rbp
	jle	SHORT $LN6@encoder_st

; 1137 :         int ref_relative_poc = -encoder->cfg.gop[state->frame->gop_offset].ref_neg[i];

	movsx	rax, BYTE PTR [r10+16]
	lea	rdx, QWORD PTR [r13+334]

; 1138 :         if (ref_poc == state->frame->poc + ref_relative_poc) {

	mov	r11d, DWORD PTR [r10+12]
	shl	rax, 6
	add	rdx, rax
	npad	3
$LL7@encoder_st:
	movsx	eax, BYTE PTR [rdx]
	mov	ecx, r11d
	sub	ecx, eax
	cmp	r9d, ecx
	je	SHORT $LN30@encoder_st

; 1133 : 
; 1134 :       int ref_poc = state->frame->ref->pocs[ref];
; 1135 : 
; 1136 :       for (int i = 0; i < neg_refs; i++) {

	inc	r8
	inc	rdx
	cmp	r8, rbp
	jl	SHORT $LL7@encoder_st

; 1146 :         if (ref_poc == state->frame->poc + ref_relative_poc) {

	jmp	SHORT $LN46@encoder_st
$LN30@encoder_st:

; 1139 :           is_referenced = true;

	mov	bl, 1
$LN46@encoder_st:

; 1140 :           break;
; 1141 :         }
; 1142 :       }
; 1143 : 
; 1144 :       for (int i = 0; i < pos_refs; i++) {

	mov	r11, QWORD PTR [r10+40]
$LN6@encoder_st:
	mov	rdx, r15
	test	rsi, rsi
	jle	SHORT $LN9@encoder_st

; 1145 :         int ref_relative_poc = encoder->cfg.gop[state->frame->gop_offset].ref_pos[i];

	movsx	rax, BYTE PTR [r10+16]
	lea	rcx, QWORD PTR [r13+317]

; 1146 :         if (ref_poc == state->frame->poc + ref_relative_poc) {

	mov	r8d, DWORD PTR [r10+12]
	shl	rax, 6
	add	rcx, rax
	npad	1
$LL10@encoder_st:
	movsx	eax, BYTE PTR [rcx]
	add	eax, r8d
	cmp	r9d, eax
	je	SHORT $LN31@encoder_st

; 1140 :           break;
; 1141 :         }
; 1142 :       }
; 1143 : 
; 1144 :       for (int i = 0; i < pos_refs; i++) {

	inc	rdx
	inc	rcx
	cmp	rdx, rsi
	jl	SHORT $LL10@encoder_st

; 1146 :         if (ref_poc == state->frame->poc + ref_relative_poc) {

	jmp	SHORT $LN9@encoder_st
$LN31@encoder_st:

; 1147 :           is_referenced = true;

	mov	bl, 1
$LN9@encoder_st:

; 1148 :           break;
; 1149 :         }
; 1150 :       }
; 1151 : 
; 1152 :       if (ref_poc < state->frame->irap_poc &&

	mov	eax, DWORD PTR [r10+20]
	cmp	r9d, eax
	jge	SHORT $LN21@encoder_st
	cmp	eax, DWORD PTR [r10+12]
	movzx	ebx, bl
	cmovl	ebx, r15d
$LN21@encoder_st:

; 1153 :           state->frame->irap_poc < state->frame->poc)
; 1154 :       {
; 1155 :         // Trailing frames cannot refer to leading frames.
; 1156 :         is_referenced = false;
; 1157 :       }
; 1158 : 
; 1159 :       if (encoder->cfg.intra_period > 0 &&

	mov	edx, DWORD PTR [r13+4]
	test	edx, edx
	jle	SHORT $LN22@encoder_st
	sub	eax, edx
	cmp	r9d, eax
	jl	SHORT $LN44@encoder_st
$LN22@encoder_st:

; 1160 :           ref_poc < state->frame->irap_poc - encoder->cfg.intra_period)
; 1161 :       {
; 1162 :         // No frame can refer past the two preceding IRAP frames.
; 1163 :         is_referenced = false;
; 1164 :       }
; 1165 : 
; 1166 :       if (!is_referenced) {

	mov	rdx, r10
	test	bl, bl
	jne	SHORT $LN2@encoder_st
$LN44@encoder_st:

; 1167 :         // This reference is not referred to by this frame, it must be removed.
; 1168 :         kvz_image_list_rem(state->frame->ref, ref);

	mov	edx, edi
	mov	rcx, r11
	call	kvz_image_list_rem
	mov	r10, QWORD PTR [r14+40]
	mov	rdx, r10
$LN2@encoder_st:

; 1128 :     // With GOP in use, go through all the existing reference pictures and
; 1129 :     // remove any picture that is not referenced by the current picture.
; 1130 : 
; 1131 :     for (int ref = state->frame->ref->used_size - 1; ref >= 0; --ref) {

	sub	r12, 4
	sub	edi, 1
	jns	$LL4@encoder_st
	mov	r15d, DWORD PTR target_ref_num$2$[rsp]
	mov	r12, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+88]
$LN3@encoder_st:

; 1169 :       }
; 1170 :     }
; 1171 :   } else {

	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+96]
	jmp	SHORT $LN12@encoder_st
$LN29@encoder_st:

; 1172 :     // Without GOP, remove the oldest picture.
; 1173 :     while (state->frame->ref->used_size > target_ref_num) {

	mov	rax, QWORD PTR [rdx+40]
	cmp	DWORD PTR [rax+36], r15d
	jbe	SHORT $LN12@encoder_st
	npad	4
$LL11@encoder_st:

; 1174 :       int8_t oldest_ref = state->frame->ref->used_size - 1;

	mov	rax, QWORD PTR [r14+40]
	mov	rcx, QWORD PTR [rax+40]
	movzx	eax, BYTE PTR [rcx+36]
	dec	al

; 1175 :       kvz_image_list_rem(state->frame->ref, oldest_ref);

	movsx	edx, al
	call	kvz_image_list_rem
	mov	rdx, QWORD PTR [r14+40]
	mov	rax, QWORD PTR [rdx+40]
	cmp	DWORD PTR [rax+36], r15d
	ja	SHORT $LL11@encoder_st
$LN12@encoder_st:

; 1176 :     }
; 1177 :   }
; 1178 : 
; 1179 :   assert(state->frame->ref->used_size <= target_ref_num);

	mov	rax, QWORD PTR [rdx+40]
	mov	r14, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+48]
	cmp	DWORD PTR [rax+36], r15d
	mov	r15, QWORD PTR [rsp+32]
	jbe	SHORT $LN25@encoder_st
	mov	r8d, 1179				; 0000049bH
	lea	rdx, OFFSET FLAT:$SG4294952900
	lea	rcx, OFFSET FLAT:$SG4294952899

; 1180 : }

	add	rsp, 72					; 00000048H

; 1176 :     }
; 1177 :   }
; 1178 : 
; 1179 :   assert(state->frame->ref->used_size <= target_ref_num);

	rex_jmp	QWORD PTR __imp__wassert
$LN25@encoder_st:

; 1180 : }

	add	rsp, 72					; 00000048H
	ret	0
encoder_state_remove_refs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 48
frame$ = 56
encoder_set_source_picture PROC

; 1183 : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1184 :   assert(!state->tile->frame->source);

	mov	rax, QWORD PTR [rcx+48]
	mov	rbx, rcx
	mov	rdi, rdx
	mov	rcx, QWORD PTR [rax]
	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN5@encoder_se
	mov	r8d, 1184				; 000004a0H
	lea	rdx, OFFSET FLAT:$SG4294952898
	lea	rcx, OFFSET FLAT:$SG4294952897
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
$LN5@encoder_se:

; 1185 :   assert(!state->tile->frame->rec);

	cmp	QWORD PTR [rcx+8], 0
	je	SHORT $LN6@encoder_se
	mov	r8d, 1185				; 000004a1H
	lea	rdx, OFFSET FLAT:$SG4294952896
	lea	rcx, OFFSET FLAT:$SG4294952895
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
$LN6@encoder_se:

; 1186 : 
; 1187 :   state->tile->frame->source = frame;

	mov	QWORD PTR [rcx], rdi

; 1188 :   if (state->encoder_control->cfg.lossless) {

	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [rax+2392], 0
	je	SHORT $LN2@encoder_se
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 147  :   int32_t new_refcount = KVZ_ATOMIC_INC(&im->refcount);

	mov	eax, 1
	lock xadd DWORD PTR [rdi+88], eax
	inc	eax

; 148  :   // The caller should have had another reference and we added one
; 149  :   // reference so refcount should be at least 2.
; 150  :   assert(new_refcount >= 2);

	cmp	eax, 2
	jge	SHORT $LN9@encoder_se
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:$SG4294955962
	lea	rcx, OFFSET FLAT:$SG4294955961
	call	QWORD PTR __imp__wassert
$LN9@encoder_se:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1190 :     state->tile->frame->rec = kvz_image_copy_ref(frame);

	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], rdi

; 1191 :   } else {

	jmp	SHORT $LN3@encoder_se
$LN2@encoder_se:

; 1192 :     state->tile->frame->rec = kvz_image_alloc(state->encoder_control->chroma_format, frame->width, frame->height);

	mov	r8d, DWORD PTR [rdi+68]
	mov	edx, DWORD PTR [rdi+64]
	mov	ecx, DWORD PTR [rax+2596]
	call	kvz_image_alloc
	mov	rcx, QWORD PTR [rbx+48]
	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rdx+8], rax

; 1193 :     state->tile->frame->rec->dts = frame->dts;

	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rdi+104]
	mov	rdx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+104], rax

; 1194 :     state->tile->frame->rec->pts = frame->pts;

	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rdi+96]
	mov	rdx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+96], rax
$LN3@encoder_se:

; 1195 :   }
; 1196 : 
; 1197 :   kvz_videoframe_set_poc(state->tile->frame, state->frame->poc);

	mov	rax, QWORD PTR [rbx+48]
	mov	rdx, QWORD PTR [rbx+40]

; 1198 : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+56], eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
encoder_set_source_picture ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 48
encoder_state_init_children PROC

; 1200 : static void encoder_state_init_children(encoder_state_t * const state) {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 202  :   kvz_bitstream_free_chunks(stream->first);

	mov	rcx, QWORD PTR [rcx+104]

; 113  :   while (chunk != NULL) {

	test	rcx, rcx
	je	SHORT $LN13@encoder_st
	npad	10
$LL12@encoder_st:

; 114  :     kvz_data_chunk *next = chunk->next;

	mov	rbx, QWORD PTR [rcx+4104]

; 115  :     free(chunk);

	call	QWORD PTR __imp_free

; 116  :     chunk = next;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL12@encoder_st
$LN13@encoder_st:
	xorps	xmm0, xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1203 :   if (state->is_leaf) {

	xor	ebx, ebx
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 74   :   memset(stream, 0, sizeof(bitstream_t));

	movups	XMMWORD PTR [rdi+96], xmm0
	movups	XMMWORD PTR [rdi+112], xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1203 :   if (state->is_leaf) {

	cmp	DWORD PTR [rdi+72], ebx
	je	SHORT $LN5@encoder_st
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 92   :   data->low = 0;

	mov	DWORD PTR [rdi+136], ebx
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1206 :     kvz_init_contexts(state, state->encoder_control->cfg.set_qp_in_cu ? 26 : state->frame->QP, state->frame->slicetype);

	mov	dl, 26
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 93   :   data->range = 510;

	mov	DWORD PTR [rdi+140], 510		; 000001feH

; 94   :   data->bits_left = 23;

	mov	DWORD PTR [rdi+152], 23

; 95   :   data->num_buffered_bytes = 0;
; 96   :   data->buffered_byte = 0xff;

	mov	QWORD PTR [rdi+144], 255		; 000000ffH

; 97   :   data->only_count = 0; // By default, write bits out

	mov	BYTE PTR [rdi+156], bl
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1206 :     kvz_init_contexts(state, state->encoder_control->cfg.set_qp_in_cu ? 26 : state->frame->QP, state->frame->slicetype);

	mov	rax, QWORD PTR [rdi]
	cmp	BYTE PTR [rax+2463], bl
	mov	rax, QWORD PTR [rdi+40]
	jne	SHORT $LN8@encoder_st
	movzx	edx, BYTE PTR [rax+24]
$LN8@encoder_st:
	movzx	r8d, BYTE PTR [rax+88]
	mov	rcx, rdi
	call	kvz_init_contexts
$LN5@encoder_st:

; 1207 :   }
; 1208 : 
; 1209 :   //Clear the jobs
; 1210 :   kvz_threadqueue_free_job(&state->tqj_bitstream_written);

	lea	rcx, QWORD PTR [rdi+408]
	call	kvz_threadqueue_free_job

; 1211 :   kvz_threadqueue_free_job(&state->tqj_recon_done);

	lea	rcx, QWORD PTR [rdi+400]
	call	kvz_threadqueue_free_job

; 1212 : 
; 1213 :   //Copy the constraint pointer
; 1214 :   // TODO: Try to do it in the if (state->is_leaf)
; 1215 :   //if (state->parent != NULL) {
; 1216 :     // state->constraint = state->parent->constraint;
; 1217 :   //}
; 1218 : 
; 1219 :   for (int i = 0; state->children[i].encoder_control; ++i) {

	mov	rdx, QWORD PTR [rdi+16]
	cmp	QWORD PTR [rdx], rbx
	je	SHORT $LN3@encoder_st
	mov	QWORD PTR [rsp+48], rsi
	mov	rsi, rbx
	npad	3
$LL4@encoder_st:

; 1220 :     encoder_state_init_children(&state->children[i]);

	movsxd	rax, ebx
	imul	rcx, rax, 424				; 000001a8H
	add	rcx, rdx
	call	encoder_state_init_children
	mov	rdx, QWORD PTR [rdi+16]
	lea	rsi, QWORD PTR [rsi+424]
	inc	ebx
	cmp	QWORD PTR [rsi+rdx], 0
	jne	SHORT $LL4@encoder_st

; 1212 : 
; 1213 :   //Copy the constraint pointer
; 1214 :   // TODO: Try to do it in the if (state->is_leaf)
; 1215 :   //if (state->parent != NULL) {
; 1216 :     // state->constraint = state->parent->constraint;
; 1217 :   //}
; 1218 : 
; 1219 :   for (int i = 0; state->children[i].encoder_control; ++i) {

	mov	rsi, QWORD PTR [rsp+48]
$LN3@encoder_st:

; 1221 :   }
; 1222 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
encoder_state_init_children ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 16
normalize_lcu_weights PROC

; 1225 : {

	sub	rsp, 8
	mov	r8, rcx

; 1226 :   if (state->frame->num == 0) return;

	mov	rcx, QWORD PTR [rcx+40]
	cmp	DWORD PTR [rcx+8], 0
	je	$LN23@normalize_

; 1227 : 
; 1228 :   const uint32_t num_lcus = state->encoder_control->in.width_in_lcu *

	mov	rax, QWORD PTR [r8]
	xorps	xmm2, xmm2
	mov	QWORD PTR [rsp+16], rbx
	xor	ebx, ebx
	mov	r10d, ebx
	mov	r9d, DWORD PTR [rax+2540]
	imul	r9d, DWORD PTR [rax+2536]

; 1229 :                             state->encoder_control->in.height_in_lcu;
; 1230 :   double sum = 0.0;
; 1231 :   for (uint32_t i = 0; i < num_lcus; i++) {

	test	r9d, r9d
	je	$LN20@normalize_
	mov	QWORD PTR [rsp], rdi
	cmp	r9d, 4
	jb	SHORT $LN15@normalize_

; 1232 :     sum += state->frame->lcu_stats[i].weight;

	mov	rdi, QWORD PTR [rcx+160]
	mov	r11d, r9d
	and	r11d, -4				; fffffffcH
	xorps	xmm3, xmm3
	mov	edx, 2
	npad	3
$LL4@normalize_:
	mov	eax, r10d
	add	r10d, 4
	lea	rcx, QWORD PTR [rax+rax*8]
	movsd	xmm1, QWORD PTR [rdi+rcx*8+8]
	lea	eax, DWORD PTR [rdx-1]
	lea	rax, QWORD PTR [rax+rax*8]
	movhpd	xmm1, QWORD PTR [rdi+rax*8+8]
	mov	eax, edx
	addpd	xmm2, xmm1
	lea	rcx, QWORD PTR [rax+rax*8]
	lea	eax, DWORD PTR [rdx+1]
	add	edx, 4
	movsd	xmm1, QWORD PTR [rdi+rcx*8+8]
	lea	rax, QWORD PTR [rax+rax*8]
	movhpd	xmm1, QWORD PTR [rdi+rax*8+8]
	addpd	xmm3, xmm1
	cmp	r10d, r11d
	jb	SHORT $LL4@normalize_

; 1227 : 
; 1228 :   const uint32_t num_lcus = state->encoder_control->in.width_in_lcu *

	addpd	xmm2, xmm3
	movaps	xmm0, xmm2
	unpckhpd xmm0, xmm2
	addsd	xmm2, xmm0
$LN15@normalize_:

; 1229 :                             state->encoder_control->in.height_in_lcu;
; 1230 :   double sum = 0.0;
; 1231 :   for (uint32_t i = 0; i < num_lcus; i++) {

	cmp	r10d, r9d
	jae	$LN43@normalize_
	mov	eax, r9d
	mov	edi, r10d
	sub	eax, r10d
	cmp	eax, 4
	mov	rax, QWORD PTR [r8+40]
	mov	rdx, QWORD PTR [rax+160]
	jb	SHORT $LN39@normalize_

; 1232 :     sum += state->frame->lcu_stats[i].weight;

	mov	eax, r9d
	lea	rcx, QWORD PTR [rdi+rdi*8]
	sub	eax, r10d
	shl	rcx, 3
	sub	eax, 4
	shr	eax, 2
	inc	eax
	mov	r11d, eax
	lea	r10d, DWORD PTR [r10+rax*4]
	lea	rdi, QWORD PTR [rdi+rax*4]
	npad	7
$LL22@normalize_:
	addsd	xmm2, QWORD PTR [rcx+rdx+8]
	addsd	xmm2, QWORD PTR [rcx+rdx+80]
	addsd	xmm2, QWORD PTR [rcx+rdx+152]
	addsd	xmm2, QWORD PTR [rcx+rdx+224]
	add	rcx, 288				; 00000120H
	sub	r11, 1
	jne	SHORT $LL22@normalize_

; 1229 :                             state->encoder_control->in.height_in_lcu;
; 1230 :   double sum = 0.0;
; 1231 :   for (uint32_t i = 0; i < num_lcus; i++) {

	cmp	r10d, r9d
	jae	SHORT $LN43@normalize_
$LN39@normalize_:
	lea	rcx, QWORD PTR [rdi+rdi*8]
	mov	eax, r9d
	shl	rcx, 3
	sub	eax, r10d
	mov	r10d, eax
$LC36@normalize_:

; 1232 :     sum += state->frame->lcu_stats[i].weight;

	addsd	xmm2, QWORD PTR [rcx+rdx+8]
	add	rcx, 72					; 00000048H
	sub	r10, 1
	jne	SHORT $LC36@normalize_
$LN43@normalize_:
	mov	rdi, QWORD PTR [rsp]
$LN20@normalize_:

; 1233 :   }
; 1234 : 
; 1235 :   for (uint32_t i = 0; i < num_lcus; i++) {

	movsd	xmm3, QWORD PTR __real@3ff0000000000000
	cmp	r9d, 4
	jb	$LN30@normalize_
	lea	eax, DWORD PTR [r9-4]
	movaps	xmm1, xmm3
	shr	eax, 2
	mov	rdx, rbx
	inc	eax
	divsd	xmm1, xmm2
	mov	r10d, eax
	lea	ebx, DWORD PTR [rax*4]
	lea	r11, QWORD PTR [rax*4]
	npad	4
$LL25@normalize_:

; 1236 :     state->frame->lcu_stats[i].weight /= sum;

	mov	rax, QWORD PTR [r8+40]
	movaps	xmm0, xmm1
	lea	rdx, QWORD PTR [rdx+288]
	mov	rcx, QWORD PTR [rax+160]
	mulsd	xmm0, QWORD PTR [rcx+rdx-280]
	movsd	QWORD PTR [rcx+rdx-280], xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR [r8+40]
	mov	rcx, QWORD PTR [rax+160]
	mulsd	xmm0, QWORD PTR [rcx+rdx-208]
	movsd	QWORD PTR [rcx+rdx-208], xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR [r8+40]
	mov	rcx, QWORD PTR [rax+160]
	mulsd	xmm0, QWORD PTR [rcx+rdx-136]
	movsd	QWORD PTR [rcx+rdx-136], xmm0
	movaps	xmm0, xmm1
	mov	rax, QWORD PTR [r8+40]
	mov	rcx, QWORD PTR [rax+160]
	mulsd	xmm0, QWORD PTR [rcx+rdx-64]
	movsd	QWORD PTR [rcx+rdx-64], xmm0
	sub	r10, 1
	jne	$LL25@normalize_

; 1233 :   }
; 1234 : 
; 1235 :   for (uint32_t i = 0; i < num_lcus; i++) {

	cmp	ebx, r9d
	jae	SHORT $LN42@normalize_
	jmp	SHORT $LN41@normalize_
$LN30@normalize_:
	test	r9d, r9d
	je	SHORT $LN42@normalize_
	mov	r11, rbx
$LN41@normalize_:
	lea	rdx, QWORD PTR [r11+r11*8]
	shl	rdx, 3
	sub	r9d, ebx
	mov	r10d, r9d
	divsd	xmm3, xmm2
$LC38@normalize_:

; 1236 :     state->frame->lcu_stats[i].weight /= sum;

	mov	rax, QWORD PTR [r8+40]
	movaps	xmm0, xmm3
	lea	rdx, QWORD PTR [rdx+72]
	mov	rcx, QWORD PTR [rax+160]
	mulsd	xmm0, QWORD PTR [rcx+rdx-64]
	movsd	QWORD PTR [rcx+rdx-64], xmm0
	sub	r10, 1
	jne	SHORT $LC38@normalize_
$LN42@normalize_:
	mov	rbx, QWORD PTR [rsp+16]
$LN23@normalize_:

; 1237 :   }
; 1238 : }

	add	rsp, 8
	ret	0
normalize_lcu_weights ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
id$ = 8
lcus_x$ = 16
lcus_y$ = 24
xdiv64$ = 32
ydiv64$ = 40
edge_lcu PROC

; 1243 :   if (xdiv64 && ydiv64) {

	movzx	r10d, BYTE PTR ydiv64$[rsp]
	mov	r11d, edx
	test	r9b, r9b
	je	SHORT $LN2@edge_lcu
	test	r10b, r10b
	jne	SHORT $LN3@edge_lcu
$LN2@edge_lcu:

; 1244 :     return false;
; 1245 :   }
; 1246 :   int last_row_first_id = (lcus_y - 1) * lcus_x;
; 1247 :   if ((id % lcus_x == lcus_x - 1 && !xdiv64) || (id >= last_row_first_id && !ydiv64)) {

	mov	eax, ecx
	dec	r8d
	cdq
	imul	r8d, r11d
	idiv	r11d
	lea	eax, DWORD PTR [r11-1]
	cmp	edx, eax
	jne	SHORT $LN6@edge_lcu
	test	r9b, r9b
	je	SHORT $LN5@edge_lcu
$LN6@edge_lcu:
	cmp	ecx, r8d
	jl	SHORT $LN3@edge_lcu
	test	r10b, r10b
	jne	SHORT $LN3@edge_lcu
$LN5@edge_lcu:

; 1248 :     return true;

	mov	al, 1

; 1252 :   }
; 1253 : }

	ret	0
$LN3@edge_lcu:

; 1249 :   }
; 1250 :   else {
; 1251 :     return false;

	xor	al, al

; 1252 :   }
; 1253 : }

	ret	0
edge_lcu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
tv4243 = 48
$T1 = 48
x$1$ = 52
y_lim$1$ = 56
y$1$ = 60
$T2 = 64
$T3 = 64
tv4242 = 68
tv4244 = 72
pxl_y$1$ = 76
tv4246 = 80
cfg$1$ = 88
chromau_tmp$4 = 96
chromav_tmp$5 = 1120
tmp$6 = 2144
state$ = 6368
frame$ = 6376
x_lim$1$ = 6384
id$1$ = 6392
encoder_state_init_new_frame PROC

; 1255 : static void encoder_state_init_new_frame(encoder_state_t * const state, kvz_picture* frame) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	eax, 6352				; 000018d0H
	call	__chkstk
	sub	rsp, rax

; 1256 :   assert(state->type == ENCODER_STATE_TYPE_MAIN);

	cmp	DWORD PTR [rcx+8], 77			; 0000004dH
	mov	rdi, rcx
	mov	QWORD PTR [rsp+6344], rbx
	mov	QWORD PTR [rsp+6328], rsi
	mov	QWORD PTR [rsp+6304], r14
	mov	r14, rdx
	je	SHORT $LN65@encoder_st
	mov	r8d, 1256				; 000004e8H
	lea	rdx, OFFSET FLAT:$SG4294952894
	lea	rcx, OFFSET FLAT:$SG4294952893
	call	QWORD PTR __imp__wassert
$LN65@encoder_st:

; 1184 :   assert(!state->tile->frame->source);

	mov	rax, QWORD PTR [rdi+48]

; 1257 : 
; 1258 :   const kvz_config * const cfg = &state->encoder_control->cfg;

	mov	rsi, QWORD PTR [rdi]
	mov	QWORD PTR cfg$1$[rsp], rsi

; 1184 :   assert(!state->tile->frame->source);

	mov	rdx, QWORD PTR [rax]
	cmp	QWORD PTR [rdx], 0
	je	SHORT $LN108@encoder_st
	mov	r8d, 1184				; 000004a0H
	lea	rdx, OFFSET FLAT:$SG4294952898
	lea	rcx, OFFSET FLAT:$SG4294952897
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rax]
$LN108@encoder_st:

; 1185 :   assert(!state->tile->frame->rec);

	cmp	QWORD PTR [rdx+8], 0
	je	SHORT $LN109@encoder_st
	mov	r8d, 1185				; 000004a1H
	lea	rdx, OFFSET FLAT:$SG4294952896
	lea	rcx, OFFSET FLAT:$SG4294952895
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rax]
$LN109@encoder_st:

; 1186 : 
; 1187 :   state->tile->frame->source = frame;

	mov	QWORD PTR [rdx], r14

; 1188 :   if (state->encoder_control->cfg.lossless) {

	mov	rax, QWORD PTR [rdi]
	cmp	DWORD PTR [rax+2392], 0
	je	SHORT $LN105@encoder_st
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 147  :   int32_t new_refcount = KVZ_ATOMIC_INC(&im->refcount);

	mov	eax, 1
	lock xadd DWORD PTR [r14+88], eax
	inc	eax

; 148  :   // The caller should have had another reference and we added one
; 149  :   // reference so refcount should be at least 2.
; 150  :   assert(new_refcount >= 2);

	cmp	eax, 2
	jge	SHORT $LN112@encoder_st
	mov	r8d, 150				; 00000096H
	lea	rdx, OFFSET FLAT:$SG4294955962
	lea	rcx, OFFSET FLAT:$SG4294955961
	call	QWORD PTR __imp__wassert
$LN112@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1190 :     state->tile->frame->rec = kvz_image_copy_ref(frame);

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], r14

; 1191 :   } else {

	jmp	SHORT $LN106@encoder_st
$LN105@encoder_st:

; 1192 :     state->tile->frame->rec = kvz_image_alloc(state->encoder_control->chroma_format, frame->width, frame->height);

	mov	r8d, DWORD PTR [r14+68]
	mov	edx, DWORD PTR [r14+64]
	mov	ecx, DWORD PTR [rax+2596]
	call	kvz_image_alloc
	mov	rcx, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rdx+8], rax

; 1193 :     state->tile->frame->rec->dts = frame->dts;

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [r14+104]
	mov	rdx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+104], rax

; 1194 :     state->tile->frame->rec->pts = frame->pts;

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [r14+96]
	mov	rdx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx+96], rax
$LN106@encoder_st:

; 1195 :   }
; 1196 : 
; 1197 :   kvz_videoframe_set_poc(state->tile->frame, state->frame->poc);

	mov	rax, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rdi+40]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+56], eax

; 1259 : 
; 1260 :   encoder_set_source_picture(state, frame);
; 1261 : 
; 1262 :   assert(!state->tile->frame->cu_array);

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	cmp	QWORD PTR [rcx+32], 0
	je	SHORT $LN66@encoder_st
	mov	r8d, 1262				; 000004eeH
	lea	rdx, OFFSET FLAT:$SG4294952892
	lea	rcx, OFFSET FLAT:$SG4294952891
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
$LN66@encoder_st:

; 1263 :   state->tile->frame->cu_array = kvz_cu_array_alloc(

	mov	edx, DWORD PTR [rcx+20]
	mov	ecx, DWORD PTR [rcx+16]
	call	kvz_cu_array_alloc
	mov	rcx, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rcx]
	mov	QWORD PTR [rdx+32], rax

; 1264 :       state->tile->frame->width,
; 1265 :       state->tile->frame->height
; 1266 :   );
; 1267 : 
; 1268 :   // Variance adaptive quantization
; 1269 :   if (cfg->vaq) {

	mov	ecx, DWORD PTR [rsi+2468]
	test	ecx, ecx
	je	$LN3@encoder_st

; 1270 :     const bool has_chroma = state->encoder_control->chroma_format != KVZ_CSP_400;

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rsp+6336], rbp
	movaps	XMMWORD PTR [rsp+6256], xmm7
	movaps	XMMWORD PTR [rsp+6240], xmm8
	mov	ebp, DWORD PTR [rax+2596]

; 1271 :     double d = cfg->vaq * 0.1; // Empirically decided constant. Affects delta-QP strength
; 1272 :     
; 1273 :     // Calculate frame pixel variance
; 1274 :     uint32_t len = state->tile->frame->width * state->tile->frame->height;

	mov	rax, QWORD PTR [rdi+48]
	movd	xmm8, ecx
	cvtdq2pd xmm8, xmm8
	mov	DWORD PTR tv4244[rsp], ebp
	mov	rcx, QWORD PTR [rax]
	mov	edx, DWORD PTR [rcx+20]
	imul	edx, DWORD PTR [rcx+16]

; 1275 :     uint32_t c_len = len / 4;
; 1276 :     double frame_var = kvz_pixel_var(state->tile->frame->source->y, len);

	mov	rcx, QWORD PTR [rcx]
	mulsd	xmm8, QWORD PTR __real@3fb999999999999a
	mov	rcx, QWORD PTR [rcx+16]
	mov	ebx, edx
	shr	ebx, 2
	call	QWORD PTR kvz_pixel_var
	movaps	xmm7, xmm0

; 1277 :     if (has_chroma) {

	test	ebp, ebp
	je	SHORT $LN25@encoder_st

; 1278 :       frame_var += kvz_pixel_var(state->tile->frame->source->u, c_len);

	mov	rax, QWORD PTR [rdi+48]
	mov	edx, ebx
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+24]
	call	QWORD PTR kvz_pixel_var

; 1279 :       frame_var += kvz_pixel_var(state->tile->frame->source->v, c_len);

	mov	rax, QWORD PTR [rdi+48]
	mov	edx, ebx
	addsd	xmm7, xmm0
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+32]
	call	QWORD PTR kvz_pixel_var
	addsd	xmm7, xmm0
$LN25@encoder_st:

; 1280 :     }
; 1281 : 
; 1282 :     // Loop through LCUs
; 1283 :     // For each LCU calculate: D * (log(LCU pixel variance) - log(frame pixel variance))
; 1284 :     unsigned x_lim = state->tile->frame->width_in_lcu;

	mov	rax, QWORD PTR [rdi+48]

; 1285 :     unsigned y_lim = state->tile->frame->height_in_lcu;
; 1286 :     
; 1287 :     unsigned id = 0;

	xor	ebx, ebx
	mov	DWORD PTR id$1$[rsp], ebx
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+24]
	mov	r10d, DWORD PTR [rcx+28]
	xor	ecx, ecx
	mov	DWORD PTR x_lim$1$[rsp], r10d
	mov	DWORD PTR y_lim$1$[rsp], eax
	mov	DWORD PTR y$1$[rsp], ecx

; 1288 :     for (int y = 0; y < y_lim; ++y) {

	test	eax, eax
	je	$LN425@encoder_st
	mov	QWORD PTR [rsp+6320], r12
	mov	QWORD PTR [rsp+6312], r13
	mov	QWORD PTR [rsp+6296], r15
	movaps	XMMWORD PTR [rsp+6272], xmm6
	npad	7
$LL4@encoder_st:

; 1289 :       for (int x = 0; x < x_lim; ++x) {

	xor	esi, esi
	mov	DWORD PTR x$1$[rsp], esi
	test	r10d, r10d
	je	$LN2@encoder_st
	mov	ebp, ecx
	shl	ebp, 6
	mov	DWORD PTR pxl_y$1$[rsp], ebp
	lea	ecx, DWORD PTR [rbp+64]
	npad	5
$LL7@encoder_st:

; 1290 :         kvz_pixel tmp[LCU_LUMA_SIZE];
; 1291 :         int pxl_x = x * LCU_WIDTH;
; 1292 :         int pxl_y = y * LCU_WIDTH;
; 1293 :         int x_max = MIN(pxl_x + LCU_WIDTH, frame->width) - pxl_x;

	mov	r15d, DWORD PTR [r14+64]
	mov	r8d, esi

; 1294 :         int y_max = MIN(pxl_y + LCU_WIDTH, frame->height) - pxl_y;

	mov	r12d, DWORD PTR [r14+68]
	mov	r9d, ecx
	shl	r8d, 6

; 1295 :         
; 1296 :         bool xdiv64 = false;
; 1297 :         bool ydiv64 = false;
; 1298 :         if (frame->width % 64 == 0) xdiv64 = true;

	mov	r13d, r15d
	mov	DWORD PTR $T2[rsp], r12d
	lea	r11d, DWORD PTR [r8+64]
	cmp	r11d, r15d
	cmovge	r11d, r15d
	sub	r11d, r8d
	cmp	ecx, r12d
	cmovge	r9d, r12d
	sub	r9d, ebp
	and	r13d, -2147483585			; ffffffff8000003fH
	mov	DWORD PTR tv4243[rsp], r13d
	jge	SHORT $LN422@encoder_st
	dec	r13d
	or	r13d, -64				; ffffffffffffffc0H
	inc	r13d
	mov	DWORD PTR tv4243[rsp], r13d
$LN422@encoder_st:

; 1299 :         if (frame->height % 64 == 0) ydiv64 = true;

	and	r12d, -2147483585			; ffffffff8000003fH
	mov	DWORD PTR tv4242[rsp], r12d
	jge	SHORT $LN421@encoder_st
	dec	r12d
	or	r12d, -64				; ffffffffffffffc0H
	inc	r12d
	mov	DWORD PTR tv4242[rsp], r12d
$LN421@encoder_st:

; 1243 :   if (xdiv64 && ydiv64) {

	test	r13d, r13d
	jne	SHORT $LN407@encoder_st
	test	r12d, r12d
	je	$LN115@encoder_st
$LN407@encoder_st:

; 1244 :     return false;
; 1245 :   }
; 1246 :   int last_row_first_id = (lcus_y - 1) * lcus_x;

	lea	ecx, DWORD PTR [rax-1]

; 1247 :   if ((id % lcus_x == lcus_x - 1 && !xdiv64) || (id >= last_row_first_id && !ydiv64)) {

	mov	eax, ebx
	cdq
	imul	ecx, r10d
	idiv	r10d
	lea	eax, DWORD PTR [r10-1]
	cmp	edx, eax
	jne	SHORT $LN118@encoder_st
	test	r13d, r13d
	jne	SHORT $LN28@encoder_st
$LN118@encoder_st:
	cmp	ebx, ecx
	jl	$LN115@encoder_st
	test	r12d, r12d
	je	$LN115@encoder_st
$LN28@encoder_st:

; 1311 :               tmp[y * LCU_WIDTH + x] = state->tile->frame->source->y[src_y * state->tile->frame->source->stride + src_x];

	mov	r14, QWORD PTR [rdi+48]
	lea	r12d, DWORD PTR [r8+2]
	mov	r13d, DWORD PTR $T2[rsp]
	lea	rdi, QWORD PTR tmp$6[rsp+1]
	mov	r11d, ebp
	mov	QWORD PTR tv4246[rsp], 64		; 00000040H
	npad	10
$LL10@encoder_st:

; 1308 :             for (int x = 0; x < LCU_WIDTH; x++) {

	lea	ebx, DWORD PTR [r13-1]
	mov	r10d, r12d

; 1309 :               int src_y = CLIP(0, frame->height - 1, pxl_y + y);

	cmp	ebx, r11d
	lea	r8d, DWORD PTR [r15-1]
	mov	esi, ebx
	mov	ebp, 16
	cmovge	esi, r11d
	npad	7
$LL13@encoder_st:
	test	esi, esi
	jns	SHORT $LN75@encoder_st
	xor	r9d, r9d
	jmp	SHORT $LN73@encoder_st
$LN75@encoder_st:
	cmp	ebx, r11d
	mov	r9d, r11d
	cmovl	r9d, ebx
$LN73@encoder_st:

; 1310 :               int src_x = CLIP(0, frame->width - 1, pxl_x + x);

	lea	ecx, DWORD PTR [r10-2]
	mov	eax, r8d
	cmp	r8d, ecx
	cmovge	eax, ecx
	test	eax, eax
	jns	SHORT $LN81@encoder_st
	xor	ecx, ecx
	jmp	SHORT $LN79@encoder_st
$LN81@encoder_st:
	cmp	r8d, ecx
	cmovl	ecx, r8d
$LN79@encoder_st:

; 1311 :               tmp[y * LCU_WIDTH + x] = state->tile->frame->source->y[src_y * state->tile->frame->source->stride + src_x];

	mov	rax, QWORD PTR [r14]
	mov	rdx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rdx+72]
	imul	eax, r9d
	add	eax, ecx
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+16]
	movzx	ecx, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdi-1], cl
	test	esi, esi
	jns	SHORT $LN325@encoder_st

; 1309 :               int src_y = CLIP(0, frame->height - 1, pxl_y + y);

	xor	r9d, r9d
	jmp	SHORT $LN326@encoder_st
$LN325@encoder_st:
	cmp	ebx, r11d
	mov	r9d, r11d
	cmovl	r9d, ebx
$LN326@encoder_st:

; 1310 :               int src_x = CLIP(0, frame->width - 1, pxl_x + x);

	lea	ecx, DWORD PTR [r10-1]
	mov	eax, r15d
	cmp	r8d, ecx
	cmovge	eax, r10d
	cmp	eax, 1
	jns	SHORT $LN331@encoder_st
	xor	ecx, ecx
	jmp	SHORT $LN332@encoder_st
$LN331@encoder_st:
	cmp	r8d, ecx
	cmovl	ecx, r8d
$LN332@encoder_st:

; 1311 :               tmp[y * LCU_WIDTH + x] = state->tile->frame->source->y[src_y * state->tile->frame->source->stride + src_x];

	mov	rax, QWORD PTR [r14]
	mov	rdx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rdx+72]
	imul	eax, r9d
	add	eax, ecx
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+16]
	movzx	ecx, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdi], cl
	test	esi, esi
	jns	SHORT $LN338@encoder_st

; 1309 :               int src_y = CLIP(0, frame->height - 1, pxl_y + y);

	xor	r9d, r9d
	jmp	SHORT $LN339@encoder_st
$LN338@encoder_st:
	cmp	ebx, r11d
	mov	r9d, r11d
	cmovl	r9d, ebx
$LN339@encoder_st:

; 1310 :               int src_x = CLIP(0, frame->width - 1, pxl_x + x);

	cmp	r8d, r10d
	mov	eax, r8d
	cmovge	eax, r10d
	test	eax, eax
	jns	SHORT $LN344@encoder_st
	xor	ecx, ecx
	jmp	SHORT $LN345@encoder_st
$LN344@encoder_st:
	cmp	r8d, r10d
	mov	ecx, r10d
	cmovl	ecx, r8d
$LN345@encoder_st:

; 1311 :               tmp[y * LCU_WIDTH + x] = state->tile->frame->source->y[src_y * state->tile->frame->source->stride + src_x];

	mov	rax, QWORD PTR [r14]
	mov	rdx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rdx+72]
	imul	eax, r9d
	add	eax, ecx
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+16]
	movzx	ecx, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdi+1], cl
	test	esi, esi
	jns	SHORT $LN351@encoder_st

; 1309 :               int src_y = CLIP(0, frame->height - 1, pxl_y + y);

	xor	r9d, r9d
	jmp	SHORT $LN352@encoder_st
$LN351@encoder_st:
	cmp	ebx, r11d
	mov	r9d, r11d
	cmovl	r9d, ebx
$LN352@encoder_st:

; 1310 :               int src_x = CLIP(0, frame->width - 1, pxl_x + x);

	lea	ecx, DWORD PTR [r10+1]
	mov	eax, r8d
	cmp	r8d, ecx
	cmovge	eax, ecx
	test	eax, eax
	jns	SHORT $LN357@encoder_st
	xor	ecx, ecx
	jmp	SHORT $LN358@encoder_st
$LN357@encoder_st:
	cmp	r8d, ecx
	cmovl	ecx, r8d
$LN358@encoder_st:

; 1311 :               tmp[y * LCU_WIDTH + x] = state->tile->frame->source->y[src_y * state->tile->frame->source->stride + src_x];

	mov	rax, QWORD PTR [r14]
	add	r10d, 4
	mov	rdx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rdx+72]
	imul	eax, r9d
	add	eax, ecx
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+16]
	movzx	ecx, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdi+2], cl
	add	rdi, 4
	sub	rbp, 1
	jne	$LL13@encoder_st

; 1304 :             x_max, y_max, state->tile->frame->source->stride, LCU_WIDTH);
; 1305 :         } else {
; 1306 :           // Extend edge pixels for edge lcus
; 1307 :           for (int y = 0; y < LCU_WIDTH; y++) {

	inc	r11d
	sub	QWORD PTR tv4246[rsp], 1
	jne	$LL10@encoder_st
	mov	r12d, DWORD PTR tv4242[rsp]
	mov	r13d, DWORD PTR tv4243[rsp]
	mov	rdi, QWORD PTR state$[rsp]
	mov	ebx, DWORD PTR id$1$[rsp]
	mov	esi, DWORD PTR x$1$[rsp]
	jmp	SHORT $LN9@encoder_st
$LN115@encoder_st:

; 1300 : 
; 1301 :         // Luma variance
; 1302 :         if (!edge_lcu(id, x_lim, y_lim, xdiv64, ydiv64)) {
; 1303 :           kvz_pixels_blit(&state->tile->frame->source->y[pxl_x + pxl_y * state->tile->frame->source->stride], tmp,

	mov	rax, QWORD PTR [rdi+48]
	mov	DWORD PTR [rsp+40], 64			; 00000040H
	mov	rcx, QWORD PTR [rax]
	mov	rdx, QWORD PTR [rcx]
	mov	r10d, DWORD PTR [rdx+72]
	mov	eax, r10d
	imul	eax, ebp
	mov	DWORD PTR [rsp+32], r10d
	add	eax, r8d
	mov	r8d, r11d
	movsxd	rcx, eax
	add	rcx, QWORD PTR [rdx+16]
	lea	rdx, QWORD PTR tmp$6[rsp]
	call	kvz_pixels_blit
$LN9@encoder_st:

; 1312 :             }
; 1313 :           }
; 1314 :         }
; 1315 :         
; 1316 :         double lcu_var = kvz_pixel_var(tmp, LCU_LUMA_SIZE);

	mov	edx, 4096				; 00001000H
	lea	rcx, QWORD PTR tmp$6[rsp]
	call	QWORD PTR kvz_pixel_var

; 1317 : 
; 1318 :         if (has_chroma) {

	cmp	DWORD PTR tv4244[rsp], 0
	movaps	xmm6, xmm0
	je	$LN30@encoder_st

; 1319 :           // Add chroma variance if not monochrome
; 1320 :           int32_t c_stride = state->tile->frame->source->stride >> 1;

	mov	r14, QWORD PTR [rdi+48]

; 1321 :           kvz_pixel chromau_tmp[LCU_CHROMA_SIZE];
; 1322 :           kvz_pixel chromav_tmp[LCU_CHROMA_SIZE];
; 1323 :           int lcu_chroma_width = LCU_WIDTH >> 1;
; 1324 :           int c_pxl_x = x * lcu_chroma_width;

	mov	r8d, esi

; 1325 :           int c_pxl_y = y * lcu_chroma_width;
; 1326 :           int c_x_max = MIN(c_pxl_x + lcu_chroma_width, frame->width >> 1) - c_pxl_x;

	mov	rcx, QWORD PTR frame$[rsp]
	mov	r10d, DWORD PTR y$1$[rsp]
	shl	r8d, 5
	mov	rax, QWORD PTR [r14]
	mov	r15d, DWORD PTR [rcx+64]

; 1327 :           int c_y_max = MIN(c_pxl_y + lcu_chroma_width, frame->height >> 1) - c_pxl_y;

	mov	r11d, DWORD PTR [rcx+68]
	shl	r10d, 5
	lea	edi, DWORD PTR [r8+32]
	mov	r9, QWORD PTR [rax]
	mov	eax, r15d
	sar	eax, 1
	mov	DWORD PTR $T1[rsp], r15d
	lea	esi, DWORD PTR [r10+32]
	mov	DWORD PTR $T3[rsp], r11d
	mov	ebp, DWORD PTR [r9+72]
	sar	ebp, 1
	cmp	edi, eax
	cmovge	edi, eax
	mov	eax, r11d
	sar	eax, 1
	sub	edi, r8d
	cmp	esi, eax
	cmovge	esi, eax
	sub	esi, r10d

; 1243 :   if (xdiv64 && ydiv64) {

	test	r13d, r13d
	jne	SHORT $LN419@encoder_st
	test	r12d, r12d
	je	$LN122@encoder_st
$LN419@encoder_st:

; 1244 :     return false;
; 1245 :   }
; 1246 :   int last_row_first_id = (lcus_y - 1) * lcus_x;

	mov	ecx, DWORD PTR y_lim$1$[rsp]

; 1247 :   if ((id % lcus_x == lcus_x - 1 && !xdiv64) || (id >= last_row_first_id && !ydiv64)) {

	mov	eax, ebx
	cdq
	dec	ecx
	idiv	DWORD PTR x_lim$1$[rsp]
	imul	ecx, DWORD PTR x_lim$1$[rsp]
	mov	eax, DWORD PTR x_lim$1$[rsp]
	dec	eax
	cmp	edx, eax
	jne	SHORT $LN125@encoder_st
	test	r13d, r13d
	jne	SHORT $LN31@encoder_st
$LN125@encoder_st:
	cmp	ebx, ecx
	jl	$LN122@encoder_st
	test	r12d, r12d
	je	$LN122@encoder_st
$LN31@encoder_st:

; 1332 :           }
; 1333 :           else {
; 1334 :             for (int y = 0; y < lcu_chroma_width; y++) {

	xor	ebx, ebx
	lea	r13d, DWORD PTR [r8+2]
	lea	r12d, QWORD PTR [rbx+32]
	npad	4
$LL16@encoder_st:

; 1335 :               for (int x = 0; x < lcu_chroma_width; x++) {
; 1336 :                 int src_y = CLIP(0, (frame->height >> 1) - 1, c_pxl_y + y);

	sar	r11d, 1
	mov	esi, r15d
	dec	r11d
	sar	esi, 1
	cmp	r11d, r10d
	mov	edi, r11d
	mov	r9d, r13d
	mov	r15d, 8
	cmovge	edi, r10d
	lea	r8d, DWORD PTR [rsi-1]
$LL19@encoder_st:
	test	edi, edi
	jns	SHORT $LN91@encoder_st
	xor	edx, edx
	jmp	SHORT $LN89@encoder_st
$LN91@encoder_st:
	cmp	r11d, r10d
	mov	edx, r10d
	cmovl	edx, r11d
$LN89@encoder_st:

; 1337 :                 int src_x = CLIP(0, (frame->width >> 1) - 1, c_pxl_x + x);

	lea	ecx, DWORD PTR [r9-2]
	mov	eax, r8d
	cmp	r8d, ecx
	cmovge	eax, ecx
	test	eax, eax
	jns	SHORT $LN97@encoder_st
	xor	ecx, ecx
	jmp	SHORT $LN95@encoder_st
$LN97@encoder_st:
	cmp	r8d, ecx
	cmovl	ecx, r8d
$LN95@encoder_st:

; 1338 :                 chromau_tmp[y * lcu_chroma_width + x] = state->tile->frame->source->u[src_y * c_stride + src_x];

	mov	rax, QWORD PTR [r14]
	imul	edx, ebp
	add	edx, ecx
	mov	rcx, QWORD PTR [rax]
	movsxd	rdx, edx
	mov	rax, QWORD PTR [rcx+24]
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR chromau_tmp$4[rsp+rbx], cl

; 1339 :                 chromav_tmp[y * lcu_chroma_width + x] = state->tile->frame->source->v[src_y * c_stride + src_x];

	mov	rax, QWORD PTR [r14]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+32]
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR chromav_tmp$5[rsp+rbx], cl
	test	edi, edi
	jns	SHORT $LN364@encoder_st

; 1335 :               for (int x = 0; x < lcu_chroma_width; x++) {
; 1336 :                 int src_y = CLIP(0, (frame->height >> 1) - 1, c_pxl_y + y);

	xor	edx, edx
	jmp	SHORT $LN365@encoder_st
$LN364@encoder_st:
	cmp	r11d, r10d
	mov	edx, r10d
	cmovl	edx, r11d
$LN365@encoder_st:

; 1337 :                 int src_x = CLIP(0, (frame->width >> 1) - 1, c_pxl_x + x);

	lea	ecx, DWORD PTR [r9-1]
	mov	eax, esi
	cmp	r8d, ecx
	cmovge	eax, r9d
	cmp	eax, 1
	jns	SHORT $LN370@encoder_st
	xor	ecx, ecx
	jmp	SHORT $LN371@encoder_st
$LN370@encoder_st:
	cmp	r8d, ecx
	cmovl	ecx, r8d
$LN371@encoder_st:

; 1338 :                 chromau_tmp[y * lcu_chroma_width + x] = state->tile->frame->source->u[src_y * c_stride + src_x];

	mov	rax, QWORD PTR [r14]
	imul	edx, ebp
	add	edx, ecx
	mov	rcx, QWORD PTR [rax]
	movsxd	rdx, edx
	mov	rax, QWORD PTR [rcx+24]
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR chromau_tmp$4[rsp+rbx+1], cl

; 1339 :                 chromav_tmp[y * lcu_chroma_width + x] = state->tile->frame->source->v[src_y * c_stride + src_x];

	mov	rax, QWORD PTR [r14]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+32]
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR chromav_tmp$5[rsp+rbx+1], cl
	test	edi, edi
	jns	SHORT $LN377@encoder_st

; 1335 :               for (int x = 0; x < lcu_chroma_width; x++) {
; 1336 :                 int src_y = CLIP(0, (frame->height >> 1) - 1, c_pxl_y + y);

	xor	ecx, ecx
	jmp	SHORT $LN378@encoder_st
$LN377@encoder_st:
	cmp	r11d, r10d
	mov	ecx, r10d
	cmovl	ecx, r11d
$LN378@encoder_st:

; 1337 :                 int src_x = CLIP(0, (frame->width >> 1) - 1, c_pxl_x + x);

	cmp	r8d, r9d
	mov	eax, r8d
	cmovge	eax, r9d
	test	eax, eax
	jns	SHORT $LN383@encoder_st
	xor	eax, eax
	jmp	SHORT $LN384@encoder_st
$LN383@encoder_st:
	cmp	r8d, r9d
	mov	eax, r9d
	cmovl	eax, r8d
$LN384@encoder_st:

; 1338 :                 chromau_tmp[y * lcu_chroma_width + x] = state->tile->frame->source->u[src_y * c_stride + src_x];

	imul	ecx, ebp
	add	ecx, eax
	mov	rax, QWORD PTR [r14]
	movsxd	rdx, ecx
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+24]
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR chromau_tmp$4[rsp+rbx+2], cl

; 1339 :                 chromav_tmp[y * lcu_chroma_width + x] = state->tile->frame->source->v[src_y * c_stride + src_x];

	mov	rax, QWORD PTR [r14]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+32]
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR chromav_tmp$5[rsp+rbx+2], cl
	test	edi, edi
	jns	SHORT $LN390@encoder_st

; 1335 :               for (int x = 0; x < lcu_chroma_width; x++) {
; 1336 :                 int src_y = CLIP(0, (frame->height >> 1) - 1, c_pxl_y + y);

	xor	edx, edx
	jmp	SHORT $LN391@encoder_st
$LN390@encoder_st:
	cmp	r11d, r10d
	mov	edx, r10d
	cmovl	edx, r11d
$LN391@encoder_st:

; 1337 :                 int src_x = CLIP(0, (frame->width >> 1) - 1, c_pxl_x + x);

	lea	ecx, DWORD PTR [r9+1]
	mov	eax, r8d
	cmp	r8d, ecx
	cmovge	eax, ecx
	test	eax, eax
	jns	SHORT $LN396@encoder_st
	xor	ecx, ecx
	jmp	SHORT $LN397@encoder_st
$LN396@encoder_st:
	cmp	r8d, ecx
	cmovl	ecx, r8d
$LN397@encoder_st:

; 1338 :                 chromau_tmp[y * lcu_chroma_width + x] = state->tile->frame->source->u[src_y * c_stride + src_x];

	mov	rax, QWORD PTR [r14]
	add	r9d, 4
	imul	edx, ebp
	add	edx, ecx
	mov	rcx, QWORD PTR [rax]
	movsxd	rdx, edx
	mov	rax, QWORD PTR [rcx+24]
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR chromau_tmp$4[rsp+rbx+3], cl

; 1339 :                 chromav_tmp[y * lcu_chroma_width + x] = state->tile->frame->source->v[src_y * c_stride + src_x];

	mov	rax, QWORD PTR [r14]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+32]
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	BYTE PTR chromav_tmp$5[rsp+rbx+3], cl
	add	rbx, 4
	sub	r15, 1
	jne	$LL19@encoder_st

; 1332 :           }
; 1333 :           else {
; 1334 :             for (int y = 0; y < lcu_chroma_width; y++) {

	mov	r11d, DWORD PTR $T3[rsp]
	inc	r10d
	mov	r15d, DWORD PTR $T1[rsp]
	sub	r12, 1
	jne	$LL16@encoder_st
	jmp	SHORT $LN15@encoder_st
$LN122@encoder_st:

; 1328 : 
; 1329 :           if (!edge_lcu(id, x_lim, y_lim, xdiv64, ydiv64)) {
; 1330 :             kvz_pixels_blit(&state->tile->frame->source->u[c_pxl_x + c_pxl_y * c_stride], chromau_tmp, c_x_max, c_y_max, c_stride, lcu_chroma_width);

	mov	rcx, QWORD PTR [r9+24]
	lea	rdx, QWORD PTR chromau_tmp$4[rsp]
	imul	r10d, ebp
	mov	r9d, esi
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	DWORD PTR [rsp+32], ebp
	add	r10d, r8d
	mov	r8d, edi
	movsxd	rbx, r10d
	add	rcx, rbx
	call	kvz_pixels_blit

; 1331 :             kvz_pixels_blit(&state->tile->frame->source->v[c_pxl_x + c_pxl_y * c_stride], chromav_tmp, c_x_max, c_y_max, c_stride, lcu_chroma_width);

	mov	rcx, QWORD PTR state$[rsp]
	lea	rdx, QWORD PTR chromav_tmp$5[rsp]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	r9d, esi
	mov	r8d, edi
	mov	DWORD PTR [rsp+32], ebp
	mov	rax, QWORD PTR [rcx+48]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax+32]
	add	rcx, rbx
	call	kvz_pixels_blit
$LN15@encoder_st:

; 1340 :               }
; 1341 :             }
; 1342 :           }
; 1343 :           lcu_var += kvz_pixel_var(chromau_tmp, LCU_CHROMA_SIZE);

	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR chromau_tmp$4[rsp]
	call	QWORD PTR kvz_pixel_var

; 1344 :           lcu_var += kvz_pixel_var(chromav_tmp, LCU_CHROMA_SIZE);

	mov	edx, 1024				; 00000400H
	lea	rcx, QWORD PTR chromav_tmp$5[rsp]
	addsd	xmm6, xmm0
	call	QWORD PTR kvz_pixel_var
	mov	rdi, QWORD PTR state$[rsp]
	addsd	xmm6, xmm0
	mov	ebx, DWORD PTR id$1$[rsp]
	mov	esi, DWORD PTR x$1$[rsp]
$LN30@encoder_st:

; 1345 :         }
; 1346 :                 
; 1347 :         state->frame->aq_offsets[id] = d * (log(lcu_var) - log(frame_var));

	divsd	xmm6, xmm7
	movaps	xmm0, xmm6
	call	log
	mov	rax, QWORD PTR [rdi+40]
	inc	esi
	mov	ebp, DWORD PTR pxl_y$1$[rsp]
	mov	r10d, DWORD PTR x_lim$1$[rsp]
	mov	r14, QWORD PTR frame$[rsp]
	mov	rcx, QWORD PTR [rax+192]
	mov	eax, DWORD PTR y_lim$1$[rsp]
	mov	edx, ebx

; 1348 :         id++; 

	inc	ebx
	mulsd	xmm0, xmm8
	mov	DWORD PTR id$1$[rsp], ebx
	mov	DWORD PTR x$1$[rsp], esi
	movsd	QWORD PTR [rcx+rdx*8], xmm0
	lea	ecx, DWORD PTR [rbp+64]
	cmp	esi, r10d
	jb	$LL7@encoder_st
	mov	ecx, DWORD PTR y$1$[rsp]
$LN2@encoder_st:

; 1288 :     for (int y = 0; y < y_lim; ++y) {

	inc	ecx
	mov	DWORD PTR y$1$[rsp], ecx
	cmp	ecx, eax
	jb	$LL4@encoder_st
	mov	rsi, QWORD PTR cfg$1$[rsp]
	movaps	xmm6, XMMWORD PTR [rsp+6272]
	mov	r15, QWORD PTR [rsp+6296]
	mov	r13, QWORD PTR [rsp+6312]
	mov	r12, QWORD PTR [rsp+6320]
$LN425@encoder_st:
	movaps	xmm7, XMMWORD PTR [rsp+6256]
	mov	rbp, QWORD PTR [rsp+6336]
	movaps	xmm8, XMMWORD PTR [rsp+6240]
$LN3@encoder_st:

; 1349 :       }
; 1350 :     }
; 1351 :   }
; 1352 :   // Variance adaptive quantization - END
; 1353 : 
; 1354 :   // Use this flag to handle closed gop irap picture selection.
; 1355 :   // If set to true, irap is already set and we avoid
; 1356 :   // setting it based on the intra period
; 1357 :   bool is_closed_normal_gop = false;
; 1358 : 
; 1359 :   encoder_state_t *previous = state->previous_encoder_state;
; 1360 :   int owf = MIN(state->encoder_control->cfg.owf, state->frame->num);

	mov	r11, QWORD PTR [rdi+40]
	xor	bl, bl
	mov	r9, QWORD PTR [rdi]
	mov	r8, QWORD PTR [rdi+32]

; 1361 : 
; 1362 :   const int layer = state->encoder_control->cfg.gop[state->frame->gop_offset].layer;
; 1363 : 
; 1364 :   while (--owf > 0 && layer != state->encoder_control->cfg.gop[previous->frame->gop_offset].layer) {

	mov	r14, QWORD PTR [rsp+6304]
	movsx	rax, BYTE PTR [r11+16]
	mov	edx, DWORD PTR [r9+172]
	shl	rax, 6
	cmp	edx, DWORD PTR [r11+8]
	cmovge	edx, DWORD PTR [r11+8]
	movzx	r10d, BYTE PTR [rax+r9+314]
	dec	edx
	test	edx, edx
	jle	SHORT $LN426@encoder_st
	npad	8
$LL20@encoder_st:
	mov	rax, QWORD PTR [r8+40]
	movsx	rcx, BYTE PTR [rax+16]
	shl	rcx, 6
	cmp	r10b, BYTE PTR [rcx+r9+314]
	je	SHORT $LN33@encoder_st

; 1365 :     previous = previous->previous_encoder_state;

	mov	r8, QWORD PTR [r8+32]
	dec	edx
	test	edx, edx
	jg	SHORT $LL20@encoder_st
$LN426@encoder_st:

; 1366 :   }
; 1367 : 
; 1368 :   if (owf == 0) previous = state;

	cmove	r8, rdi
$LN33@encoder_st:

; 1369 :   state->frame->previous_layer_state = previous;

	mov	QWORD PTR [r11+184], r8

; 1370 :   // Set POC.
; 1371 :   if (state->frame->num == 0) {

	mov	r9, QWORD PTR [rdi+40]
	mov	eax, DWORD PTR [r9+8]
	test	eax, eax
	jne	SHORT $LN34@encoder_st

; 1372 :     state->frame->poc = 0;

	mov	DWORD PTR [r9+12], eax
	jmp	$LN43@encoder_st
$LN34@encoder_st:

; 1373 :   } else if (cfg->gop_len && !cfg->gop_lowdelay) {

	movsx	r10d, BYTE PTR [rsi+300]
	test	r10b, r10b
	je	$LN36@encoder_st
	cmp	BYTE PTR [rsi+301], bl
	jne	$LN36@encoder_st

; 1374 : 
; 1375 :     int32_t framenum = state->frame->num - 1;
; 1376 :     // Handle closed GOP
; 1377 :     // Closed GOP structure has an extra IDR between the GOPs
; 1378 :     if (cfg->intra_period > 0 && !cfg->open_gop) {

	mov	r8d, DWORD PTR [rsi+4]
	lea	r11d, DWORD PTR [rax-1]
	test	r8d, r8d
	jle	SHORT $LN420@encoder_st
	cmp	BYTE PTR [rsi+2464], bl
	jne	SHORT $LN420@encoder_st

; 1379 :       is_closed_normal_gop = true;
; 1380 :       if (framenum % (cfg->intra_period + 1) == cfg->intra_period) {

	mov	eax, r11d
	lea	ecx, DWORD PTR [r8+1]
	cdq
	mov	bl, 1
	idiv	ecx
	mov	r11d, edx
	cmp	edx, r8d
	jne	SHORT $LN40@encoder_st

; 1381 :         // Insert IDR before each new GOP after intra period in closed GOP configuration
; 1382 :         state->frame->poc = 0;

	mov	DWORD PTR [r9+12], 0

; 1383 :       } else {

	jmp	SHORT $LN39@encoder_st
$LN40@encoder_st:

; 1384 :         // Calculate frame number again and use that for the POC
; 1385 :         framenum = framenum % (cfg->intra_period + 1);
; 1386 :         int32_t poc_offset = cfg->gop[state->frame->gop_offset].poc_offset;

	movsx	rax, BYTE PTR [r9+16]
	shl	rax, 6
	movsx	r8d, BYTE PTR [rax+rsi+313]

; 1387 :         state->frame->poc = framenum - framenum % cfg->gop_len + poc_offset;

	mov	eax, r11d
	cdq
	idiv	r10d
	sub	r8d, edx
	add	r8d, r11d
	mov	DWORD PTR [r9+12], r8d

; 1388 :         // This should not be an irap picture in closed GOP
; 1389 :         state->frame->is_irap = false;

	mov	rax, QWORD PTR [rdi+40]
	mov	BYTE PTR [rax+83], 0

; 1390 :       }
; 1391 :     } else { // Open GOP

	jmp	SHORT $LN39@encoder_st
$LN420@encoder_st:

; 1392 :       // Calculate POC according to the global frame counter and GOP structure
; 1393 :       int32_t poc_offset = cfg->gop[state->frame->gop_offset].poc_offset;

	movsx	rax, BYTE PTR [r9+16]
	shl	rax, 6
	movsx	r8d, BYTE PTR [rax+rsi+313]

; 1394 :       state->frame->poc = framenum - framenum % cfg->gop_len + poc_offset;

	mov	eax, r11d
	cdq
	idiv	r10d
	sub	r8d, edx
	add	r8d, r11d
	mov	DWORD PTR [r9+12], r8d
$LN39@encoder_st:

; 1395 :     }
; 1396 :     
; 1397 :     kvz_videoframe_set_poc(state->tile->frame, state->frame->poc);

	mov	rax, QWORD PTR [rdi+48]
	mov	rdx, QWORD PTR [rdi+40]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rdx+12]
	mov	DWORD PTR [rcx+56], eax
	jmp	SHORT $LN43@encoder_st
$LN36@encoder_st:

; 1398 :   } else if (cfg->intra_period > 0) {

	mov	ecx, DWORD PTR [rsi+4]
	test	ecx, ecx
	jle	SHORT $LN42@encoder_st

; 1399 :     state->frame->poc = state->frame->num % cfg->intra_period;

	cdq
	idiv	ecx
	mov	DWORD PTR [r9+12], edx

; 1400 :   } else {

	jmp	SHORT $LN43@encoder_st
$LN42@encoder_st:

; 1401 :     state->frame->poc = state->frame->num;

	mov	DWORD PTR [r9+12], eax
$LN43@encoder_st:

; 1402 :   }
; 1403 : 
; 1404 :   // Check whether the frame is a keyframe or not.
; 1405 :   if (state->frame->num == 0 || state->frame->poc == 0) {

	mov	rcx, QWORD PTR [rdi+40]
	cmp	DWORD PTR [rcx+8], 0
	je	SHORT $LN46@encoder_st
	mov	eax, DWORD PTR [rcx+12]
	test	eax, eax
	je	SHORT $LN46@encoder_st

; 1407 :   } else if(!is_closed_normal_gop) { // In closed-GOP IDR frames are poc==0 so skip this check

	test	bl, bl
	jne	SHORT $LN47@encoder_st

; 1408 :     state->frame->is_irap =

	mov	r8d, DWORD PTR [rsi+4]
	test	r8d, r8d
	jle	SHORT $LN101@encoder_st
	cdq
	idiv	r8d
	test	edx, edx
	jne	SHORT $LN101@encoder_st
	mov	al, 1
	mov	BYTE PTR [rcx+83], al
	jmp	SHORT $LN47@encoder_st
$LN101@encoder_st:
	xor	al, al
	mov	BYTE PTR [rcx+83], al
	jmp	SHORT $LN47@encoder_st
$LN46@encoder_st:

; 1406 :     state->frame->is_irap = true;

	mov	BYTE PTR [rcx+83], 1
$LN47@encoder_st:

; 1409 :       cfg->intra_period > 0 &&
; 1410 :       (state->frame->poc % cfg->intra_period) == 0;
; 1411 :   }
; 1412 :   if (state->frame->is_irap) {

	mov	rcx, QWORD PTR [rdi+40]
	mov	rbx, QWORD PTR [rsp+6344]
	cmp	BYTE PTR [rcx+83], 0
	je	SHORT $LN49@encoder_st

; 1413 :     state->frame->irap_poc = state->frame->poc;

	mov	eax, DWORD PTR [rcx+12]
	mov	DWORD PTR [rcx+20], eax
	mov	rcx, QWORD PTR [rdi+40]

; 1414 :   }
; 1415 : 
; 1416 :   // Set pictype.
; 1417 :   if (state->frame->is_irap) {

	cmp	BYTE PTR [rcx+83], 0
	je	SHORT $LN49@encoder_st

; 1418 :     if (state->frame->num == 0 ||
; 1419 :         cfg->intra_period == 1 ||
; 1420 :         cfg->gop_len == 0 ||
; 1421 :         cfg->gop_lowdelay ||

	cmp	DWORD PTR [rcx+8], 0
	je	SHORT $LN53@encoder_st
	cmp	DWORD PTR [rsi+4], 1
	je	SHORT $LN53@encoder_st
	cmp	BYTE PTR [rsi+300], 0
	je	SHORT $LN53@encoder_st
	cmp	BYTE PTR [rsi+301], 0
	jne	SHORT $LN53@encoder_st
	cmp	BYTE PTR [rsi+2464], 0

; 1425 :     } else {
; 1426 :       state->frame->pictype = KVZ_NAL_CRA_NUT;

	mov	al, 21
	jne	SHORT $LN52@encoder_st
$LN53@encoder_st:

; 1422 :         !cfg->open_gop) // Closed GOP uses IDR pictures
; 1423 :     {
; 1424 :       state->frame->pictype = KVZ_NAL_IDR_W_RADL;

	mov	al, 19
$LN52@encoder_st:

; 1427 :     }

	lea	rdx, QWORD PTR [rcx+84]
	jmp	SHORT $LN55@encoder_st
$LN49@encoder_st:

; 1428 :   } else if (state->frame->poc < state->frame->irap_poc) {

	mov	eax, DWORD PTR [rcx+20]
	lea	rdx, QWORD PTR [rcx+84]
	cmp	DWORD PTR [rcx+12], eax

; 1429 :     state->frame->pictype = KVZ_NAL_RASL_R;

	mov	al, 9
	jl	SHORT $LN55@encoder_st

; 1430 :   } else {
; 1431 :     state->frame->pictype = KVZ_NAL_TRAIL_R;

	mov	al, 1
$LN55@encoder_st:

; 1432 :   }
; 1433 : 
; 1434 :   encoder_state_remove_refs(state);

	mov	rcx, rdi
	mov	BYTE PTR [rdx], al
	call	encoder_state_remove_refs

; 1435 :   kvz_encoder_create_ref_lists(state);

	mov	rcx, rdi
	call	kvz_encoder_create_ref_lists

; 1436 : 
; 1437 :   // Set slicetype.
; 1438 :   if (state->frame->is_irap) {

	mov	rcx, QWORD PTR [rdi+40]
	cmp	BYTE PTR [rcx+83], 0
	je	SHORT $LN56@encoder_st

; 1439 :     state->frame->slicetype = KVZ_SLICE_I;

	mov	DWORD PTR [rcx+88], 2
	jmp	SHORT $LN58@encoder_st
$LN56@encoder_st:

; 1440 :   } else if (state->frame->ref_LX_size[1] > 0) {

	xor	eax, eax
	cmp	BYTE PTR [rcx+82], al
	setbe	al
	mov	DWORD PTR [rcx+88], eax
$LN58@encoder_st:

; 1441 :     state->frame->slicetype = KVZ_SLICE_B;
; 1442 :   } else {
; 1443 :     state->frame->slicetype = KVZ_SLICE_P;
; 1444 :   }
; 1445 : 
; 1446 :   if (cfg->target_bitrate > 0 && state->frame->num > cfg->owf) {

	cmp	DWORD PTR [rsi+2352], 0
	jle	SHORT $LN60@encoder_st
	mov	rcx, QWORD PTR [rdi+40]
	mov	eax, DWORD PTR [rsi+172]
	cmp	DWORD PTR [rcx+8], eax
	jle	SHORT $LN60@encoder_st

; 1447 :     normalize_lcu_weights(state);

	mov	rcx, rdi
	call	normalize_lcu_weights
$LN60@encoder_st:

; 1448 :   }
; 1449 :   state->frame->cur_frame_bits_coded = 0;

	mov	rax, QWORD PTR [rdi+40]

; 1450 : 
; 1451 :   switch (state->encoder_control->cfg.rc_algorithm) {

	mov	rsi, QWORD PTR [rsp+6328]
	mov	QWORD PTR [rax+112], 0
	mov	rax, QWORD PTR [rdi]
	movzx	ecx, BYTE PTR [rax+2484]
	test	cl, cl
	js	SHORT $LN63@encoder_st
	cmp	cl, 1
	jle	SHORT $LN61@encoder_st
	cmp	cl, 2
	jne	SHORT $LN63@encoder_st

; 1455 :       break;
; 1456 :     case KVZ_OBA:
; 1457 :       kvz_estimate_pic_lambda(state);

	mov	rcx, rdi
	call	kvz_estimate_pic_lambda

; 1461 :   }
; 1462 :  
; 1463 :   encoder_state_init_children(state);

	mov	rcx, rdi

; 1464 : }

	add	rsp, 6352				; 000018d0H
	pop	rdi

; 1461 :   }
; 1462 :  
; 1463 :   encoder_state_init_children(state);

	jmp	encoder_state_init_children
$LN61@encoder_st:

; 1452 :     case KVZ_NO_RC:
; 1453 :     case KVZ_LAMBDA:
; 1454 :       kvz_set_picture_lambda_and_qp(state);

	mov	rcx, rdi
	call	kvz_set_picture_lambda_and_qp

; 1461 :   }
; 1462 :  
; 1463 :   encoder_state_init_children(state);

	mov	rcx, rdi

; 1464 : }

	add	rsp, 6352				; 000018d0H
	pop	rdi

; 1461 :   }
; 1462 :  
; 1463 :   encoder_state_init_children(state);

	jmp	encoder_state_init_children
$LN63@encoder_st:

; 1458 :       break;
; 1459 :     default:
; 1460 :       assert(0);

	mov	r8d, 1460				; 000005b4H
	lea	rdx, OFFSET FLAT:$SG4294952890
	lea	rcx, OFFSET FLAT:$SG4294952889
	call	QWORD PTR __imp__wassert

; 1461 :   }
; 1462 :  
; 1463 :   encoder_state_init_children(state);

	mov	rcx, rdi

; 1464 : }

	add	rsp, 6352				; 000018d0H
	pop	rdi

; 1461 :   }
; 1462 :  
; 1463 :   encoder_state_init_children(state);

	jmp	encoder_state_init_children
encoder_state_init_new_frame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 48
job$ = 56
_encode_one_frame_add_bitstream_deps PROC

; 1466 : static void _encode_one_frame_add_bitstream_deps(const encoder_state_t * const state, threadqueue_job_t * const job) {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 1467 :   int i;
; 1468 :   for (i = 0; state->children[i].encoder_control; ++i) {

	xor	ebx, ebx
	mov	rdx, QWORD PTR [rcx+16]
	mov	rbp, rcx
	cmp	QWORD PTR [rdx], rbx
	je	SHORT $LN3@encode_one
	mov	QWORD PTR [rsp+48], rsi
	mov	esi, ebx
	npad	9
$LL4@encode_one:

; 1469 :     _encode_one_frame_add_bitstream_deps(&state->children[i], job);

	movsxd	rax, ebx
	imul	rcx, rax, 424				; 000001a8H
	add	rcx, rdx
	mov	rdx, rdi
	call	_encode_one_frame_add_bitstream_deps
	mov	rdx, QWORD PTR [rbp+16]
	lea	rsi, QWORD PTR [rsi+424]
	inc	ebx
	cmp	QWORD PTR [rsi+rdx], 0
	jne	SHORT $LL4@encode_one

; 1467 :   int i;
; 1468 :   for (i = 0; state->children[i].encoder_control; ++i) {

	mov	rsi, QWORD PTR [rsp+48]
$LN3@encode_one:

; 1470 :   }
; 1471 :   if (state->tqj_bitstream_written) {

	mov	rbx, QWORD PTR [rbp+408]
	test	rbx, rbx
	je	$LN88@encode_one
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp__Mtx_lock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN48@encode_one

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN48@encode_one:
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 492  :   if (dependency->state == THREADQUEUE_JOB_STATE_DONE) {

	cmp	DWORD PTR [rbx+8], 4
	jne	SHORT $LN31@encode_one
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp__Mtx_unlock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	$LN88@encode_one

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN31@encode_one:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp__Mtx_lock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN67@encode_one

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN67@encode_one:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	rcx, QWORD PTR [rdi]
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 499  :   job->ndepends++;

	inc	DWORD PTR [rdi+12]
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	call	QWORD PTR __imp__Mtx_unlock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN76@encode_one

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN76@encode_one:
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 503  :   if (dependency->rdepends_count >= dependency->rdepends_size) {

	mov	eax, DWORD PTR [rbx+28]
	cmp	DWORD PTR [rbx+24], eax
	jl	SHORT $LN35@encode_one

; 504  :     dependency->rdepends_size += THREADQUEUE_LIST_REALLOC_SIZE;
; 505  :     size_t bytes = dependency->rdepends_size * sizeof(threadqueue_job_t*);
; 506  :     dependency->rdepends = realloc(dependency->rdepends, bytes);

	mov	rcx, QWORD PTR [rbx+16]
	add	eax, 32					; 00000020H
	movsxd	rdx, eax
	shl	rdx, 3
	mov	DWORD PTR [rbx+28], eax
	call	QWORD PTR __imp_realloc
	mov	QWORD PTR [rbx+16], rax
$LN35@encode_one:

; 523  :   int32_t new_refcount = KVZ_ATOMIC_INC(&job->refcount);

	mov	eax, 1
	lock xadd DWORD PTR [rdi+32], eax
	inc	eax

; 524  :   // The caller should have had another reference and we added one
; 525  :   // reference so refcount should be at least 2.
; 526  :   assert(new_refcount >= 2);

	cmp	eax, 2
	jge	SHORT $LN82@encode_one
	mov	r8d, 526				; 0000020eH
	lea	rdx, OFFSET FLAT:$SG4294956574
	lea	rcx, OFFSET FLAT:$SG4294956573
	call	QWORD PTR __imp__wassert
$LN82@encode_one:

; 508  :   dependency->rdepends[dependency->rdepends_count++] = kvz_threadqueue_copy_ref(job);

	movsxd	rcx, DWORD PTR [rbx+24]
	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rax+rcx*8], rdi
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	rcx, QWORD PTR [rbx]
; File F:\open_codec_learn_2021\kvazaar-master\src\threadqueue.c

; 508  :   dependency->rdepends[dependency->rdepends_count++] = kvz_threadqueue_copy_ref(job);

	inc	DWORD PTR [rbx+24]
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	call	QWORD PTR __imp__Mtx_unlock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN88@encode_one

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN88@encode_one:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1474 :   if (state->tqj_recon_done) {

	mov	rdx, QWORD PTR [rbp+400]
	test	rdx, rdx
	je	SHORT $LN6@encode_one

; 1475 :     kvz_threadqueue_job_dep_add(job, state->tqj_recon_done);

	mov	rcx, rdi
	call	kvz_threadqueue_job_dep_add
$LN6@encode_one:

; 1476 :   }
; 1477 : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN97@encode_one:
_encode_one_frame_add_bitstream_deps ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
cu_type$ = 8
intra_mode$ = 16
depth$ = 24
kvz_get_scan_order PROC

; 1582 :   // Scan mode is diagonal, except for 4x4+8x8 luma and 4x4 chroma, where:
; 1583 :   // - angular 6-14 = vertical
; 1584 :   // - angular 22-30 = horizontal
; 1585 :   if (cu_type == CU_INTRA && depth >= 3) {

	cmp	cl, 1
	jne	SHORT $LN5@kvz_get_sc
	cmp	r8d, 3
	jl	SHORT $LN5@kvz_get_sc

; 1586 :     if (intra_mode >= 6 && intra_mode <= 14) {

	lea	eax, DWORD PTR [rdx-6]
	cmp	eax, 8
	ja	SHORT $LN3@kvz_get_sc

; 1587 :       return SCAN_VER;

	mov	eax, 2

; 1594 : }

	ret	0
$LN3@kvz_get_sc:

; 1588 :     } else if (intra_mode >= 22 && intra_mode <= 30) {

	lea	eax, DWORD PTR [rdx-22]
	cmp	eax, 8
	ja	SHORT $LN5@kvz_get_sc

; 1589 :       return SCAN_HOR;

	mov	eax, 1

; 1594 : }

	ret	0
$LN5@kvz_get_sc:

; 1590 :     }
; 1591 :   }
; 1592 : 
; 1593 :   return SCAN_DIAG;

	xor	eax, eax

; 1594 : }

	ret	0
kvz_get_scan_order ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
_TEXT	SEGMENT
state$ = 64
x$ = 72
y$ = 80
last_qp$ = 88
kvz_get_cu_ref_qp PROC

; 1605 : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1606 :   const encoder_control_t *ctrl = state->encoder_control;
; 1607 :   const cu_array_t *cua = state->tile->frame->cu_array;

	mov	rax, QWORD PTR [rcx+48]
	mov	ebp, r9d
	mov	rbx, QWORD PTR [rcx]
	mov	r14d, r8d
	mov	r15d, edx
	mov	rcx, QWORD PTR [rax]
	mov	rsi, QWORD PTR [rcx+32]

; 1608 :   // Quantization group width
; 1609 :   const int qg_width = LCU_WIDTH >> MIN(ctrl->max_qp_delta_depth, kvz_cu_array_at_const(cua, x, y)->depth);

	mov	rcx, rsi
	call	kvz_cu_array_at_const
	movsx	r10d, BYTE PTR [rbx+6520]
	movzx	ecx, BYTE PTR [rax]
	shr	ecx, 2
	and	ecx, 7
	cmp	r10d, ecx
	jl	SHORT $LN6@kvz_get_cu
	mov	r8d, r14d
	mov	edx, r15d
	mov	rcx, rsi
	call	kvz_cu_array_at_const
	movzx	r10d, BYTE PTR [rax]
	shr	r10d, 2
	and	r10d, 7
$LN6@kvz_get_cu:
	mov	ebx, 64					; 00000040H
	mov	ecx, r10d
	sar	ebx, cl

; 1610 : 
; 1611 :   // Coordinates of the top-left corner of the quantization group
; 1612 :   const int x_qg = x & ~(qg_width - 1);

	dec	ebx
	not	ebx
	mov	edi, ebx

; 1613 :   const int y_qg = y & ~(qg_width - 1);

	and	ebx, r14d
	and	edi, r15d

; 1614 : 
; 1615 :   int qp_pred_a = last_qp;

	mov	r14d, ebp

; 1616 :   if (x_qg % LCU_WIDTH > 0) {

	mov	eax, edi
	and	eax, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN8@kvz_get_cu
	dec	eax
	or	eax, -64				; ffffffffffffffc0H
	inc	eax
$LN8@kvz_get_cu:
	test	eax, eax
	jle	SHORT $LN2@kvz_get_cu

; 1617 :     qp_pred_a = kvz_cu_array_at_const(cua, x_qg - 1, y_qg)->qp;

	lea	edx, DWORD PTR [rdi-1]
	mov	r8d, ebx
	mov	rcx, rsi
	call	kvz_cu_array_at_const
	movzx	r14d, BYTE PTR [rax+6]
$LN2@kvz_get_cu:

; 1618 :   }
; 1619 : 
; 1620 :   int qp_pred_b = last_qp;
; 1621 :   if (y_qg % LCU_WIDTH > 0) {

	mov	eax, ebx
	and	eax, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN7@kvz_get_cu
	dec	eax
	or	eax, -64				; ffffffffffffffc0H
	inc	eax
$LN7@kvz_get_cu:
	test	eax, eax
	jle	SHORT $LN3@kvz_get_cu

; 1622 :     qp_pred_b = kvz_cu_array_at_const(cua, x_qg, y_qg - 1)->qp;

	lea	r8d, DWORD PTR [rbx-1]
	mov	edx, edi
	mov	rcx, rsi
	call	kvz_cu_array_at_const
	movzx	ebp, BYTE PTR [rax+6]
$LN3@kvz_get_cu:

; 1623 :   }
; 1624 : 
; 1625 :   return ((qp_pred_a + qp_pred_b + 1) >> 1);
; 1626 : }

	mov	rbx, QWORD PTR [rsp+64]
	lea	eax, DWORD PTR [r14+1]
	mov	rsi, QWORD PTR [rsp+80]
	add	eax, ebp
	mov	rbp, QWORD PTR [rsp+72]
	sar	eax, 1
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
kvz_get_cu_ref_qp ENDP
_TEXT	ENDS
END
