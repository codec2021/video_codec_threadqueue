; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	kvz_md5_update
PUBLIC	kvz_md5_init
PUBLIC	kvz_md5_final
pdata	SEGMENT
$pdata$MD5Transform DD imagerel MD5Transform
	DD	imagerel MD5Transform+2020
	DD	imagerel $unwind$MD5Transform
$pdata$kvz_md5_update DD imagerel $LN16
	DD	imagerel $LN16+252
	DD	imagerel $unwind$kvz_md5_update
$pdata$kvz_md5_final DD imagerel $LN6
	DD	imagerel $LN6+190
	DD	imagerel $unwind$kvz_md5_final
xdata	SEGMENT
$unwind$MD5Transform DD 091501H
	DD	0f0114215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
$unwind$kvz_md5_update DD 0a3f01H
	DD	0af43fH
	DD	09543aH
	DD	08342bH
	DD	0e0053209H
	DD	060027003H
$unwind$kvz_md5_final DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\libmd5.c
_TEXT	SEGMENT
digest$ = 48
ctx$ = 56
kvz_md5_final PROC

; 115  : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 116  :   unsigned count;
; 117  :   unsigned char *p;
; 118  : 
; 119  :   /* Compute number of bytes mod 64 */
; 120  :   count = (ctx->bits[0] >> 3) & 0x3F;

	mov	r8d, DWORD PTR [rdx+16]
	mov	rsi, rcx
	shr	r8d, 3

; 121  : 
; 122  :   /* Set the first char of padding to 0x80.  This is safe since there is
; 123  :      always at least one byte free */
; 124  :   p = ctx->in.b8 + count;
; 125  :   *p++ = 0x80;
; 126  : 
; 127  :   /* Bytes of padding needed to make 64 bytes */
; 128  :   count = 64 - 1 - count;

	mov	eax, 63					; 0000003fH
	and	r8d, 63					; 0000003fH
	mov	rbx, rdx
	mov	ecx, r8d
	sub	eax, r8d
	add	rcx, rdx

; 129  : 
; 130  :   /* Pad out to 56 mod 64 */
; 131  :   if (count < 8) {

	xor	edx, edx
	mov	BYTE PTR [rcx+24], 128			; 00000080H
	add	rcx, 25
	cmp	eax, 8
	jae	SHORT $LN2@kvz_md5_fi

; 132  :     /* Two lots of padding:  Pad the first block to 64 bytes */
; 133  :     memset(p, 0, count);

	mov	r8d, eax
	call	memset

; 134  :     byteReverse(ctx->in.b32, 16);
; 135  :     MD5Transform(ctx->buf, ctx->in.b32);

	lea	rdx, QWORD PTR [rbx+24]
	mov	rcx, rbx
	call	MD5Transform
	xorps	xmm0, xmm0

; 136  : 
; 137  :     /* Now fill the next block with 56 bytes */
; 138  :     memset(ctx->in.b8, 0, 56);

	xor	eax, eax
	movups	XMMWORD PTR [rbx+24], xmm0
	movups	XMMWORD PTR [rbx+40], xmm0
	movups	XMMWORD PTR [rbx+56], xmm0
	mov	QWORD PTR [rbx+72], rax

; 139  :   } else {

	jmp	SHORT $LN3@kvz_md5_fi
$LN2@kvz_md5_fi:

; 140  :     /* Pad block to 56 bytes */
; 141  :     memset(p, 0, count - 8);

	add	eax, -8					; fffffff8H
	mov	r8d, eax
	call	memset
$LN3@kvz_md5_fi:

; 142  :   }
; 143  :   byteReverse(ctx->in.b32, 14);
; 144  : 
; 145  :   /* Append length in bits and transform */
; 146  :   ctx->in.b32[14] = ctx->bits[0];

	mov	eax, DWORD PTR [rbx+16]

; 147  :   ctx->in.b32[15] = ctx->bits[1];
; 148  : 
; 149  :   MD5Transform(ctx->buf, ctx->in.b32);

	lea	rdx, QWORD PTR [rbx+24]
	mov	DWORD PTR [rbx+80], eax
	mov	rcx, rbx
	mov	eax, DWORD PTR [rbx+20]
	mov	DWORD PTR [rbx+84], eax
	call	MD5Transform

; 150  :   byteReverse((uint32_t *) ctx->buf, 4);
; 151  :   memcpy(digest, ctx->buf, 16);

	movups	xmm0, XMMWORD PTR [rbx]

; 152  : 
; 153  :   memset(ctx, 0, sizeof(* ctx));    /* In case it's sensitive */

	xor	eax, eax
	xorps	xmm1, xmm1
	movups	XMMWORD PTR [rsi], xmm0

; 154  :   /* The original version of this code omitted the asterisk. In
; 155  :      effect, only the first part of ctx was wiped with zeros, not
; 156  :      the whole thing. Bug found by Derek Jones. Original line: */
; 157  :   // memset(ctx, 0, sizeof(ctx));    /* In case it's sensitive */
; 158  : }

	mov	rsi, QWORD PTR [rsp+56]
	movups	XMMWORD PTR [rbx], xmm1
	movups	XMMWORD PTR [rbx+16], xmm1
	movups	XMMWORD PTR [rbx+32], xmm1
	movups	XMMWORD PTR [rbx+48], xmm1
	movups	XMMWORD PTR [rbx+64], xmm1
	mov	QWORD PTR [rbx+80], rax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
kvz_md5_final ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\libmd5.c
_TEXT	SEGMENT
ctx$ = 8
kvz_md5_init PROC

; 53   :   ctx->buf[0] = 0x67452301;
; 54   :   ctx->buf[1] = 0xefcdab89;
; 55   :   ctx->buf[2] = 0x98badcfe;
; 56   :   ctx->buf[3] = 0x10325476;
; 57   : 
; 58   :   ctx->bits[0] = 0;

	xor	eax, eax
	mov	DWORD PTR [rcx], 1732584193		; 67452301H

; 59   :   ctx->bits[1] = 0;

	mov	DWORD PTR [rcx+20], eax
	mov	DWORD PTR [rcx+4], -271733879		; efcdab89H
	mov	DWORD PTR [rcx+8], -1732584194		; 98badcfeH
	mov	QWORD PTR [rcx+12], 271733878		; 10325476H

; 60   : }

	ret	0
kvz_md5_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\libmd5.c
_TEXT	SEGMENT
ctx$ = 64
buf$ = 72
len$ = 80
kvz_md5_update PROC

; 67   : {

$LN16:
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	r14, rcx
	mov	esi, r8d

; 68   :   uint32_t t;
; 69   : 
; 70   :   /* Update bitcount */
; 71   : 
; 72   :   t = ctx->bits[0];

	mov	ecx, DWORD PTR [rcx+16]
	mov	rdi, rdx

; 73   :   if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t)

	mov	edx, DWORD PTR [r14+20]
	lea	eax, DWORD PTR [rcx+rsi*8]
	mov	DWORD PTR [r14+16], eax
	cmp	eax, ecx
	jae	SHORT $LN4@kvz_md5_up

; 74   :     ctx->bits[1]++;        /* Carry from low to high */

	inc	edx
$LN4@kvz_md5_up:
	mov	QWORD PTR [rsp+64], rbx

; 75   :   ctx->bits[1] += len >> 29;

	mov	eax, esi
	shr	eax, 29
	add	eax, edx

; 76   : 
; 77   :   t = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */

	shr	ecx, 3
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], r15
	mov	DWORD PTR [r14+20], eax
	and	ecx, 63					; 0000003fH

; 78   : 
; 79   :   /* Handle any leading odd-sized chunks */
; 80   : 
; 81   :   if (t) {

	je	SHORT $LN12@kvz_md5_up

; 82   :     unsigned char *p = ctx->in.b8 + t;
; 83   : 
; 84   :     t = 64 - t;

	mov	r15d, 64				; 00000040H

; 85   :     if (len < t) {

	mov	rdx, rdi
	sub	r15d, ecx
	add	rcx, 24
	add	rcx, r14
	cmp	esi, r15d
	jae	SHORT $LN6@kvz_md5_up

; 86   :       memcpy(p, buf, len);

	mov	r8, rsi

; 87   :       return;

	jmp	SHORT $LN14@kvz_md5_up
$LN6@kvz_md5_up:

; 88   :     }
; 89   :     memcpy(p, buf, t);

	mov	r8d, r15d
	mov	ebx, r15d
	call	memcpy

; 90   :     byteReverse(ctx->in.b32, 16);
; 91   :     MD5Transform(ctx->buf, ctx->in.b32);

	lea	rbp, QWORD PTR [r14+24]
	mov	rcx, r14
	mov	rdx, rbp
	call	MD5Transform

; 92   :     buf += t;

	add	rdi, rbx

; 93   :     len -= t;

	sub	esi, r15d
	jmp	SHORT $LN8@kvz_md5_up
$LN12@kvz_md5_up:
	lea	rbp, QWORD PTR [r14+24]
$LN8@kvz_md5_up:

; 94   :   }
; 95   :   /* Process data in 64-byte chunks */
; 96   : 
; 97   :   while (len >= 64) {

	cmp	esi, 64					; 00000040H
	jb	SHORT $LN3@kvz_md5_up
	mov	ebx, esi
	shr	rbx, 6
	npad	10
$LL2@kvz_md5_up:

; 98   :     memcpy(ctx->in.b8, buf, 64);

	movups	xmm0, XMMWORD PTR [rdi]

; 99   :     byteReverse(ctx->in.b32, 16);
; 100  :     MD5Transform(ctx->buf, ctx->in.b32);

	mov	rdx, rbp
	mov	rcx, r14
	movups	XMMWORD PTR [rbp], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rbp+16], xmm1
	movups	xmm0, XMMWORD PTR [rdi+32]
	movups	XMMWORD PTR [rbp+32], xmm0
	movups	xmm1, XMMWORD PTR [rdi+48]
	movups	XMMWORD PTR [rbp+48], xmm1
	call	MD5Transform

; 101  :     buf += 64;

	add	rdi, 64					; 00000040H

; 102  :     len -= 64;

	add	esi, -64				; ffffffc0H
	sub	rbx, 1
	jne	SHORT $LL2@kvz_md5_up
$LN3@kvz_md5_up:

; 103  :   }
; 104  : 
; 105  :     /* Handle any remaining bytes of data. */
; 106  : 
; 107  :   memcpy(ctx->in.b8, buf, len);

	mov	r8d, esi
	mov	rdx, rdi
	mov	rcx, rbp
$LN14@kvz_md5_up:

; 108  : }

	mov	r15, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	jmp	memcpy
kvz_md5_update ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\libmd5.c
_TEXT	SEGMENT
tv1983 = 0
tv1985 = 4
tv1978 = 8
tv1987 = 12
tv1980 = 16
buf$ = 112
tv1989 = 120
in$ = 120
tv1986 = 128
tv1988 = 136
MD5Transform PROC

; 178  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 179  :   register uint32_t a, b, c, d;
; 180  : 
; 181  :   a = buf[0];
; 182  :   b = buf[1];

	mov	r10d, DWORD PTR [rcx+4]
	mov	rbx, rdx

; 183  :   c = buf[2];

	mov	r9d, DWORD PTR [rcx+8]

; 184  :   d = buf[3];

	mov	r8d, DWORD PTR [rcx+12]

; 185  : 
; 186  :   MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);

	mov	eax, r8d
	mov	edx, DWORD PTR [rcx]
	xor	eax, r9d
	and	eax, r10d
	mov	ecx, DWORD PTR [rbx]
	xor	eax, r8d

; 187  :   MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
; 188  :   MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
; 189  :   MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
; 190  :   MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
; 191  :   MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);

	mov	r12d, DWORD PTR [rbx+20]
	add	eax, ecx
	mov	DWORD PTR tv1989[rsp], ecx
	lea	ecx, DWORD PTR [rdx-680876936]
	mov	edx, DWORD PTR [rbx+4]
	add	ecx, eax
	mov	DWORD PTR tv1988[rsp], edx
	rol	ecx, 7
	mov	eax, r9d
	xor	eax, r10d
	add	ecx, r10d
	and	eax, ecx
	xor	eax, r9d
	add	eax, edx
	lea	edx, DWORD PTR [r8-389564586]
	mov	r8d, DWORD PTR [rbx+8]
	add	edx, eax
	rol	edx, 12
	mov	eax, r10d
	xor	eax, ecx
	mov	DWORD PTR tv1987[rsp], r8d
	add	edx, ecx
	and	eax, edx
	xor	eax, r10d
	add	eax, r8d
	lea	r8d, DWORD PTR [r9+606105819]
	mov	r9d, DWORD PTR [rbx+12]
	add	r8d, eax
	mov	eax, edx
	mov	DWORD PTR tv1986[rsp], r9d
	xor	eax, ecx
	ror	r8d, 15
	add	r8d, edx
	and	eax, r8d
	xor	eax, ecx
	add	eax, r9d
	lea	r9d, DWORD PTR [r10-1044525330]
	mov	r10d, DWORD PTR [rbx+16]
	add	r9d, eax
	mov	eax, edx
	mov	DWORD PTR tv1985[rsp], r10d
	xor	eax, r8d
	ror	r9d, 10
	add	r9d, r8d
	and	eax, r9d
	xor	eax, edx
	add	eax, r10d
	lea	r10d, DWORD PTR [rcx-176418897]
	add	r10d, eax
	lea	ecx, DWORD PTR [rdx+1200080426]

; 192  :   MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);

	mov	edx, DWORD PTR [rbx+24]
	mov	eax, r8d
	xor	eax, r9d
	mov	DWORD PTR tv1983[rsp], edx
	rol	r10d, 7
	add	r10d, r9d
	and	eax, r10d
	xor	eax, r8d
	add	eax, r12d
	add	ecx, eax
	mov	eax, r9d
	xor	eax, r10d
	rol	ecx, 12
	add	ecx, r10d
	and	eax, ecx
	xor	eax, r9d
	add	eax, edx
	lea	edx, DWORD PTR [r8-1473231341]
	add	edx, eax
	ror	edx, 15
	add	edx, ecx

; 193  :   MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);

	mov	ebp, DWORD PTR [rbx+28]
	lea	r8d, DWORD PTR [r9-45705983]

; 194  :   MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);

	mov	r13d, DWORD PTR [rbx+32]
	lea	r9d, DWORD PTR [r10+1770035416]

; 195  :   MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
; 196  :   MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);

	mov	r14d, DWORD PTR [rbx+40]
	mov	eax, ecx
	xor	eax, r10d

; 197  :   MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
; 198  :   MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);

	mov	esi, DWORD PTR [rbx+48]
	and	eax, edx

; 199  :   MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);

	mov	r15d, DWORD PTR [rbx+52]
	xor	eax, r10d

; 200  :   MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);

	mov	edi, DWORD PTR [rbx+56]
	mov	r10d, DWORD PTR [rbx+36]
	add	eax, ebp
	add	r8d, eax
	mov	DWORD PTR tv1980[rsp], r10d
	ror	r8d, 10
	mov	eax, ecx
	xor	eax, edx
	add	r8d, edx
	and	eax, r8d
	xor	eax, ecx
	add	eax, r13d
	add	r9d, eax
	lea	r11d, DWORD PTR [r8-1990404162]
	mov	eax, edx
	rol	r9d, 7
	xor	eax, r8d
	add	r9d, r8d
	and	eax, r9d
	xor	eax, edx
	add	eax, r10d
	lea	r10d, DWORD PTR [rcx-1958414417]
	add	r10d, eax
	lea	ecx, DWORD PTR [rdx-42063]
	mov	edx, DWORD PTR [rbx+44]
	mov	eax, r8d
	xor	eax, r9d
	mov	DWORD PTR tv1978[rsp], edx
	rol	r10d, 12
	add	r10d, r9d
	and	eax, r10d
	xor	eax, r8d
	add	eax, r14d
	add	ecx, eax
	mov	eax, r10d
	xor	eax, r9d
	ror	ecx, 15
	add	ecx, r10d
	and	eax, ecx
	mov	r8d, ecx
	xor	eax, r9d
	add	eax, edx
	lea	edx, DWORD PTR [r9+1804603682]
	add	r11d, eax
	lea	r9d, DWORD PTR [rcx-1502002290]
	ror	r11d, 10
	mov	eax, r10d
	xor	eax, ecx
	add	r11d, ecx
	and	eax, r11d
	xor	r8d, r11d
	xor	eax, r10d
	add	eax, esi
	add	edx, eax
	mov	eax, r11d
	rol	edx, 7
	add	edx, r11d
	and	r8d, edx
	xor	eax, edx
	xor	r8d, ecx
	add	r8d, -40341101				; fd987193H
	add	r8d, r15d
	add	r8d, r10d
	rol	r8d, 12
	add	r8d, edx
	and	eax, r8d
	xor	eax, r11d
	add	eax, edi
	add	r9d, eax
	ror	r9d, 15

; 201  :   MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

	mov	ebx, DWORD PTR [rbx+60]
	add	r9d, r8d
	mov	ecx, r8d

; 202  : 
; 203  :   MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);

	mov	eax, r9d
	xor	ecx, edx
	and	ecx, r9d
	xor	ecx, edx
	add	ecx, 1236535329				; 49b40821H
	add	ecx, ebx
	add	ecx, r11d
	ror	ecx, 10
	add	ecx, r9d
	xor	eax, ecx
	and	eax, r8d
	xor	eax, r9d
	add	eax, -165796510				; f61e2562H

; 204  :   MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
; 205  :   MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
; 206  :   MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);

	lea	r10d, DWORD PTR [rcx-373897302]
	add	eax, DWORD PTR tv1988[rsp]
	add	edx, eax
	mov	eax, ecx
	rol	edx, 5
	add	edx, ecx
	xor	eax, edx
	and	eax, r9d
	xor	eax, ecx
	add	eax, -1069501632			; c040b340H
	add	eax, DWORD PTR tv1983[rsp]
	add	r8d, eax
	rol	r8d, 9
	add	r8d, edx
	mov	eax, r8d
	xor	eax, edx
	and	eax, ecx

; 207  :   MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);

	lea	ecx, DWORD PTR [rdx-701558691]
	xor	eax, edx
	add	eax, 643717713				; 265e5a51H
	add	eax, DWORD PTR tv1978[rsp]
	add	r9d, eax
	mov	eax, r8d
	rol	r9d, 14
	add	r9d, r8d
	xor	eax, r9d
	and	eax, edx

; 208  :   MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);

	lea	edx, DWORD PTR [r8+38016083]
	xor	eax, r8d
	add	eax, DWORD PTR tv1989[rsp]
	add	r10d, eax
	mov	eax, r9d
	ror	r10d, 12
	add	r10d, r9d
	xor	eax, r10d
	and	eax, r8d

; 209  :   MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);

	lea	r8d, DWORD PTR [r9-660478335]
	xor	eax, r9d
	add	eax, r12d
	add	ecx, eax
	mov	eax, r10d
	rol	ecx, 5
	add	ecx, r10d
	xor	eax, ecx
	and	eax, r9d

; 210  :   MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);

	lea	r9d, DWORD PTR [r10-405537848]
	xor	eax, r10d
	add	eax, r14d
	add	edx, eax
	rol	edx, 9
	add	edx, ecx
	mov	eax, edx
	xor	eax, ecx
	and	eax, r10d
	xor	eax, ecx
	add	eax, ebx
	add	r8d, eax
	mov	eax, edx
	rol	r8d, 14
	add	r8d, edx
	xor	eax, r8d
	and	eax, ecx
	xor	eax, edx
	add	eax, DWORD PTR tv1985[rsp]
	add	r9d, eax

; 211  :   MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);

	lea	r10d, DWORD PTR [rcx+568446438]
	ror	r9d, 12
	add	r9d, r8d

; 212  :   MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);

	lea	ecx, DWORD PTR [rdx-1019803690]
	mov	eax, r8d
	xor	eax, r9d
	and	eax, edx

; 213  :   MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);

	lea	edx, DWORD PTR [r8-187363961]
	xor	eax, r8d

; 214  :   MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);

	lea	r11d, DWORD PTR [r9+1163531501]
	add	eax, DWORD PTR tv1980[rsp]
	add	r10d, eax
	mov	eax, r9d
	rol	r10d, 5
	add	r10d, r9d
	xor	eax, r10d
	and	eax, r8d
	xor	eax, r9d
	add	eax, edi

; 215  :   MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);

	lea	r8d, DWORD PTR [r10-1444681467]
	add	ecx, eax
	rol	ecx, 9
	add	ecx, r10d
	mov	eax, ecx
	xor	eax, r10d
	and	eax, r9d
	xor	eax, r10d

; 216  :   MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);

	lea	r9d, DWORD PTR [rcx-51403784]
	add	eax, DWORD PTR tv1986[rsp]
	add	edx, eax
	mov	eax, ecx
	rol	edx, 14
	add	edx, ecx
	xor	eax, edx
	and	eax, r10d
	xor	eax, ecx
	add	eax, r13d

; 217  :   MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);

	lea	r10d, DWORD PTR [rdx+1735328473]
	add	r11d, eax
	mov	eax, edx
	ror	r11d, 12
	add	r11d, edx
	xor	eax, r11d
	and	eax, ecx
	xor	eax, edx
	add	eax, r15d
	add	r8d, eax
	mov	eax, r11d
	rol	r8d, 5
	add	r8d, r11d
	xor	eax, r8d
	and	eax, edx

; 218  :   MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

	lea	edx, DWORD PTR [r11-1926607734]
	xor	eax, r11d
	add	eax, DWORD PTR tv1987[rsp]
	add	r9d, eax
	rol	r9d, 9
	add	r9d, r8d
	mov	eax, r9d
	mov	ecx, r9d
	xor	eax, r8d
	and	eax, r11d
	xor	eax, r8d
	add	eax, ebp
	add	r10d, eax
	rol	r10d, 14
	add	r10d, r9d
	xor	ecx, r10d
	mov	eax, ecx
	and	eax, r8d
	xor	eax, r9d
	add	eax, esi
	add	edx, eax
	ror	edx, 12
	add	edx, r10d

; 219  : 
; 220  :   MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);

	xor	ecx, edx
	add	ecx, -378558				; fffa3942H
	add	ecx, r12d
	add	r8d, ecx
	rol	r8d, 4
	add	r8d, edx

; 221  :   MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);

	mov	eax, r10d

; 222  :   MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
; 223  :   MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);

	lea	r11d, DWORD PTR [rdx-35309556]
	xor	eax, edx
	xor	eax, r8d
	add	eax, -2022574463			; 8771f681H
	add	eax, r13d
	add	r9d, eax
	rol	r9d, 11
	add	r9d, r8d
	mov	eax, r9d
	mov	ecx, r9d
	xor	eax, edx

; 224  :   MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);

	lea	edx, DWORD PTR [r8-1530992060]
	xor	eax, r8d
	add	eax, 1839030562				; 6d9d6122H
	add	eax, DWORD PTR tv1978[rsp]
	add	r10d, eax
	rol	r10d, 16
	add	r10d, r9d
	xor	ecx, r10d
	mov	eax, ecx
	xor	eax, r8d

; 225  :   MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);

	lea	r8d, DWORD PTR [r9+1272893353]
	add	eax, edi

; 226  :   MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);

	lea	r9d, DWORD PTR [r10-155497632]
	add	r11d, eax
	mov	eax, r10d
	ror	r11d, 9
	add	r11d, r10d
	xor	eax, r11d
	xor	ecx, r11d
	add	ecx, DWORD PTR tv1988[rsp]
	add	edx, ecx

; 227  :   MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);

	lea	r10d, DWORD PTR [r11-1094730640]
	rol	edx, 4
	add	edx, r11d
	xor	eax, edx
	add	eax, DWORD PTR tv1985[rsp]
	add	r8d, eax
	rol	r8d, 11
	add	r8d, edx
	mov	eax, r8d
	mov	ecx, r8d
	xor	eax, r11d

; 228  :   MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);

	lea	r11d, DWORD PTR [rdx+681279174]
	xor	eax, edx
	add	eax, ebp
	add	r9d, eax
	rol	r9d, 16
	add	r9d, r8d
	xor	ecx, r9d
	mov	eax, ecx
	xor	eax, edx
	add	eax, r14d
	add	r10d, eax

; 229  :   MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);

	mov	eax, r9d
	ror	r10d, 9
	add	r10d, r9d
	xor	eax, r10d
	xor	ecx, r10d
	add	ecx, r15d
	add	r11d, ecx
	rol	r11d, 4
	add	r11d, r10d
	xor	eax, r11d
	add	eax, -358537222				; eaa127faH
	add	eax, DWORD PTR tv1989[rsp]
	add	r8d, eax
	rol	r8d, 11
	add	r8d, r11d

; 230  :   MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);

	mov	eax, r8d

; 231  :   MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);

	mov	ecx, r8d
	xor	eax, r10d
	xor	eax, r11d
	add	eax, -722521979				; d4ef3085H
	add	eax, DWORD PTR tv1986[rsp]
	add	r9d, eax
	rol	r9d, 16
	add	r9d, r8d
	xor	ecx, r9d
	mov	eax, ecx
	xor	eax, r11d
	lea	edx, DWORD PTR [r10+76029189]
	add	eax, DWORD PTR tv1983[rsp]
	add	edx, eax

; 232  :   MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
; 233  :   MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);

	mov	eax, r9d
	ror	edx, 9
	add	edx, r9d
	xor	eax, edx
	xor	ecx, edx
	add	ecx, DWORD PTR tv1980[rsp]
	lea	r10d, DWORD PTR [rcx-640364487]
	lea	ecx, DWORD PTR [r8-421815835]
	add	r10d, r11d

; 234  :   MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);

	lea	r8d, DWORD PTR [r9+530742520]
	rol	r10d, 4
	add	r10d, edx

; 235  :   MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

	lea	r9d, DWORD PTR [rdx-995338651]
	xor	eax, r10d
	add	eax, esi
	add	ecx, eax
	rol	ecx, 11
	add	ecx, r10d
	mov	eax, ecx
	xor	eax, edx

; 236  : 
; 237  :   MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);

	lea	edx, DWORD PTR [r10-198630844]
	xor	eax, r10d
	add	eax, ebx
	add	r8d, eax
	mov	eax, ecx
	rol	r8d, 16
	add	r8d, ecx
	xor	eax, r8d
	xor	eax, r10d

; 238  :   MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);

	lea	r10d, DWORD PTR [rcx+1126891415]
	add	eax, DWORD PTR tv1987[rsp]
	add	r9d, eax
	mov	eax, ecx
	not	eax
	ror	r9d, 9
	add	r9d, r8d

; 239  :   MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);

	lea	ecx, DWORD PTR [r8-1416354905]
	or	eax, r9d
	xor	eax, r8d
	add	eax, DWORD PTR tv1989[rsp]
	add	edx, eax
	mov	eax, r8d
	not	eax
	rol	edx, 6
	add	edx, r9d

; 240  :   MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);

	lea	r8d, DWORD PTR [r9-57434055]
	or	eax, edx
	xor	eax, r9d
	add	eax, ebp
	add	r10d, eax
	mov	eax, r9d
	not	eax
	rol	r10d, 10
	add	r10d, edx

; 241  :   MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);

	lea	r9d, DWORD PTR [rdx+1700485571]
	or	eax, r10d
	xor	eax, edx
	add	eax, edi
	add	ecx, eax
	mov	eax, edx
	not	eax
	rol	ecx, 15
	add	ecx, r10d
	or	eax, ecx
	xor	eax, r10d
	add	eax, r12d
	add	r8d, eax
	mov	eax, r10d
	not	eax
	ror	r8d, 11
	add	r8d, ecx
	or	eax, r8d
	xor	eax, ecx
	add	eax, esi
	add	r9d, eax
	rol	r9d, 6
	add	r9d, r8d

; 242  :   MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);

	lea	edx, DWORD PTR [r10-1894986606]
	mov	eax, ecx
	not	eax

; 243  :   MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);

	lea	r10d, DWORD PTR [rcx-1051523]
	or	eax, r9d

; 244  :   MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);

	lea	ecx, DWORD PTR [r8-2054922799]
	xor	eax, r8d
	add	eax, DWORD PTR tv1986[rsp]
	add	edx, eax
	mov	eax, r8d
	not	eax
	rol	edx, 10
	add	edx, r9d

; 245  :   MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);

	lea	r8d, DWORD PTR [r9+1873313359]
	or	eax, edx
	xor	eax, r9d
	add	eax, r14d
	add	r10d, eax
	mov	eax, r9d
	not	eax
	rol	r10d, 15
	add	r10d, edx
	or	eax, r10d

; 246  :   MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);

	mov	r9d, r10d
	xor	eax, edx
	not	r9d
	add	eax, DWORD PTR tv1988[rsp]
	add	ecx, eax

; 247  :   MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);

	lea	r11d, DWORD PTR [r10-1560198380]
	mov	eax, edx
	ror	ecx, 11
	not	eax
	add	ecx, r10d
	or	eax, ecx
	xor	eax, r10d
	add	eax, r13d
	add	r8d, eax

; 248  :   MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);

	lea	r10d, DWORD PTR [rcx+1309151649]
	rol	r8d, 6
	mov	eax, ecx
	not	eax
	add	r8d, ecx
	or	r9d, r8d
	xor	r9d, ecx
	add	r9d, -30611744				; fe2ce6e0H
	add	r9d, ebx
	add	r9d, edx
	rol	r9d, 10
	add	r9d, r8d
	or	eax, r9d
	xor	eax, r8d
	add	eax, DWORD PTR tv1983[rsp]
	add	r11d, eax

; 249  :   MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
; 250  :   MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);

	lea	edx, DWORD PTR [r9-1120210379]
	mov	eax, r8d
	rol	r11d, 15
	not	eax
	add	r11d, r9d
	or	eax, r11d
	xor	eax, r9d
	add	eax, r15d
	add	r10d, eax
	mov	eax, r9d
	not	eax
	ror	r10d, 11
	add	r10d, r11d
	or	eax, r10d
	xor	eax, r11d
	add	eax, -145523070				; f7537e82H
	add	eax, DWORD PTR tv1985[rsp]
	add	r8d, eax
	mov	eax, r11d
	not	eax
	rol	r8d, 6
	add	r8d, r10d
	or	eax, r8d
	xor	eax, r10d
	add	eax, DWORD PTR tv1978[rsp]
	add	edx, eax
	rol	edx, 10
	add	edx, r8d

; 251  :   MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
; 252  :   MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
; 253  : 
; 254  :   buf[0] += a;

	mov	r9, QWORD PTR buf$[rsp]
	lea	eax, DWORD PTR [r10-343485551]
	mov	ecx, r10d
	not	ecx
	or	ecx, edx
	add	DWORD PTR [r9], r8d
	xor	ecx, r8d
	add	ecx, 718787259				; 2ad7d2bbH
	not	r8d
	add	ecx, DWORD PTR tv1987[rsp]
	add	ecx, r11d
	rol	ecx, 15
	add	ecx, edx

; 255  :   buf[1] += b;
; 256  :   buf[2] += c;

	add	DWORD PTR [r9+8], ecx
	or	r8d, ecx
	xor	r8d, edx
	add	r8d, DWORD PTR tv1980[rsp]
	add	eax, r8d
	ror	eax, 11
	add	eax, DWORD PTR [r9+4]
	add	eax, ecx

; 257  :   buf[3] += d;

	add	DWORD PTR [r9+12], edx
	mov	DWORD PTR [r9+4], eax

; 258  : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
MD5Transform ENDP
_TEXT	ENDS
END
