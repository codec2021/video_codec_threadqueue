; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	kvz_bit_set_mask
kvz_bit_set_mask DD 01H
	DD	02H
	DD	04H
	DD	08H
	DD	010H
	DD	020H
	DD	040H
	DD	080H
	DD	0100H
	DD	0200H
	DD	0400H
	DD	0800H
	DD	01000H
	DD	02000H
	DD	04000H
	DD	08000H
	DD	010000H
	DD	020000H
	DD	040000H
	DD	080000H
	DD	0100000H
	DD	0200000H
	DD	0400000H
	DD	0800000H
	DD	01000000H
	DD	02000000H
	DD	04000000H
	DD	08000000H
	DD	010000000H
	DD	020000000H
	DD	040000000H
	DD	080000000H
PUBLIC	kvz_bitstream_align_zero
PUBLIC	kvz_bitstream_align
PUBLIC	kvz_bitstream_add_rbsp_trailing_bits
PUBLIC	kvz_bitstream_put_se
PUBLIC	kvz_bitstream_put_ue
PUBLIC	kvz_bitstream_put
PUBLIC	kvz_bitstream_put_byte
PUBLIC	kvz_bitstream_clear
PUBLIC	kvz_bitstream_move
PUBLIC	kvz_bitstream_writebyte
PUBLIC	kvz_bitstream_alloc_chunk
PUBLIC	kvz_bitstream_init
PUBLIC	kvz_bitstream_free_chunks
PUBLIC	kvz_bitstream_take_chunks
PUBLIC	kvz_bitstream_tell
PUBLIC	kvz_bitstream_finalize
pdata	SEGMENT
$pdata$kvz_bitstream_align DD imagerel $LN8
	DD	imagerel $LN8+67
	DD	imagerel $unwind$kvz_bitstream_align
$pdata$kvz_bitstream_add_rbsp_trailing_bits DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$kvz_bitstream_add_rbsp_trailing_bits
$pdata$kvz_bitstream_put_ue DD imagerel $LN19
	DD	imagerel $LN19+200
	DD	imagerel $unwind$kvz_bitstream_put_ue
$pdata$kvz_bitstream_put DD imagerel $LN20
	DD	imagerel $LN20+17
	DD	imagerel $unwind$kvz_bitstream_put
$pdata$2$kvz_bitstream_put DD imagerel $LN20+17
	DD	imagerel $LN20+184
	DD	imagerel $chain$2$kvz_bitstream_put
$pdata$3$kvz_bitstream_put DD imagerel $LN20+184
	DD	imagerel $LN20+185
	DD	imagerel $chain$3$kvz_bitstream_put
$pdata$kvz_bitstream_put_byte DD imagerel $LN8
	DD	imagerel $LN8+109
	DD	imagerel $unwind$kvz_bitstream_put_byte
$pdata$kvz_bitstream_clear DD imagerel $LN14
	DD	imagerel $LN14+18
	DD	imagerel $unwind$kvz_bitstream_clear
$pdata$0$kvz_bitstream_clear DD imagerel $LN14+18
	DD	imagerel $LN14+58
	DD	imagerel $chain$0$kvz_bitstream_clear
$pdata$1$kvz_bitstream_clear DD imagerel $LN14+58
	DD	imagerel $LN14+74
	DD	imagerel $chain$1$kvz_bitstream_clear
$pdata$kvz_bitstream_move DD imagerel $LN20
	DD	imagerel $LN20+147
	DD	imagerel $unwind$kvz_bitstream_move
$pdata$kvz_bitstream_writebyte DD imagerel $LN16
	DD	imagerel $LN16+247
	DD	imagerel $unwind$kvz_bitstream_writebyte
$pdata$kvz_bitstream_alloc_chunk DD imagerel $LN6
	DD	imagerel $LN6+40
	DD	imagerel $unwind$kvz_bitstream_alloc_chunk
$pdata$kvz_math_floor_log2 DD imagerel kvz_math_floor_log2
	DD	imagerel kvz_math_floor_log2+142
	DD	imagerel $unwind$kvz_math_floor_log2
$pdata$kvz_bitstream_free_chunks DD imagerel $LN10
	DD	imagerel $LN10+9
	DD	imagerel $unwind$kvz_bitstream_free_chunks
$pdata$0$kvz_bitstream_free_chunks DD imagerel $LN10+9
	DD	imagerel $LN10+42
	DD	imagerel $chain$0$kvz_bitstream_free_chunks
$pdata$1$kvz_bitstream_free_chunks DD imagerel $LN10+42
	DD	imagerel $LN10+47
	DD	imagerel $chain$1$kvz_bitstream_free_chunks
$pdata$kvz_bitstream_take_chunks DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$kvz_bitstream_take_chunks
$pdata$kvz_bitstream_finalize DD imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$kvz_bitstream_finalize
$pdata$0$kvz_bitstream_finalize DD imagerel $LN16+18
	DD	imagerel $LN16+58
	DD	imagerel $chain$0$kvz_bitstream_finalize
$pdata$1$kvz_bitstream_finalize DD imagerel $LN16+58
	DD	imagerel $LN16+74
	DD	imagerel $chain$1$kvz_bitstream_finalize
xdata	SEGMENT
$unwind$kvz_bitstream_align DD 020601H
	DD	030023206H
$unwind$kvz_bitstream_add_rbsp_trailing_bits DD 020601H
	DD	030023206H
$unwind$kvz_bitstream_put_ue DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$kvz_bitstream_put DD 041101H
	DD	0e00d3211H
	DD	0600a700bH
$chain$2$kvz_bitstream_put DD 062021H
	DD	0af420H
	DD	09540dH
	DD	083405H
	DD	imagerel $LN20
	DD	imagerel $LN20+17
	DD	imagerel $unwind$kvz_bitstream_put
$chain$3$kvz_bitstream_put DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+17
	DD	imagerel $unwind$kvz_bitstream_put
$unwind$kvz_bitstream_put_byte DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$kvz_bitstream_clear DD 020601H
	DD	070023206H
$chain$0$kvz_bitstream_clear DD 020521H
	DD	063405H
	DD	imagerel $LN14
	DD	imagerel $LN14+18
	DD	imagerel $unwind$kvz_bitstream_clear
$chain$1$kvz_bitstream_clear DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+18
	DD	imagerel $unwind$kvz_bitstream_clear
$unwind$kvz_bitstream_move DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$kvz_bitstream_writebyte DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$kvz_bitstream_alloc_chunk DD 010401H
	DD	04204H
$unwind$kvz_math_floor_log2 DD 020601H
	DD	030023206H
$unwind$kvz_bitstream_free_chunks DD 010401H
	DD	04204H
$chain$0$kvz_bitstream_free_chunks DD 020521H
	DD	043405H
	DD	imagerel $LN10
	DD	imagerel $LN10+9
	DD	imagerel $unwind$kvz_bitstream_free_chunks
$chain$1$kvz_bitstream_free_chunks DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+9
	DD	imagerel $unwind$kvz_bitstream_free_chunks
$unwind$kvz_bitstream_take_chunks DD 020601H
	DD	030023206H
$unwind$kvz_bitstream_finalize DD 020601H
	DD	070023206H
$chain$0$kvz_bitstream_finalize DD 020521H
	DD	063405H
	DD	imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$kvz_bitstream_finalize
$chain$1$kvz_bitstream_finalize DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+18
	DD	imagerel $unwind$kvz_bitstream_finalize
	ORG $+1
$SG4294953919 DB 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'u', 00H, 'r', 00H, '_', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
	ORG $+6
$SG4294953921 DB 'd', 00H, 's', 00H, 't', 00H, '-', 00H, '>', 00H, 'c', 00H
	DB	'u', 00H, 'r', 00H, '_', 00H, 'b', 00H, 'i', 00H, 't', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+4
$SG4294953920 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'm', 00H, '.', 00H, 'c', 00H, 00H, 00H
$SG4294953922 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'm', 00H, '.', 00H, 'c', 00H, 00H, 00H
$SG4294953923 DB 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'-', 00H, '>', 00H, 'l', 00H, 'a', 00H, 's', 00H, 't', 00H, '-'
	DB	00H, '>', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'K', 00H, 'V', 00H, 'Z', 00H, '_', 00H, 'D', 00H, 'A'
	DB	00H, 'T', 00H, 'A', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'U', 00H
	DB	'N', 00H, 'K', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E'
	DB	00H, 00H, 00H
$SG4294953924 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'm', 00H, '.', 00H, 'c', 00H, 00H, 00H
$SG4294953925 DB 'n', 00H, 'e', 00H, 'w', 00H, '_', 00H, 'c', 00H, 'h', 00H
	DB	'u', 00H, 'n', 00H, 'k', 00H, 00H, 00H
	ORG $+7
$SG4294953926 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'm', 00H, '.', 00H, 'c', 00H, 00H, 00H
$SG4294953927 DB 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'u', 00H, 'r', 00H, '_', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
	ORG $+6
$SG4294953928 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'm', 00H, '.', 00H, 'c', 00H, 00H, 00H
$SG4294953929 DB 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'u', 00H, 'r', 00H, '_', 00H, 'b'
	DB	00H, 'i', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H
	ORG $+6
$SG4294953930 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'm', 00H, '.', 00H, 'c', 00H, 00H, 00H
$SG4294953933 DB 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+7
$SG4294953934 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'k', 00H
	DB	'v', 00H, 'z', 00H, '_', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'h'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 48
kvz_bitstream_finalize PROC

; 124  : {

$LN16:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 202  :   kvz_bitstream_free_chunks(stream->first);

	mov	rcx, QWORD PTR [rcx+8]

; 113  :   while (chunk != NULL) {

	test	rcx, rcx
	je	SHORT $LN7@kvz_bitstr
	mov	QWORD PTR [rsp+48], rbx
	npad	9
$LL6@kvz_bitstr:

; 114  :     kvz_data_chunk *next = chunk->next;

	mov	rbx, QWORD PTR [rcx+4104]

; 115  :     free(chunk);

	call	QWORD PTR __imp_free

; 116  :     chunk = next;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL6@kvz_bitstr

; 75   : }
; 76   : 
; 77   : /**
; 78   :  * \brief Take chunks from a bitstream.
; 79   :  *
; 80   :  * Move ownership of the chunks to the caller and clear the bitstream.
; 81   :  *
; 82   :  * The bitstream must be byte-aligned.
; 83   :  */
; 84   : kvz_data_chunk * kvz_bitstream_take_chunks(bitstream_t *const stream)
; 85   : {
; 86   :   assert(stream->cur_bit == 0);
; 87   :   kvz_data_chunk *chunks = stream->first;
; 88   :   stream->first = stream->last = NULL;
; 89   :   stream->len = 0;
; 90   :   return chunks;
; 91   : }
; 92   : 
; 93   : /**
; 94   :  * \brief Allocates a new bitstream chunk.
; 95   :  *
; 96   :  * \return Pointer to the new chunk, or NULL.
; 97   :  */
; 98   : kvz_data_chunk * kvz_bitstream_alloc_chunk()
; 99   : {
; 100  :     kvz_data_chunk *chunk = malloc(sizeof(kvz_data_chunk));
; 101  :     if (chunk) {
; 102  :       chunk->len = 0;
; 103  :       chunk->next = NULL;
; 104  :     }
; 105  :     return chunk;
; 106  : }
; 107  : 
; 108  : /**
; 109  :  * \brief Free a list of chunks.
; 110  :  */
; 111  : void kvz_bitstream_free_chunks(kvz_data_chunk *chunk)
; 112  : {
; 113  :   while (chunk != NULL) {

	mov	rbx, QWORD PTR [rsp+48]
$LN7@kvz_bitstr:
	xorps	xmm0, xmm0

; 74   :   memset(stream, 0, sizeof(bitstream_t));

	movups	XMMWORD PTR [rdi], xmm0
	movups	XMMWORD PTR [rdi+16], xmm0

; 125  :   kvz_bitstream_clear(stream);
; 126  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
kvz_bitstream_finalize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 8
kvz_bitstream_tell PROC

; 135  :   uint64_t position = stream->len;

	mov	edx, DWORD PTR [rcx]

; 136  :   return position * 8 + stream->cur_bit;

	movzx	eax, BYTE PTR [rcx+25]
	lea	rax, QWORD PTR [rax+rdx*8]

; 137  : }

	ret	0
kvz_bitstream_tell ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 48
kvz_bitstream_take_chunks PROC

; 85   : {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H

; 86   :   assert(stream->cur_bit == 0);

	cmp	BYTE PTR [rcx+25], 0
	mov	rbx, rcx
	je	SHORT $LN3@kvz_bitstr
	mov	r8d, 86					; 00000056H
	lea	rdx, OFFSET FLAT:$SG4294953930
	lea	rcx, OFFSET FLAT:$SG4294953929
	call	QWORD PTR __imp__wassert
$LN3@kvz_bitstr:

; 87   :   kvz_data_chunk *chunks = stream->first;

	mov	rax, QWORD PTR [rbx+8]

; 88   :   stream->first = stream->last = NULL;

	xor	ecx, ecx
	mov	QWORD PTR [rbx+16], rcx
	mov	QWORD PTR [rbx+8], rcx

; 89   :   stream->len = 0;

	mov	DWORD PTR [rbx], ecx

; 90   :   return chunks;
; 91   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
kvz_bitstream_take_chunks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
chunk$ = 48
kvz_bitstream_free_chunks PROC

; 112  : {

$LN10:
	sub	rsp, 40					; 00000028H

; 113  :   while (chunk != NULL) {

	test	rcx, rcx
	je	SHORT $LN3@kvz_bitstr
	mov	QWORD PTR [rsp+32], rbx
	npad	2
$LL2@kvz_bitstr:

; 114  :     kvz_data_chunk *next = chunk->next;

	mov	rbx, QWORD PTR [rcx+4104]

; 115  :     free(chunk);

	call	QWORD PTR __imp_free

; 116  :     chunk = next;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL2@kvz_bitstr

; 113  :   while (chunk != NULL) {

	mov	rbx, QWORD PTR [rsp+32]
$LN3@kvz_bitstr:

; 117  :   }
; 118  : }

	add	rsp, 40					; 00000028H
	ret	0
kvz_bitstream_free_chunks ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 8
kvz_bitstream_init PROC

; 73   : {

	xorps	xmm0, xmm0

; 74   :   memset(stream, 0, sizeof(bitstream_t));

	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0

; 75   : }

	ret	0
kvz_bitstream_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
_TEXT	SEGMENT
value$ = 48
kvz_math_floor_log2 PROC

; 44   : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx

; 45   :   assert(value > 0);

	test	ecx, ecx
	jne	SHORT $LN6@kvz_math_f
	lea	r8d, QWORD PTR [rcx+45]
	lea	rcx, OFFSET FLAT:$SG4294953933
	lea	rdx, OFFSET FLAT:$SG4294953934
	call	QWORD PTR __imp__wassert
$LN6@kvz_math_f:

; 46   : 
; 47   :   unsigned result = 0;
; 48   : 
; 49   :   for (int i = 4; i >= 0; --i) {
; 50   :     unsigned bits = 1ull << i;
; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	xor	r9d, r9d
	mov	eax, 1
	mov	edx, eax
	mov	r8d, r9d
	rol	rdx, 4
	mov	ecx, edx
	shl	eax, cl
	cmp	ebx, eax
	mov	eax, 8
	cmovae	r8d, edx
	mov	edx, 4

; 52   :     result += shift;
; 53   :     value >>= shift;

	mov	ecx, r8d
	shr	ebx, cl
	mov	ecx, r9d
	cmp	ebx, 256				; 00000100H
	cmovae	ecx, eax
	shr	ebx, cl
	cmp	ebx, 16
	lea	eax, DWORD PTR [r8+rcx]
	mov	ecx, r9d
	cmovae	ecx, edx
	mov	edx, 2
	add	eax, ecx
	shr	ebx, cl
	cmp	ebx, 4
	mov	ecx, r9d
	cmovae	ecx, edx
	add	eax, ecx
	shr	ebx, cl
	cmp	ebx, edx
	setae	r9b
	add	eax, r9d

; 54   :   }
; 55   : 
; 56   :   return result;
; 57   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
kvz_math_floor_log2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
kvz_bitstream_alloc_chunk PROC

; 99   : {

$LN6:
	sub	rsp, 40					; 00000028H

; 100  :     kvz_data_chunk *chunk = malloc(sizeof(kvz_data_chunk));

	mov	ecx, 4112				; 00001010H
	call	QWORD PTR __imp_malloc

; 101  :     if (chunk) {

	test	rax, rax
	je	SHORT $LN4@kvz_bitstr

; 102  :       chunk->len = 0;

	xor	ecx, ecx
	mov	DWORD PTR [rax+4096], ecx

; 103  :       chunk->next = NULL;

	mov	QWORD PTR [rax+4104], rcx
$LN4@kvz_bitstr:

; 104  :     }
; 105  :     return chunk;
; 106  : }

	add	rsp, 40					; 00000028H
	ret	0
kvz_bitstream_alloc_chunk ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 48
byte$ = 56
kvz_bitstream_writebyte PROC

; 148  : {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 149  :   assert(stream->cur_bit == 0);

	cmp	BYTE PTR [rcx+25], 0
	movzx	esi, dl
	mov	rdi, rcx
	je	SHORT $LN7@kvz_bitstr
	mov	r8d, 149				; 00000095H
	lea	rdx, OFFSET FLAT:$SG4294953928
	lea	rcx, OFFSET FLAT:$SG4294953927
	call	QWORD PTR __imp__wassert
$LN7@kvz_bitstr:

; 150  : 
; 151  :   if (stream->last == NULL || stream->last->len == KVZ_DATA_CHUNK_SIZE) {

	mov	rbx, QWORD PTR [rdi+16]
	test	rbx, rbx
	je	SHORT $LN3@kvz_bitstr
	cmp	DWORD PTR [rbx+4096], 4096		; 00001000H
	jne	SHORT $LN14@kvz_bitstr
$LN3@kvz_bitstr:

; 100  :     kvz_data_chunk *chunk = malloc(sizeof(kvz_data_chunk));

	mov	ecx, 4112				; 00001010H
	call	QWORD PTR __imp_malloc
	mov	rbx, rax

; 101  :     if (chunk) {

	test	rax, rax
	je	SHORT $LN13@kvz_bitstr

; 102  :       chunk->len = 0;

	xor	eax, eax
	mov	DWORD PTR [rbx+4096], eax

; 103  :       chunk->next = NULL;

	mov	QWORD PTR [rbx+4104], rax

; 152  :     // Need to allocate a new chunk.
; 153  :     kvz_data_chunk *new_chunk = kvz_bitstream_alloc_chunk();
; 154  :     assert(new_chunk);

	jmp	SHORT $LN8@kvz_bitstr
$LN13@kvz_bitstr:
	mov	r8d, 154				; 0000009aH
	lea	rdx, OFFSET FLAT:$SG4294953926
	lea	rcx, OFFSET FLAT:$SG4294953925
	call	QWORD PTR __imp__wassert
$LN8@kvz_bitstr:

; 155  : 
; 156  :     if (!stream->first) stream->first = new_chunk;

	cmp	QWORD PTR [rdi+8], 0
	jne	SHORT $LN4@kvz_bitstr
	mov	QWORD PTR [rdi+8], rbx
$LN4@kvz_bitstr:

; 157  :     if (stream->last)   stream->last->next = new_chunk;

	mov	rax, QWORD PTR [rdi+16]
	test	rax, rax
	je	SHORT $LN5@kvz_bitstr
	mov	QWORD PTR [rax+4104], rbx
$LN5@kvz_bitstr:

; 158  :     stream->last = new_chunk;

	mov	QWORD PTR [rdi+16], rbx

; 159  :   }
; 160  :   assert(stream->last->len < KVZ_DATA_CHUNK_SIZE);

	cmp	DWORD PTR [rbx+4096], 4096		; 00001000H
$LN14@kvz_bitstr:
	jb	SHORT $LN9@kvz_bitstr
	mov	r8d, 160				; 000000a0H
	lea	rdx, OFFSET FLAT:$SG4294953924
	lea	rcx, OFFSET FLAT:$SG4294953923
	call	QWORD PTR __imp__wassert
	mov	rbx, QWORD PTR [rdi+16]
$LN9@kvz_bitstr:

; 161  : 
; 162  :   stream->last->data[stream->last->len] = byte;

	mov	eax, DWORD PTR [rbx+4096]
	mov	BYTE PTR [rax+rbx], sil

; 163  :   stream->last->len += 1;

	mov	rax, QWORD PTR [rdi+16]

; 164  :   stream->len += 1;
; 165  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	inc	DWORD PTR [rax+4096]
	inc	DWORD PTR [rdi]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
kvz_bitstream_writebyte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
dst$ = 48
src$ = 56
kvz_bitstream_move PROC

; 173  : {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 174  :   assert(dst->cur_bit == 0);

	cmp	BYTE PTR [rcx+25], 0
	mov	rbx, rdx
	mov	rdi, rcx
	je	SHORT $LN6@kvz_bitstr
	mov	r8d, 174				; 000000aeH
	lea	rdx, OFFSET FLAT:$SG4294953922
	lea	rcx, OFFSET FLAT:$SG4294953921
	call	QWORD PTR __imp__wassert
$LN6@kvz_bitstr:

; 175  : 
; 176  :   if (src->len > 0) {

	cmp	DWORD PTR [rbx], 0
	jbe	SHORT $LN4@kvz_bitstr

; 177  :     if (dst->first == NULL) {

	cmp	QWORD PTR [rdi+8], 0
	mov	rax, QWORD PTR [rbx+8]
	jne	SHORT $LN3@kvz_bitstr

; 178  :       dst->first = src->first;

	mov	QWORD PTR [rdi+8], rax

; 179  :       dst->last = src->last;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rdi+16], rax

; 180  :       dst->len = src->len;

	mov	eax, DWORD PTR [rbx]
	mov	DWORD PTR [rdi], eax

; 181  :     } else {

	jmp	SHORT $LN4@kvz_bitstr
$LN3@kvz_bitstr:

; 182  :       dst->last->next = src->first;

	mov	rcx, QWORD PTR [rdi+16]
	mov	QWORD PTR [rcx+4104], rax

; 183  :       dst->last = src->last;

	mov	rax, QWORD PTR [rbx+16]
	mov	QWORD PTR [rdi+16], rax

; 184  :       dst->len += src->len;

	mov	eax, DWORD PTR [rbx]
	add	DWORD PTR [rdi], eax
$LN4@kvz_bitstr:

; 185  :     }
; 186  :   }
; 187  : 
; 188  :   // Move the leftover bits.
; 189  :   dst->data = src->data;

	movzx	eax, BYTE PTR [rbx+24]
	xorps	xmm0, xmm0
	mov	BYTE PTR [rdi+24], al

; 190  :   dst->cur_bit = src->cur_bit;

	movzx	eax, BYTE PTR [rbx+25]
	mov	BYTE PTR [rdi+25], al

; 191  :   dst->zerocount = src->zerocount;

	movzx	eax, BYTE PTR [rbx+26]
	mov	BYTE PTR [rdi+26], al

; 74   :   memset(stream, 0, sizeof(bitstream_t));

	movups	XMMWORD PTR [rbx], xmm0
	movups	XMMWORD PTR [rbx+16], xmm0

; 192  : 
; 193  :   src->first = src->last = NULL;
; 194  :   kvz_bitstream_clear(src);
; 195  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
kvz_bitstream_move ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 48
kvz_bitstream_clear PROC

; 201  : {

$LN14:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 202  :   kvz_bitstream_free_chunks(stream->first);

	mov	rcx, QWORD PTR [rcx+8]

; 113  :   while (chunk != NULL) {

	test	rcx, rcx
	je	SHORT $LN5@kvz_bitstr
	mov	QWORD PTR [rsp+48], rbx
	npad	9
$LL4@kvz_bitstr:

; 114  :     kvz_data_chunk *next = chunk->next;

	mov	rbx, QWORD PTR [rcx+4104]

; 115  :     free(chunk);

	call	QWORD PTR __imp_free

; 116  :     chunk = next;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL4@kvz_bitstr

; 75   : }
; 76   : 
; 77   : /**
; 78   :  * \brief Take chunks from a bitstream.
; 79   :  *
; 80   :  * Move ownership of the chunks to the caller and clear the bitstream.
; 81   :  *
; 82   :  * The bitstream must be byte-aligned.
; 83   :  */
; 84   : kvz_data_chunk * kvz_bitstream_take_chunks(bitstream_t *const stream)
; 85   : {
; 86   :   assert(stream->cur_bit == 0);
; 87   :   kvz_data_chunk *chunks = stream->first;
; 88   :   stream->first = stream->last = NULL;
; 89   :   stream->len = 0;
; 90   :   return chunks;
; 91   : }
; 92   : 
; 93   : /**
; 94   :  * \brief Allocates a new bitstream chunk.
; 95   :  *
; 96   :  * \return Pointer to the new chunk, or NULL.
; 97   :  */
; 98   : kvz_data_chunk * kvz_bitstream_alloc_chunk()
; 99   : {
; 100  :     kvz_data_chunk *chunk = malloc(sizeof(kvz_data_chunk));
; 101  :     if (chunk) {
; 102  :       chunk->len = 0;
; 103  :       chunk->next = NULL;
; 104  :     }
; 105  :     return chunk;
; 106  : }
; 107  : 
; 108  : /**
; 109  :  * \brief Free a list of chunks.
; 110  :  */
; 111  : void kvz_bitstream_free_chunks(kvz_data_chunk *chunk)
; 112  : {
; 113  :   while (chunk != NULL) {

	mov	rbx, QWORD PTR [rsp+48]
$LN5@kvz_bitstr:
	xorps	xmm0, xmm0

; 74   :   memset(stream, 0, sizeof(bitstream_t));

	movups	XMMWORD PTR [rdi], xmm0
	movups	XMMWORD PTR [rdi+16], xmm0

; 203  :   kvz_bitstream_init(stream);
; 204  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
kvz_bitstream_clear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 48
data$ = 56
kvz_bitstream_put_byte PROC

; 212  : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 213  :   assert(stream->cur_bit == 0);

	cmp	BYTE PTR [rcx+25], 0
	mov	edi, edx
	mov	rbx, rcx
	je	SHORT $LN4@kvz_bitstr
	mov	r8d, 213				; 000000d5H
	lea	rdx, OFFSET FLAT:$SG4294953920
	lea	rcx, OFFSET FLAT:$SG4294953919
	call	QWORD PTR __imp__wassert
$LN4@kvz_bitstr:

; 214  :   const uint8_t emulation_prevention_three_byte = 0x03;
; 215  : 
; 216  :   if ((stream->zerocount == 2) && (data < 4)) {

	movzx	eax, BYTE PTR [rbx+26]
	cmp	al, 2
	jne	SHORT $LN2@kvz_bitstr
	cmp	edi, 4
	jae	SHORT $LN2@kvz_bitstr

; 217  :     kvz_bitstream_writebyte(stream, emulation_prevention_three_byte);

	mov	dl, 3
	mov	rcx, rbx
	call	kvz_bitstream_writebyte

; 218  :     stream->zerocount = 0;

	xor	al, al
$LN2@kvz_bitstr:

; 219  :   }
; 220  :   stream->zerocount = data == 0 ? stream->zerocount + 1 : 0;

	inc	al
	xor	ecx, ecx
	test	edi, edi
	movzx	eax, al

; 221  :   kvz_bitstream_writebyte(stream, data);

	movzx	edx, dil
	cmovne	eax, ecx
	mov	rcx, rbx
	mov	BYTE PTR [rbx+26], al

; 222  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 221  :   kvz_bitstream_writebyte(stream, data);

	jmp	kvz_bitstream_writebyte
kvz_bitstream_put_byte ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 64
data$ = 72
bits$ = 80
kvz_bitstream_put PROC

; 232  : {

$LN20:

; 233  :   while (bits--) {

	test	r8b, r8b
	je	$LN18@kvz_bitstr
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+64], rbx
	mov	rdi, rcx
	mov	QWORD PTR [rsp+72], rbp
	lea	rcx, OFFSET FLAT:kvz_bit_set_mask
	movzx	esi, r8b
	mov	r14d, edx
	mov	QWORD PTR [rsp+80], r15
	xor	r15d, r15d
	lea	rbp, QWORD PTR [rcx+rsi*4]
	npad	8
$LL2@kvz_bitstr:

; 234  :     stream->data <<= 1;

	movzx	ebx, BYTE PTR [rdi+24]
	lea	rbp, QWORD PTR [rbp-4]
	add	bl, bl
	add	sil, 255				; 000000ffH
	mov	BYTE PTR [rdi+24], bl

; 235  : 
; 236  :     if (data & kvz_bit_set_mask[bits]) {

	test	DWORD PTR [rbp], r14d
	je	SHORT $LN16@kvz_bitstr

; 237  :       stream->data |= 1;

	or	bl, 1
	mov	BYTE PTR [rdi+24], bl
$LN16@kvz_bitstr:

; 238  :     }
; 239  :     stream->cur_bit++;

	inc	BYTE PTR [rdi+25]

; 240  : 
; 241  :     // write byte to output
; 242  :     if (stream->cur_bit == 8) {

	cmp	BYTE PTR [rdi+25], 8
	jne	SHORT $LN7@kvz_bitstr

; 216  :   if ((stream->zerocount == 2) && (data < 4)) {

	movzx	eax, BYTE PTR [rdi+26]

; 243  :       stream->cur_bit = 0;

	mov	BYTE PTR [rdi+25], r15b

; 216  :   if ((stream->zerocount == 2) && (data < 4)) {

	cmp	al, 2
	jne	SHORT $LN8@kvz_bitstr
	cmp	bl, 4
	jae	SHORT $LN8@kvz_bitstr

; 217  :     kvz_bitstream_writebyte(stream, emulation_prevention_three_byte);

	mov	dl, 3
	mov	rcx, rdi
	call	kvz_bitstream_writebyte

; 218  :     stream->zerocount = 0;

	xor	al, al
$LN8@kvz_bitstr:

; 219  :   }
; 220  :   stream->zerocount = data == 0 ? stream->zerocount + 1 : 0;

	inc	al

; 221  :   kvz_bitstream_writebyte(stream, data);

	movzx	edx, bl
	test	bl, bl
	movzx	eax, al
	mov	rcx, rdi
	cmovne	eax, r15d
	mov	BYTE PTR [rdi+26], al
	call	kvz_bitstream_writebyte
$LN7@kvz_bitstr:

; 233  :   while (bits--) {

	test	sil, sil
	jne	SHORT $LL2@kvz_bitstr
	mov	r15, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]

; 244  :       kvz_bitstream_put_byte(stream, stream->data);
; 245  :     }
; 246  :   }
; 247  : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
$LN18@kvz_bitstr:
	ret	0
kvz_bitstream_put ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 48
code_num$ = 56
kvz_bitstream_put_ue PROC

; 253  : {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 254  :   unsigned code_num_log2 = kvz_math_floor_log2(code_num + 1);

	lea	ebx, DWORD PTR [rdx+1]
	mov	edi, edx
	mov	rsi, rcx
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h

; 45   :   assert(value > 0);

	test	ebx, ebx
	jne	SHORT $LN8@kvz_bitstr
	lea	r8d, QWORD PTR [rbx+45]
	lea	rdx, OFFSET FLAT:$SG4294953934
	lea	rcx, OFFSET FLAT:$SG4294953933
	call	QWORD PTR __imp__wassert
$LN8@kvz_bitstr:

; 46   : 
; 47   :   unsigned result = 0;
; 48   : 
; 49   :   for (int i = 4; i >= 0; --i) {
; 50   :     unsigned bits = 1ull << i;
; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	xor	r9d, r9d
	mov	r10d, 1
	mov	eax, r10d
	mov	r8d, r10d
	rol	r8, 4
	mov	edx, r9d
	mov	ecx, r8d
	shl	eax, cl
	cmp	ebx, eax
	mov	eax, 8
	cmovae	edx, r8d

; 52   :     result += shift;
; 53   :     value >>= shift;

	mov	ecx, edx
	shr	ebx, cl
	mov	ecx, r9d
	cmp	ebx, 256				; 00000100H
	cmovae	ecx, eax
	shr	ebx, cl
	cmp	ebx, 16
	lea	eax, DWORD PTR [rdx+rcx]
	mov	ecx, r9d
	mov	edx, 4
	cmovae	ecx, edx
	mov	edx, 2
	add	eax, ecx
	shr	ebx, cl
	cmp	ebx, 4
	mov	ecx, r9d
	cmovae	ecx, edx
	add	eax, ecx
	shr	ebx, cl
	cmp	ebx, edx
	setae	r9b
	add	eax, r9d
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 255  :   unsigned prefix = 1 << code_num_log2;

	mov	ecx, eax
	shl	r10d, cl

; 256  :   unsigned suffix = code_num + 1 - prefix;
; 257  :   unsigned num_bits = code_num_log2 * 2 + 1;
; 258  :   unsigned value = prefix | suffix;
; 259  : 
; 260  :   kvz_bitstream_put(stream, value, num_bits);

	mov	rcx, rsi
	sub	edi, r10d
	lea	r8b, DWORD PTR [rax*2+1]
	lea	edx, DWORD PTR [rdi+1]
	or	edx, r10d

; 261  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 256  :   unsigned suffix = code_num + 1 - prefix;
; 257  :   unsigned num_bits = code_num_log2 * 2 + 1;
; 258  :   unsigned value = prefix | suffix;
; 259  : 
; 260  :   kvz_bitstream_put(stream, value, num_bits);

	jmp	kvz_bitstream_put
kvz_bitstream_put_ue ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 8
data$ = 16
kvz_bitstream_put_se PROC

; 268  :   // Map positive values to even and negative to odd values.
; 269  :   uint32_t code_num = data <= 0 ? (-data) << 1 : (data << 1) - 1;

	test	edx, edx
	jg	SHORT $LN3@kvz_bitstr
	neg	edx
	add	edx, edx

; 270  :   kvz_bitstream_put_ue(stream, code_num);

	jmp	kvz_bitstream_put_ue
$LN3@kvz_bitstr:

; 268  :   // Map positive values to even and negative to odd values.
; 269  :   uint32_t code_num = data <= 0 ? (-data) << 1 : (data << 1) - 1;

	lea	edx, DWORD PTR [rdx*2-1]

; 270  :   kvz_bitstream_put_ue(stream, code_num);

	jmp	kvz_bitstream_put_ue
kvz_bitstream_put_se ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 48
kvz_bitstream_add_rbsp_trailing_bits PROC

; 277  : {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H

; 278  :   kvz_bitstream_put(stream, 1, 1);

	mov	r8b, 1
	mov	edx, 1
	mov	rbx, rcx
	call	kvz_bitstream_put

; 279  :   if ((stream->cur_bit & 7) != 0) {

	movzx	ecx, BYTE PTR [rbx+25]
	and	cl, 7
	je	SHORT $LN2@kvz_bitstr

; 280  :     kvz_bitstream_put(stream, 0, 8 - (stream->cur_bit & 7));

	mov	r8d, 8
	xor	edx, edx
	sub	r8b, cl
	mov	rcx, rbx

; 281  :   }
; 282  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 280  :     kvz_bitstream_put(stream, 0, 8 - (stream->cur_bit & 7));

	jmp	kvz_bitstream_put
$LN2@kvz_bitstr:

; 281  :   }
; 282  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
kvz_bitstream_add_rbsp_trailing_bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 48
kvz_bitstream_align PROC

; 288  : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 289  :   if ((stream->cur_bit & 7) != 0) {

	test	BYTE PTR [rcx+25], 7
	mov	rbx, rcx
	je	SHORT $LN5@kvz_bitstr

; 278  :   kvz_bitstream_put(stream, 1, 1);

	mov	r8b, 1
	mov	edx, 1
	call	kvz_bitstream_put

; 279  :   if ((stream->cur_bit & 7) != 0) {

	movzx	ecx, BYTE PTR [rbx+25]
	and	cl, 7
	je	SHORT $LN5@kvz_bitstr

; 280  :     kvz_bitstream_put(stream, 0, 8 - (stream->cur_bit & 7));

	mov	r8d, 8
	xor	edx, edx
	sub	r8b, cl
	mov	rcx, rbx

; 290  :     kvz_bitstream_add_rbsp_trailing_bits(stream);
; 291  :   }
; 292  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 280  :     kvz_bitstream_put(stream, 0, 8 - (stream->cur_bit & 7));

	jmp	kvz_bitstream_put
$LN5@kvz_bitstr:

; 290  :     kvz_bitstream_add_rbsp_trailing_bits(stream);
; 291  :   }
; 292  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
kvz_bitstream_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
_TEXT	SEGMENT
stream$ = 8
kvz_bitstream_align_zero PROC

; 299  :   if ((stream->cur_bit & 7) != 0) {

	movzx	edx, BYTE PTR [rcx+25]
	and	dl, 7
	je	SHORT $LN2@kvz_bitstr

; 300  :     kvz_bitstream_put(stream, 0, 8 - (stream->cur_bit & 7));

	mov	r8d, 8
	sub	r8b, dl
	xor	edx, edx
	jmp	kvz_bitstream_put
$LN2@kvz_bitstr:

; 301  :   }
; 302  : }

	ret	0
kvz_bitstream_align_zero ENDP
_TEXT	ENDS
END
