; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+2
?offsets@?3??search_intra_rough@@9@9 DB 02H		; `search_intra_rough'::`4'::offsets
	DB	04H
	DB	08H
	DB	08H
cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
PUBLIC	kvz_search_intra_chroma_rdo
PUBLIC	kvz_search_cu_intra
PUBLIC	kvz_chroma_mode_bits
PUBLIC	kvz_search_cu_intra_chroma
PUBLIC	kvz_luma_mode_bits
pdata	SEGMENT
$pdata$kvz_search_intra_chroma_rdo DD imagerel $LN20
	DD	imagerel $LN20+41
	DD	imagerel $unwind$kvz_search_intra_chroma_rdo
$pdata$2$kvz_search_intra_chroma_rdo DD imagerel $LN20+41
	DD	imagerel $LN20+148
	DD	imagerel $chain$2$kvz_search_intra_chroma_rdo
$pdata$6$kvz_search_intra_chroma_rdo DD imagerel $LN20+148
	DD	imagerel $LN20+431
	DD	imagerel $chain$6$kvz_search_intra_chroma_rdo
$pdata$7$kvz_search_intra_chroma_rdo DD imagerel $LN20+431
	DD	imagerel $LN20+468
	DD	imagerel $chain$7$kvz_search_intra_chroma_rdo
$pdata$8$kvz_search_intra_chroma_rdo DD imagerel $LN20+468
	DD	imagerel $LN20+483
	DD	imagerel $chain$8$kvz_search_intra_chroma_rdo
$pdata$search_intra_rdo DD imagerel search_intra_rdo
	DD	imagerel search_intra_rdo+46
	DD	imagerel $unwind$search_intra_rdo
$pdata$0$search_intra_rdo DD imagerel search_intra_rdo+46
	DD	imagerel search_intra_rdo+54
	DD	imagerel $chain$0$search_intra_rdo
$pdata$2$search_intra_rdo DD imagerel search_intra_rdo+54
	DD	imagerel search_intra_rdo+389
	DD	imagerel $chain$2$search_intra_rdo
$pdata$4$search_intra_rdo DD imagerel search_intra_rdo+389
	DD	imagerel search_intra_rdo+1030
	DD	imagerel $chain$4$search_intra_rdo
$pdata$5$search_intra_rdo DD imagerel search_intra_rdo+1030
	DD	imagerel search_intra_rdo+1054
	DD	imagerel $chain$5$search_intra_rdo
$pdata$6$search_intra_rdo DD imagerel search_intra_rdo+1054
	DD	imagerel search_intra_rdo+1171
	DD	imagerel $chain$6$search_intra_rdo
$pdata$7$search_intra_rdo DD imagerel search_intra_rdo+1171
	DD	imagerel search_intra_rdo+1307
	DD	imagerel $chain$7$search_intra_rdo
$pdata$search_intra_rough DD imagerel search_intra_rough
	DD	imagerel search_intra_rough+48
	DD	imagerel $unwind$search_intra_rough
$pdata$2$search_intra_rough DD imagerel search_intra_rough+48
	DD	imagerel search_intra_rough+1703
	DD	imagerel $chain$2$search_intra_rough
$pdata$3$search_intra_rough DD imagerel search_intra_rough+1703
	DD	imagerel search_intra_rough+2119
	DD	imagerel $chain$3$search_intra_rough
$pdata$4$search_intra_rough DD imagerel search_intra_rough+2119
	DD	imagerel search_intra_rough+2334
	DD	imagerel $chain$4$search_intra_rough
$pdata$search_intra_chroma_rough DD imagerel search_intra_chroma_rough
	DD	imagerel search_intra_chroma_rough+18
	DD	imagerel $unwind$search_intra_chroma_rough
$pdata$4$search_intra_chroma_rough DD imagerel search_intra_chroma_rough+18
	DD	imagerel search_intra_chroma_rough+688
	DD	imagerel $chain$4$search_intra_chroma_rough
$pdata$5$search_intra_chroma_rough DD imagerel search_intra_chroma_rough+688
	DD	imagerel search_intra_chroma_rough+777
	DD	imagerel $chain$5$search_intra_chroma_rough
$pdata$search_intra_trdepth DD imagerel search_intra_trdepth
	DD	imagerel search_intra_trdepth+1478
	DD	imagerel $unwind$search_intra_trdepth
$pdata$get_cost_dual DD imagerel get_cost_dual
	DD	imagerel get_cost_dual+143
	DD	imagerel $unwind$get_cost_dual
$pdata$0$get_cost_dual DD imagerel get_cost_dual+143
	DD	imagerel get_cost_dual+359
	DD	imagerel $chain$0$get_cost_dual
$pdata$1$get_cost_dual DD imagerel get_cost_dual+359
	DD	imagerel get_cost_dual+385
	DD	imagerel $chain$1$get_cost_dual
$pdata$get_cost DD imagerel get_cost
	DD	imagerel get_cost+241
	DD	imagerel $unwind$get_cost
$pdata$kvz_search_cu_intra DD imagerel $LN74
	DD	imagerel $LN74+1133
	DD	imagerel $unwind$kvz_search_cu_intra
$pdata$kvz_search_cu_intra_chroma DD imagerel $LN43
	DD	imagerel $LN43+595
	DD	imagerel $unwind$kvz_search_cu_intra_chroma
$pdata$2$kvz_search_cu_intra_chroma DD imagerel $LN43+595
	DD	imagerel $LN43+646
	DD	imagerel $chain$2$kvz_search_cu_intra_chroma
$pdata$3$kvz_search_cu_intra_chroma DD imagerel $LN43+646
	DD	imagerel $LN43+875
	DD	imagerel $chain$3$kvz_search_cu_intra_chroma
$pdata$4$kvz_search_cu_intra_chroma DD imagerel $LN43+875
	DD	imagerel $LN43+885
	DD	imagerel $chain$4$kvz_search_cu_intra_chroma
$pdata$5$kvz_search_cu_intra_chroma DD imagerel $LN43+885
	DD	imagerel $LN43+927
	DD	imagerel $chain$5$kvz_search_cu_intra_chroma
xdata	SEGMENT
$unwind$kvz_search_intra_chroma_rdo DD 051301H
	DD	0140113H
	DD	0e00af00cH
	DD	05008H
$chain$2$kvz_search_intra_chroma_rdo DD 062321H
	DD	086823H
	DD	012d417H
	DD	013c404H
	DD	imagerel $LN20
	DD	imagerel $LN20+41
	DD	imagerel $unwind$kvz_search_intra_chroma_rdo
$chain$6$kvz_search_intra_chroma_rdo DD 081b21H
	DD	07781bH
	DD	01a740eH
	DD	0196408H
	DD	0183404H
	DD	imagerel $LN20+41
	DD	imagerel $LN20+148
	DD	imagerel $chain$2$kvz_search_intra_chroma_rdo
$chain$7$kvz_search_intra_chroma_rdo DD 021H
	DD	imagerel $LN20+41
	DD	imagerel $LN20+148
	DD	imagerel $chain$2$kvz_search_intra_chroma_rdo
$chain$8$kvz_search_intra_chroma_rdo DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+41
	DD	imagerel $unwind$kvz_search_intra_chroma_rdo
$unwind$search_intra_rdo DD 072801H
	DD	021a0128H
	DD	0d019e01bH
	DD	06015c017H
	DD	03014H
$chain$0$search_intra_rdo DD 020821H
	DD	02195408H
	DD	imagerel search_intra_rdo
	DD	imagerel search_intra_rdo+46
	DD	imagerel $unwind$search_intra_rdo
$chain$2$search_intra_rdo DD 041021H
	DD	0217f410H
	DD	02187408H
	DD	imagerel search_intra_rdo+46
	DD	imagerel search_intra_rdo+54
	DD	imagerel $chain$0$search_intra_rdo
$chain$4$search_intra_rdo DD 042b21H
	DD	0109782bH
	DD	010a6808H
	DD	imagerel search_intra_rdo+54
	DD	imagerel search_intra_rdo+389
	DD	imagerel $chain$2$search_intra_rdo
$chain$5$search_intra_rdo DD 021H
	DD	imagerel search_intra_rdo+54
	DD	imagerel search_intra_rdo+389
	DD	imagerel $chain$2$search_intra_rdo
$chain$6$search_intra_rdo DD 021H
	DD	imagerel search_intra_rdo+46
	DD	imagerel search_intra_rdo+54
	DD	imagerel $chain$0$search_intra_rdo
$chain$7$search_intra_rdo DD 021H
	DD	imagerel search_intra_rdo
	DD	imagerel search_intra_rdo+46
	DD	imagerel $unwind$search_intra_rdo
$unwind$search_intra_rough DD 0b2501H
	DD	01ad3425H
	DD	01a40125H
	DD	0e01cf01eH
	DD	0c018d01aH
	DD	060157016H
	DD	05014H
$chain$2$search_intra_rough DD 061121H
	DD	0ce9811H
	DD	0cf880cH
	DD	0d16804H
	DD	imagerel search_intra_rough
	DD	imagerel search_intra_rough+48
	DD	imagerel $unwind$search_intra_rough
$chain$3$search_intra_rough DD 020821H
	DD	0d07808H
	DD	imagerel search_intra_rough+48
	DD	imagerel search_intra_rough+1703
	DD	imagerel $chain$2$search_intra_rough
$chain$4$search_intra_rough DD 021H
	DD	imagerel search_intra_rough
	DD	imagerel search_intra_rough+48
	DD	imagerel $unwind$search_intra_rough
$unwind$search_intra_chroma_rough DD 051201H
	DD	01140112H
	DD	07009f00bH
	DD	03008H
$chain$4$search_intra_chroma_rough DD 0a8d21H
	DD	011bc48dH
	DD	0112e416H
	DD	0113d412H
	DD	011a640bH
	DD	01195404H
	DD	imagerel search_intra_chroma_rough
	DD	imagerel search_intra_chroma_rough+18
	DD	imagerel $unwind$search_intra_chroma_rough
$chain$5$search_intra_chroma_rough DD 021H
	DD	imagerel search_intra_chroma_rough
	DD	imagerel search_intra_chroma_rough+18
	DD	imagerel $unwind$search_intra_chroma_rough
$unwind$search_intra_trdepth DD 0f3101H
	DD	0c67831H
	DD	0c7682aH
	DD	01983420H
	DD	01900120H
	DD	0e017f019H
	DD	0c013d015H
	DD	060107011H
	DD	0500fH
$unwind$get_cost_dual DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
$chain$0$get_cost_dual DD 020521H
	DD	036805H
	DD	imagerel get_cost_dual
	DD	imagerel get_cost_dual+143
	DD	imagerel $unwind$get_cost_dual
$chain$1$get_cost_dual DD 021H
	DD	imagerel get_cost_dual
	DD	imagerel get_cost_dual+143
	DD	imagerel $unwind$get_cost_dual
$unwind$get_cost DD 0a1f01H
	DD	02781fH
	DD	036817H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
$unwind$kvz_search_cu_intra DD 0a2e01H
	DD	05b012eH
	DD	0e01df01fH
	DD	0c019d01bH
	DD	060167017H
	DD	050143015H
$unwind$kvz_search_cu_intra_chroma DD 0c9c01H
	DD	061649cH
	DD	0623494H
	DD	0630122H
	DD	0e011f013H
	DD	0c00dd00fH
	DD	0500a700bH
$chain$2$kvz_search_cu_intra_chroma DD 020821H
	DD	02f6808H
	DD	imagerel $LN43
	DD	imagerel $LN43+595
	DD	imagerel $unwind$kvz_search_cu_intra_chroma
$chain$3$kvz_search_cu_intra_chroma DD 020821H
	DD	02e7808H
	DD	imagerel $LN43+595
	DD	imagerel $LN43+646
	DD	imagerel $chain$2$kvz_search_cu_intra_chroma
$chain$4$kvz_search_cu_intra_chroma DD 021H
	DD	imagerel $LN43+595
	DD	imagerel $LN43+646
	DD	imagerel $chain$2$kvz_search_cu_intra_chroma
$chain$5$kvz_search_cu_intra_chroma DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+595
	DD	imagerel $unwind$kvz_search_cu_intra_chroma
	ORG $+2
$SG4294942676 DB 'l', 00H, 'o', 00H, 'g', 00H, '2', 00H, '_', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '2', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, '2', 00H, '_', 00H, 'w', 00H, 'i'
	DB	00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '5', 00H, 00H, 00H
	ORG $+10
$SG4294942677 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '_', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'r', 00H, 'a', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294942678 DB '!', 00H, '(', 00H, 'x', 00H, '_', 00H, 'p', 00H, 'x', 00H
	DB	' ', 00H, '&', 00H, ' ', 00H, '4', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'y', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H
	DB	'&', 00H, ' ', 00H, '4', 00H, ')', 00H, 00H, 00H
	ORG $+8
$SG4294942679 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '_', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'r', 00H, 'a', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294942680 DB 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, 'T', 00H, 'R', 00H, '_', 00H, 'M'
	DB	00H, 'A', 00H, 'X', 00H, '_', 00H, 'W', 00H, 'I', 00H, 'D', 00H
	DB	'T', 00H, 'H', 00H, 00H, 00H
	ORG $+12
$SG4294942681 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '_', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'r', 00H, 'a', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+10
$SG4294942682 DB 'd', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'd', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'M', 00H, 'A', 00H, 'X'
	DB	00H, '_', 00H, 'P', 00H, 'U', 00H, '_', 00H, 'D', 00H, 'E', 00H
	DB	'P', 00H, 'T', 00H, 'H', 00H, 00H, 00H
	ORG $+8
$SG4294942683 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '_', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'r', 00H, 'a', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
state$ = 8
luma_mode$ = 16
intra_preds$ = 24
kvz_luma_mode_bits PROC

; 645  :   double mode_bits;
; 646  : 
; 647  :   bool mode_in_preds = false;
; 648  :   for (int i = 0; i < 3; ++i) {
; 649  :     if (luma_mode == intra_preds[i]) {

	movzx	r11d, BYTE PTR [r8]
	movzx	r10d, dl
	cmp	dl, r11b
	sete	al
	cmp	dl, BYTE PTR [r8+1]
	movzx	r9d, al
	mov	eax, 1
	cmove	r9d, eax
	cmp	dl, BYTE PTR [r8+2]
	lea	rdx, OFFSET FLAT:kvz_f_entropy_bits
	jne	SHORT $LN14@kvz_luma_m

; 650  :       mode_in_preds = true;

	movzx	eax, BYTE PTR [rcx+173]
	xor	rax, 1
	movss	xmm0, DWORD PTR [rdx+rax*4]
	cvtps2pd xmm0, xmm0
	jmp	SHORT $LN17@kvz_luma_m
$LN14@kvz_luma_m:

; 651  :     }
; 652  :   }
; 653  : 
; 654  :   const cabac_ctx_t *ctx = &(state->cabac.ctx.intra_mode_model);
; 655  :   mode_bits = CTX_ENTROPY_FBITS(ctx, mode_in_preds);

	movzx	ecx, BYTE PTR [rcx+173]
	movzx	eax, r9b
	xor	rcx, rax
	movss	xmm0, DWORD PTR [rdx+rcx*4]
	cvtps2pd xmm0, xmm0

; 656  : 
; 657  :   if (mode_in_preds) {

	test	r9b, r9b
	je	SHORT $LN6@kvz_luma_m
$LN17@kvz_luma_m:

; 658  :     mode_bits += ((luma_mode == intra_preds[0]) ? 1 : 2);

	xor	eax, eax
	cmp	r10b, r11b
	setne	al
	inc	eax
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1

; 661  :   }
; 662  : 
; 663  :   return mode_bits;

	addsd	xmm0, xmm1

; 664  : }

	ret	0
$LN6@kvz_luma_m:

; 659  :   } else {
; 660  :     mode_bits += 5;

	movsd	xmm1, QWORD PTR __real@4014000000000000

; 661  :   }
; 662  : 
; 663  :   return mode_bits;

	addsd	xmm0, xmm1

; 664  : }

	ret	0
kvz_luma_mode_bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
chroma$2 = 96
luma_px$3 = 96
modes_in_depth$ = 96
tr_cu$1$ = 112
pic_px$4 = 112
best_chroma$5 = 128
costs$ = 144
refs_v$6 = 192
refs_u$7 = 464
lcu_px$1$sroa$481$1$ = 848
state$ = 848
x_px$ = 856
y_px$ = 864
lcu_px$1$sroa$482$1$ = 872
depth$ = 872
modes$ = 880
lcu$ = 880
kvz_search_cu_intra_chroma PROC

; 729  : {

$LN43:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-536]
	sub	rsp, 792				; 00000318H

; 730  :   const vector2d_t lcu_px = { SUB_SCU(x_px), SUB_SCU(y_px) };
; 731  : 
; 732  :   cu_info_t *cur_pu = LCU_GET_CU_AT_PX(lcu, lcu_px.x, lcu_px.y);
; 733  :   int8_t intra_mode = cur_pu->intra.mode;

	mov	r15, QWORD PTR lcu$[rbp-256]
	mov	r14, rcx
	mov	ecx, edx
	movsxd	r13, r9d
	and	ecx, 63					; 0000003fH

; 734  : 
; 735  :   double costs[5];
; 736  :   int8_t modes[5] = { 0, 26, 10, 1, 34 };

	mov	DWORD PTR modes$[rbp-256], 17439232	; 010a1a00H
	mov	eax, r8d
	mov	DWORD PTR lcu_px$1$sroa$481$1$[rbp-256], ecx
	and	eax, 63					; 0000003fH
	mov	BYTE PTR modes$[rbp-252], 34		; 00000022H
	mov	DWORD PTR lcu_px$1$sroa$482$1$[rbp-256], eax
	shr	eax, 2
	imul	edi, eax, 17
	mov	eax, ecx
	shr	eax, 2
	add	edi, eax
	lea	rcx, QWORD PTR [rdi+rdi*4]
	movsx	r12d, BYTE PTR [r15+rcx*4+25344]

; 737  :   if (intra_mode != 0 && intra_mode != 26 && intra_mode != 10 && intra_mode != 1) {

	cmp	r12b, 26
	ja	SHORT $LN38@kvz_search
	mov	ecx, 67109891				; 04000403H
	bt	ecx, r12d
	jb	SHORT $LN2@kvz_search
$LN38@kvz_search:

; 738  :     modes[4] = intra_mode;

	mov	BYTE PTR modes$[rbp-252], r12b
$LN2@kvz_search:

; 747  : 
; 748  :   if (state->encoder_control->cfg.rdo == 3) {

	mov	rax, QWORD PTR [r14]
	mov	QWORD PTR [rsp+784], rbx
	mov	QWORD PTR [rsp+776], rsi
	mov	DWORD PTR modes_in_depth$[rsp], 16843009 ; 01010101H
	cmp	DWORD PTR [rax+64], 3
	mov	BYTE PTR modes_in_depth$[rsp+4], 2
	jne	SHORT $LN33@kvz_search

; 749  :     num_modes = 5;

	mov	esi, 5
	jmp	$LN37@kvz_search
$LN33@kvz_search:

; 739  :   }
; 740  : 
; 741  :   // The number of modes to select for slower chroma search. Luma mode
; 742  :   // is always one of the modes, so 2 means the final decision is made
; 743  :   // between luma mode and one other mode that looks the best
; 744  :   // according to search_intra_chroma_rough.
; 745  :   const int8_t modes_in_depth[5] = { 1, 1, 1, 1, 2 };
; 746  :   int num_modes = modes_in_depth[depth];

	movsx	esi, BYTE PTR modes_in_depth$[rsp+r13]

; 750  :   }
; 751  : 
; 752  :   // Don't do rough mode search if all modes are selected.
; 753  :   // FIXME: It might make more sense to only disable rough search if
; 754  :   // num_modes is 0.is 0.
; 755  :   if (num_modes != 1 && num_modes != 5) {

	lea	eax, DWORD PTR [rsi-1]
	test	eax, -5					; fffffffbH
	je	$LN4@kvz_search

; 756  :     const int_fast8_t log2_width_c = MAX(LOG2_LCU_WIDTH - depth - 1, 2);

	mov	ebx, 5
	mov	eax, ebx
	sub	eax, r13d
	cmp	eax, 2
	jle	SHORT $LN7@kvz_search
	sub	bl, r13b
	jmp	SHORT $LN8@kvz_search
$LN7@kvz_search:
	mov	bl, 2
$LN8@kvz_search:

; 757  :     const vector2d_t pic_px = { state->tile->frame->width, state->tile->frame->height };

	mov	rax, QWORD PTR [r14+48]

; 758  :     const vector2d_t luma_px = { x_px, y_px };

	mov	DWORD PTR luma_px$3[rsp], edx
	mov	DWORD PTR luma_px$3[rsp+4], r8d
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR pic_px$4[rsp], eax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR pic_px$4[rsp+4], eax
	test	edx, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 554  :   if (luma_px->x > 0 && luma_px->y > 0) {

	jle	SHORT $LN10@kvz_search
	test	r8d, r8d
	jle	SHORT $LN10@kvz_search

; 555  :     kvz_intra_build_reference_inner(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs_u$7[rbp-256]
	mov	edx, 1
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$4[rsp]
	lea	r8, QWORD PTR luma_px$3[rsp]
	mov	QWORD PTR [rsp+32], r15
	movzx	ecx, bl
	call	kvz_intra_build_reference_inner

; 556  :   } else {

	jmp	SHORT $LN11@kvz_search
$LN10@kvz_search:

; 557  :     kvz_intra_build_reference_any(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs_u$7[rbp-256]
	mov	edx, 1
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$4[rsp]
	lea	r8, QWORD PTR luma_px$3[rsp]
	mov	QWORD PTR [rsp+32], r15
	movzx	ecx, bl
	call	kvz_intra_build_reference_any
$LN11@kvz_search:

; 554  :   if (luma_px->x > 0 && luma_px->y > 0) {

	cmp	DWORD PTR luma_px$3[rsp], 0
	jle	SHORT $LN14@kvz_search
	cmp	DWORD PTR luma_px$3[rsp+4], 0
	jle	SHORT $LN14@kvz_search

; 555  :     kvz_intra_build_reference_inner(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs_v$6[rbp-256]
	mov	edx, 2
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$4[rsp]
	lea	r8, QWORD PTR luma_px$3[rsp]
	mov	QWORD PTR [rsp+32], r15
	movzx	ecx, bl
	call	kvz_intra_build_reference_inner

; 556  :   } else {

	jmp	SHORT $LN15@kvz_search
$LN14@kvz_search:

; 557  :     kvz_intra_build_reference_any(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs_v$6[rbp-256]
	mov	edx, 2
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$4[rsp]
	lea	r8, QWORD PTR luma_px$3[rsp]
	mov	QWORD PTR [rsp+32], r15
	movzx	ecx, bl
	call	kvz_intra_build_reference_any
$LN15@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 766  :     vector2d_t lcu_cpx = { lcu_px.x / 2, lcu_px.y / 2 };

	mov	eax, DWORD PTR lcu_px$1$sroa$481$1$[rbp-256]

; 767  :     kvz_pixel *ref_u = &lcu->ref.u[lcu_cpx.x + lcu_cpx.y * LCU_WIDTH_C];

	lea	rdx, QWORD PTR [r15+4488]
	mov	ecx, DWORD PTR lcu_px$1$sroa$482$1$[rbp-256]

; 768  :     kvz_pixel *ref_v = &lcu->ref.v[lcu_cpx.x + lcu_cpx.y * LCU_WIDTH_C];
; 769  : 
; 770  :     search_intra_chroma_rough(state, x_px, y_px, depth,

	mov	r9d, r13d
	mov	r8d, DWORD PTR y_px$[rbp-256]
	shr	eax, 1
	shr	ecx, 1
	shl	ecx, 5
	add	eax, ecx
	lea	rcx, QWORD PTR [r15+5512]
	add	rdx, rax
	add	rcx, rax
	lea	rax, QWORD PTR costs$[rbp-256]
	mov	QWORD PTR [rsp+88], rax
	lea	rax, QWORD PTR modes$[rbp-256]
	mov	QWORD PTR [rsp+80], rax
	lea	rax, QWORD PTR refs_v$6[rbp-256]
	mov	BYTE PTR [rsp+72], r12b
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR refs_u$7[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+40], rcx
	mov	QWORD PTR [rsp+32], rdx
	mov	edx, DWORD PTR x_px$[rbp-256]
	call	search_intra_chroma_rough
	mov	r8d, DWORD PTR y_px$[rbp-256]
	mov	edx, DWORD PTR x_px$[rbp-256]
$LN4@kvz_search:

; 771  :                               ref_u, ref_v, LCU_WIDTH_C,
; 772  :                               &refs_u, &refs_v,
; 773  :                               intra_mode, modes, costs);
; 774  :   }
; 775  : 
; 776  :   int8_t intra_mode_chroma = intra_mode;
; 777  :   if (num_modes > 1) {

	cmp	esi, 1
	jle	$LN41@kvz_search
$LN37@kvz_search:
	mov	eax, edx
	or	eax, r8d
	test	al, 4

; 687  :   const bool reconstruct_chroma = !(x_px & 4 || y_px & 4);

	jne	$LN21@kvz_search

; 691  :     cu_info_t *const tr_cu = LCU_GET_CU_AT_PX(lcu, lcu_px.x, lcu_px.y);

	lea	eax, DWORD PTR [rdi+18]
	movaps	XMMWORD PTR [rsp+752], xmm6

; 692  : 
; 693  :     struct {
; 694  :       double cost;
; 695  :       int8_t mode;
; 696  :     } chroma, best_chroma;
; 697  : 
; 698  :     best_chroma.mode = 0;
; 699  :     best_chroma.cost = MAX_INT;

	movsd	xmm6, QWORD PTR __real@41dfffffffc00000
	mov	ecx, eax
	add	rax, 1561				; 00000619H
	lea	rax, QWORD PTR [rcx+rax*4]
	lea	rax, QWORD PTR [r15+rax*4]
	mov	QWORD PTR tr_cu$1$[rsp], rax
	xor	al, al
	mov	BYTE PTR best_chroma$5[rbp-248], al

; 700  : 
; 701  :     for (int8_t chroma_mode_i = 0; chroma_mode_i < num_modes; ++chroma_mode_i) {

	test	sil, sil
	jle	$LN19@kvz_search

; 688  : 
; 689  :   if (reconstruct_chroma) {
; 690  :     const vector2d_t lcu_px = { SUB_SCU(x_px), SUB_SCU(y_px) };

	movaps	XMMWORD PTR [rsp+736], xmm7
	lea	rdi, QWORD PTR modes$[rbp-256]
	movsd	xmm7, QWORD PTR __real@4000000000000000
	movzx	esi, sil
$LL20@kvz_search:

; 702  :       chroma.mode = modes[chroma_mode_i];

	movzx	ebx, BYTE PTR [rdi]

; 703  : 
; 704  :       kvz_intra_recon_cu(state,

	mov	r9d, r13d
	mov	QWORD PTR [rsp+56], r15
	mov	rcx, r14
	mov	QWORD PTR [rsp+48], 0
	mov	BYTE PTR [rsp+40], bl
	mov	BYTE PTR [rsp+32], -1
	mov	BYTE PTR chroma$2[rsp+8], bl
	call	kvz_intra_recon_cu

; 705  :                          x_px, y_px,
; 706  :                          depth,
; 707  :                          -1, chroma.mode, // skip luma
; 708  :                          NULL, lcu);
; 709  :       chroma.cost = kvz_cu_rd_cost_chroma(state, lcu_px.x, lcu_px.y, depth, tr_cu, lcu);

	mov	rax, QWORD PTR tr_cu$1$[rsp]
	mov	r9d, r13d
	mov	r8d, DWORD PTR lcu_px$1$sroa$482$1$[rbp-256]
	mov	rcx, r14
	mov	edx, DWORD PTR lcu_px$1$sroa$481$1$[rbp-256]
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rax
	call	kvz_cu_rd_cost_chroma

; 669  :   const cabac_ctx_t *ctx = &(state->cabac.ctx.chroma_pred_model[0]);

	movzx	eax, BYTE PTR [r14+174]

; 670  :   double mode_bits;
; 671  :   if (chroma_mode == luma_mode) {

	lea	rcx, OFFSET FLAT:kvz_f_entropy_bits
	cmp	bl, r12b
	jne	SHORT $LN27@kvz_search
	movss	xmm1, DWORD PTR [rcx+rax*4]

; 672  :     mode_bits = CTX_ENTROPY_FBITS(ctx, 0);

	cvtps2pd xmm1, xmm1

; 673  :   } else {

	jmp	SHORT $LN28@kvz_search
$LN27@kvz_search:

; 674  :     mode_bits = 2.0 + CTX_ENTROPY_FBITS(ctx, 1);

	xor	rax, 1
	movss	xmm1, DWORD PTR [rcx+rax*4]
	cvtps2pd xmm1, xmm1
	addsd	xmm1, xmm7
$LN28@kvz_search:

; 712  :       chroma.cost += mode_bits * state->lambda;

	mulsd	xmm1, QWORD PTR [r14+368]
	addsd	xmm0, xmm1
	comisd	xmm0, xmm6
	movsd	QWORD PTR chroma$2[rsp], xmm0

; 713  : 
; 714  :       if (chroma.cost < best_chroma.cost) {

	jae	SHORT $LN18@kvz_search

; 715  :         best_chroma = chroma;

	movaps	xmm0, XMMWORD PTR chroma$2[rsp]
	movaps	xmm6, xmm0
	movdqa	XMMWORD PTR best_chroma$5[rbp-256], xmm0
$LN18@kvz_search:

; 700  : 
; 701  :     for (int8_t chroma_mode_i = 0; chroma_mode_i < num_modes; ++chroma_mode_i) {

	mov	r8d, DWORD PTR y_px$[rbp-256]
	inc	rdi
	mov	edx, DWORD PTR x_px$[rbp-256]
	sub	rsi, 1
	jne	$LL20@kvz_search
	movzx	eax, BYTE PTR best_chroma$5[rbp-248]
	movaps	xmm7, XMMWORD PTR [rsp+736]
$LN19@kvz_search:

; 778  :     intra_mode_chroma = kvz_search_intra_chroma_rdo(state, x_px, y_px, depth, intra_mode, modes, num_modes, lcu);
; 779  :   }
; 780  : 
; 781  :   return intra_mode_chroma;

	movaps	xmm6, XMMWORD PTR [rsp+752]

; 719  :     return best_chroma.mode;

	jmp	SHORT $LN17@kvz_search
$LN21@kvz_search:

; 778  :     intra_mode_chroma = kvz_search_intra_chroma_rdo(state, x_px, y_px, depth, intra_mode, modes, num_modes, lcu);
; 779  :   }
; 780  : 
; 781  :   return intra_mode_chroma;

	mov	al, 100					; 00000064H
	jmp	SHORT $LN17@kvz_search
$LN41@kvz_search:
	movzx	eax, r12b
$LN17@kvz_search:
	mov	rsi, QWORD PTR [rsp+776]

; 782  : }

	mov	rbx, QWORD PTR [rsp+784]
	add	rsp, 792				; 00000318H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
kvz_search_cu_intra_chroma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
state$ = 8
chroma_mode$ = 16
luma_mode$ = 24
kvz_chroma_mode_bits PROC

; 669  :   const cabac_ctx_t *ctx = &(state->cabac.ctx.chroma_pred_model[0]);

	movzx	eax, BYTE PTR [rcx+174]

; 670  :   double mode_bits;
; 671  :   if (chroma_mode == luma_mode) {

	lea	rcx, OFFSET FLAT:kvz_f_entropy_bits
	cmp	dl, r8b
	jne	SHORT $LN2@kvz_chroma

; 672  :     mode_bits = CTX_ENTROPY_FBITS(ctx, 0);

	movss	xmm0, DWORD PTR [rcx+rax*4]
	cvtps2pd xmm0, xmm0

; 675  :   }
; 676  : 
; 677  :   return mode_bits;
; 678  : }

	ret	0
$LN2@kvz_chroma:

; 673  :   } else {
; 674  :     mode_bits = 2.0 + CTX_ENTROPY_FBITS(ctx, 1);

	xor	rax, 1
	movss	xmm0, DWORD PTR [rcx+rax*4]
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@4000000000000000

; 675  :   }
; 676  : 
; 677  :   return mode_bits;
; 678  : }

	ret	0
kvz_chroma_mode_bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
pic_px$1 = 96
luma_px$2 = 104
modes$ = 112
costs$ = 160
refs$ = 448
state$ = 800
x_px$ = 808
y_px$ = 816
depth$ = 824
candidate_modes$ = 832
lcu$ = 832
mode_out$ = 840
cost_out$ = 848
kvz_search_cu_intra PROC

; 793  : {

$LN74:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-472]
	sub	rsp, 728				; 000002d8H
	mov	r13, QWORD PTR lcu$[rbp-256]

; 794  :   const vector2d_t lcu_px = { SUB_SCU(x_px), SUB_SCU(y_px) };
; 795  :   const int8_t cu_width = LCU_WIDTH >> depth;
; 796  :   const int_fast8_t log2_width = LOG2_LCU_WIDTH - depth;
; 797  : 
; 798  :   cu_info_t *cur_cu = LCU_GET_CU_AT_PX(lcu, lcu_px.x, lcu_px.y);
; 799  : 
; 800  :   kvz_intra_references refs;
; 801  : 
; 802  :   int8_t candidate_modes[3];
; 803  : 
; 804  :   cu_info_t *left_cu = 0;

	xor	edi, edi
	mov	ebx, r8d
	mov	r15, rcx
	mov	ecx, r9d
	mov	esi, edx
	mov	r12d, 64				; 00000040H
	mov	r14d, 6
	sub	r14b, r9b
	sar	r12d, cl
	and	esi, 63					; 0000003fH
	and	ebx, 63					; 0000003fH
	mov	r10d, r9d
	mov	r11d, r8d
	mov	r8d, edi

; 805  :   cu_info_t *above_cu = 0;

	mov	r9d, edi

; 806  : 
; 807  :   // Select left and top CUs if they are available.
; 808  :   // Top CU is not available across LCU boundary.
; 809  :   if (x_px >= SCU_WIDTH) {

	cmp	edx, 4
	jl	SHORT $LN5@kvz_search

; 810  :     left_cu = LCU_GET_CU_AT_PX(lcu, lcu_px.x - 1, lcu_px.y);

	mov	eax, ebx
	lea	r8, QWORD PTR [r13+24976]
	shr	eax, 2
	imul	ecx, eax, 17
	lea	eax, DWORD PTR [rsi-1]
	sar	eax, 2
	add	eax, 18
	add	eax, ecx
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	r8, QWORD PTR [r8+rax*4]
$LN5@kvz_search:

; 811  :   }
; 812  :   if (y_px >= SCU_WIDTH && lcu_px.y > 0) {

	cmp	r11d, 4
	jl	SHORT $LN6@kvz_search
	test	ebx, ebx
	je	SHORT $LN6@kvz_search

; 813  :     above_cu = LCU_GET_CU_AT_PX(lcu, lcu_px.x, lcu_px.y - 1);

	lea	eax, DWORD PTR [rbx-1]
	sar	eax, 2
	lea	r9, QWORD PTR [r13+24976]
	imul	ecx, eax, 17
	mov	eax, esi
	shr	eax, 2
	add	eax, 18
	add	eax, ecx
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	r9, QWORD PTR [r9+rax*4]
$LN6@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 93   :   int8_t left_intra_dir  = 1;

	mov	dl, 1

; 94   :   if (left_pu && left_pu->type == CU_INTRA) {

	test	r8, r8
	je	SHORT $LN22@kvz_search
	movzx	eax, BYTE PTR [r8]
	and	al, 3
	cmp	al, dl
	jne	SHORT $LN22@kvz_search

; 95   :     left_intra_dir = left_pu->intra.mode;

	movzx	edx, BYTE PTR [r8+8]
$LN22@kvz_search:

; 96   :   }
; 97   : 
; 98   :   int8_t above_intra_dir = 1;

	mov	cl, 1

; 99   :   if (above_pu && above_pu->type == CU_INTRA && y % LCU_WIDTH != 0) {

	test	r9, r9
	je	SHORT $LN23@kvz_search
	movzx	eax, BYTE PTR [r9]
	and	al, 3
	cmp	al, cl
	jne	SHORT $LN23@kvz_search
	test	ebx, ebx
	je	SHORT $LN23@kvz_search

; 100  :     above_intra_dir = above_pu->intra.mode;

	movzx	ecx, BYTE PTR [r9+8]
$LN23@kvz_search:

; 101  :   }
; 102  : 
; 103  :   // If the predictions are the same, add new predictions
; 104  :   if (left_intra_dir == above_intra_dir) {

	cmp	dl, cl
	jne	SHORT $LN24@kvz_search

; 105  :     if (left_intra_dir > 1) { // angular modes

	cmp	dl, 1
	jle	SHORT $LN26@kvz_search

; 106  :       preds[0] = left_intra_dir;
; 107  :       preds[1] = ((left_intra_dir + 29) % 32) + 2;

	movsx	ecx, dl
	mov	BYTE PTR candidate_modes$[rbp-256], dl
	lea	eax, DWORD PTR [rcx+29]
	and	eax, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN70@kvz_search
	dec	eax
	or	eax, -32				; ffffffffffffffe0H
	inc	eax
$LN70@kvz_search:
	add	al, 2
	mov	BYTE PTR candidate_modes$[rbp-255], al

; 108  :       preds[2] = ((left_intra_dir - 1 ) % 32) + 2;

	lea	eax, DWORD PTR [rcx-1]
	and	eax, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN69@kvz_search
	dec	eax
	or	eax, -32				; ffffffffffffffe0H
	inc	eax
$LN69@kvz_search:
	add	al, 2

; 109  :     } else { //non-angular

	jmp	SHORT $LN71@kvz_search
$LN26@kvz_search:

; 110  :       preds[0] = 0;//PLANAR_IDX;

	mov	WORD PTR candidate_modes$[rbp-256], 256	; 00000100H

; 111  :       preds[1] = 1;//DC_IDX;
; 112  :       preds[2] = 26;//VER_IDX;

	mov	BYTE PTR candidate_modes$[rbp-254], 26

; 113  :     }
; 114  :   } else { // If we have two distinct predictions

	jmp	SHORT $LN29@kvz_search
$LN24@kvz_search:

; 115  :     preds[0] = left_intra_dir;

	mov	BYTE PTR candidate_modes$[rbp-256], dl

; 116  :     preds[1] = above_intra_dir;

	mov	BYTE PTR candidate_modes$[rbp-255], cl

; 117  : 
; 118  :     // add planar mode if it's not yet present
; 119  :     if (left_intra_dir && above_intra_dir ) {

	test	dl, dl
	je	SHORT $LN28@kvz_search
	test	cl, cl
	je	SHORT $LN28@kvz_search

; 120  :       preds[2] = 0; // PLANAR_IDX;

	mov	BYTE PTR candidate_modes$[rbp-254], dil

; 121  :     } else {  // Add DC mode if it's not present, otherwise 26.

	jmp	SHORT $LN29@kvz_search
$LN28@kvz_search:

; 122  :       preds[2] =  (left_intra_dir+above_intra_dir)<2? 26 : 1;

	movsx	eax, dl
	mov	edx, 26
	movsx	ecx, cl
	add	ecx, eax
	mov	eax, 1
	cmp	ecx, 2
	cmovl	eax, edx
$LN71@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 817  :   if (depth > 0) {

	mov	BYTE PTR candidate_modes$[rbp-254], al
$LN29@kvz_search:
	test	r10d, r10d
	jle	$LN33@kvz_search

; 818  :     const vector2d_t luma_px = { x_px, y_px };
; 819  :     const vector2d_t pic_px = { state->tile->frame->width, state->tile->frame->height };

	mov	rax, QWORD PTR [r15+48]
	mov	edx, DWORD PTR x_px$[rbp-256]
	mov	DWORD PTR luma_px$2[rsp], edx
	mov	DWORD PTR luma_px$2[rsp+4], r11d
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR pic_px$1[rsp], eax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR pic_px$1[rsp+4], eax
	test	edx, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 554  :   if (luma_px->x > 0 && luma_px->y > 0) {

	jle	SHORT $LN32@kvz_search
	test	r11d, r11d
	jle	SHORT $LN32@kvz_search

; 555  :     kvz_intra_build_reference_inner(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs$[rbp-256]
	xor	edx, edx
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$1[rsp]
	lea	r8, QWORD PTR luma_px$2[rsp]
	mov	QWORD PTR [rsp+32], r13
	movzx	ecx, r14b
	call	kvz_intra_build_reference_inner
$LN72@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 830  :   bool skip_rough_search = (depth == 0 || state->encoder_control->cfg.rdo >= 3);

	shl	ebx, 6
	lea	r15, QWORD PTR [r13+392]
	lea	eax, DWORD PTR [rsi+rbx]
	add	r15, rax
	jmp	SHORT $LN67@kvz_search
$LN32@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 557  :     kvz_intra_build_reference_any(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs$[rbp-256]
	xor	edx, edx
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$1[rsp]
	lea	r8, QWORD PTR luma_px$2[rsp]
	mov	QWORD PTR [rsp+32], r13
	movzx	ecx, r14b
	call	kvz_intra_build_reference_any
	jmp	SHORT $LN72@kvz_search
$LN33@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 827  :   kvz_pixel *ref_pixels = &lcu->ref.y[lcu_px.x + lcu_px.y * LCU_WIDTH];

	shl	ebx, 6
	lea	r15, QWORD PTR [r13+392]
	lea	eax, DWORD PTR [rsi+rbx]
	add	r15, rax

; 830  :   bool skip_rough_search = (depth == 0 || state->encoder_control->cfg.rdo >= 3);

	test	r10d, r10d
	je	SHORT $LN66@kvz_search
$LN67@kvz_search:
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax+64], 3
	jge	SHORT $LN66@kvz_search

; 831  :   if (!skip_rough_search) {
; 832  :     number_of_modes = search_intra_rough(state,

	lea	rdx, QWORD PTR costs$[rbp-256]
	movsx	eax, r14b
	mov	QWORD PTR [rsp+56], rdx
	lea	r9, QWORD PTR refs$[rbp-256]
	lea	rdx, QWORD PTR modes$[rsp]
	xor	sil, sil
	mov	QWORD PTR [rsp+48], rdx
	lea	rdx, QWORD PTR candidate_modes$[rbp-256]
	mov	QWORD PTR [rsp+40], rdx
	mov	rdx, r15
	mov	DWORD PTR [rsp+32], eax
	call	search_intra_rough
	movzx	ebx, al

; 833  :                                          ref_pixels, LCU_WIDTH,
; 834  :                                          &refs,
; 835  :                                          log2_width, candidate_modes,
; 836  :                                          modes, costs);
; 837  :   } else {

	jmp	SHORT $LN3@kvz_search
$LN66@kvz_search:

; 830  :   bool skip_rough_search = (depth == 0 || state->encoder_control->cfg.rdo >= 3);

	mov	sil, 1

; 838  :     number_of_modes = 35;

	lea	rdx, QWORD PTR modes$[rsp]
	mov	bl, 35					; 00000023H
	lea	rax, QWORD PTR costs$[rbp-256]

; 839  :     for (int i = 0; i < number_of_modes; ++i) {

	mov	ecx, edi
	mov	r9, 4746794007244308480			; 41dfffffffc00000H
	mov	r8d, 4
	npad	11
$LL68@kvz_search:

; 838  :     number_of_modes = 35;

	mov	QWORD PTR [rax], r9
	mov	QWORD PTR [rax+8], r9
	mov	QWORD PTR [rax+16], r9
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r9
	mov	QWORD PTR [rax-32], r9
	mov	QWORD PTR [rax-24], r9
	mov	QWORD PTR [rax-16], r9
	mov	QWORD PTR [rax-8], r9
	sub	r8, 1
	jne	SHORT $LL68@kvz_search
	mov	QWORD PTR [rax], r9
	mov	QWORD PTR [rax+8], r9
	mov	QWORD PTR [rax+16], r9
	npad	12
$LL4@kvz_search:

; 840  :       modes[i] = i;

	mov	BYTE PTR [rdx], cl
	lea	rdx, QWORD PTR [rdx+1]
	inc	ecx
	cmp	ecx, 35					; 00000023H
	jl	SHORT $LL4@kvz_search
$LN3@kvz_search:

; 841  :       costs[i] = MAX_INT;
; 842  :     }
; 843  :   }
; 844  : 
; 845  :   // Set transform depth to current depth, meaning no transform splits.
; 846  :   kvz_lcu_fill_trdepth(lcu, x_px, y_px, depth, depth);

	mov	r14d, DWORD PTR depth$[rbp-256]
	mov	rcx, r13
	mov	r8d, DWORD PTR y_px$[rbp-256]
	mov	r9d, r14d
	mov	edx, DWORD PTR x_px$[rbp-256]
	mov	DWORD PTR [rsp+32], r14d
	call	kvz_lcu_fill_trdepth

; 847  :   // Refine results with slower search or get some results if rough search was skipped.
; 848  :   const int32_t rdo_level = state->encoder_control->cfg.rdo;

	mov	rdx, QWORD PTR state$[rbp-256]
	mov	rdx, QWORD PTR [rdx]
	mov	eax, DWORD PTR [rdx+64]

; 849  :   if (rdo_level >= 2 || skip_rough_search) {

	cmp	eax, 2
	jge	SHORT $LN11@kvz_search
	test	sil, sil
	je	$LN10@kvz_search
$LN11@kvz_search:

; 850  :     int number_of_modes_to_search;
; 851  :     if (rdo_level == 3) {

	cmp	eax, 3
	jne	SHORT $LN12@kvz_search

; 852  :       number_of_modes_to_search = 35;

	lea	edi, QWORD PTR [rax+32]
	jmp	SHORT $LN14@kvz_search
$LN12@kvz_search:

; 853  :     } else if (rdo_level == 2) {

	cmp	eax, 2
	jne	SHORT $LN14@kvz_search

; 854  :       number_of_modes_to_search = (cu_width == 4) ? 3 : 2;

	cmp	r12b, 4
	sete	dil
	add	edi, eax
$LN14@kvz_search:

; 859  :     int num_modes_to_check = MIN(number_of_modes, number_of_modes_to_search);

	movsx	esi, bl
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 427  :   for (uint8_t i = 1; i < length; ++i) {

	mov	r8b, 1
	cmp	esi, edi
	cmovge	esi, edi
	cmp	bl, r8b
	jbe	SHORT $LN37@kvz_search
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 859  :     int num_modes_to_check = MIN(number_of_modes, number_of_modes_to_search);

	lea	r9, QWORD PTR modes$[rsp+1]
	lea	r10, QWORD PTR costs$[rbp-248]
	npad	2
$LL38@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 428  :     const double cur_cost = costs[i];

	movsd	xmm1, QWORD PTR [r10]

; 429  :     const int8_t cur_mode = modes[i];
; 430  :     uint8_t j = i;

	movzx	edx, r8b
	movzx	r11d, BYTE PTR [r9]
	npad	3
$LL39@kvz_search:

; 431  :     while (j > 0 && cur_cost < costs[j - 1]) {

	movzx	ecx, dl
	movsd	xmm0, QWORD PTR costs$[rbp+rcx*8-264]
	comisd	xmm1, xmm0
	jae	SHORT $LN40@kvz_search

; 432  :       costs[j] = costs[j - 1];
; 433  :       modes[j] = modes[j - 1];

	movzx	eax, BYTE PTR modes$[rsp+rcx-1]
	mov	BYTE PTR modes$[rsp+rcx], al
	movsd	QWORD PTR costs$[rbp+rcx*8-256], xmm0

; 434  :       --j;

	add	dl, 255					; 000000ffH
	jne	SHORT $LL39@kvz_search
$LN40@kvz_search:

; 435  :     }
; 436  :     costs[j] = cur_cost;

	movzx	eax, dl
	inc	r8b
	add	r10, 8
	inc	r9
	movsd	QWORD PTR costs$[rbp+rax*8-256], xmm1

; 437  :     modes[j] = cur_mode;

	mov	BYTE PTR modes$[rsp+rax], r11b
	cmp	r8b, bl
	jb	SHORT $LL38@kvz_search
$LN37@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 862  :     number_of_modes = search_intra_rdo(state,

	mov	r8d, DWORD PTR y_px$[rbp-256]
	lea	rax, QWORD PTR costs$[rbp-256]
	mov	edx, DWORD PTR x_px$[rbp-256]
	mov	r9d, r14d
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	QWORD PTR [rsp+80], r13
	mov	QWORD PTR [rsp+72], rax
	lea	rax, QWORD PTR modes$[rsp]
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR candidate_modes$[rbp-256]
	mov	DWORD PTR [rsp+56], esi
	mov	QWORD PTR [rsp+48], rax
	mov	QWORD PTR [rsp+32], r15
	call	search_intra_rdo
	movzx	ebx, al
$LN10@kvz_search:

; 62   :   double best_cost = costs[0];

	movsd	xmm1, QWORD PTR costs$[rbp-256]
	xor	r8b, r8b

; 63   :   
; 64   :   for (uint8_t i = 1; i < length; ++i) {

	mov	dl, 1
	cmp	bl, dl
	jbe	SHORT $LN44@kvz_search
	npad	6
$LL45@kvz_search:

; 65   :     if (costs[i] < best_cost) {

	movzx	eax, dl
	movzx	ecx, dl
	movsd	xmm0, QWORD PTR costs$[rbp+rax*8-256]
	comisd	xmm1, xmm0
	movzx	eax, r8b
	minsd	xmm0, xmm1
	cmovbe	ecx, eax
	inc	dl
	movzx	r8d, cl
	movaps	xmm1, xmm0
	cmp	dl, bl
	jb	SHORT $LL45@kvz_search
$LN44@kvz_search:

; 863  :                       x_px, y_px, depth,
; 864  :                       ref_pixels, LCU_WIDTH,
; 865  :                       candidate_modes,
; 866  :                       num_modes_to_check,
; 867  :                       modes, costs, lcu);
; 868  :   }
; 869  : 
; 870  :   uint8_t best_mode_i = select_best_mode_index(modes, costs, number_of_modes);
; 871  : 
; 872  :   *mode_out = modes[best_mode_i];

	mov	rax, QWORD PTR mode_out$[rbp-256]
	movzx	edx, r8b
	movzx	ecx, BYTE PTR modes$[rsp+rdx]
	mov	BYTE PTR [rax], cl

; 873  :   *cost_out = costs[best_mode_i];

	mov	rax, QWORD PTR cost_out$[rbp-256]
	mov	rcx, QWORD PTR costs$[rbp+rdx*8-256]
	mov	QWORD PTR [rax], rcx

; 874  : }

	add	rsp, 728				; 000002d8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
kvz_search_cu_intra ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_is_set PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	movzx	r9d, cx
	lea	rcx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+r8*4]
	shl	edx, cl
	mov	eax, 0
	test	edx, r9d
	setne	al

; 519  : }

	ret	0
cbf_is_set ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
cbf_is_set_any PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rdx+rax*2]
	test	dx, cx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, edx
	shl	edx, 5
	or	edx, eax
	movzx	eax, cx
	shl	edx, 5
	test	edx, eax

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set
	xor	eax, eax

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
$LN3@cbf_is_set:

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	mov	eax, 1

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
cbf_is_set_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_clear PROC

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	movsxd	rax, edx
	mov	r9, rcx
	lea	rdx, OFFSET FLAT:cbf_masks
	lea	ecx, DWORD PTR [r8+r8*4]
	movzx	edx, WORD PTR [rdx+rax*2]
	shl	dx, cl
	not	dx
	and	WORD PTR [r9], dx

; 560  : }

	ret	0
cbf_clear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
modes$dead$ = 8
costs$ = 16
length$ = 24
select_best_mode_index PROC

; 61   :   uint8_t best_index = 0;
; 62   :   double best_cost = costs[0];

	movsd	xmm1, QWORD PTR [rdx]
	xor	r10b, r10b

; 63   :   
; 64   :   for (uint8_t i = 1; i < length; ++i) {

	mov	r9b, 1
	cmp	r8b, r9b
	jbe	SHORT $LN11@select_bes
	npad	1
$LL4@select_bes:

; 65   :     if (costs[i] < best_cost) {

	movzx	eax, r9b
	movzx	ecx, r9b
	movsd	xmm0, QWORD PTR [rdx+rax*8]
	comisd	xmm1, xmm0
	movzx	eax, r10b
	minsd	xmm0, xmm1
	cmovbe	ecx, eax
	inc	r9b
	movzx	r10d, cl
	movaps	xmm1, xmm0
	cmp	r9b, r8b
	jb	SHORT $LL4@select_bes
$LN11@select_bes:

; 66   :       best_cost = costs[i];
; 67   :       best_index = i;
; 68   :     }
; 69   :   }
; 70   : 
; 71   :   return best_index;
; 72   : }

	movzx	eax, r10b
	ret	0
select_best_mode_index ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
state$ = 80
pred$ = 88
orig_block$ = 96
satd_func$ = 104
sad_func$ = 112
width$ = 120
get_cost PROC

; 92   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rsi, rdx
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	rbx, rcx
	movaps	XMMWORD PTR [rsp+32], xmm7

; 93   :   double satd_cost = satd_func(pred, orig_block);

	mov	rcx, rsi
	mov	rdx, r8
	mov	rdi, r8
	call	r9

; 94   :   if (TRSKIP_RATIO != 0 && width == 4 && state->encoder_control->cfg.trskip_enable) {

	cmp	DWORD PTR width$[rsp], 4
	xorps	xmm7, xmm7
	mov	eax, eax
	cvtsi2sd xmm7, rax
	jne	$LN4@get_cost
	mov	rcx, QWORD PTR [rbx]
	cmp	DWORD PTR [rcx+72], 0
	je	$LN4@get_cost

; 95   :     // If the mode looks better with SAD than SATD it might be a good
; 96   :     // candidate for transform skip. How much better SAD has to be is
; 97   :     // controlled by TRSKIP_RATIO.
; 98   : 
; 99   :     // Add the offset bit costs of signaling 'luma and chroma use trskip',
; 100  :     // versus signaling 'luma and chroma don't use trskip' to the SAD cost.
; 101  :     const cabac_ctx_t *ctx = &state->cabac.ctx.transform_skip_model_luma;
; 102  :     double trskip_bits = CTX_ENTROPY_FBITS(ctx, 1) - CTX_ENTROPY_FBITS(ctx, 0);

	movzx	edx, BYTE PTR [rbx+350]
	lea	r8, OFFSET FLAT:kvz_f_entropy_bits
	mov	eax, edx
	xor	rax, 1

; 103  : 
; 104  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [rcx+2596], 0
	movss	xmm0, DWORD PTR [r8+rax*4]
	subss	xmm0, DWORD PTR [r8+rdx*4]
	cvtps2pd xmm6, xmm0
	je	SHORT $LN3@get_cost

; 105  :       ctx = &state->cabac.ctx.transform_skip_model_chroma;
; 106  :       trskip_bits += 2.0 * (CTX_ENTROPY_FBITS(ctx, 1) - CTX_ENTROPY_FBITS(ctx, 0));

	movzx	ecx, BYTE PTR [rbx+351]
	mov	eax, ecx
	xor	rax, 1
	movss	xmm0, DWORD PTR [r8+rax*4]
	subss	xmm0, DWORD PTR [r8+rcx*4]
	cvtps2pd xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@4000000000000000
	addsd	xmm6, xmm1
$LN3@get_cost:

; 107  :     }
; 108  : 
; 109  :     double sad_cost = TRSKIP_RATIO * sad_func(pred, orig_block) + state->lambda_sqrt * trskip_bits;

	mov	rdx, rdi
	mov	rcx, rsi
	call	QWORD PTR sad_func$[rsp]
	mulsd	xmm6, QWORD PTR [rbx+376]
	xorps	xmm0, xmm0
	mov	eax, eax
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR __real@3ffb333333333333
	addsd	xmm6, xmm0

; 110  :     if (sad_cost < satd_cost) {

	comisd	xmm6, xmm7
	jae	SHORT $LN4@get_cost

; 111  :       return sad_cost;

	movaps	xmm0, xmm6
	jmp	SHORT $LN1@get_cost
$LN4@get_cost:

; 112  :     }
; 113  :   }
; 114  :   return satd_cost;

	movaps	xmm0, xmm7
$LN1@get_cost:

; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	movaps	xmm7, XMMWORD PTR [rsp+32]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
get_cost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
satd_costs$ = 32
state$ = 80
preds$ = 88
orig_block$ = 96
satd_twin_func$ = 104
sad_twin_func$ = 112
width$ = 120
unsigned_sad_costs$1 = 128
costs_out$ = 128
get_cost_dual PROC

; 130  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rsi, r8

; 131  :   #define PARALLEL_BLKS 2
; 132  :   unsigned satd_costs[PARALLEL_BLKS] = { 0 };

	mov	QWORD PTR satd_costs$[rsp], 0
	mov	rbp, rdx
	mov	rax, r9
	mov	rbx, rcx

; 133  :   satd_twin_func(preds, orig_block, PARALLEL_BLKS, satd_costs);

	lea	r9, QWORD PTR satd_costs$[rsp]
	mov	rdx, rsi
	mov	rcx, rbp
	mov	r8d, 2
	call	rax

; 134  :   costs_out[0] = (double)satd_costs[0];
; 135  :   costs_out[1] = (double)satd_costs[1];
; 136  : 
; 137  :   if (TRSKIP_RATIO != 0 && width == 4 && state->encoder_control->cfg.trskip_enable) {

	cmp	DWORD PTR width$[rsp], 4
	xorps	xmm1, xmm1
	movq	xmm0, QWORD PTR satd_costs$[rsp]
	mov	rdi, QWORD PTR costs_out$[rsp]
	cvtdq2pd xmm2, xmm0
	movaps	xmm0, xmm2
	cmppd	xmm0, xmm1, 1
	andps	xmm0, XMMWORD PTR __xmm@41f000000000000041f0000000000000
	addpd	xmm0, xmm2
	movups	XMMWORD PTR [rdi], xmm0
	jne	$LN30@get_cost_d
	mov	rdx, QWORD PTR [rbx]
	cmp	DWORD PTR [rdx+72], 0
	je	$LN30@get_cost_d

; 138  :     // If the mode looks better with SAD than SATD it might be a good
; 139  :     // candidate for transform skip. How much better SAD has to be is
; 140  :     // controlled by TRSKIP_RATIO.
; 141  : 
; 142  :     // Add the offset bit costs of signaling 'luma and chroma use trskip',
; 143  :     // versus signaling 'luma and chroma don't use trskip' to the SAD cost.
; 144  :     const cabac_ctx_t *ctx = &state->cabac.ctx.transform_skip_model_luma;
; 145  :     double trskip_bits = CTX_ENTROPY_FBITS(ctx, 1) - CTX_ENTROPY_FBITS(ctx, 0);

	movzx	ecx, BYTE PTR [rbx+350]
	lea	r9, OFFSET FLAT:kvz_f_entropy_bits
	mov	eax, ecx
	movaps	XMMWORD PTR [rsp+48], xmm6
	xor	rax, 1

; 146  : 
; 147  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [rdx+2596], 0
	movss	xmm0, DWORD PTR [r9+rax*4]
	subss	xmm0, DWORD PTR [r9+rcx*4]
	cvtps2pd xmm6, xmm0
	je	SHORT $LN6@get_cost_d

; 148  :       ctx = &state->cabac.ctx.transform_skip_model_chroma;
; 149  :       trskip_bits += 2.0 * (CTX_ENTROPY_FBITS(ctx, 1) - CTX_ENTROPY_FBITS(ctx, 0));

	movzx	ecx, BYTE PTR [rbx+351]
	mov	eax, ecx
	xor	rax, 1
	movss	xmm0, DWORD PTR [r9+rax*4]
	subss	xmm0, DWORD PTR [r9+rcx*4]
	cvtps2pd xmm1, xmm0
	mulsd	xmm1, QWORD PTR __real@4000000000000000
	addsd	xmm6, xmm1
$LN6@get_cost_d:

; 150  :     }
; 151  : 
; 152  :     unsigned unsigned_sad_costs[PARALLEL_BLKS] = { 0 };
; 153  :     double sad_costs[PARALLEL_BLKS] = { 0 };
; 154  :     sad_twin_func(preds, orig_block, PARALLEL_BLKS, unsigned_sad_costs);

	lea	r9, QWORD PTR unsigned_sad_costs$1[rsp]
	mov	QWORD PTR unsigned_sad_costs$1[rsp], 0
	mov	r8d, 2
	mov	rdx, rsi
	mov	rcx, rbp
	call	QWORD PTR sad_twin_func$[rsp]

; 155  :     for (int i = 0; i < PARALLEL_BLKS; ++i) {
; 156  :       sad_costs[i] = TRSKIP_RATIO * (double)unsigned_sad_costs[i] + state->lambda_sqrt * trskip_bits;

	mov	eax, DWORD PTR unsigned_sad_costs$1[rsp]
	xorps	xmm1, xmm1
	movsd	xmm2, QWORD PTR __real@3ffb333333333333
	xorps	xmm0, xmm0
	mulsd	xmm6, QWORD PTR [rbx+376]
	cvtsi2sd xmm1, rax

; 157  :       if (sad_costs[i] < (double)satd_costs[i]) {

	mov	eax, DWORD PTR satd_costs$[rsp]
	cvtsi2sd xmm0, rax
	mulsd	xmm1, xmm2
	addsd	xmm1, xmm6
	comisd	xmm1, xmm0
	jae	SHORT $LN18@get_cost_d

; 158  :         costs_out[i] = sad_costs[i];

	movsd	QWORD PTR [rdi], xmm1
$LN18@get_cost_d:

; 155  :     for (int i = 0; i < PARALLEL_BLKS; ++i) {
; 156  :       sad_costs[i] = TRSKIP_RATIO * (double)unsigned_sad_costs[i] + state->lambda_sqrt * trskip_bits;

	mov	eax, DWORD PTR unsigned_sad_costs$1[rsp+4]
	xorps	xmm1, xmm1
	xorps	xmm0, xmm0
	cvtsi2sd xmm1, rax

; 157  :       if (sad_costs[i] < (double)satd_costs[i]) {

	mov	eax, DWORD PTR satd_costs$[rsp+4]
	cvtsi2sd xmm0, rax
	mulsd	xmm1, xmm2
	addsd	xmm1, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+48]
	comisd	xmm1, xmm0
	jae	SHORT $LN30@get_cost_d

; 158  :         costs_out[i] = sad_costs[i];

	movsd	QWORD PTR [rdi+8], xmm1
$LN30@get_cost_d:

; 159  :       }
; 160  :     }
; 161  :   }
; 162  : 
; 163  :   #undef PARALLEL_BLKS
; 164  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
get_cost_dual ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
offset$1$ = 80
nosplit_pixels$ = 96
state$ = 3264
x_px$ = 3272
y_px$ = 3280
$T1 = 3288
depth$ = 3288
max_depth$ = 3296
intra_mode$ = 3304
cost_treshold$ = 3312
pred_cu$ = 3320
nosplit_cbf$1$ = 3328
lcu$ = 3328
search_intra_trdepth PROC

; 183  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	mov	DWORD PTR [rax+16], edx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 3200				; 00000c80H
	movsxd	rbx, r9d
	mov	r10d, r8d
	movaps	XMMWORD PTR [rax-72], xmm6
	mov	r11d, edx
	movaps	XMMWORD PTR [rax-88], xmm7
	mov	r14, rcx

; 184  :   assert(depth >= 0 && depth <= MAX_PU_DEPTH);

	cmp	ebx, 4
	jbe	SHORT $LN24@search_int
	mov	r8d, 184				; 000000b8H
	lea	rdx, OFFSET FLAT:$SG4294942683
	lea	rcx, OFFSET FLAT:$SG4294942682
	call	QWORD PTR __imp__wassert
	mov	r10d, DWORD PTR y_px$[rsp]
	mov	r11d, DWORD PTR x_px$[rsp]
$LN24@search_int:

; 185  : 
; 186  :   const int width = LCU_WIDTH >> depth;
; 187  :   const int width_c = width > TR_MIN_WIDTH ? width / 2 : width;
; 188  : 
; 189  :   const int offset = width / 2;
; 190  :   const vector2d_t lcu_px = { SUB_SCU(x_px), SUB_SCU(y_px) };
; 191  :   cu_info_t *const tr_cu = LCU_GET_CU_AT_PX(lcu, lcu_px.x, lcu_px.y);

	mov	rsi, QWORD PTR lcu$[rsp]
	mov	ecx, ebx
	mov	r12d, 64				; 00000040H
	mov	r13d, r10d
	sar	r12d, cl
	mov	ebp, r11d
	mov	eax, r12d
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
	mov	DWORD PTR offset$1$[rsp], eax
	cmp	r12d, 4
	cmovle	edi, r12d
	and	r13d, 63				; 0000003fH
	mov	eax, r13d
	and	ebp, 63					; 0000003fH
	shr	eax, 2
	imul	ecx, eax, 17
	mov	eax, ebp
	shr	eax, 2
	add	eax, ecx
	add	rax, 18
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	eax, r11d
	or	eax, r10d
	test	al, 4

; 192  : 
; 193  :   const bool reconstruct_chroma = !(x_px & 4 || y_px & 4) && state->encoder_control->chroma_format != KVZ_CSP_400;

	jne	SHORT $LN134@search_int
	mov	rax, QWORD PTR [r14]
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN134@search_int
	mov	r8b, 1
	jmp	SHORT $LN141@search_int
$LN134@search_int:
	xor	r8b, r8b
$LN141@search_int:

; 194  : 
; 195  :   struct {
; 196  :     kvz_pixel y[TR_MAX_WIDTH*TR_MAX_WIDTH];
; 197  :     kvz_pixel u[TR_MAX_WIDTH*TR_MAX_WIDTH];
; 198  :     kvz_pixel v[TR_MAX_WIDTH*TR_MAX_WIDTH];
; 199  :   } nosplit_pixels;
; 200  :   uint16_t nosplit_cbf = 0;
; 201  : 
; 202  :   double split_cost = INT32_MAX;

	movsd	xmm6, QWORD PTR __real@41dfffffffc00000

; 203  :   double nosplit_cost = INT32_MAX;
; 204  : 
; 205  :   if (depth > 0) {

	lea	rdx, OFFSET FLAT:__ImageBase
	mov	r15, QWORD PTR pred_cu$[rsp]
	xor	eax, eax
	mov	BYTE PTR $T1[rsp], r8b
	movaps	xmm7, xmm6
	mov	WORD PTR nosplit_cbf$1$[rsp], ax
	test	ebx, ebx
	jle	$LN6@search_int

; 206  :     tr_cu->tr_depth = depth;

	and	BYTE PTR [rsi+rcx*4+24977], 248		; 000000f8H
	movzx	eax, bl
	and	al, 7
	or	BYTE PTR [rsi+rcx*4+24977], al
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	movzx	ecx, WORD PTR cbf_masks[rdx+rbx*2]
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 207  :     pred_cu->tr_depth = depth;

	and	BYTE PTR [r15+1], 248			; 000000f8H
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	movzx	edx, cx
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 207  :     pred_cu->tr_depth = depth;

	or	BYTE PTR [r15+1], al
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	not	dx
	and	dx, WORD PTR [r15+4]
	mov	WORD PTR [r15+4], dx
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 212  :     if (reconstruct_chroma) {

	test	r8b, r8b
	je	SHORT $LN34@search_int
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	movzx	eax, cx
	shl	cx, 5
	shl	ax, 10
	not	cx
	not	ax
	and	ax, cx
	and	ax, dx
	mov	WORD PTR [r15+4], ax
$LN34@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 217  :     const int8_t chroma_mode = reconstruct_chroma ? intra_mode : -1;

	movzx	ecx, BYTE PTR intra_mode$[rsp]
	test	r8b, r8b

; 218  :     kvz_intra_recon_cu(state,

	mov	QWORD PTR [rsp+56], rsi
	mov	eax, -1					; ffffffffH
	cmovne	eax, ecx
	mov	QWORD PTR [rsp+48], r15
	mov	BYTE PTR [rsp+40], al
	mov	r9d, ebx
	mov	BYTE PTR [rsp+32], cl
	mov	r8d, r10d
	mov	rcx, r14
	mov	edx, r11d
	call	kvz_intra_recon_cu

; 219  :                        x_px, y_px,
; 220  :                        depth,
; 221  :                        intra_mode, chroma_mode,
; 222  :                        pred_cu, lcu);
; 223  : 
; 224  :     nosplit_cost += kvz_cu_rd_cost_luma(state, lcu_px.x, lcu_px.y, depth, pred_cu, lcu);

	mov	r9d, ebx
	mov	QWORD PTR [rsp+40], rsi
	mov	r8d, r13d
	mov	QWORD PTR [rsp+32], r15
	mov	edx, ebp
	mov	rcx, r14
	call	kvz_cu_rd_cost_luma

; 225  :     if (reconstruct_chroma) {

	cmp	BYTE PTR $T1[rsp], 0
	movaps	xmm7, xmm0
	je	SHORT $LN4@search_int

; 226  :       nosplit_cost += kvz_cu_rd_cost_chroma(state, lcu_px.x, lcu_px.y, depth, pred_cu, lcu);

	mov	QWORD PTR [rsp+40], rsi
	mov	r9d, ebx
	mov	r8d, r13d
	mov	QWORD PTR [rsp+32], r15
	mov	edx, ebp
	mov	rcx, r14
	call	kvz_cu_rd_cost_chroma
	addsd	xmm7, xmm0
$LN4@search_int:

; 227  :     }
; 228  : 
; 229  :     // Early stop codition for the recursive search.
; 230  :     // If the cost of any 1/4th of the transform is already larger than the
; 231  :     // whole transform, assume that splitting further is a bad idea.
; 232  :     if (nosplit_cost >= cost_treshold) {

	movd	xmm0, DWORD PTR cost_treshold$[rsp]
	cvtdq2pd xmm0, xmm0
	comisd	xmm7, xmm0
	jae	$LN21@search_int

; 233  :       return nosplit_cost;
; 234  :     }
; 235  : 
; 236  :     nosplit_cbf = pred_cu->cbf;

	movzx	eax, WORD PTR [r15+4]

; 237  : 
; 238  :     kvz_pixels_blit(lcu->rec.y, nosplit_pixels.y, width, width, LCU_WIDTH, width);

	lea	rcx, QWORD PTR [rsi+6540]
	mov	DWORD PTR [rsp+40], r12d
	lea	rdx, QWORD PTR nosplit_pixels$[rsp]
	mov	r9d, r12d
	mov	WORD PTR nosplit_cbf$1$[rsp], ax
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	call	kvz_pixels_blit

; 239  :     if (reconstruct_chroma) {

	cmp	BYTE PTR $T1[rsp], 0
	je	SHORT $LN139@search_int

; 240  :       kvz_pixels_blit(lcu->rec.u, nosplit_pixels.u, width_c, width_c, LCU_WIDTH_C, width_c);

	lea	rcx, QWORD PTR [rsi+10636]
	mov	DWORD PTR [rsp+40], edi
	mov	r9d, edi
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	mov	r8d, edi
	lea	rdx, QWORD PTR nosplit_pixels$[rsp+1024]
	call	kvz_pixels_blit

; 241  :       kvz_pixels_blit(lcu->rec.v, nosplit_pixels.v, width_c, width_c, LCU_WIDTH_C, width_c);

	lea	rcx, QWORD PTR [rsi+11660]
	mov	DWORD PTR [rsp+40], edi
	mov	r9d, edi
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	mov	r8d, edi
	lea	rdx, QWORD PTR nosplit_pixels$[rsp+2048]
	call	kvz_pixels_blit
$LN139@search_int:

; 242  :     }
; 243  :   }
; 244  : 
; 245  :   // Recurse further if all of the following:
; 246  :   // - Current depth is less than maximum depth of the search (max_depth).
; 247  :   //   - Maximum transform hierarchy depth is constrained by clipping
; 248  :   //     max_depth.
; 249  :   // - Min transform size hasn't been reached (MAX_PU_DEPTH).
; 250  :   if (depth < max_depth && depth < MAX_PU_DEPTH) {

	mov	r11d, DWORD PTR x_px$[rsp]
	mov	r10d, DWORD PTR y_px$[rsp]
$LN6@search_int:
	mov	ebp, DWORD PTR max_depth$[rsp]
	cmp	ebx, ebp
	jge	$LN7@search_int
	cmp	ebx, 4
	jge	$LN7@search_int

; 251  :     split_cost = 3 * state->lambda;
; 252  : 
; 253  :     split_cost += search_intra_trdepth(state, x_px, y_px, depth + 1, max_depth, intra_mode, nosplit_cost, pred_cu, lcu);

	mov	ecx, DWORD PTR intra_mode$[rsp]
	lea	r9d, DWORD PTR [rbx+1]
	movsd	xmm6, QWORD PTR [r14+368]
	mov	r8d, r10d
	mulsd	xmm6, QWORD PTR __real@4008000000000000
	mov	edx, r11d
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], r15
	cvttsd2si r13d, xmm7
	mov	DWORD PTR [rsp+48], r13d
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], ebp
	call	search_intra_trdepth
	addsd	xmm6, xmm0

; 254  :     if (split_cost < nosplit_cost) {

	comisd	xmm6, xmm7
	jae	$LN11@search_int

; 255  :       split_cost += search_intra_trdepth(state, x_px + offset, y_px, depth + 1, max_depth, intra_mode, nosplit_cost, pred_cu, lcu);

	mov	edx, DWORD PTR offset$1$[rsp]
	lea	r9d, DWORD PTR [rbx+1]
	mov	eax, DWORD PTR intra_mode$[rsp]
	mov	rcx, r14
	add	edx, DWORD PTR x_px$[rsp]
	mov	r8d, DWORD PTR y_px$[rsp]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], r15
	mov	DWORD PTR [rsp+48], r13d
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ebp
	call	search_intra_trdepth
	addsd	xmm6, xmm0

; 256  :     }
; 257  :     if (split_cost < nosplit_cost) {

	comisd	xmm6, xmm7
	jae	$LN11@search_int

; 258  :       split_cost += search_intra_trdepth(state, x_px, y_px + offset, depth + 1, max_depth, intra_mode, nosplit_cost, pred_cu, lcu);

	mov	r8d, DWORD PTR offset$1$[rsp]
	lea	r9d, DWORD PTR [rbx+1]
	mov	eax, DWORD PTR intra_mode$[rsp]
	mov	rcx, r14
	add	r8d, DWORD PTR y_px$[rsp]
	mov	edx, DWORD PTR x_px$[rsp]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], r15
	mov	DWORD PTR [rsp+48], r13d
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ebp
	call	search_intra_trdepth
	addsd	xmm6, xmm0

; 259  :     }
; 260  :     if (split_cost < nosplit_cost) {

	comisd	xmm6, xmm7
	jae	SHORT $LN11@search_int

; 261  :       split_cost += search_intra_trdepth(state, x_px + offset, y_px + offset, depth + 1, max_depth, intra_mode, nosplit_cost, pred_cu, lcu);

	mov	r8d, DWORD PTR y_px$[rsp]
	lea	r9d, DWORD PTR [rbx+1]
	mov	edx, DWORD PTR x_px$[rsp]
	mov	rcx, r14
	mov	eax, DWORD PTR intra_mode$[rsp]
	add	r8d, DWORD PTR offset$1$[rsp]
	add	edx, DWORD PTR offset$1$[rsp]
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], r15
	mov	DWORD PTR [rsp+48], r13d
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ebp
	call	search_intra_trdepth
	addsd	xmm6, xmm0
$LN11@search_int:

; 262  :     }
; 263  : 
; 264  :     double tr_split_bit = 0.0;
; 265  :     double cbf_bits = 0.0;
; 266  : 
; 267  :     // Add bits for split_transform_flag = 1, because transform depth search bypasses
; 268  :     // the normal recursion in the cost functions.
; 269  :     if (depth >= 1 && depth <= 3) {

	lea	rbp, OFFSET FLAT:__ImageBase
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	cmp	ebx, 1
	jl	SHORT $LN12@search_int

; 270  :       const cabac_ctx_t *ctx = &(state->cabac.ctx.trans_subdiv_model[5 - (6 - depth)]);
; 271  :       tr_split_bit += CTX_ENTROPY_FBITS(ctx, 1);

	movzx	ecx, BYTE PTR [rbx+r14+180]
	xor	rcx, 1
	movss	xmm2, DWORD PTR kvz_f_entropy_bits[rbp+rcx*4]
	cvtps2pd xmm2, xmm2
$LN12@search_int:

; 272  :     }
; 273  : 
; 274  :     // Add cost of cbf chroma bits on transform tree.
; 275  :     // All cbf bits are accumulated to pred_cu.cbf and cbf_is_set returns true
; 276  :     // if cbf is set at any level >= depth, so cbf chroma is assumed to be 0
; 277  :     // if this and any previous transform block has no chroma coefficients.
; 278  :     // When searching the first block we don't actually know the real values,
; 279  :     // so this will code cbf as 0 and not code the cbf at all for descendants.
; 280  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r14]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN16@search_int

; 281  :       const uint8_t tr_depth = depth - pred_cu->depth;

	movzx	eax, BYTE PTR [r15]
	movzx	r9d, bl
	shr	al, 2

; 284  :       if (tr_depth == 0 || cbf_is_set(pred_cu->cbf, depth - 1, COLOR_U)) {

	mov	r8, rbx
	and	al, 7
	sub	r9b, al
	movzx	r10d, r9b
	je	SHORT $LN132@search_int
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[rbp+rbx*2-2]
	movzx	edx, WORD PTR [r15+4]
	shl	eax, 5
	test	eax, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 284  :       if (tr_depth == 0 || cbf_is_set(pred_cu->cbf, depth - 1, COLOR_U)) {

	je	SHORT $LN136@search_int
$LN132@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[rbp+r8*2]
	mov	ecx, 0
	movzx	edx, WORD PTR [r15+4]
	shl	eax, 5
	test	eax, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 285  :         cbf_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_U));

	movzx	eax, BYTE PTR [r10+r14+188]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	setne	cl
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 285  :         cbf_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_U));

	xor	rcx, rax
	movss	xmm1, DWORD PTR kvz_f_entropy_bits[rbp+rcx*4]
	cvtps2pd xmm1, xmm1
$LN136@search_int:

; 287  :       if (tr_depth == 0 || cbf_is_set(pred_cu->cbf, depth - 1, COLOR_V)) {

	movzx	ecx, dx
	test	r9b, r9b
	je	SHORT $LN17@search_int
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[rbp+r8*2-2]
	shl	eax, 10
	test	eax, ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 287  :       if (tr_depth == 0 || cbf_is_set(pred_cu->cbf, depth - 1, COLOR_V)) {

	je	SHORT $LN16@search_int
$LN17@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[rbp+r8*2]
	mov	r11d, 0
	shl	eax, 10
	test	eax, ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 288  :         cbf_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_V));

	movzx	eax, BYTE PTR [r10+r14+188]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	setne	r11b
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 288  :         cbf_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_V));

	xor	r11, rax
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[rbp+r11*4]
	cvtps2pd xmm0, xmm0
	addsd	xmm1, xmm0
$LN16@search_int:

; 289  :       }
; 290  :     }
; 291  : 
; 292  :     double bits = tr_split_bit + cbf_bits;

	addsd	xmm1, xmm2

; 293  :     split_cost += bits * state->lambda;

	mulsd	xmm1, QWORD PTR [r14+368]
	addsd	xmm6, xmm1

; 294  :   } else {

	jmp	SHORT $LN29@search_int
$LN7@search_int:

; 295  :     assert(width <= TR_MAX_WIDTH);

	cmp	r12d, 32				; 00000020H
	jle	SHORT $LN29@search_int
	mov	r8d, 295				; 00000127H
	lea	rdx, OFFSET FLAT:$SG4294942681
	lea	rcx, OFFSET FLAT:$SG4294942680
	call	QWORD PTR __imp__wassert
$LN29@search_int:

; 296  :   }
; 297  : 
; 298  :   if (depth == 0 || split_cost < nosplit_cost) {

	test	ebx, ebx
	je	$LN20@search_int
	comisd	xmm6, xmm7
	jb	$LN20@search_int

; 300  :   } else {
; 301  :     kvz_lcu_fill_trdepth(lcu, x_px, y_px, depth, depth);

	mov	r8d, DWORD PTR y_px$[rsp]
	mov	r9d, ebx
	mov	edx, DWORD PTR x_px$[rsp]
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], ebx
	call	kvz_lcu_fill_trdepth

; 302  : 
; 303  :     pred_cu->cbf = nosplit_cbf;

	movzx	edx, WORD PTR nosplit_cbf$1$[rsp]

; 304  : 
; 305  :     // We only restore the pixel data and not coefficients or cbf data.
; 306  :     // The only thing we really need are the border pixels.kvz_intra_get_dir_luma_predictor
; 307  :     kvz_pixels_blit(nosplit_pixels.y, lcu->rec.y, width, width, width, LCU_WIDTH);

	lea	rcx, QWORD PTR nosplit_pixels$[rsp]
	mov	WORD PTR [r15+4], dx
	mov	r9d, r12d
	lea	rdx, QWORD PTR [rsi+6540]
	mov	DWORD PTR [rsp+40], 64			; 00000040H
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], r12d
	call	kvz_pixels_blit

; 308  :     if (reconstruct_chroma) {

	cmp	BYTE PTR $T1[rsp], 0
	je	SHORT $LN21@search_int

; 309  :       kvz_pixels_blit(nosplit_pixels.u, lcu->rec.u, width_c, width_c, width_c, LCU_WIDTH_C);

	lea	rdx, QWORD PTR [rsi+10636]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	r9d, edi
	mov	DWORD PTR [rsp+32], edi
	mov	r8d, edi
	lea	rcx, QWORD PTR nosplit_pixels$[rsp+1024]
	call	kvz_pixels_blit

; 310  :       kvz_pixels_blit(nosplit_pixels.v, lcu->rec.v, width_c, width_c, width_c, LCU_WIDTH_C);

	lea	rdx, QWORD PTR [rsi+11660]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	r9d, edi
	mov	DWORD PTR [rsp+32], edi
	mov	r8d, edi
	lea	rcx, QWORD PTR nosplit_pixels$[rsp+2048]
	call	kvz_pixels_blit
$LN21@search_int:

; 311  :     }
; 312  : 
; 313  :     return nosplit_cost;
; 314  :   }
; 315  : }

	movaps	xmm0, xmm7
	jmp	SHORT $LN19@search_int
$LN20@search_int:

; 299  :     return split_cost;

	movaps	xmm0, xmm6
$LN19@search_int:

; 311  :     }
; 312  : 
; 313  :     return nosplit_cost;
; 314  :   }
; 315  : }

	lea	r11, QWORD PTR [rsp+3200]
	mov	rbx, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
search_intra_trdepth ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\strategies\strategies-picture.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
pred$1$ = 48
$T1 = 56
tv791 = 64
_pred$ = 80
_orig_block$ = 1136
orig_block$1$ = 2240
state$dead$ = 2240
x_px$ = 2248
y_px$ = 2256
depth$ = 2264
orig_u$ = 2272
orig_v$ = 2280
width$1$ = 2288
origstride$dead$ = 2288
refs_u$ = 2296
refs_v$ = 2304
luma_mode$ = 2312
modes$ = 2320
costs$ = 2328
search_intra_chroma_rough PROC

; 324  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+8], rcx
	push	rbx
	push	rdi
	push	r15
	sub	rsp, 2208				; 000008a0H
	mov	QWORD PTR [rax+16], rbp
	or	edx, r8d
	mov	QWORD PTR [rax+24], rsi
	mov	ebx, r9d
	mov	QWORD PTR [rax-32], r13
	mov	QWORD PTR [rax-40], r14
	test	dl, 4

; 325  :   assert(!(x_px & 4 || y_px & 4));

	je	SHORT $LN15@search_int
	mov	r8d, 325				; 00000145H
	lea	rdx, OFFSET FLAT:$SG4294942679
	lea	rcx, OFFSET FLAT:$SG4294942678
	call	QWORD PTR __imp__wassert
$LN15@search_int:

; 326  : 
; 327  :   const unsigned width = MAX(LCU_WIDTH_C >> depth, TR_MIN_WIDTH);

	mov	ebp, 4
	mov	ecx, ebx
	mov	eax, 32					; 00000020H

; 328  :   const int_fast8_t log2_width_c = MAX(LOG2_LCU_WIDTH - (depth + 1), 2);

	mov	r13d, 5
	sar	eax, cl
	cmp	eax, ebp
	cmovg	ebp, eax
	mov	eax, r13d
	sub	eax, ebx
	mov	DWORD PTR width$1$[rsp], ebp
	cmp	eax, 2
	jle	SHORT $LN18@search_int
	sub	r13b, bl
	jmp	SHORT $LL19@search_int
$LN18@search_int:
	mov	r13b, 2
	npad	7
$LL19@search_int:

; 329  : 
; 330  :   for (int i = 0; i < 5; ++i) {
; 331  :     costs[i] = 0;

	mov	rbx, QWORD PTR costs$[rsp]
	xor	esi, esi
	mov	QWORD PTR [rbx+8], rsi
	lea	r15, QWORD PTR [rbx+8]
	mov	QWORD PTR tv791[rsp], r15
	mov	QWORD PTR [rsp+2264], r12
	mov	QWORD PTR $T1[rsp], rsi
	mov	QWORD PTR [rbx], rsi
	mov	QWORD PTR [rbx+16], rsi
	mov	QWORD PTR [rbx+24], rsi
	mov	QWORD PTR [rbx+32], rsi
; File F:\open_codec_learn_2021\kvazaar-master\src\strategies\strategies-picture.c

; 119  :   switch (n) {

	cmp	ebp, 4
	je	SHORT $LN23@search_int
	cmp	ebp, 8
	je	SHORT $LN24@search_int
	cmp	ebp, 16
	je	SHORT $LN25@search_int
	cmp	ebp, 32					; 00000020H
	je	SHORT $LN26@search_int
	mov	r12, QWORD PTR kvz_satd_64x64
	cmp	ebp, 64					; 00000040H
	cmovne	r12, rsi

; 128  :   case 64:
; 129  :     return kvz_satd_64x64;

	jmp	SHORT $LN20@search_int
$LN26@search_int:

; 126  :   case 32:
; 127  :     return kvz_satd_32x32;

	mov	r12, QWORD PTR kvz_satd_32x32
	jmp	SHORT $LN20@search_int
$LN25@search_int:

; 124  :   case 16:
; 125  :     return kvz_satd_16x16;

	mov	r12, QWORD PTR kvz_satd_16x16
	jmp	SHORT $LN20@search_int
$LN24@search_int:

; 122  :   case 8:
; 123  :     return kvz_satd_8x8;

	mov	r12, QWORD PTR kvz_satd_8x8
	jmp	SHORT $LN20@search_int
$LN23@search_int:

; 120  :   case 4:
; 121  :     return kvz_satd_4x4;

	mov	r12, QWORD PTR kvz_satd_4x4
$LN20@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 338  :   kvz_pixel *pred = ALIGNED_POINTER(_pred, SIMD_ALIGNMENT);

	lea	rax, QWORD PTR _pred$[rsp]

; 339  : 
; 340  :   kvz_pixel _orig_block[32 * 32 + SIMD_ALIGNMENT];
; 341  :   kvz_pixel *orig_block = ALIGNED_POINTER(_orig_block, SIMD_ALIGNMENT);
; 342  : 
; 343  :   kvz_pixels_blit(orig_u, orig_block, width, width, origstride, width);

	mov	DWORD PTR [rsp+40], ebp
	cdq
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	and	edx, 31
	lea	rcx, QWORD PTR _pred$[rsp+32]
	add	rax, rdx
	mov	r9d, ebp
	and	eax, 31
	mov	r8d, ebp
	sub	rax, rdx
	sub	rcx, rax
	lea	rax, QWORD PTR _orig_block$[rsp]
	cdq
	mov	QWORD PTR pred$1$[rsp], rcx
	and	edx, 31
	lea	rcx, QWORD PTR _orig_block$[rsp+32]
	add	rax, rdx
	and	eax, 31
	sub	rax, rdx
	sub	rcx, rax
	mov	QWORD PTR orig_block$1$[rsp], rcx
	mov	rdx, rcx
	mov	rcx, QWORD PTR orig_u$[rsp]
	call	kvz_pixels_blit
	mov	rdi, QWORD PTR modes$[rsp]
	mov	r14, rsi
	mov	rsi, QWORD PTR pred$1$[rsp]
	mov	rbp, QWORD PTR orig_block$1$[rsp]
	npad	4
$LL7@search_int:

; 345  :     if (modes[i] == luma_mode) continue;

	movzx	r8d, BYTE PTR [r14+rdi]
	cmp	r8b, BYTE PTR luma_mode$[rsp]
	je	SHORT $LN5@search_int

; 346  :     kvz_intra_predict(refs_u, log2_width_c, modes[i], COLOR_U, pred, false);

	mov	rcx, QWORD PTR refs_u$[rsp]
	mov	r9d, 1
	mov	BYTE PTR [rsp+40], 0
	movzx	edx, r13b
	mov	QWORD PTR [rsp+32], rsi
	call	kvz_intra_predict

; 347  :     //costs[i] += get_cost(encoder_state, pred, orig_block, satd_func, sad_func, width);
; 348  :     costs[i] += satd_func(pred, orig_block);

	mov	rdx, rbp
	mov	rcx, rsi
	call	r12
	xorps	xmm0, xmm0
	mov	eax, eax
	cvtsi2sd xmm0, rax
	addsd	xmm0, QWORD PTR [rbx+r14*8]
	movsd	QWORD PTR [rbx+r14*8], xmm0
$LN5@search_int:

; 344  :   for (int i = 0; i < 5; ++i) {

	inc	r14
	cmp	r14, 5
	jl	SHORT $LL7@search_int

; 349  :   }
; 350  : 
; 351  :   kvz_pixels_blit(orig_v, orig_block, width, width, origstride, width);

	mov	ebp, DWORD PTR width$1$[rsp]
	mov	r9d, ebp
	mov	r14, QWORD PTR orig_block$1$[rsp]
	mov	r8d, ebp
	mov	rcx, QWORD PTR orig_v$[rsp]
	mov	rdx, r14
	mov	DWORD PTR [rsp+40], ebp
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	call	kvz_pixels_blit
	mov	rsi, QWORD PTR $T1[rsp]
	movzx	ebp, BYTE PTR luma_mode$[rsp]
	mov	r15, QWORD PTR pred$1$[rsp]
	npad	5
$LL10@search_int:

; 353  :     if (modes[i] == luma_mode) continue;

	movzx	r8d, BYTE PTR [rsi+rdi]
	cmp	r8b, bpl
	je	SHORT $LN8@search_int

; 354  :     kvz_intra_predict(refs_v, log2_width_c, modes[i], COLOR_V, pred, false);

	mov	rcx, QWORD PTR refs_v$[rsp]
	mov	r9d, 2
	mov	BYTE PTR [rsp+40], 0
	movzx	edx, r13b
	mov	QWORD PTR [rsp+32], r15
	call	kvz_intra_predict

; 355  :     //costs[i] += get_cost(encoder_state, pred, orig_block, satd_func, sad_func, width);
; 356  :     costs[i] += satd_func(pred, orig_block);

	mov	rdx, r14
	mov	rcx, r15
	call	r12
	xorps	xmm0, xmm0
	mov	eax, eax
	cvtsi2sd xmm0, rax
	addsd	xmm0, QWORD PTR [rbx+rsi*8]
	movsd	QWORD PTR [rbx+rsi*8], xmm0
$LN8@search_int:

; 352  :   for (int i = 0; i < 5; ++i) {

	inc	rsi
	cmp	rsi, 5
	jl	SHORT $LL10@search_int
	mov	r15, QWORD PTR tv791[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 427  :   for (uint8_t i = 1; i < length; ++i) {

	lea	r9, QWORD PTR [rdi+1]
	mov	r14, QWORD PTR [rsp+2192]
	mov	r8b, 1
	mov	r13, QWORD PTR [rsp+2200]
	mov	r12, QWORD PTR [rsp+2264]
	mov	rsi, QWORD PTR [rsp+2256]
	mov	rbp, QWORD PTR [rsp+2248]
	npad	11
$LL33@search_int:

; 428  :     const double cur_cost = costs[i];

	movsd	xmm1, QWORD PTR [r15]

; 429  :     const int8_t cur_mode = modes[i];
; 430  :     uint8_t j = i;

	movzx	edx, r8b
	movzx	r10d, BYTE PTR [r9]
	npad	3
$LL34@search_int:

; 431  :     while (j > 0 && cur_cost < costs[j - 1]) {

	movzx	ecx, dl
	movsd	xmm0, QWORD PTR [rbx+rcx*8-8]
	comisd	xmm1, xmm0
	jae	SHORT $LN35@search_int

; 432  :       costs[j] = costs[j - 1];
; 433  :       modes[j] = modes[j - 1];

	movzx	eax, BYTE PTR [rcx+rdi-1]
	mov	BYTE PTR [rcx+rdi], al
	movsd	QWORD PTR [rbx+rcx*8], xmm0

; 434  :       --j;

	add	dl, 255					; 000000ffH
	jne	SHORT $LL34@search_int
$LN35@search_int:

; 435  :     }
; 436  :     costs[j] = cur_cost;

	movzx	eax, dl
	inc	r8b
	add	r15, 8
	inc	r9
	movsd	QWORD PTR [rbx+rax*8], xmm1

; 437  :     modes[j] = cur_mode;

	mov	BYTE PTR [rax+rdi], r10b
	cmp	r8b, 5
	jb	SHORT $LL33@search_int
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 360  : }

	add	rsp, 2208				; 000008a0H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
search_intra_chroma_rough ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\strategies\strategies-picture.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
filter_boundary$1$ = 64
test_modes$1$ = 65
test_modes$2$ = 66
tv2455 = 67
max_cost$1$ = 68
test_modes$1 = 68
tv2495 = 72
satd_dual_func$1$ = 80
min_cost$1$ = 88
sad_dual_func$1$ = 96
satd_func$1$ = 104
sad_func$1$ = 112
preds$1$ = 120
orig_block$1$ = 128
tv2534 = 136
costs_out$2 = 144
costs_out$3 = 144
_orig_block$ = 160
_preds$ = 1216
state$ = 3424
orig$ = 3432
modes_selected$1$ = 3440
origstride$dead$ = 3440
refs$ = 3448
log2_width$ = 3456
intra_preds$ = 3464
modes$ = 3472
add_modes$ = 3480
costs$ = 3480
search_intra_rough PROC

; 398  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+32], r9
	mov	DWORD PTR [rax+24], r8d
	mov	QWORD PTR [rax+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 3360				; 00000d20H

; 399  :   #define PARALLEL_BLKS 2 // TODO: use 4 for AVX-512 in the future?
; 400  :   assert(log2_width >= 2 && log2_width <= 5);

	movsxd	r13, DWORD PTR log2_width$[rsp]
	mov	rbx, rdx
	movaps	XMMWORD PTR [rax-72], xmm6
	mov	rdi, rcx
	movaps	XMMWORD PTR [rax-104], xmm8
	movaps	XMMWORD PTR [rax-120], xmm9
	cmp	r13d, 2
	jl	SHORT $LN43@search_int
	cmp	r13d, 5
	jle	SHORT $LN44@search_int
$LN43@search_int:
	mov	r8d, 400				; 00000190H
	lea	rdx, OFFSET FLAT:$SG4294942677
	lea	rcx, OFFSET FLAT:$SG4294942676
	call	QWORD PTR __imp__wassert
$LN44@search_int:

; 401  :   int_fast8_t width = 1 << log2_width;

	mov	ecx, r13d
	mov	esi, 1
	mov	eax, esi
	shl	al, cl

; 402  :   cost_pixel_nxn_func *satd_func = kvz_pixels_get_satd_func(width);

	movsx	ecx, al
	mov	DWORD PTR tv2495[rsp], ecx
	mov	DWORD PTR tv2534[rsp], eax
; File F:\open_codec_learn_2021\kvazaar-master\src\strategies\strategies-picture.c

; 119  :   switch (n) {

	cmp	al, 4
	je	$LN56@search_int
	cmp	al, 8
	je	$LN57@search_int
	cmp	al, 16
	je	$LN58@search_int
	cmp	al, 32					; 00000020H
	je	SHORT $LN59@search_int
	cmp	al, 64					; 00000040H
	je	SHORT $LN60@search_int

; 208  :     return NULL;

	mov	QWORD PTR sad_dual_func$1$[rsp], 0
	mov	QWORD PTR satd_dual_func$1$[rsp], 0
	mov	QWORD PTR satd_func$1$[rsp], 0
	mov	QWORD PTR sad_func$1$[rsp], 0
	jmp	$LN83@search_int
$LN60@search_int:

; 205  :   case 64:
; 206  :     return kvz_sad_64x64_dual;

	mov	rdx, QWORD PTR kvz_sad_64x64_dual
	mov	rcx, QWORD PTR kvz_satd_64x64_dual
	mov	QWORD PTR sad_dual_func$1$[rsp], rdx
	mov	rdx, QWORD PTR kvz_satd_64x64
	mov	QWORD PTR satd_func$1$[rsp], rdx
	mov	rdx, QWORD PTR kvz_sad_64x64
	mov	QWORD PTR satd_dual_func$1$[rsp], rcx
	mov	ecx, DWORD PTR tv2495[rsp]
	mov	QWORD PTR sad_func$1$[rsp], rdx
	jmp	$LN83@search_int
$LN59@search_int:

; 203  :   case 32:
; 204  :     return kvz_sad_32x32_dual;

	mov	rdx, QWORD PTR kvz_sad_32x32_dual
	mov	rcx, QWORD PTR kvz_satd_32x32_dual
	mov	QWORD PTR sad_dual_func$1$[rsp], rdx
	mov	rdx, QWORD PTR kvz_satd_32x32
	mov	QWORD PTR satd_func$1$[rsp], rdx
	mov	rdx, QWORD PTR kvz_sad_32x32
	mov	QWORD PTR satd_dual_func$1$[rsp], rcx
	mov	ecx, DWORD PTR tv2495[rsp]
	mov	QWORD PTR sad_func$1$[rsp], rdx
	jmp	$LN83@search_int
$LN58@search_int:

; 201  :   case 16:
; 202  :     return kvz_sad_16x16_dual;

	mov	rdx, QWORD PTR kvz_sad_16x16_dual
	mov	rcx, QWORD PTR kvz_satd_16x16_dual
	mov	QWORD PTR sad_dual_func$1$[rsp], rdx
	mov	rdx, QWORD PTR kvz_satd_16x16
	mov	QWORD PTR satd_func$1$[rsp], rdx
	mov	rdx, QWORD PTR kvz_sad_16x16
	mov	QWORD PTR satd_dual_func$1$[rsp], rcx
	mov	ecx, DWORD PTR tv2495[rsp]
	mov	QWORD PTR sad_func$1$[rsp], rdx
	jmp	SHORT $LN83@search_int
$LN57@search_int:

; 199  :   case 8:
; 200  :     return kvz_sad_8x8_dual;

	mov	rdx, QWORD PTR kvz_sad_8x8_dual
	mov	rcx, QWORD PTR kvz_satd_8x8_dual
	mov	QWORD PTR sad_dual_func$1$[rsp], rdx
	mov	rdx, QWORD PTR kvz_satd_8x8
	mov	QWORD PTR satd_func$1$[rsp], rdx
	mov	rdx, QWORD PTR kvz_sad_8x8
	mov	QWORD PTR satd_dual_func$1$[rsp], rcx
	mov	ecx, DWORD PTR tv2495[rsp]
	mov	QWORD PTR sad_func$1$[rsp], rdx
	jmp	SHORT $LN83@search_int
$LN56@search_int:

; 120  :   case 4:
; 121  :     return kvz_satd_4x4;
; 122  :   case 8:
; 123  :     return kvz_satd_8x8;
; 124  :   case 16:
; 125  :     return kvz_satd_16x16;
; 126  :   case 32:
; 127  :     return kvz_satd_32x32;
; 128  :   case 64:
; 129  :     return kvz_satd_64x64;
; 130  :   default:
; 131  :     return NULL;
; 132  :   }
; 133  : }
; 134  : 
; 135  : 
; 136  : /**
; 137  : * \brief  Get a function that calculates SAD for NxN block.
; 138  : *
; 139  : * \param n  Width of the region for which SAD is calculated.
; 140  : *
; 141  : * \returns  Pointer to cost_16bit_nxn_func.
; 142  : */
; 143  : cost_pixel_nxn_func * kvz_pixels_get_sad_func(unsigned n)
; 144  : {
; 145  :   switch (n) {
; 146  :   case 4:
; 147  :     return kvz_sad_4x4;
; 148  :   case 8:
; 149  :     return kvz_sad_8x8;
; 150  :   case 16:
; 151  :     return kvz_sad_16x16;
; 152  :   case 32:
; 153  :     return kvz_sad_32x32;
; 154  :   case 64:
; 155  :     return kvz_sad_64x64;
; 156  :   default:
; 157  :     return NULL;
; 158  :   }
; 159  : }
; 160  : 
; 161  : /**
; 162  : * \brief  Get a function that calculates SATDs for 2 NxN blocks.
; 163  : *
; 164  : * \param n  Width of the region for which SATD is calculated.
; 165  : *
; 166  : * \returns  Pointer to cost_pixel_nxn_multi_func.
; 167  : */
; 168  : cost_pixel_nxn_multi_func * kvz_pixels_get_satd_dual_func(unsigned n)
; 169  : {
; 170  :   switch (n) {
; 171  :   case 4:
; 172  :     return kvz_satd_4x4_dual;
; 173  :   case 8:
; 174  :     return kvz_satd_8x8_dual;
; 175  :   case 16:
; 176  :     return kvz_satd_16x16_dual;
; 177  :   case 32:
; 178  :     return kvz_satd_32x32_dual;
; 179  :   case 64:
; 180  :     return kvz_satd_64x64_dual;
; 181  :   default:
; 182  :     return NULL;
; 183  :   }
; 184  : }
; 185  : 
; 186  : 
; 187  : /**
; 188  : * \brief  Get a function that calculates SADs for 2 NxN blocks.
; 189  : *
; 190  : * \param n  Width of the region for which SAD is calculated.
; 191  : *
; 192  : * \returns  Pointer to cost_pixel_nxn_multi_func.
; 193  : */
; 194  : cost_pixel_nxn_multi_func * kvz_pixels_get_sad_dual_func(unsigned n)
; 195  : {
; 196  :   switch (n) {
; 197  :   case 4:
; 198  :     return kvz_sad_4x4_dual;

	mov	rax, QWORD PTR kvz_sad_4x4_dual
	mov	QWORD PTR sad_dual_func$1$[rsp], rax
	mov	rax, QWORD PTR kvz_satd_4x4_dual
	mov	QWORD PTR satd_dual_func$1$[rsp], rax
	mov	rax, QWORD PTR kvz_satd_4x4
	mov	QWORD PTR satd_func$1$[rsp], rax
	mov	rax, QWORD PTR kvz_sad_4x4
	mov	QWORD PTR sad_func$1$[rsp], rax
$LN83@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 407  :   const kvz_config *cfg = &state->encoder_control->cfg;

	mov	rax, QWORD PTR [rdi]

; 408  :   const bool filter_boundary = !(cfg->lossless && cfg->implicit_rdpcm);

	cmp	DWORD PTR [rax+2392], 0
	je	SHORT $LN45@search_int
	cmp	DWORD PTR [rax+2420], 0
	mov	BYTE PTR filter_boundary$1$[rsp], 0
	jne	SHORT $LN46@search_int
$LN45@search_int:
	mov	BYTE PTR filter_boundary$1$[rsp], sil
$LN46@search_int:

; 409  : 
; 410  :   // Temporary block arrays
; 411  :   kvz_pixel _preds[PARALLEL_BLKS * 32 * 32 + SIMD_ALIGNMENT];
; 412  :   pred_buffer preds = ALIGNED_POINTER(_preds, SIMD_ALIGNMENT);
; 413  :   
; 414  :   kvz_pixel _orig_block[32 * 32 + SIMD_ALIGNMENT];
; 415  :   kvz_pixel *orig_block = ALIGNED_POINTER(_orig_block, SIMD_ALIGNMENT);
; 416  : 
; 417  :   // Store original block for SAD computation
; 418  :   kvz_pixels_blit(orig, orig_block, width, width, origstride, width);

	mov	DWORD PTR [rsp+40], ecx
	lea	rax, QWORD PTR _preds$[rsp]
	cdq
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	and	edx, 31
	lea	r14, QWORD PTR _preds$[rsp+32]
	add	rax, rdx
	mov	r9d, ecx
	and	eax, 31
	mov	r8d, ecx
	sub	rax, rdx
	mov	rcx, rbx
	sub	r14, rax
	lea	rax, QWORD PTR _orig_block$[rsp]
	cdq
	mov	QWORD PTR preds$1$[rsp], r14
	and	edx, 31
	add	rax, rdx
	and	eax, 31
	sub	rax, rdx
	lea	rdx, QWORD PTR _orig_block$[rsp+32]
	sub	rdx, rax
	mov	QWORD PTR orig_block$1$[rsp], rdx
	call	kvz_pixels_blit

; 419  : 
; 420  :   int8_t modes_selected = 0;
; 421  :   // Note: get_cost and get_cost_dual may return negative costs.
; 422  :   int32_t min_cost = INT_MAX;
; 423  :   int32_t max_cost = INT_MIN;
; 424  :   
; 425  :   // Initial offset decides how many modes are tried before moving on to the
; 426  :   // recursive search.
; 427  :   int offset;
; 428  :   if (state->encoder_control->cfg.full_intra_search) {

	mov	rax, QWORD PTR [rdi]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	r12d, 2147483647			; 7fffffffH
	mov	BYTE PTR modes_selected$1$[rsp], 0
	mov	DWORD PTR min_cost$1$[rsp], r12d

; 429  :     offset = 1;

	mov	edi, esi
	mov	DWORD PTR max_cost$1$[rsp], -2147483648	; ffffffff80000000H
	cmp	DWORD PTR [rax+68], 0
	jne	SHORT $LN32@search_int

; 430  :   } else {
; 431  :     static const int8_t offsets[4] = { 2, 4, 8, 8 };
; 432  :     offset = offsets[log2_width - 2];

	movsx	edi, BYTE PTR ?offsets@?3??search_intra_rough@@9@9[r13+rcx-2]
$LN32@search_int:

; 433  :   }
; 434  : 
; 435  :   // Calculate SAD for evenly spaced modes to select the starting point for 
; 436  :   // the recursive search.
; 437  :   for (int mode = 2; mode <= 34; mode += PARALLEL_BLKS * offset) {

	mov	r15d, 2
	jmp	SHORT $LN4@search_int
	npad	2
$LL195@search_int:
	mov	r13d, DWORD PTR log2_width$[rsp]
$LN4@search_int:
	movzx	r12d, BYTE PTR filter_boundary$1$[rsp]
	xorps	xmm0, xmm0

; 438  :     
; 439  :     double costs_out[PARALLEL_BLKS] = { 0 };

	movups	XMMWORD PTR costs_out$3[rsp], xmm0

; 440  :     for (int i = 0; i < PARALLEL_BLKS; ++i) {

	xor	esi, esi
	mov	ebp, r15d
	npad	2
$LL7@search_int:

; 441  :       if (mode + i * offset <= 34) {

	cmp	ebp, 34					; 00000022H
	jg	SHORT $LN180@search_int

; 442  :         kvz_intra_predict(refs, log2_width, mode + i * offset, COLOR_Y, preds[i], filter_boundary);

	mov	rcx, QWORD PTR refs$[rsp]
	xor	r9d, r9d
	movsx	eax, dil
	movzx	edx, r13b
	movsx	r8d, sil
	imul	r8d, eax
	mov	BYTE PTR [rsp+40], r12b
	mov	QWORD PTR [rsp+32], r14
	add	r8b, r15b
	call	kvz_intra_predict
$LN180@search_int:

; 440  :     for (int i = 0; i < PARALLEL_BLKS; ++i) {

	inc	esi
	add	ebp, edi
	add	r14, 1024				; 00000400H
	movzx	ebx, dil
	cmp	esi, 2
	jl	SHORT $LL7@search_int

; 443  :       }
; 444  :     }
; 445  :     
; 446  :     //TODO: add generic version of get cost  multi
; 447  :     get_cost_dual(state, preds, orig_block, satd_dual_func, sad_dual_func, width, costs_out);

	mov	r14, QWORD PTR preds$1$[rsp]
	lea	rax, QWORD PTR costs_out$3[rsp]
	mov	r9, QWORD PTR satd_dual_func$1$[rsp]
	mov	rdx, r14
	mov	r8, QWORD PTR orig_block$1$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR tv2495[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR sad_dual_func$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	get_cost_dual
	mov	r12d, DWORD PTR min_cost$1$[rsp]
	lea	r10, QWORD PTR costs_out$3[rsp]

; 448  : 
; 449  :     for (int i = 0; i < PARALLEL_BLKS; ++i) {

	xor	r8d, r8d
	mov	r9d, r15d
	npad	6
$LL10@search_int:

; 450  :       if (mode + i * offset <= 34) {

	mov	r13, QWORD PTR modes$[rsp]
	cmp	r9d, 34					; 00000022H
	jg	SHORT $LN179@search_int

; 451  :         costs[modes_selected] = costs_out[i];

	movsx	rbp, BYTE PTR modes_selected$1$[rsp]
	movsd	xmm2, QWORD PTR [r10]
	movd	xmm1, DWORD PTR max_cost$1$[rsp]
	mov	rax, QWORD PTR costs$[rsp]
	movd	xmm0, r12d

; 452  :         modes[modes_selected] = mode + i * offset;
; 453  :         min_cost = MIN(min_cost, costs[modes_selected]);
; 454  :         max_cost = MAX(max_cost, costs[modes_selected]);

	cvtdq2pd xmm1, xmm1
	movsx	ecx, bl
	movsd	QWORD PTR [rax+rbp*8], xmm2
	maxsd	xmm1, xmm2
	movsx	eax, r8b
	imul	ecx, eax
	cvtdq2pd xmm0, xmm0
	add	cl, r15b
	mov	BYTE PTR [rbp+r13], cl

; 455  :         ++modes_selected;

	inc	bpl
	cvttsd2si r11d, xmm1
	mov	BYTE PTR modes_selected$1$[rsp], bpl
	minsd	xmm0, xmm2
	mov	DWORD PTR max_cost$1$[rsp], r11d
	cvttsd2si r12d, xmm0
	jmp	SHORT $LN8@search_int
$LN179@search_int:
	movzx	ebp, BYTE PTR modes_selected$1$[rsp]
	movzx	ebx, dil
	mov	r11d, DWORD PTR max_cost$1$[rsp]
$LN8@search_int:

; 448  : 
; 449  :     for (int i = 0; i < PARALLEL_BLKS; ++i) {

	inc	r8d
	add	r9d, edi
	add	r10, 8
	cmp	r8d, 2
	jl	$LL10@search_int

; 433  :   }
; 434  : 
; 435  :   // Calculate SAD for evenly spaced modes to select the starting point for 
; 436  :   // the recursive search.
; 437  :   for (int mode = 2; mode <= 34; mode += PARALLEL_BLKS * offset) {

	lea	r15d, DWORD PTR [r15+rdi*2]
	mov	DWORD PTR min_cost$1$[rsp], r12d
	cmp	r15d, 34				; 00000022H
	jle	$LL195@search_int

; 62   :   double best_cost = costs[0];

	mov	r15, QWORD PTR costs$[rsp]
	xor	r8b, r8b

; 63   :   
; 64   :   for (uint8_t i = 1; i < length; ++i) {

	mov	dl, 1
	movsd	xmm1, QWORD PTR [r15]
	cmp	bpl, dl
	jbe	SHORT $LN95@search_int
	npad	15
$LL96@search_int:

; 65   :     if (costs[i] < best_cost) {

	movzx	eax, dl
	movzx	ecx, dl
	movsd	xmm0, QWORD PTR [r15+rax*8]
	comisd	xmm1, xmm0
	movzx	eax, r8b
	minsd	xmm0, xmm1
	cmovbe	ecx, eax
	inc	dl
	movzx	r8d, cl
	movaps	xmm1, xmm0
	cmp	dl, bpl
	jb	SHORT $LL96@search_int
$LN95@search_int:

; 456  :       }
; 457  :     }
; 458  :   }
; 459  : 
; 460  :   int8_t best_mode = modes[select_best_mode_index(modes, costs, modes_selected)];

	movzx	eax, r8b
	movzx	r12d, BYTE PTR [rax+r13]

; 461  :   double best_cost = min_cost;

	mov	eax, DWORD PTR min_cost$1$[rsp]
	movd	xmm6, eax
	cvtdq2pd xmm6, xmm6

; 462  :   
; 463  :   // Skip recursive search if all modes have the same cost.
; 464  :   if (min_cost != max_cost) {

	cmp	eax, r11d
	je	$LN12@search_int

; 465  :     // Do a recursive search to find the best mode, always centering on the
; 466  :     // current best mode.
; 467  :     while (offset > 1) {

	cmp	edi, 1
	jle	$LN12@search_int
	mov	rcx, QWORD PTR satd_dual_func$1$[rsp]
	npad	11
$LL11@search_int:

; 468  :       offset >>= 1;

	shr	edi, 1

; 469  : 
; 470  :       int8_t center_node = best_mode;
; 471  :       int8_t test_modes[] = { center_node - offset, center_node + offset };

	movzx	r15d, r12b
	sub	r15b, dil
	xorps	xmm0, xmm0
	mov	BYTE PTR test_modes$1$[rsp], r15b
	mov	BYTE PTR test_modes$1[rsp], r15b
	lea	r13d, DWORD PTR [r12+rdi]

; 472  : 
; 473  :       double costs_out[PARALLEL_BLKS] = { 0 };
; 474  :       char mode_in_range = 0;
; 475  : 
; 476  :       for (int i = 0; i < PARALLEL_BLKS; ++i) mode_in_range |= (test_modes[i] >= 2 && test_modes[i] <= 34);

	lea	eax, DWORD PTR [r13-2]
	mov	BYTE PTR test_modes$2$[rsp], r13b
	mov	BYTE PTR test_modes$1[rsp+1], r13b
	lea	r14d, DWORD PTR [r15-2]
	mov	BYTE PTR tv2455[rsp], al
	movups	XMMWORD PTR costs_out$2[rsp], xmm0
	cmp	al, 32					; 00000020H
	jbe	SHORT $LN178@search_int

; 477  : 
; 478  :       if (mode_in_range) {

	cmp	r14b, 32				; 00000020H
	ja	$LN196@search_int
$LN178@search_int:

; 479  :         for (int i = 0; i < PARALLEL_BLKS; ++i) {

	mov	rsi, QWORD PTR preds$1$[rsp]
	lea	rbx, QWORD PTR test_modes$1[rsp]
	movzx	r13d, BYTE PTR filter_boundary$1$[rsp]
	mov	ebp, 2
	mov	r15, QWORD PTR refs$[rsp]
	mov	QWORD PTR satd_dual_func$1$[rsp], rcx
	npad	8
$LL18@search_int:

; 480  :           if (test_modes[i] >= 2 && test_modes[i] <= 34) {

	movzx	r8d, BYTE PTR [rbx]
	lea	eax, DWORD PTR [r8-2]
	cmp	al, 32					; 00000020H
	ja	SHORT $LN16@search_int

; 481  :             kvz_intra_predict(refs, log2_width, test_modes[i], COLOR_Y, preds[i], filter_boundary);

	movzx	edx, BYTE PTR log2_width$[rsp]
	xor	r9d, r9d
	mov	BYTE PTR [rsp+40], r13b
	mov	rcx, r15
	mov	QWORD PTR [rsp+32], rsi
	call	kvz_intra_predict
$LN16@search_int:

; 479  :         for (int i = 0; i < PARALLEL_BLKS; ++i) {

	add	rsi, 1024				; 00000400H
	inc	rbx
	sub	rbp, 1
	jne	SHORT $LL18@search_int

; 482  :           }
; 483  :         }
; 484  : 
; 485  :         //TODO: add generic version of get cost multi
; 486  :         get_cost_dual(state, preds, orig_block, satd_dual_func, sad_dual_func, width, costs_out);

	mov	r9, QWORD PTR satd_dual_func$1$[rsp]
	lea	rax, QWORD PTR costs_out$2[rsp]
	mov	r8, QWORD PTR orig_block$1$[rsp]
	mov	rdx, QWORD PTR preds$1$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR tv2495[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR sad_dual_func$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	get_cost_dual

; 487  : 
; 488  :         for (int i = 0; i < PARALLEL_BLKS; ++i) {
; 489  :           if (test_modes[i] >= 2 && test_modes[i] <= 34) {

	movzx	r15d, BYTE PTR test_modes$1$[rsp]
	movzx	r13d, BYTE PTR test_modes$2$[rsp]
	mov	rdx, QWORD PTR modes$[rsp]
	cmp	r14b, 32				; 00000020H
	ja	SHORT $LN193@search_int

; 490  :             costs[modes_selected] = costs_out[i];

	movsx	rbp, BYTE PTR modes_selected$1$[rsp]
	movsd	xmm0, QWORD PTR costs_out$2[rsp]
	mov	rcx, QWORD PTR costs$[rsp]

; 491  :             modes[modes_selected] = test_modes[i];
; 492  :             if (costs[modes_selected] < best_cost) {
; 493  :               best_cost = costs[modes_selected];
; 494  :               best_mode = modes[modes_selected];
; 495  :             }
; 496  :             ++modes_selected;

	movzx	eax, r12b
	mov	BYTE PTR [rbp+rdx], r15b
	movsd	QWORD PTR [rcx+rbp*8], xmm0
	inc	bpl
	comisd	xmm6, xmm0
	mov	BYTE PTR modes_selected$1$[rsp], bpl
	mov	ecx, r15d
	minsd	xmm0, xmm6
	cmovbe	ecx, eax
	movzx	r12d, cl
	movaps	xmm6, xmm0
	jmp	SHORT $LN19@search_int
$LN193@search_int:

; 487  : 
; 488  :         for (int i = 0; i < PARALLEL_BLKS; ++i) {
; 489  :           if (test_modes[i] >= 2 && test_modes[i] <= 34) {

	movzx	ebp, BYTE PTR modes_selected$1$[rsp]
$LN19@search_int:
	cmp	BYTE PTR tv2455[rsp], 32		; 00000020H
	mov	r15, QWORD PTR costs$[rsp]
	ja	SHORT $LN194@search_int

; 490  :             costs[modes_selected] = costs_out[i];

	movsd	xmm0, QWORD PTR costs_out$2[rsp+8]

; 491  :             modes[modes_selected] = test_modes[i];
; 492  :             if (costs[modes_selected] < best_cost) {
; 493  :               best_cost = costs[modes_selected];
; 494  :               best_mode = modes[modes_selected];
; 495  :             }
; 496  :             ++modes_selected;

	mov	ecx, r13d
	movsx	rax, bpl
	inc	bpl
	comisd	xmm6, xmm0
	mov	BYTE PTR modes_selected$1$[rsp], bpl
	mov	BYTE PTR [rax+rdx], r13b
	movsd	QWORD PTR [r15+rax*8], xmm0
	minsd	xmm0, xmm6
	movzx	eax, r12b
	cmovbe	ecx, eax
	movzx	r12d, cl
	movaps	xmm6, xmm0
$LN194@search_int:

; 465  :     // Do a recursive search to find the best mode, always centering on the
; 466  :     // current best mode.
; 467  :     while (offset > 1) {

	mov	rcx, QWORD PTR satd_dual_func$1$[rsp]
	jmp	SHORT $LN141@search_int
$LN196@search_int:

; 477  : 
; 478  :       if (mode_in_range) {

	mov	r15, QWORD PTR costs$[rsp]
$LN141@search_int:

; 465  :     // Do a recursive search to find the best mode, always centering on the
; 466  :     // current best mode.
; 467  :     while (offset > 1) {

	cmp	edi, 1
	ja	$LL11@search_int
	mov	r13, QWORD PTR modes$[rsp]
$LN12@search_int:

; 497  :           }
; 498  :         }
; 499  :       }
; 500  :     }
; 501  :   }
; 502  : 
; 503  :   int8_t add_modes[5] = {intra_preds[0], intra_preds[1], intra_preds[2], 0, 1};

	mov	r14, QWORD PTR intra_preds$[rsp]
	lea	rdi, QWORD PTR add_modes$[rsp]
	movsd	xmm8, QWORD PTR __real@4000000000000000
	mov	esi, 5
	movsd	xmm9, QWORD PTR __real@3ffb333333333333
	mov	WORD PTR add_modes$[rsp+3], 256		; 00000100H
	movzx	eax, BYTE PTR [r14]
	mov	BYTE PTR add_modes$[rsp], al
	movzx	eax, BYTE PTR [r14+1]
	mov	BYTE PTR add_modes$[rsp+1], al
	movzx	eax, BYTE PTR [r14+2]
	movzx	r14d, BYTE PTR filter_boundary$1$[rsp]
	mov	BYTE PTR add_modes$[rsp+2], al
	movaps	XMMWORD PTR [rsp+3328], xmm7
	npad	1
$LL24@search_int:

; 507  :     bool has_mode = false;
; 508  :     int8_t mode = add_modes[pred_i];

	movzx	ebx, BYTE PTR [rdi]

; 509  : 
; 510  :     for (int mode_i = 0; mode_i < modes_selected; ++mode_i) {

	xor	eax, eax
	test	bpl, bpl
	jle	SHORT $LN173@search_int
	movsx	rcx, bpl
	npad	2
$LL27@search_int:

; 511  :       if (modes[mode_i] == add_modes[pred_i]) {

	cmp	BYTE PTR [rax+r13], bl
	je	$LN22@search_int

; 509  : 
; 510  :     for (int mode_i = 0; mode_i < modes_selected; ++mode_i) {

	inc	rax
	cmp	rax, rcx
	jl	SHORT $LL27@search_int
$LN173@search_int:

; 512  :         has_mode = true;
; 513  :         break;
; 514  :       }
; 515  :     }
; 516  : 
; 517  :     if (!has_mode) {
; 518  :       kvz_intra_predict(refs, log2_width, mode, COLOR_Y, preds[0], filter_boundary);

	mov	r12, QWORD PTR preds$1$[rsp]
	xor	r9d, r9d
	movzx	edx, BYTE PTR log2_width$[rsp]
	movzx	r8d, bl
	mov	rcx, QWORD PTR refs$[rsp]
	mov	BYTE PTR [rsp+40], r14b
	mov	QWORD PTR [rsp+32], r12
	call	kvz_intra_predict

; 93   :   double satd_cost = satd_func(pred, orig_block);

	mov	rdx, QWORD PTR orig_block$1$[rsp]
	mov	rcx, r12
	call	QWORD PTR satd_func$1$[rsp]

; 94   :   if (TRSKIP_RATIO != 0 && width == 4 && state->encoder_control->cfg.trskip_enable) {

	cmp	BYTE PTR tv2534[rsp], 4
	xorps	xmm7, xmm7

; 66   :       best_cost = costs[i];
; 67   :       best_index = i;
; 68   :     }
; 69   :   }
; 70   : 
; 71   :   return best_index;
; 72   : }
; 73   : 
; 74   : 
; 75   : /**
; 76   :  * \brief Calculate quality of the reconstruction.
; 77   :  *
; 78   :  * \param pred  Predicted pixels in continous memory.
; 79   :  * \param orig_block  Orignal (target) pixels in continous memory.
; 80   :  * \param satd_func  SATD function for this block size.
; 81   :  * \param sad_func  SAD function this block size.
; 82   :  * \param width  Pixel width of the block.
; 83   :  *
; 84   :  * \return  Estimated RD cost of the reconstruction and signaling the
; 85   :  *     coefficients of the residual.
; 86   :  */
; 87   : static double get_cost(encoder_state_t * const state, 
; 88   :                        kvz_pixel *pred, kvz_pixel *orig_block,
; 89   :                        cost_pixel_nxn_func *satd_func,
; 90   :                        cost_pixel_nxn_func *sad_func,
; 91   :                        int width)
; 92   : {
; 93   :   double satd_cost = satd_func(pred, orig_block);

	mov	eax, eax
	cvtsi2sd xmm7, rax

; 94   :   if (TRSKIP_RATIO != 0 && width == 4 && state->encoder_control->cfg.trskip_enable) {

	jne	$LN102@search_int
	mov	r12, QWORD PTR state$[rsp]
	mov	rdx, QWORD PTR [r12]
	cmp	DWORD PTR [rdx+72], 0
	je	$LN102@search_int

; 95   :     // If the mode looks better with SAD than SATD it might be a good
; 96   :     // candidate for transform skip. How much better SAD has to be is
; 97   :     // controlled by TRSKIP_RATIO.
; 98   : 
; 99   :     // Add the offset bit costs of signaling 'luma and chroma use trskip',
; 100  :     // versus signaling 'luma and chroma don't use trskip' to the SAD cost.
; 101  :     const cabac_ctx_t *ctx = &state->cabac.ctx.transform_skip_model_luma;
; 102  :     double trskip_bits = CTX_ENTROPY_FBITS(ctx, 1) - CTX_ENTROPY_FBITS(ctx, 0);

	movzx	ecx, BYTE PTR [r12+350]
	lea	r8, OFFSET FLAT:__ImageBase
	mov	eax, ecx
	xor	rax, 1

; 103  : 
; 104  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [rdx+2596], 0
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[r8+rax*4]
	subss	xmm0, DWORD PTR kvz_f_entropy_bits[r8+rcx*4]
	cvtps2pd xmm6, xmm0
	je	SHORT $LN101@search_int

; 105  :       ctx = &state->cabac.ctx.transform_skip_model_chroma;
; 106  :       trskip_bits += 2.0 * (CTX_ENTROPY_FBITS(ctx, 1) - CTX_ENTROPY_FBITS(ctx, 0));

	movzx	ecx, BYTE PTR [r12+351]
	mov	eax, ecx
	xor	rax, 1
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[r8+rax*4]
	subss	xmm0, DWORD PTR kvz_f_entropy_bits[r8+rcx*4]
	cvtps2pd xmm1, xmm0
	mulsd	xmm1, xmm8
	addsd	xmm6, xmm1
$LN101@search_int:

; 107  :     }
; 108  : 
; 109  :     double sad_cost = TRSKIP_RATIO * sad_func(pred, orig_block) + state->lambda_sqrt * trskip_bits;

	mov	rdx, QWORD PTR orig_block$1$[rsp]
	mov	rcx, QWORD PTR preds$1$[rsp]
	call	QWORD PTR sad_func$1$[rsp]
	mulsd	xmm6, QWORD PTR [r12+376]
	xorps	xmm0, xmm0
	mov	eax, eax
	cvtsi2sd xmm0, rax
	mulsd	xmm0, xmm9
	addsd	xmm6, xmm0

; 110  :     if (sad_cost < satd_cost) {

	comisd	xmm6, xmm7
	jb	SHORT $LN99@search_int
$LN102@search_int:

; 111  :       return sad_cost;
; 112  :     }
; 113  :   }
; 114  :   return satd_cost;

	movaps	xmm6, xmm7
$LN99@search_int:

; 519  :       costs[modes_selected] = get_cost(state, preds[0], orig_block, satd_func, sad_func, width);

	movsx	rax, bpl

; 520  :       modes[modes_selected] = mode;
; 521  :       ++modes_selected;

	inc	bpl
	movsd	QWORD PTR [r15+rax*8], xmm6
	mov	BYTE PTR [rax+r13], bl
$LN22@search_int:

; 504  : 
; 505  :   // Add DC, planar and missing predicted modes.
; 506  :   for (int8_t pred_i = 0; pred_i < 5; ++pred_i) {

	inc	rdi
	sub	rsi, 1
	jne	$LL24@search_int

; 522  :     }
; 523  :   }
; 524  : 
; 525  :   // Add prediction mode coding cost as the last thing. We don't want this
; 526  :   // affecting the halving search.
; 527  :   int lambda_cost = (int)(state->lambda_sqrt + 0.5);

	mov	rcx, QWORD PTR state$[rsp]

; 528  :   for (int mode_i = 0; mode_i < modes_selected; ++mode_i) {

	movaps	xmm9, XMMWORD PTR [rsp+3296]
	movaps	xmm8, XMMWORD PTR [rsp+3312]
	movaps	xmm7, XMMWORD PTR [rsp+3328]
	movsd	xmm0, QWORD PTR [rcx+376]
	movaps	xmm6, XMMWORD PTR [rsp+3344]
	mov	r14, QWORD PTR intra_preds$[rsp]
	movsx	rbx, bpl
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si eax, xmm0
	test	bpl, bpl
	jle	$LN192@search_int
	movzx	edi, BYTE PTR [r14+1]

; 658  :     mode_bits += ((luma_mode == intra_preds[0]) ? 1 : 2);

	xor	edx, edx
	movzx	esi, BYTE PTR [r14+2]
	movzx	r10d, BYTE PTR [r14]
	lea	r14, OFFSET FLAT:__ImageBase
	movzx	r11d, BYTE PTR [rcx+173]
	movsd	xmm2, QWORD PTR __real@4014000000000000
	lea	r12d, QWORD PTR [rdx+1]
	movd	xmm3, eax
	cvtdq2pd xmm3, xmm3
	npad	6
$LL30@search_int:

; 529  :     costs[mode_i] += lambda_cost * kvz_luma_mode_bits(state, modes[mode_i], intra_preds);

	movzx	r9d, BYTE PTR [rdx+r13]

; 649  :     if (luma_mode == intra_preds[i]) {

	cmp	r9b, r10b
	sete	al
	cmp	r9b, dil
	movzx	r8d, al
	cmove	r8d, r12d
	cmp	r9b, sil
	jne	SHORT $LN145@search_int

; 650  :       mode_in_preds = true;

	mov	rax, r11
	xor	rax, r12
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[r14+rax*4]
	cvtps2pd xmm0, xmm0

; 442  :         kvz_intra_predict(refs, log2_width, mode + i * offset, COLOR_Y, preds[i], filter_boundary);

	jmp	SHORT $LN181@search_int
$LN145@search_int:

; 655  :   mode_bits = CTX_ENTROPY_FBITS(ctx, mode_in_preds);

	mov	rcx, r11
	movzx	eax, r8b
	xor	rcx, rax
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[r14+rcx*4]
	cvtps2pd xmm0, xmm0

; 656  : 
; 657  :   if (mode_in_preds) {

	test	r8b, r8b
	je	SHORT $LN109@search_int
$LN181@search_int:

; 658  :     mode_bits += ((luma_mode == intra_preds[0]) ? 1 : 2);

	xor	eax, eax
	cmp	r9b, r10b
	setne	al
	inc	eax
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1

; 659  :   } else {

	jmp	SHORT $LN110@search_int
$LN109@search_int:

; 660  :     mode_bits += 5;

	movaps	xmm1, xmm2
$LN110@search_int:

; 529  :     costs[mode_i] += lambda_cost * kvz_luma_mode_bits(state, modes[mode_i], intra_preds);

	addsd	xmm0, xmm1
	mulsd	xmm0, xmm3
	addsd	xmm0, QWORD PTR [r15+rdx*8]
	movsd	QWORD PTR [r15+rdx*8], xmm0
	inc	rdx
	cmp	rdx, rbx
	jl	SHORT $LL30@search_int
$LN192@search_int:

; 530  :   }
; 531  : 
; 532  :   #undef PARALLEL_BLKS
; 533  : 
; 534  :   return modes_selected;
; 535  : }

	mov	rbx, QWORD PTR [rsp+3432]
	movzx	eax, bpl
	add	rsp, 3360				; 00000d20H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
search_intra_rough ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
pred_cu$1 = 80
pred_cu$2 = 80
tv1561 = 104
y_local$1$ = 108
tv1473 = 112
tv1472 = 120
orig_block$ = 128
state$ = 4352
x_px$ = 4360
y_px$ = 4368
depth$ = 4376
orig$ = 4384
tr_depth$1$ = 4392
origstride$dead$ = 4392
intra_preds$ = 4400
rdo_mode$1$ = 4408
modes_to_check$ = 4408
modes$ = 4416
costs$ = 4424
lcu$ = 4432
search_intra_rdo PROC

; 570  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	r12
	push	r13
	push	r14
	mov	eax, 4304				; 000010d0H
	call	__chkstk
	sub	rsp, rax

; 571  :   const int tr_depth = CLIP(1, MAX_PU_DEPTH, depth + state->encoder_control->cfg.tr_depth_intra);

	mov	rax, QWORD PTR [rcx]
	mov	r12d, r9d
	mov	QWORD PTR [rsp+4296], rbp
	mov	QWORD PTR [rsp+4288], rdi
	mov	QWORD PTR [rsp+4280], r15
	mov	r15d, DWORD PTR [rax+76]
	mov	eax, 1
	add	r15d, r9d
	cmp	r15d, 4
	jg	SHORT $LN111@search_int
	cmp	r15d, eax
	cmovl	r15d, eax
	mov	DWORD PTR tr_depth$1$[rsp], r15d
	jmp	SHORT $LN20@search_int
$LN111@search_int:
	mov	DWORD PTR tr_depth$1$[rsp], 4
$LN20@search_int:

; 572  :   const int width = LCU_WIDTH >> depth;

	mov	ecx, r12d

; 573  : 
; 574  :   kvz_pixel orig_block[LCU_WIDTH * LCU_WIDTH + 1];
; 575  : 
; 576  :   kvz_pixels_blit(orig, orig_block, width, width, origstride, width);

	lea	rdx, QWORD PTR orig_block$[rsp]
	mov	edi, 64					; 00000040H
	sar	edi, cl
	mov	rcx, QWORD PTR orig$[rsp]
	mov	r9d, edi
	mov	DWORD PTR [rsp+40], edi
	mov	r8d, edi
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	call	kvz_pixels_blit

; 577  : 
; 578  :   // Check that the predicted modes are in the RDO mode list
; 579  :   if (modes_to_check < 35) {

	movsxd	r14, DWORD PTR modes_to_check$[rsp]
	xor	r13d, r13d
	mov	rbx, QWORD PTR lcu$[rsp]
	mov	r9d, 24
	mov	rbp, QWORD PTR costs$[rsp]
	mov	rsi, QWORD PTR modes$[rsp]
	cmp	r14d, 35				; 00000023H
	jge	$LN100@search_int

; 580  :     for (int pred_mode = 0; pred_mode < 3; pred_mode++) {
; 581  :       int mode_found = 0;
; 582  :       for (int rdo_mode = 0; rdo_mode < modes_to_check; rdo_mode++) {

	mov	r8, QWORD PTR intra_preds$[rsp]
	mov	ecx, r13d
	test	r14d, r14d
	jle	SHORT $LN112@search_int

; 583  :         if (intra_preds[pred_mode] == modes[rdo_mode]) {

	movzx	edx, BYTE PTR [r8]
	mov	rax, rsi
	npad	1
$LL7@search_int:
	cmp	dl, BYTE PTR [rax]
	je	SHORT $LN120@search_int

; 580  :     for (int pred_mode = 0; pred_mode < 3; pred_mode++) {
; 581  :       int mode_found = 0;
; 582  :       for (int rdo_mode = 0; rdo_mode < modes_to_check; rdo_mode++) {

	inc	ecx
	inc	rax
	cmp	ecx, r14d
	jl	SHORT $LL7@search_int
$LN112@search_int:

; 584  :           mode_found = 1;
; 585  :           break;
; 586  :         }
; 587  :       }
; 588  :       // Add this prediction mode to RDO checking
; 589  :       if (!mode_found) {
; 590  :         modes[modes_to_check] = intra_preds[pred_mode];

	movzx	eax, BYTE PTR [r8]
	mov	BYTE PTR [r14+rsi], al

; 591  :         modes_to_check++;

	lea	eax, DWORD PTR [r14+1]
	mov	r14d, eax
	test	eax, eax
	jle	SHORT $LN113@search_int
$LN120@search_int:

; 583  :         if (intra_preds[pred_mode] == modes[rdo_mode]) {

	movzx	edx, BYTE PTR [r8+1]
	mov	rax, rsi
	mov	ecx, r13d
	npad	4
$LL75@search_int:
	cmp	dl, BYTE PTR [rax]
	je	SHORT $LN119@search_int

; 580  :     for (int pred_mode = 0; pred_mode < 3; pred_mode++) {
; 581  :       int mode_found = 0;
; 582  :       for (int rdo_mode = 0; rdo_mode < modes_to_check; rdo_mode++) {

	inc	ecx
	inc	rax
	cmp	ecx, r14d
	jl	SHORT $LL75@search_int
$LN113@search_int:

; 584  :           mode_found = 1;
; 585  :           break;
; 586  :         }
; 587  :       }
; 588  :       // Add this prediction mode to RDO checking
; 589  :       if (!mode_found) {
; 590  :         modes[modes_to_check] = intra_preds[pred_mode];

	movzx	eax, BYTE PTR [r8+1]
	movsxd	rcx, r14d
	mov	BYTE PTR [rcx+rsi], al

; 591  :         modes_to_check++;

	lea	eax, DWORD PTR [r14+1]
	mov	r14d, eax
	test	eax, eax
	jle	SHORT $LN114@search_int
$LN119@search_int:

; 583  :         if (intra_preds[pred_mode] == modes[rdo_mode]) {

	movzx	edx, BYTE PTR [r8+2]
	mov	rax, rsi
	mov	ecx, r13d
	npad	1
$LL80@search_int:
	cmp	dl, BYTE PTR [rax]
	je	SHORT $LN118@search_int

; 580  :     for (int pred_mode = 0; pred_mode < 3; pred_mode++) {
; 581  :       int mode_found = 0;
; 582  :       for (int rdo_mode = 0; rdo_mode < modes_to_check; rdo_mode++) {

	inc	ecx
	inc	rax
	cmp	ecx, r14d
	jl	SHORT $LL80@search_int
$LN114@search_int:

; 584  :           mode_found = 1;
; 585  :           break;
; 586  :         }
; 587  :       }
; 588  :       // Add this prediction mode to RDO checking
; 589  :       if (!mode_found) {
; 590  :         modes[modes_to_check] = intra_preds[pred_mode];

	movzx	eax, BYTE PTR [r8+2]
	movsxd	rcx, r14d

; 591  :         modes_to_check++;

	inc	r14d
	mov	BYTE PTR [rcx+rsi], al
$LN100@search_int:

; 596  :   for(int rdo_mode = 0; rdo_mode < modes_to_check; rdo_mode ++) {

	test	r14d, r14d
	jle	$LN9@search_int
$LN118@search_int:
	mov	r11d, DWORD PTR y_px$[rsp]
	movzx	r15d, r12b
	and	r15b, 7
	movaps	XMMWORD PTR [rsp+4256], xmm6

; 591  :         modes_to_check++;

	movsd	xmm6, QWORD PTR __real@4014000000000000

; 599  : 
; 600  :     // Perform transform split search and save mode RD cost for the best one.
; 601  :     cu_info_t pred_cu;
; 602  :     pred_cu.depth = depth;
; 603  :     pred_cu.type = CU_INTRA;
; 604  :     pred_cu.part_size = ((depth == MAX_PU_DEPTH) ? SIZE_NxN : SIZE_2Nx2N);

	cmp	r12d, 4
	mov	r12d, DWORD PTR x_px$[rsp]
	mov	eax, r13d
	cmove	eax, r9d
	movaps	XMMWORD PTR [rsp+4240], xmm7
	movsd	xmm7, QWORD PTR __real@3fe0000000000000
	or	al, r15b
	shl	al, 2
	and	r12d, 63				; 0000003fH
	or	al, 1
	mov	QWORD PTR tv1472[rsp], rbp
	and	r11d, 63				; 0000003fH
	mov	DWORD PTR tv1561[rsp], eax
	mov	rdx, rsi
	mov	DWORD PTR y_local$1$[rsp], r11d
	mov	QWORD PTR tv1473[rsp], rdx
	mov	r9, rbp
	mov	DWORD PTR rdo_mode$1$[rsp], r13d
	npad	7
$LL10@search_int:

; 597  :     int rdo_bitcost = kvz_luma_mode_bits(state, modes[rdo_mode], intra_preds);

	movsx	r10d, BYTE PTR [rdx]

; 649  :     if (luma_mode == intra_preds[i]) {

	mov	rcx, QWORD PTR intra_preds$[rsp]
	movzx	r8d, BYTE PTR [rcx]
	cmp	r10b, r8b
	sete	al
	cmp	r10b, BYTE PTR [rcx+1]
	movzx	edx, al
	mov	eax, 1
	cmove	edx, eax
	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+173]
	cmp	r10b, BYTE PTR [rcx+2]
	jne	SHORT $LN87@search_int

; 650  :       mode_in_preds = true;

	xor	rax, 1
	lea	rcx, OFFSET FLAT:__ImageBase
	movss	xmm1, DWORD PTR kvz_f_entropy_bits[rcx+rax*4]
	cvtps2pd xmm1, xmm1
	jmp	SHORT $LN117@search_int
$LN87@search_int:

; 651  :     }
; 652  :   }
; 653  : 
; 654  :   const cabac_ctx_t *ctx = &(state->cabac.ctx.intra_mode_model);
; 655  :   mode_bits = CTX_ENTROPY_FBITS(ctx, mode_in_preds);

	movzx	ecx, dl
	xor	rcx, rax
	lea	rax, OFFSET FLAT:__ImageBase
	movss	xmm1, DWORD PTR kvz_f_entropy_bits[rax+rcx*4]
	cvtps2pd xmm1, xmm1

; 656  : 
; 657  :   if (mode_in_preds) {

	test	dl, dl
	je	SHORT $LN28@search_int
$LN117@search_int:

; 658  :     mode_bits += ((luma_mode == intra_preds[0]) ? 1 : 2);

	cmp	r10b, r8b
	mov	eax, r13d
	setne	al
	inc	eax
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0

; 659  :   } else {

	jmp	SHORT $LN29@search_int
$LN28@search_int:

; 660  :     mode_bits += 5;

	movaps	xmm0, xmm6
$LN29@search_int:

; 598  :     costs[rdo_mode] = rdo_bitcost * (int)(state->lambda + 0.5);

	mov	rax, QWORD PTR state$[rsp]
	addsd	xmm0, xmm1

; 605  :     pred_cu.intra.mode = modes[rdo_mode];

	mov	BYTE PTR pred_cu$2[rsp+8], r10b

; 606  :     pred_cu.intra.mode_chroma = modes[rdo_mode];

	mov	BYTE PTR pred_cu$2[rsp+9], r10b
	cvttsd2si ecx, xmm0
	movsd	xmm0, QWORD PTR [rax+368]
	addsd	xmm0, xmm7
	cvttsd2si eax, xmm0
	imul	ecx, eax
	mov	eax, DWORD PTR tv1561[rsp]
	mov	BYTE PTR pred_cu$2[rsp], al

; 607  :     FILL(pred_cu.cbf, 0);

	xor	eax, eax
	mov	WORD PTR pred_cu$2[rsp+4], ax
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	movsd	QWORD PTR [r9], xmm0
	mov	r9d, r13d
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 137  :   for (unsigned y = 0; y < width; y += SCU_WIDTH) {

	test	edi, edi
	je	SHORT $LN33@search_int
	npad	8
$LL34@search_int:
	lea	eax, DWORD PTR [r9+r11]

; 138  :     for (unsigned x = 0; x < width; x += SCU_WIDTH) {

	mov	edx, r13d
	shr	eax, 2
	imul	r8d, eax, 17
	npad	2
$LL37@search_int:

; 139  :       LCU_GET_CU_AT_PX(lcu, x_local + x, y_local + y)->tr_depth = tr_depth;

	lea	eax, DWORD PTR [rdx+r12]
	add	edx, 4
	shr	eax, 2
	add	eax, 18
	add	eax, r8d
	lea	rax, QWORD PTR [rax+rax*4]
	and	BYTE PTR [rbx+rax*4+24977], 248		; 000000f8H
	or	BYTE PTR [rbx+rax*4+24977], r15b
	cmp	edx, edi
	jb	SHORT $LL37@search_int

; 137  :   for (unsigned y = 0; y < width; y += SCU_WIDTH) {

	add	r9d, 4
	cmp	r9d, edi
	jb	SHORT $LL34@search_int
$LN33@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 612  :     double mode_cost = search_intra_trdepth(state, x_px, y_px, depth, tr_depth, modes[rdo_mode], MAX_INT, &pred_cu, lcu);

	mov	eax, DWORD PTR tr_depth$1$[rsp]
	lea	rcx, QWORD PTR pred_cu$2[rsp]
	mov	r9d, DWORD PTR depth$[rsp]
	mov	r8d, DWORD PTR y_px$[rsp]
	mov	edx, DWORD PTR x_px$[rsp]
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, QWORD PTR state$[rsp]
	mov	DWORD PTR [rsp+48], 2147483647		; 7fffffffH
	mov	DWORD PTR [rsp+40], r10d
	mov	DWORD PTR [rsp+32], eax
	call	search_intra_trdepth

; 613  :     costs[rdo_mode] += mode_cost;

	mov	r9, QWORD PTR tv1472[rsp]

; 614  : 
; 615  :     // Early termination if no coefficients has to be coded
; 616  :     if (state->encoder_control->cfg.intra_rdo_et && !cbf_is_set_any(pred_cu.cbf, depth)) {

	mov	rax, QWORD PTR state$[rsp]
	addsd	xmm0, QWORD PTR [r9]
	mov	rax, QWORD PTR [rax]
	movsd	QWORD PTR [r9], xmm0
	cmp	DWORD PTR [rax+2388], r13d
	je	SHORT $LN8@search_int
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, DWORD PTR depth$[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	edx, WORD PTR pred_cu$2[rsp+4]
	movzx	ecx, WORD PTR cbf_masks[rcx+rax*2]
	test	cx, dx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN8@search_int

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, ecx
	shl	ecx, 5
	or	ecx, eax
	shl	ecx, 5
	test	ecx, edx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	je	SHORT $LN65@search_int
$LN8@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 596  :   for(int rdo_mode = 0; rdo_mode < modes_to_check; rdo_mode ++) {

	mov	ecx, DWORD PTR rdo_mode$1$[rsp]
	add	r9, 8
	mov	rdx, QWORD PTR tv1473[rsp]
	inc	ecx
	inc	rdx
	mov	DWORD PTR rdo_mode$1$[rsp], ecx
	mov	QWORD PTR tv1473[rsp], rdx
	mov	QWORD PTR tv1472[rsp], r9
	cmp	ecx, r14d
	jge	SHORT $LN123@search_int
	mov	r11d, DWORD PTR y_local$1$[rsp]
	jmp	$LL10@search_int
$LN65@search_int:

; 617  :       modes_to_check = rdo_mode + 1;

	mov	r14d, DWORD PTR rdo_mode$1$[rsp]
	inc	r14d
$LN123@search_int:

; 596  :   for(int rdo_mode = 0; rdo_mode < modes_to_check; rdo_mode ++) {

	mov	r12d, DWORD PTR depth$[rsp]
	movaps	xmm6, XMMWORD PTR [rsp+4256]
	movaps	xmm7, XMMWORD PTR [rsp+4240]
$LN9@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 427  :   for (uint8_t i = 1; i < length; ++i) {

	mov	r15, QWORD PTR [rsp+4280]
	mov	r8b, 1
	mov	rdi, QWORD PTR [rsp+4288]
	cmp	r14b, r8b
	jbe	SHORT $LN51@search_int
	lea	r9, QWORD PTR [rsi+1]
	lea	r10, QWORD PTR [rbp+8]
	npad	10
$LL52@search_int:

; 428  :     const double cur_cost = costs[i];

	movsd	xmm1, QWORD PTR [r10]

; 429  :     const int8_t cur_mode = modes[i];
; 430  :     uint8_t j = i;

	movzx	edx, r8b
	movzx	r11d, BYTE PTR [r9]
	npad	3
$LL53@search_int:

; 431  :     while (j > 0 && cur_cost < costs[j - 1]) {

	movzx	ecx, dl
	movsd	xmm0, QWORD PTR [rbp+rcx*8-8]
	comisd	xmm1, xmm0
	jae	SHORT $LN54@search_int

; 432  :       costs[j] = costs[j - 1];
; 433  :       modes[j] = modes[j - 1];

	movzx	eax, BYTE PTR [rcx+rsi-1]
	mov	BYTE PTR [rcx+rsi], al
	movsd	QWORD PTR [rbp+rcx*8], xmm0

; 434  :       --j;

	add	dl, 255					; 000000ffH
	jne	SHORT $LL53@search_int
$LN54@search_int:

; 435  :     }
; 436  :     costs[j] = cur_cost;

	movzx	eax, dl
	inc	r8b
	add	r10, 8
	inc	r9
	movsd	QWORD PTR [rbp+rax*8], xmm1

; 437  :     modes[j] = cur_mode;

	mov	BYTE PTR [rax+rsi], r11b
	cmp	r8b, r14b
	jb	SHORT $LL52@search_int
$LN51@search_int:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 628  :   if (tr_depth != depth) {

	mov	r8d, DWORD PTR tr_depth$1$[rsp]
	mov	rbp, QWORD PTR [rsp+4296]
	cmp	r8d, r12d
	je	SHORT $LN121@search_int

; 629  :     cu_info_t pred_cu;
; 630  :     pred_cu.depth = depth;
; 631  :     pred_cu.type = CU_INTRA;
; 632  :     pred_cu.part_size = ((depth == MAX_PU_DEPTH) ? SIZE_NxN : SIZE_2Nx2N);
; 633  :     pred_cu.intra.mode = modes[0];

	movsx	ecx, BYTE PTR [rsi]
	mov	eax, 24

; 634  :     pred_cu.intra.mode_chroma = modes[0];
; 635  :     FILL(pred_cu.cbf, 0);
; 636  :     search_intra_trdepth(state, x_px, y_px, depth, tr_depth, modes[0], MAX_INT, &pred_cu, lcu);

	mov	edx, DWORD PTR x_px$[rsp]
	cmp	r12d, 4
	mov	QWORD PTR [rsp+64], rbx
	mov	r9d, r12d
	cmove	r13d, eax
	mov	BYTE PTR pred_cu$1[rsp+8], cl
	movzx	eax, r12b
	mov	BYTE PTR pred_cu$1[rsp+9], cl
	and	al, 7
	or	r13b, al
	xor	eax, eax
	mov	WORD PTR pred_cu$1[rsp+4], ax
	lea	rax, QWORD PTR pred_cu$1[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	DWORD PTR [rsp+48], 2147483647		; 7fffffffH
	mov	DWORD PTR [rsp+40], ecx
	mov	rcx, QWORD PTR state$[rsp]
	shl	r13b, 2
	mov	DWORD PTR [rsp+32], r8d
	or	r13b, 1
	mov	r8d, DWORD PTR y_px$[rsp]
	mov	BYTE PTR pred_cu$1[rsp], r13b
	call	search_intra_trdepth
$LN121@search_int:

; 637  :   }
; 638  : 
; 639  :   return modes_to_check;
; 640  : }

	movzx	eax, r14b
	add	rsp, 4304				; 000010d0H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbx
	ret	0
search_intra_rdo ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
_TEXT	SEGMENT
tr_cu$1$ = 64
chroma$2 = 80
best_chroma$3 = 96
state$ = 192
x_px$ = 200
y_px$ = 208
depth$ = 216
intra_mode$ = 224
modes$ = 232
num_modes$ = 240
lcu$ = 248
kvz_search_intra_chroma_rdo PROC

; 686  : {

$LN20:
	mov	r11, rsp
	mov	DWORD PTR [r11+32], r9d
	push	rbp
	push	r14
	push	r15
	sub	rsp, 160				; 000000a0H
	mov	eax, edx
	mov	r14d, r8d
	or	eax, r8d
	mov	r15d, edx
	mov	rbp, rcx
	test	al, 4

; 687  :   const bool reconstruct_chroma = !(x_px & 4 || y_px & 4);

	jne	$LN5@kvz_search

; 688  : 
; 689  :   if (reconstruct_chroma) {
; 690  :     const vector2d_t lcu_px = { SUB_SCU(x_px), SUB_SCU(y_px) };

	mov	QWORD PTR [r11-32], r12
	mov	r12d, edx

; 691  :     cu_info_t *const tr_cu = LCU_GET_CU_AT_PX(lcu, lcu_px.x, lcu_px.y);

	mov	rdx, QWORD PTR lcu$[rsp]
	and	r12d, 63				; 0000003fH
	mov	QWORD PTR [r11-40], r13
	mov	r13d, r8d
	and	r13d, 63				; 0000003fH
	movaps	XMMWORD PTR [r11-56], xmm6

; 692  : 
; 693  :     struct {
; 694  :       double cost;
; 695  :       int8_t mode;
; 696  :     } chroma, best_chroma;
; 697  : 
; 698  :     best_chroma.mode = 0;
; 699  :     best_chroma.cost = MAX_INT;

	movsd	xmm6, QWORD PTR __real@41dfffffffc00000
	mov	eax, r13d
	shr	eax, 2
	imul	ecx, eax, 17
	mov	eax, r12d
	shr	eax, 2
	add	eax, 18
	add	eax, ecx
	mov	ecx, eax
	add	rcx, 6244				; 00001864H
	lea	rax, QWORD PTR [rcx+rax*4]

; 700  : 
; 701  :     for (int8_t chroma_mode_i = 0; chroma_mode_i < num_modes; ++chroma_mode_i) {

	movzx	ecx, BYTE PTR num_modes$[rsp]
	lea	rax, QWORD PTR [rdx+rax*4]
	mov	QWORD PTR tr_cu$1$[rsp], rax
	xor	al, al
	mov	BYTE PTR best_chroma$3[rsp+8], al
	test	cl, cl
	jle	$LN3@kvz_search

; 688  : 
; 689  :   if (reconstruct_chroma) {
; 690  :     const vector2d_t lcu_px = { SUB_SCU(x_px), SUB_SCU(y_px) };

	mov	QWORD PTR [r11+8], rbx
	mov	QWORD PTR [r11+16], rsi
	mov	esi, ecx
	mov	QWORD PTR [r11+24], rdi
	mov	rdi, QWORD PTR modes$[rsp]
	movaps	XMMWORD PTR [rsp+112], xmm7
	movsd	xmm7, QWORD PTR __real@4000000000000000
	npad	9
$LL4@kvz_search:

; 702  :       chroma.mode = modes[chroma_mode_i];

	movzx	ebx, BYTE PTR [rdi]

; 703  : 
; 704  :       kvz_intra_recon_cu(state,

	mov	r8d, r14d
	mov	QWORD PTR [rsp+56], rdx
	mov	rcx, rbp
	mov	QWORD PTR [rsp+48], 0
	mov	edx, r15d
	mov	BYTE PTR [rsp+40], bl
	mov	BYTE PTR [rsp+32], -1
	mov	BYTE PTR chroma$2[rsp+8], bl
	call	kvz_intra_recon_cu

; 705  :                          x_px, y_px,
; 706  :                          depth,
; 707  :                          -1, chroma.mode, // skip luma
; 708  :                          NULL, lcu);
; 709  :       chroma.cost = kvz_cu_rd_cost_chroma(state, lcu_px.x, lcu_px.y, depth, tr_cu, lcu);

	mov	rax, QWORD PTR lcu$[rsp]
	mov	r8d, r13d
	mov	r9d, DWORD PTR depth$[rsp]
	mov	edx, r12d
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rbp
	mov	rax, QWORD PTR tr_cu$1$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	kvz_cu_rd_cost_chroma

; 671  :   if (chroma_mode == luma_mode) {

	lea	rcx, OFFSET FLAT:kvz_f_entropy_bits
	movzx	eax, BYTE PTR [rbp+174]
	cmp	bl, BYTE PTR intra_mode$[rsp]
	jne	SHORT $LN11@kvz_search
	movss	xmm1, DWORD PTR [rcx+rax*4]

; 672  :     mode_bits = CTX_ENTROPY_FBITS(ctx, 0);

	cvtps2pd xmm1, xmm1

; 673  :   } else {

	jmp	SHORT $LN12@kvz_search
$LN11@kvz_search:

; 674  :     mode_bits = 2.0 + CTX_ENTROPY_FBITS(ctx, 1);

	xor	rax, 1
	movss	xmm1, DWORD PTR [rcx+rax*4]
	cvtps2pd xmm1, xmm1
	addsd	xmm1, xmm7
$LN12@kvz_search:

; 710  : 
; 711  :       double mode_bits = kvz_chroma_mode_bits(state, chroma.mode, intra_mode);
; 712  :       chroma.cost += mode_bits * state->lambda;

	mulsd	xmm1, QWORD PTR [rbp+368]
	addsd	xmm0, xmm1
	comisd	xmm0, xmm6
	movsd	QWORD PTR chroma$2[rsp], xmm0

; 713  : 
; 714  :       if (chroma.cost < best_chroma.cost) {

	jae	SHORT $LN2@kvz_search

; 715  :         best_chroma = chroma;

	movaps	xmm0, XMMWORD PTR chroma$2[rsp]
	movaps	xmm6, xmm0
	movdqa	XMMWORD PTR best_chroma$3[rsp], xmm0
$LN2@kvz_search:

; 700  : 
; 701  :     for (int8_t chroma_mode_i = 0; chroma_mode_i < num_modes; ++chroma_mode_i) {

	mov	rdx, QWORD PTR lcu$[rsp]
	inc	rdi
	mov	r9d, DWORD PTR depth$[rsp]
	sub	rsi, 1
	jne	$LL4@kvz_search
	movzx	eax, BYTE PTR best_chroma$3[rsp+8]
	movaps	xmm7, XMMWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+208]
	mov	rsi, QWORD PTR [rsp+200]
	mov	rbx, QWORD PTR [rsp+192]
$LN3@kvz_search:

; 716  :       }
; 717  :     }
; 718  : 
; 719  :     return best_chroma.mode;

	movaps	xmm6, XMMWORD PTR [rsp+128]
	mov	r13, QWORD PTR [rsp+144]
	mov	r12, QWORD PTR [rsp+152]

; 723  : }

	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
$LN5@kvz_search:

; 720  :   }
; 721  : 
; 722  :   return 100;

	mov	al, 100					; 00000064H

; 723  : }

	add	rsp, 160				; 000000a0H
	pop	r15
	pop	r14
	pop	rbp
	ret	0
kvz_search_intra_chroma_rdo ENDP
_TEXT	ENDS
END
