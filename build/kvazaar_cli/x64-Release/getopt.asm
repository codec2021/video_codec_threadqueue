; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	optind
PUBLIC	optarg
PUBLIC	optreset
PUBLIC	opterr
EXTRN	__imp_getenv:PROC
EXTRN	__imp_strchr:PROC
optarg	DQ	01H DUP (?)
$SG4294966164 DB 01H DUP (?)
	ALIGN	4

optreset DD	01H DUP (?)
_BSS	ENDS
opterr	DD	01H
ambig	DB	'ambiguous option -- %.*s', 00H
	ORG $+7
noarg	DB	'option doesn''t take an argument -- %.*s', 00H
illoptchar DB	'illegal option -- %c', 00H
	ORG $+3
recargstring DB	'option requires an argument -- %s', 00H
illoptstring DB	'illegal option -- %s', 00H
	ORG $+3
recargchar DB	'option requires an argument -- %c', 00H
optind	DD	01H
PUBLIC	vfprintf
PUBLIC	getopt_long
	ALIGN	8

progname DQ	01H DUP (?)
$SG4294966154 DB 01H DUP (?)
	ALIGN	4

$SG4294966155 DB 01H DUP (?)
	ALIGN	4

$SG4294966156 DB 01H DUP (?)
	ALIGN	4

$SG4294966157 DB 01H DUP (?)
	ALIGN	4

$SG4294966160 DB 01H DUP (?)
	ALIGN	4

$SG4294966161 DB 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$getopt_internal DD imagerel getopt_internal
	DD	imagerel getopt_internal+792
	DD	imagerel $unwind$getopt_internal
$pdata$permute_args DD imagerel permute_args
	DD	imagerel permute_args+131
	DD	imagerel $unwind$permute_args
$pdata$1$permute_args DD imagerel permute_args+131
	DD	imagerel permute_args+259
	DD	imagerel $chain$1$permute_args
$pdata$2$permute_args DD imagerel permute_args+259
	DD	imagerel permute_args+277
	DD	imagerel $chain$2$permute_args
$pdata$xwarnx DD imagerel xwarnx
	DD	imagerel xwarnx+92
	DD	imagerel $unwind$xwarnx
$pdata$0$xwarnx DD imagerel xwarnx+92
	DD	imagerel xwarnx+139
	DD	imagerel $chain$0$xwarnx
$pdata$1$xwarnx DD imagerel xwarnx+139
	DD	imagerel xwarnx+172
	DD	imagerel $chain$1$xwarnx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vfprintf DD imagerel $LN6
	DD	imagerel $LN6+68
	DD	imagerel $unwind$vfprintf
pdata	ENDS
pdata	SEGMENT
$pdata$getopt_long DD imagerel $LN57
	DD	imagerel $LN57+604
	DD	imagerel $unwind$getopt_long
;	COMDAT xdata
xdata	SEGMENT
$unwind$vfprintf DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
xdata	SEGMENT
$unwind$getopt_internal DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$permute_args DD 081601H
	DD	0b3416H
	DD	0f0121216H
	DD	0c00ee010H
	DD	0500b700cH
$chain$1$permute_args DD 040e21H
	DD	09d40eH
	DD	086405H
	DD	imagerel permute_args
	DD	imagerel permute_args+131
	DD	imagerel $unwind$permute_args
$chain$2$permute_args DD 021H
	DD	imagerel permute_args
	DD	imagerel permute_args+131
	DD	imagerel $unwind$permute_args
$unwind$xwarnx DD 031a01H
	DD	07016621aH
	DD	06015H
$chain$0$xwarnx DD 020521H
	DD	063405H
	DD	imagerel xwarnx
	DD	imagerel xwarnx+92
	DD	imagerel $unwind$xwarnx
$chain$1$xwarnx DD 021H
	DD	imagerel xwarnx
	DD	imagerel xwarnx+92
	DD	imagerel $unwind$xwarnx
$unwind$getopt_long DD 0c2101H
	DD	0d6421H
	DD	0c5421H
	DD	0a3421H
	DD	0f01d3221H
	DD	0d019e01bH
	DD	07015c017H
	ORG $+2
nonopt_end DD	0ffffffffH
	ORG $+2
nonopt_start DD	0ffffffffH
	ORG $+2
$SG4294966162 DB 0aH, 00H
$SG4294966163 DB '%s: ', 00H
place	DQ	FLAT:$SG4294966164
$SG4294966158 DB 'POSIXLY_CORRECT', 00H
$SG4294966159 DB 'POSIXLY_CORRECT', 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
_TEXT	SEGMENT
nargc$ = 80
nargv$ = 88
options$dead$ = 96
long_options$dead$ = 104
idx$ = 112
getopt_long PROC

; 356  : {

$LN57:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [rsp+16], rdx
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 357  : 	int retval;
; 358  : 
; 359  : 	_DIAGASSERT(nargv != NULL);
; 360  : 	_DIAGASSERT(options != NULL);
; 361  : 	_DIAGASSERT(long_options != NULL);
; 362  : 	/* idx may be NULL */
; 363  : 
; 364  : 	progname = nargv[0];

	mov	rax, QWORD PTR [rdx]
	mov	rsi, rdx
	mov	QWORD PTR progname, rax

; 365  : 
; 366  : 	if ((retval = getopt_internal(nargc, nargv, options)) == -2) {

	call	getopt_internal
	mov	r13d, eax
	cmp	eax, -2
	jne	$LN41@getopt_lon

; 367  : 		char *current_argv, *has_equal;
; 368  : 		size_t current_argv_len;
; 369  : 		int i, match;
; 370  : 
; 371  : 		current_argv = place;

	mov	rdi, QWORD PTR place

; 372  : 		match = -1;

	lea	ebp, QWORD PTR [rax+1]

; 373  : 
; 374  : 		optind++;

	mov	ebx, DWORD PTR optind

; 375  : 		place = EMSG;

	lea	rax, OFFSET FLAT:$SG4294966154
	inc	ebx
	mov	QWORD PTR place, rax
	mov	DWORD PTR optind, ebx

; 376  : 
; 377  : 		if (*current_argv == '\0') {		/* found "--" */

	cmp	BYTE PTR [rdi], 0
	jne	SHORT $LN6@getopt_lon

; 378  : 			/*
; 379  : 			 * We found an option (--), so if we skipped
; 380  : 			 * non-options, we have to permute.
; 381  : 			 */
; 382  : 			if (nonopt_end != -1) {

	mov	edi, DWORD PTR nonopt_end
	cmp	edi, ebp
	je	SHORT $LN7@getopt_lon

; 383  : 				permute_args(nonopt_start, nonopt_end,

	mov	r9, rsi
	call	permute_args

; 384  : 				    optind, nargv);
; 385  : 				optind -= nonopt_end - nonopt_start;

	sub	ebx, edi
	add	ebx, DWORD PTR nonopt_start
	mov	DWORD PTR optind, ebx
$LN7@getopt_lon:

; 386  : 			}
; 387  : 			nonopt_start = nonopt_end = -1;

	mov	DWORD PTR nonopt_end, ebp

; 388  : 			return -1;

	mov	eax, ebp
	mov	DWORD PTR nonopt_start, ebp
	jmp	$LN1@getopt_lon
$LN6@getopt_lon:

; 389  : 		}
; 390  : 		if ((has_equal = strchr(current_argv, '=')) != NULL) {

	mov	edx, 61					; 0000003dH
	mov	rcx, rdi
	call	QWORD PTR __imp_strchr
	mov	r14, rax
	test	rax, rax
	je	SHORT $LN8@getopt_lon

; 391  : 			/* argument found (--option=arg) */
; 392  : 			current_argv_len = has_equal - current_argv;

	mov	rbx, rax
	sub	rbx, rdi

; 393  : 			has_equal++;

	inc	r14

; 394  : 		} else

	jmp	SHORT $LN9@getopt_lon
$LN8@getopt_lon:

; 395  : 			current_argv_len = strlen(current_argv);

	mov	rbx, -1
$LL55@getopt_lon:
	inc	rbx
	cmp	BYTE PTR [rdi+rbx], 0
	jne	SHORT $LL55@getopt_lon
$LN9@getopt_lon:

; 396  : 	    
; 397  : 		for (i = 0; long_options[i].name; i++) {

	mov	rax, QWORD PTR long_options
	xor	r13d, r13d
	mov	r15d, r13d
	test	rax, rax
	je	$LN17@getopt_lon
	mov	r12d, r13d
	lea	rsi, OFFSET FLAT:long_options
	npad	2
$LL4@getopt_lon:

; 398  : 			/* find matching long option */
; 399  : 			if (strncmp(current_argv, long_options[i].name,

	mov	r8, rbx
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	jne	SHORT $LN2@getopt_lon

; 400  : 			    current_argv_len))
; 401  : 				continue;
; 402  : 
; 403  : 			if (strlen(long_options[i].name) ==

	mov	rax, QWORD PTR [rsi]
	mov	rcx, -1
	npad	3
$LL54@getopt_lon:
	inc	rcx
	cmp	BYTE PTR [rax+rcx], r13b
	jne	SHORT $LL54@getopt_lon
	mov	eax, ebx
	cmp	rcx, rax
	je	SHORT $LN44@getopt_lon

; 407  : 				break;
; 408  : 			}
; 409  : 			if (match == -1)		/* partial match */

	cmp	ebp, -1
	jne	SHORT $LN12@getopt_lon

; 410  : 				match = i;

	mov	ebp, r15d
$LN2@getopt_lon:

; 396  : 	    
; 397  : 		for (i = 0; long_options[i].name; i++) {

	inc	r12
	lea	r8, OFFSET FLAT:long_options
	mov	rsi, r12
	inc	r15d
	shl	rsi, 5
	add	rsi, r8
	mov	rax, QWORD PTR [rsi]
	test	rax, rax
	jne	SHORT $LL4@getopt_lon
	jmp	SHORT $LN52@getopt_lon
$LN12@getopt_lon:

; 411  : 			else {
; 412  : 				/* ambiguous abbreviation */
; 413  : 				if (PRINT_ERROR)
; 414  : 					xwarnx(ambig, (int)current_argv_len,

	mov	r8, rdi
	lea	rcx, OFFSET FLAT:ambig
	mov	edx, ebx
	call	xwarnx

; 415  : 					     current_argv);
; 416  : 				optopt = 0;
; 417  : 				return BADCH;

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_lon
$LN44@getopt_lon:

; 404  : 			    (unsigned)current_argv_len) {
; 405  : 				/* exact match */
; 406  : 				match = i;

	mov	ebp, r15d
	lea	r8, OFFSET FLAT:long_options
$LN52@getopt_lon:

; 418  : 			}
; 419  : 		}
; 420  : 		if (match != -1) {			/* option found */

	cmp	ebp, -1
	je	$LN17@getopt_lon

; 421  : 		        if (long_options[match].has_arg == no_argument
; 422  : 			    && has_equal) {

	movsxd	rdx, ebp
	shl	rdx, 5
	mov	ecx, DWORD PTR [rdx+r8+8]
	test	ecx, ecx
	jne	SHORT $LN19@getopt_lon
	test	r14, r14
	je	SHORT $LN30@getopt_lon

; 423  : 				if (PRINT_ERROR)
; 424  : 					xwarnx(noarg, (int)current_argv_len,

	mov	r8, rdi
	lea	rcx, OFFSET FLAT:noarg
	mov	edx, ebx
	call	xwarnx

; 425  : 					     current_argv);
; 426  : 				/*
; 427  : 				 * XXX: GNU sets optopt to val regardless of
; 428  : 				 * flag
; 429  : 				 */
; 430  : 				if (long_options[match].flag == NULL)
; 431  : 					optopt = long_options[match].val;
; 432  : 				else
; 433  : 					optopt = 0;
; 434  : 				/* XXX: GNU returns '?' if options[0] != ':' */
; 435  : 				return BADARG;

	mov	eax, 58					; 0000003aH
	jmp	$LN1@getopt_lon
$LN19@getopt_lon:

; 436  : 			}
; 437  : 			if (long_options[match].has_arg == required_argument ||

	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 1
	ja	SHORT $LN30@getopt_lon

; 438  : 			    long_options[match].has_arg == optional_argument) {
; 439  : 				if (has_equal)

	test	r14, r14
	je	SHORT $LN27@getopt_lon

; 440  : 					optarg = has_equal;

	mov	QWORD PTR optarg, r14

; 448  : 				}
; 449  : 			}
; 450  : 			if ((long_options[match].has_arg == required_argument)
; 451  : 			    && (optarg == NULL)) {

	cmp	ecx, 1
	je	SHORT $LN50@getopt_lon
$LN30@getopt_lon:

; 475  : 		}
; 476  : 		if (long_options[match].flag) {

	mov	rcx, QWORD PTR [rdx+r8+16]
	mov	eax, DWORD PTR [rdx+r8+24]
	test	rcx, rcx
	je	SHORT $LN39@getopt_lon

; 477  : 			*long_options[match].flag = long_options[match].val;

	mov	DWORD PTR [rcx], eax

; 478  : 			retval = 0;
; 479  : 		} else 

	jmp	SHORT $LN40@getopt_lon
$LN27@getopt_lon:

; 441  : 				else if (long_options[match].has_arg ==

	cmp	ecx, 1
	jne	SHORT $LN30@getopt_lon

; 442  : 				    required_argument) {
; 443  : 					/*
; 444  : 					 * optional argument doesn't use
; 445  : 					 * next nargv
; 446  : 					 */
; 447  : 					optarg = nargv[optind++];

	movsxd	rcx, DWORD PTR optind
	mov	r14, QWORD PTR nargv$[rsp]
	mov	r14, QWORD PTR [r14+rcx*8]
	inc	ecx
	mov	DWORD PTR optind, ecx
	mov	QWORD PTR optarg, r14
$LN50@getopt_lon:

; 448  : 				}
; 449  : 			}
; 450  : 			if ((long_options[match].has_arg == required_argument)
; 451  : 			    && (optarg == NULL)) {

	test	r14, r14
	jne	SHORT $LN30@getopt_lon

; 452  : 				/*
; 453  : 				 * Missing argument; leading ':'
; 454  : 				 * indicates no error should be generated
; 455  : 				 */
; 456  : 				if (PRINT_ERROR)
; 457  : 					xwarnx(recargstring, current_argv);

	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:recargstring
	call	xwarnx

; 458  : 				/*
; 459  : 				 * XXX: GNU sets optopt to val regardless
; 460  : 				 * of flag
; 461  : 				 */
; 462  : 				if (long_options[match].flag == NULL)
; 463  : 					optopt = long_options[match].val;
; 464  : 				else
; 465  : 					optopt = 0;
; 466  : 				/* XXX: GNU returns '?' if options[0] != ':' */
; 467  : 				--optind;

	dec	DWORD PTR optind

; 468  : 				return BADARG;

	lea	eax, QWORD PTR [r14+58]
	jmp	SHORT $LN1@getopt_lon
$LN39@getopt_lon:

; 480  : 			retval = long_options[match].val;

	mov	r13d, eax
$LN40@getopt_lon:

; 481  : 		if (idx)

	mov	rax, QWORD PTR idx$[rsp]
	test	rax, rax
	je	SHORT $LN41@getopt_lon

; 482  : 			*idx = match;

	mov	DWORD PTR [rax], ebp
$LN41@getopt_lon:

; 483  : 	}
; 484  : 	return retval;

	mov	eax, r13d
$LN1@getopt_lon:

; 485  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN17@getopt_lon:

; 469  : 			}
; 470  : 		} else {			/* unknown option */
; 471  : 			if (PRINT_ERROR)
; 472  : 				xwarnx(illoptstring, current_argv);

	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:illoptstring
	call	xwarnx

; 473  : 			optopt = 0;
; 474  : 			return BADCH;

	mov	eax, 63					; 0000003fH
	jmp	SHORT $LN1@getopt_lon
getopt_long ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT vfprintf
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_ArgList$ = 80
vfprintf PROC						; COMDAT

; 656  :     {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 657  :         return _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 658  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
_TEXT	SEGMENT
fmt$ = 80
xwarnx	PROC

; 94   : static void xwarnx(const char *fmt, ...) {

	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 95   : 	va_list ap;
; 96   : 
; 97   : 	va_start(ap, fmt);
; 98   : 	if (progname)

	cmp	QWORD PTR progname, 0
	lea	rsi, QWORD PTR fmt$[rsp+8]
	mov	rdi, rcx
	je	SHORT $LN2@xwarnx

; 99   : 		(void) fprintf(stderr, "%s: ", progname);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8, QWORD PTR progname
	lea	rdx, OFFSET FLAT:$SG4294966163
	mov	rcx, rax
	call	fprintf
	mov	rdi, QWORD PTR fmt$[rsp]
$LN2@xwarnx:

; 100  : 	if (fmt)

	test	rdi, rdi
	je	SHORT $LN3@xwarnx

; 101  : 		(void) vfprintf(stderr, fmt, ap);

	mov	ecx, 2
	mov	QWORD PTR [rsp+48], rbx
	call	QWORD PTR __imp___acrt_iob_func
	mov	rbx, rax
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf
	mov	rbx, QWORD PTR [rsp+48]
$LN3@xwarnx:
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c

; 102  : 	(void) fprintf(stderr, "\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294966162
	call	fprintf

; 103  : 	va_end(ap);
; 104  : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
xwarnx	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
_TEXT	SEGMENT
a$ = 8
b$ = 16
gcd	PROC

; 114  : 	int c;
; 115  : 
; 116  : 	c = a % b;

	mov	eax, ecx
	mov	r8d, edx
	cdq
	idiv	r8d
	mov	ecx, edx

; 117  : 	while (c != 0) {

	test	edx, edx
	je	SHORT $LN9@gcd
	npad	1
$LL2@gcd:

; 118  : 		a = b;

	mov	eax, r8d

; 119  : 		b = c;

	mov	r8d, ecx

; 120  : 		c = a % b;

	cdq
	idiv	ecx
	mov	ecx, edx
	test	edx, edx
	jne	SHORT $LL2@gcd
$LN9@gcd:

; 121  : 	}
; 122  : 	   
; 123  : 	return b;
; 124  : }

	mov	eax, r8d
	ret	0
gcd	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
_TEXT	SEGMENT
tv402 = 0
nonopt_start$dead$ = 64
nonopt_end$dead$ = 72
cyclelen$1$ = 80
opt_end$dead$ = 80
nargv$ = 88
permute_args PROC

; 137  : {

	mov	QWORD PTR [rsp+32], rbx
	mov	DWORD PTR [rsp+24], r8d
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 16

; 138  : 	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
; 139  : 	char *swap;
; 140  : 
; 141  : 	/*
; 142  : 	 * compute lengths of blocks and number and size of cycles
; 143  : 	 */
; 144  : 	nnonopts = nonopt_end - nonopt_start;

	movsxd	rbx, DWORD PTR nonopt_end
	mov	r12, r9
	mov	r9d, DWORD PTR nonopt_start
	mov	r14d, ebx
	mov	r10d, DWORD PTR optind
	sub	r14d, r9d

; 116  : 	c = a % b;

	mov	eax, r14d

; 145  : 	nopts = opt_end - nonopt_end;

	mov	ebp, r10d
	sub	ebp, ebx

; 116  : 	c = a % b;

	cdq
	idiv	ebp

; 146  : 	ncycle = gcd(nnonopts, nopts);

	mov	r8d, ebp

; 116  : 	c = a % b;

	mov	ecx, edx

; 117  : 	while (c != 0) {

	test	edx, edx
	je	SHORT $LN13@permute_ar
	npad	8
$LL12@permute_ar:

; 118  : 		a = b;

	mov	eax, r8d

; 119  : 		b = c;

	mov	r8d, ecx

; 120  : 		c = a % b;

	cdq
	idiv	ecx
	mov	ecx, edx
	test	edx, edx
	jne	SHORT $LL12@permute_ar
$LN13@permute_ar:

; 147  : 	cyclelen = (opt_end - nonopt_start) / ncycle;

	sub	r10d, r9d
	mov	rdi, rbx
	mov	eax, r10d
	cdq
	idiv	r8d
	mov	DWORD PTR cyclelen$1$[rsp], eax
	mov	r15d, eax

; 148  : 
; 149  : 	for (i = 0; i < ncycle; i++) {

	movsxd	rax, r8d
	mov	QWORD PTR tv402[rsp], rax
	test	r8d, r8d
	jle	$LN3@permute_ar
	mov	QWORD PTR [rsp+64], rsi
	lea	r10, QWORD PTR [r12+rbx*8]
	mov	QWORD PTR [rsp+72], r13
	xor	r11d, r11d
	movsxd	r13, r14d
	npad	9
$LL4@permute_ar:

; 151  : 		pos = cstart;

	lea	r9, QWORD PTR [rdi+r11]
	mov	eax, ebx

; 152  : 		for (j = 0; j < cyclelen; j++) {

	test	r15d, r15d
	jle	SHORT $LN2@permute_ar

; 150  : 		cstart = nonopt_end+i;

	mov	esi, r15d
	movsxd	r15, ebp
$LL7@permute_ar:

; 153  : 			if (pos >= nonopt_end)
; 154  : 				pos -= nnonopts;
; 155  : 			else
; 156  : 				pos += nopts;
; 157  : 			swap = nargv[pos];

	lea	rcx, QWORD PTR [r15+r9]
	mov	r8, r9
	sub	r8, r13
	cmp	r9, rdi
	cmovl	r8, rcx

; 158  : 			/* LINTED const cast */
; 159  : 			((char **) nargv)[pos] = nargv[cstart];

	mov	rcx, QWORD PTR [r10]
	mov	rdx, QWORD PTR [r12+r8*8]
	mov	QWORD PTR [r12+r8*8], rcx
	lea	ecx, DWORD PTR [rax+rbp]
	sub	eax, r14d

; 160  : 			/* LINTED const cast */
; 161  : 			((char **)nargv)[cstart] = swap;

	mov	QWORD PTR [r10], rdx
	cmp	r9, rdi
	mov	r9, r8
	cmovl	eax, ecx
	sub	rsi, 1
	jne	SHORT $LL7@permute_ar
	mov	r15d, DWORD PTR cyclelen$1$[rsp]
$LN2@permute_ar:

; 148  : 
; 149  : 	for (i = 0; i < ncycle; i++) {

	inc	ebx
	inc	r11
	add	r10, 8
	cmp	r11, QWORD PTR tv402[rsp]
	jl	SHORT $LL4@permute_ar
	mov	r13, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
$LN3@permute_ar:

; 162  : 		}
; 163  : 	}
; 164  : }

	mov	rbx, QWORD PTR [rsp+88]
	add	rsp, 16
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
permute_args ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\extras\getopt.c
_TEXT	SEGMENT
nargc$ = 64
nargv$ = 72
options$dead$ = 80
getopt_internal PROC

; 176  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 177  : 	char *oli;				/* option letter list index */
; 178  : 	int optchar;
; 179  : 
; 180  : 	_DIAGASSERT(nargv != NULL);
; 181  : 	_DIAGASSERT(options != NULL);
; 182  : 
; 183  : 	optarg = NULL;
; 184  : 
; 185  : 	/*
; 186  : 	 * XXX Some programs (like rsyncd) expect to be able to
; 187  : 	 * XXX re-initialize optind to 0 and have getopt_long(3)
; 188  : 	 * XXX properly function again.  Work around this braindamage.
; 189  : 	 */
; 190  : 	if (optind == 0)

	mov	ebx, DWORD PTR optind
	xor	r15d, r15d
	test	ebx, ebx
	mov	QWORD PTR optarg, r15
	mov	eax, 1
	mov	r14, rdx
	cmove	ebx, eax
	mov	ebp, ecx

; 191  : 		optind = 1;
; 192  : 
; 193  : 	if (optreset)

	mov	eax, DWORD PTR optreset
	mov	DWORD PTR optind, ebx
	test	eax, eax
	je	SHORT $LN63@getopt_int

; 194  : 		nonopt_start = nonopt_end = -1;

	mov	esi, -1
	mov	DWORD PTR nonopt_end, esi
	mov	edi, esi
	mov	DWORD PTR nonopt_start, esi
	jmp	SHORT $LN62@getopt_int
$LN63@getopt_int:

; 191  : 		optind = 1;
; 192  : 
; 193  : 	if (optreset)

	mov	edi, DWORD PTR nonopt_start
	mov	esi, DWORD PTR nonopt_end
$LN62@getopt_int:
	lea	r12, OFFSET FLAT:$SG4294966160
$start$73:

; 195  : start:
; 196  : 	if (optreset || !*place) {		/* update scanning pointer */

	test	eax, eax
	jne	SHORT $LN5@getopt_int
	mov	rax, QWORD PTR place
	cmp	BYTE PTR [rax], r15b
	jne	$LN19@getopt_int
$LN5@getopt_int:

; 197  : 		optreset = 0;

	mov	DWORD PTR optreset, r15d

; 198  : 		if (optind >= nargc) {          /* end of argument vector */

	cmp	ebx, ebp
	jge	$LN48@getopt_int

; 214  : 			return -1;
; 215  : 		}
; 216  : 		if (*(place = nargv[optind]) != '-') {  /* found non-option */

	movsxd	rax, ebx
	mov	rax, QWORD PTR [r14+rax*8]
	cmp	BYTE PTR [rax], 45			; 0000002dH
	je	$LN10@getopt_int

; 217  : 			place = EMSG;
; 218  : 			if (IN_ORDER) {

	lea	rcx, OFFSET FLAT:$SG4294966159
	mov	QWORD PTR place, r12
	call	QWORD PTR __imp_getenv

; 219  : 				/*
; 220  : 				 * GNU extension: 
; 221  : 				 * return non-option as argument to option 1
; 222  : 				 */
; 223  : 				optarg = nargv[optind++];
; 224  : 				return INORDER;
; 225  : 			}
; 226  : 			if (!PERMUTE) {

	lea	rcx, OFFSET FLAT:$SG4294966158
	call	QWORD PTR __imp_getenv
	test	rax, rax
	jne	$LN50@getopt_int

; 227  : 				/*
; 228  : 				 * if no permutation wanted, stop parsing
; 229  : 				 * at first non-option
; 230  : 				 */
; 231  : 				return -1;
; 232  : 			}
; 233  : 			/* do permutation */
; 234  : 			if (nonopt_start == -1)

	mov	edi, DWORD PTR nonopt_start
	mov	ebx, DWORD PTR optind
	mov	esi, DWORD PTR nonopt_end
	cmp	edi, -1
	jne	SHORT $LN15@getopt_int

; 242  : 			}
; 243  : 			optind++;
; 244  : 			/* process next argument */
; 245  : 			goto start;

	mov	eax, DWORD PTR optreset
	mov	edi, ebx
	mov	DWORD PTR nonopt_start, ebx
	inc	ebx
	mov	DWORD PTR optind, ebx
	jmp	$start$73
$LN15@getopt_int:

; 235  : 				nonopt_start = optind;
; 236  : 			else if (nonopt_end != -1) {

	cmp	esi, -1
	je	SHORT $LN17@getopt_int

; 237  : 				permute_args(nonopt_start, nonopt_end,

	mov	r9, r14
	call	permute_args

; 238  : 				    optind, nargv);
; 239  : 				nonopt_start = optind -

	mov	eax, ebx
	sub	eax, esi

; 240  : 				    (nonopt_end - nonopt_start);
; 241  : 				nonopt_end = -1;

	mov	esi, -1
	add	edi, eax
	mov	DWORD PTR nonopt_end, esi
	mov	DWORD PTR nonopt_start, edi
$LN17@getopt_int:

; 242  : 			}
; 243  : 			optind++;
; 244  : 			/* process next argument */
; 245  : 			goto start;

	mov	eax, DWORD PTR optreset
	inc	ebx
	mov	DWORD PTR optind, ebx
	jmp	$start$73
$LN10@getopt_int:

; 246  : 		}
; 247  : 		if (nonopt_start != -1 && nonopt_end == -1)

	cmp	edi, -1
	je	SHORT $LN18@getopt_int
	cmp	esi, -1
	cmove	esi, ebx
	mov	DWORD PTR nonopt_end, esi
$LN18@getopt_int:

; 248  : 			nonopt_end = optind;
; 249  : 		if (place[1] && *++place == '-') {	/* found "--" */

	cmp	BYTE PTR [rax+1], r15b
	lea	rcx, QWORD PTR [rax+1]
	je	SHORT $LN19@getopt_int
	cmp	BYTE PTR [rcx], 45			; 0000002dH
	mov	rax, rcx
	jne	SHORT $LN19@getopt_int

; 250  : 			place++;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR place, rax
$LN69@getopt_int:

; 308  : }

	mov	eax, -2
	jmp	$LN1@getopt_int
$LN19@getopt_int:

; 251  : 			return -2;
; 252  : 		}
; 253  : 	}
; 254  : 	if ((optchar = (int)*place++) == (int)':' ||

	movsx	edi, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR place, rax
	cmp	edi, 58					; 0000003aH
	je	$LN21@getopt_int
	mov	edx, edi
	lea	rcx, OFFSET FLAT:short_options
	call	QWORD PTR __imp_strchr
	test	rax, rax
	je	$LN65@getopt_int

; 263  : 	}
; 264  : 	if (optchar == 'W' && oli[1] == ';') {		/* -W long-option */

	cmp	edi, 87					; 00000057H
	jne	SHORT $LN58@getopt_int
	cmp	BYTE PTR [rax+1], 59			; 0000003bH
	jne	SHORT $LN58@getopt_int

; 265  : 		/* XXX: what if no long options provided (called by getopt)? */
; 266  : 		if (*place) 

	mov	rax, QWORD PTR place
	cmp	BYTE PTR [rax], r15b
	jne	SHORT $LN69@getopt_int

; 267  : 			return -2;
; 268  : 
; 269  : 		if (++optind >= nargc) {	/* no arg */

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax
	cmp	eax, ebp
	jl	SHORT $LN28@getopt_int

; 270  : 			place = EMSG;

	lea	rax, OFFSET FLAT:$SG4294966157

; 271  : 			if (PRINT_ERROR)
; 272  : 				xwarnx(recargchar, optchar);

	mov	edx, edi
$LN71@getopt_int:

; 308  : }

	lea	rcx, OFFSET FLAT:recargchar
	mov	QWORD PTR place, rax
	call	xwarnx
	mov	eax, 58					; 0000003aH
	jmp	$LN1@getopt_int
$LN28@getopt_int:

; 273  : 			optopt = optchar;
; 274  : 			/* XXX: GNU returns '?' if options[0] != ':' */
; 275  : 			return BADARG;
; 276  : 		} else				/* white space */
; 277  : 			place = nargv[optind];

	cdqe
	mov	rcx, QWORD PTR [r14+rax*8]

; 278  : 		/*
; 279  : 		 * Handle -W arg the same as --arg (which causes getopt to
; 280  : 		 * stop parsing).
; 281  : 		 */
; 282  : 		return -2;

	mov	eax, -2
	mov	QWORD PTR place, rcx
	jmp	$LN1@getopt_int
$LN58@getopt_int:

; 283  : 	}
; 284  : 	if (*++oli != ':') {			/* doesn't take argument */

	cmp	BYTE PTR [rax+1], 58			; 0000003aH
	je	SHORT $LN33@getopt_int

; 285  : 		if (!*place)

	mov	rax, QWORD PTR place
	cmp	BYTE PTR [rax], r15b
	jne	SHORT $LN34@getopt_int

; 304  : 		++optind;
; 305  : 	}
; 306  : 	/* dump back option letter */
; 307  : 	return optchar;

	inc	DWORD PTR optind
	mov	eax, edi
	jmp	$LN1@getopt_int
$LN33@getopt_int:

; 286  : 			++optind;
; 287  : 	} else {				/* takes (optional) argument */
; 288  : 		optarg = NULL;
; 289  : 		if (*place)			/* no white space */

	mov	rcx, QWORD PTR place
	mov	QWORD PTR optarg, r15
	cmp	BYTE PTR [rcx], r15b
	jne	SHORT $LN67@getopt_int

; 290  : 			optarg = place;
; 291  : 		/* XXX: disable test for :: if PC? (GNU doesn't) */
; 292  : 		else if (oli[1] != ':') {	/* arg not optional */

	cmp	BYTE PTR [rax+2], 58			; 0000003aH
	je	SHORT $LN64@getopt_int

; 293  : 			if (++optind >= nargc) {	/* no arg */

	mov	eax, DWORD PTR optind
	inc	eax
	mov	DWORD PTR optind, eax
	cmp	eax, ebp
	jl	SHORT $LN39@getopt_int

; 294  : 				place = EMSG;

	lea	rax, OFFSET FLAT:$SG4294966156

; 295  : 				if (PRINT_ERROR)
; 296  : 					xwarnx(recargchar, optchar);

	mov	edx, edi

; 297  : 				optopt = optchar;
; 298  : 				/* XXX: GNU returns '?' if options[0] != ':' */
; 299  : 				return BADARG;

	jmp	$LN71@getopt_int
$LN39@getopt_int:

; 300  : 			} else
; 301  : 				optarg = nargv[optind];

	cdqe
	mov	rcx, QWORD PTR [r14+rax*8]
$LN67@getopt_int:

; 302  : 		}
; 303  : 		place = EMSG;

	mov	QWORD PTR optarg, rcx
$LN64@getopt_int:

; 304  : 		++optind;
; 305  : 	}
; 306  : 	/* dump back option letter */
; 307  : 	return optchar;

	inc	DWORD PTR optind
	lea	rax, OFFSET FLAT:$SG4294966155
	mov	QWORD PTR place, rax
$LN34@getopt_int:
	mov	eax, edi
	jmp	SHORT $LN1@getopt_int
$LN65@getopt_int:

; 251  : 			return -2;
; 252  : 		}
; 253  : 	}
; 254  : 	if ((optchar = (int)*place++) == (int)':' ||

	mov	ebx, DWORD PTR optind
	mov	rax, QWORD PTR place
$LN21@getopt_int:

; 255  : 	    (oli = strchr(options + (IGNORE_FIRST ? 1 : 0), optchar)) == NULL) {
; 256  : 		/* option letter unknown or ':' */
; 257  : 		if (!*place)

	cmp	BYTE PTR [rax], r15b
	jne	SHORT $LN22@getopt_int

; 258  : 			++optind;

	inc	ebx
	mov	DWORD PTR optind, ebx
$LN22@getopt_int:

; 259  : 		if (PRINT_ERROR)
; 260  : 			xwarnx(illoptchar, optchar);

	mov	edx, edi
	lea	rcx, OFFSET FLAT:illoptchar
	call	xwarnx

; 261  : 		optopt = optchar;
; 262  : 		return BADCH;

	mov	eax, 63					; 0000003fH
	jmp	SHORT $LN1@getopt_int
$LN48@getopt_int:

; 199  : 			place = EMSG;

	lea	rax, OFFSET FLAT:$SG4294966161
	mov	QWORD PTR place, rax

; 200  : 			if (nonopt_end != -1) {

	cmp	esi, -1
	je	SHORT $LN7@getopt_int

; 201  : 				/* do permutation, if we have to */
; 202  : 				permute_args(nonopt_start, nonopt_end,

	mov	r9, r14
	call	permute_args

; 203  : 				    optind, nargv);
; 204  : 				optind -= nonopt_end - nonopt_start;

	sub	edi, esi
	add	ebx, edi

; 205  : 			}

	jmp	SHORT $LN68@getopt_int
$LN7@getopt_int:

; 206  : 			else if (nonopt_start != -1) {

	cmp	edi, -1
	cmovne	ebx, edi
$LN68@getopt_int:

; 207  : 				/*
; 208  : 				 * If we skipped non-options, set optind
; 209  : 				 * to the first of them.
; 210  : 				 */
; 211  : 				optind = nonopt_start;
; 212  : 			}
; 213  : 			nonopt_start = nonopt_end = -1;

	mov	DWORD PTR optind, ebx
	mov	DWORD PTR nonopt_end, -1
	mov	DWORD PTR nonopt_start, -1
$LN50@getopt_int:

; 308  : }

	mov	eax, -1
$LN1@getopt_int:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
getopt_internal ENDP
_TEXT	ENDS
END
