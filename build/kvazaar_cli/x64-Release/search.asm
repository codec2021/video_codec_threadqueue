; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

INTRA_THRESHOLD DD 08H
	ORG $+6
cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
?mp_modes@?8??search_cu@@9@9 DD 01H			; `search_cu'::`9'::mp_modes
	DD	02H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
PUBLIC	kvz_sort_modes
PUBLIC	kvz_cu_rd_cost_chroma
PUBLIC	kvz_cu_rd_cost_luma
PUBLIC	kvz_lcu_fill_trdepth
PUBLIC	kvz_search_lcu
pdata	SEGMENT
$pdata$copy_lcu_to_cu_data DD imagerel copy_lcu_to_cu_data
	DD	imagerel copy_lcu_to_cu_data+483
	DD	imagerel $unwind$copy_lcu_to_cu_data
$pdata$init_lcu_t DD imagerel init_lcu_t
	DD	imagerel init_lcu_t+1415
	DD	imagerel $unwind$init_lcu_t
$pdata$search_cu DD imagerel search_cu
	DD	imagerel search_cu+178
	DD	imagerel $unwind$search_cu
$pdata$0$search_cu DD imagerel search_cu+178
	DD	imagerel search_cu+4122
	DD	imagerel $chain$0$search_cu
$pdata$1$search_cu DD imagerel search_cu+4122
	DD	imagerel search_cu+4193
	DD	imagerel $chain$1$search_cu
$pdata$get_ctx_cu_split_model DD imagerel get_ctx_cu_split_model
	DD	imagerel get_ctx_cu_split_model+155
	DD	imagerel $unwind$get_ctx_cu_split_model
$pdata$kvz_sort_modes DD imagerel $LN17
	DD	imagerel $LN17+17
	DD	imagerel $unwind$kvz_sort_modes
$pdata$1$kvz_sort_modes DD imagerel $LN17+17
	DD	imagerel $LN17+139
	DD	imagerel $chain$1$kvz_sort_modes
$pdata$2$kvz_sort_modes DD imagerel $LN17+139
	DD	imagerel $LN17+141
	DD	imagerel $chain$2$kvz_sort_modes
$pdata$calc_mode_bits DD imagerel calc_mode_bits
	DD	imagerel calc_mode_bits+605
	DD	imagerel $unwind$calc_mode_bits
$pdata$kvz_cu_rd_cost_chroma DD imagerel $LN154
	DD	imagerel $LN154+228
	DD	imagerel $unwind$kvz_cu_rd_cost_chroma
$pdata$0$kvz_cu_rd_cost_chroma DD imagerel $LN154+228
	DD	imagerel $LN154+762
	DD	imagerel $chain$0$kvz_cu_rd_cost_chroma
$pdata$1$kvz_cu_rd_cost_chroma DD imagerel $LN154+762
	DD	imagerel $LN154+782
	DD	imagerel $chain$1$kvz_cu_rd_cost_chroma
$pdata$2$kvz_cu_rd_cost_chroma DD imagerel $LN154+782
	DD	imagerel $LN154+785
	DD	imagerel $chain$2$kvz_cu_rd_cost_chroma
$pdata$3$kvz_cu_rd_cost_chroma DD imagerel $LN154+785
	DD	imagerel $LN154+1243
	DD	imagerel $chain$3$kvz_cu_rd_cost_chroma
$pdata$5$kvz_cu_rd_cost_chroma DD imagerel $LN154+1243
	DD	imagerel $LN154+1251
	DD	imagerel $chain$5$kvz_cu_rd_cost_chroma
$pdata$kvz_cu_rd_cost_luma DD imagerel $LN129
	DD	imagerel $LN129+301
	DD	imagerel $unwind$kvz_cu_rd_cost_luma
$pdata$0$kvz_cu_rd_cost_luma DD imagerel $LN129+301
	DD	imagerel $LN129+463
	DD	imagerel $chain$0$kvz_cu_rd_cost_luma
$pdata$1$kvz_cu_rd_cost_luma DD imagerel $LN129+463
	DD	imagerel $LN129+950
	DD	imagerel $chain$1$kvz_cu_rd_cost_luma
$pdata$cu_zero_coeff_cost DD imagerel cu_zero_coeff_cost
	DD	imagerel cu_zero_coeff_cost+29
	DD	imagerel $unwind$cu_zero_coeff_cost
$pdata$1$cu_zero_coeff_cost DD imagerel cu_zero_coeff_cost+29
	DD	imagerel cu_zero_coeff_cost+239
	DD	imagerel $chain$1$cu_zero_coeff_cost
$pdata$2$cu_zero_coeff_cost DD imagerel cu_zero_coeff_cost+239
	DD	imagerel cu_zero_coeff_cost+377
	DD	imagerel $chain$2$cu_zero_coeff_cost
$pdata$3$cu_zero_coeff_cost DD imagerel cu_zero_coeff_cost+377
	DD	imagerel cu_zero_coeff_cost+471
	DD	imagerel $chain$3$cu_zero_coeff_cost
$pdata$4$cu_zero_coeff_cost DD imagerel cu_zero_coeff_cost+471
	DD	imagerel cu_zero_coeff_cost+606
	DD	imagerel $chain$4$cu_zero_coeff_cost
$pdata$lcu_fill_cbf DD imagerel lcu_fill_cbf
	DD	imagerel lcu_fill_cbf+72
	DD	imagerel $unwind$lcu_fill_cbf
$pdata$1$lcu_fill_cbf DD imagerel lcu_fill_cbf+72
	DD	imagerel lcu_fill_cbf+235
	DD	imagerel $chain$1$lcu_fill_cbf
$pdata$2$lcu_fill_cbf DD imagerel lcu_fill_cbf+235
	DD	imagerel lcu_fill_cbf+251
	DD	imagerel $chain$2$lcu_fill_cbf
$pdata$lcu_fill_inter DD imagerel lcu_fill_inter
	DD	imagerel lcu_fill_inter+92
	DD	imagerel $unwind$lcu_fill_inter
$pdata$1$lcu_fill_inter DD imagerel lcu_fill_inter+92
	DD	imagerel lcu_fill_inter+301
	DD	imagerel $chain$1$lcu_fill_inter
$pdata$2$lcu_fill_inter DD imagerel lcu_fill_inter+301
	DD	imagerel lcu_fill_inter+320
	DD	imagerel $chain$2$lcu_fill_inter
$pdata$lcu_fill_cu_info DD imagerel lcu_fill_cu_info
	DD	imagerel lcu_fill_cu_info+39
	DD	imagerel $unwind$lcu_fill_cu_info
$pdata$0$lcu_fill_cu_info DD imagerel lcu_fill_cu_info+39
	DD	imagerel lcu_fill_cu_info+327
	DD	imagerel $chain$0$lcu_fill_cu_info
$pdata$1$lcu_fill_cu_info DD imagerel lcu_fill_cu_info+327
	DD	imagerel lcu_fill_cu_info+339
	DD	imagerel $chain$1$lcu_fill_cu_info
$pdata$kvz_lcu_fill_trdepth DD imagerel $LN18
	DD	imagerel $LN18+145
	DD	imagerel $unwind$kvz_lcu_fill_trdepth
$pdata$work_tree_copy_down DD imagerel work_tree_copy_down
	DD	imagerel work_tree_copy_down+51
	DD	imagerel $unwind$work_tree_copy_down
$pdata$4$work_tree_copy_down DD imagerel work_tree_copy_down+51
	DD	imagerel work_tree_copy_down+538
	DD	imagerel $chain$4$work_tree_copy_down
$pdata$5$work_tree_copy_down DD imagerel work_tree_copy_down+538
	DD	imagerel work_tree_copy_down+547
	DD	imagerel $chain$5$work_tree_copy_down
$pdata$work_tree_copy_up DD imagerel work_tree_copy_up
	DD	imagerel work_tree_copy_up+36
	DD	imagerel $unwind$work_tree_copy_up
$pdata$0$work_tree_copy_up DD imagerel work_tree_copy_up+36
	DD	imagerel work_tree_copy_up+426
	DD	imagerel $chain$0$work_tree_copy_up
$pdata$1$work_tree_copy_up DD imagerel work_tree_copy_up+426
	DD	imagerel work_tree_copy_up+896
	DD	imagerel $chain$1$work_tree_copy_up
$pdata$copy_cu_coeffs DD imagerel copy_cu_coeffs
	DD	imagerel copy_cu_coeffs+504
	DD	imagerel $unwind$copy_cu_coeffs
$pdata$copy_cu_pixels DD imagerel copy_cu_pixels
	DD	imagerel copy_cu_pixels+103
	DD	imagerel $unwind$copy_cu_pixels
$pdata$0$copy_cu_pixels DD imagerel copy_cu_pixels+103
	DD	imagerel copy_cu_pixels+234
	DD	imagerel $chain$0$copy_cu_pixels
$pdata$1$copy_cu_pixels DD imagerel copy_cu_pixels+234
	DD	imagerel copy_cu_pixels+254
	DD	imagerel $chain$1$copy_cu_pixels
$pdata$copy_cu_info DD imagerel copy_cu_info
	DD	imagerel copy_cu_info+23
	DD	imagerel $unwind$copy_cu_info
$pdata$0$copy_cu_info DD imagerel copy_cu_info+23
	DD	imagerel copy_cu_info+137
	DD	imagerel $chain$0$copy_cu_info
$pdata$1$copy_cu_info DD imagerel copy_cu_info+137
	DD	imagerel copy_cu_info+144
	DD	imagerel $chain$1$copy_cu_info
$pdata$xy_to_zorder DD imagerel xy_to_zorder
	DD	imagerel xy_to_zorder+259
	DD	imagerel $unwind$xy_to_zorder
$pdata$copy_coeffs DD imagerel copy_coeffs
	DD	imagerel copy_coeffs+30
	DD	imagerel $unwind$copy_coeffs
$pdata$kvz_search_lcu DD imagerel $LN25
	DD	imagerel $LN25+539
	DD	imagerel $unwind$kvz_search_lcu
xdata	SEGMENT
$unwind$copy_lcu_to_cu_data DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
$unwind$init_lcu_t DD 0a1901H
	DD	0103419H
	DD	0f0155219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
$unwind$search_cu DD 0f4f01H
	DD	0c884fH
	DD	0d7841H
	DD	0e683aH
	DD	0200123H
	DD	0d01af01cH
	DD	07016c018H
	DD	050146015H
	DD	03013H
$chain$0$search_cu DD 020821H
	DD	01fe408H
	DD	imagerel search_cu
	DD	imagerel search_cu+178
	DD	imagerel $unwind$search_cu
$chain$1$search_cu DD 021H
	DD	imagerel search_cu
	DD	imagerel search_cu+178
	DD	imagerel $unwind$search_cu
$unwind$get_ctx_cu_split_model DD 040a01H
	DD	02740aH
	DD	013405H
$unwind$kvz_sort_modes DD 010201H
	DD	06002H
$chain$1$kvz_sort_modes DD 040e21H
	DD	03740eH
	DD	023405H
	DD	imagerel $LN17
	DD	imagerel $LN17+17
	DD	imagerel $unwind$kvz_sort_modes
$chain$2$kvz_sort_modes DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+17
	DD	imagerel $unwind$kvz_sort_modes
$unwind$calc_mode_bits DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$kvz_cu_rd_cost_chroma DD 0a2301H
	DD	047823H
	DD	0f013b217H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0300a500bH
$chain$0$kvz_cu_rd_cost_chroma DD 020821H
	DD	016e408H
	DD	imagerel $LN154
	DD	imagerel $LN154+228
	DD	imagerel $unwind$kvz_cu_rd_cost_chroma
$chain$1$kvz_cu_rd_cost_chroma DD 021H
	DD	imagerel $LN154
	DD	imagerel $LN154+228
	DD	imagerel $unwind$kvz_cu_rd_cost_chroma
$chain$2$kvz_cu_rd_cost_chroma DD 020021H
	DD	016e400H
	DD	imagerel $LN154
	DD	imagerel $LN154+228
	DD	imagerel $unwind$kvz_cu_rd_cost_chroma
$chain$3$kvz_cu_rd_cost_chroma DD 020521H
	DD	056805H
	DD	imagerel $LN154+782
	DD	imagerel $LN154+785
	DD	imagerel $chain$2$kvz_cu_rd_cost_chroma
$chain$5$kvz_cu_rd_cost_chroma DD 021H
	DD	imagerel $LN154
	DD	imagerel $LN154+228
	DD	imagerel $unwind$kvz_cu_rd_cost_chroma
$unwind$kvz_cu_rd_cost_luma DD 0e4301H
	DD	047843H
	DD	015641cH
	DD	014541cH
	DD	012341cH
	DD	0f018b21cH
	DD	0d014e016H
	DD	07010c012H
$chain$0$kvz_cu_rd_cost_luma DD 020521H
	DD	056805H
	DD	imagerel $LN129
	DD	imagerel $LN129+301
	DD	imagerel $unwind$kvz_cu_rd_cost_luma
$chain$1$kvz_cu_rd_cost_luma DD 021H
	DD	imagerel $LN129
	DD	imagerel $LN129+301
	DD	imagerel $unwind$kvz_cu_rd_cost_luma
$unwind$cu_zero_coeff_cost DD 0a1a01H
	DD	03781aH
	DD	0133416H
	DD	0f0129216H
	DD	0700ee010H
	DD	0500c600dH
$chain$1$cu_zero_coeff_cost DD 040c21H
	DD	012d40cH
	DD	010c404H
	DD	imagerel cu_zero_coeff_cost
	DD	imagerel cu_zero_coeff_cost+29
	DD	imagerel $unwind$cu_zero_coeff_cost
$chain$2$cu_zero_coeff_cost DD 020521H
	DD	046805H
	DD	imagerel cu_zero_coeff_cost+29
	DD	imagerel cu_zero_coeff_cost+239
	DD	imagerel $chain$1$cu_zero_coeff_cost
$chain$3$cu_zero_coeff_cost DD 021H
	DD	imagerel cu_zero_coeff_cost+29
	DD	imagerel cu_zero_coeff_cost+239
	DD	imagerel $chain$1$cu_zero_coeff_cost
$chain$4$cu_zero_coeff_cost DD 021H
	DD	imagerel cu_zero_coeff_cost
	DD	imagerel cu_zero_coeff_cost+29
	DD	imagerel $unwind$cu_zero_coeff_cost
$unwind$lcu_fill_cbf DD 070f01H
	DD	07640fH
	DD	06340fH
	DD	0c00df00fH
	DD	0700bH
$chain$1$lcu_fill_cbf DD 040e21H
	DD	05e40eH
	DD	045405H
	DD	imagerel lcu_fill_cbf
	DD	imagerel lcu_fill_cbf+72
	DD	imagerel $unwind$lcu_fill_cbf
$chain$2$lcu_fill_cbf DD 021H
	DD	imagerel lcu_fill_cbf
	DD	imagerel lcu_fill_cbf+72
	DD	imagerel $unwind$lcu_fill_cbf
$unwind$lcu_fill_inter DD 081201H
	DD	0e6412H
	DD	0f00e5212H
	DD	0d00ae00cH
	DD	07006c008H
$chain$1$lcu_fill_inter DD 041221H
	DD	0d5412H
	DD	0c3405H
	DD	imagerel lcu_fill_inter
	DD	imagerel lcu_fill_inter+92
	DD	imagerel $unwind$lcu_fill_inter
$chain$2$lcu_fill_inter DD 021H
	DD	imagerel lcu_fill_inter
	DD	imagerel lcu_fill_inter+92
	DD	imagerel $unwind$lcu_fill_inter
$unwind$lcu_fill_cu_info DD 050b01H
	DD	04540bH
	DD	03340bH
	DD	0600bH
$chain$0$lcu_fill_cu_info DD 020521H
	DD	027405H
	DD	imagerel lcu_fill_cu_info
	DD	imagerel lcu_fill_cu_info+39
	DD	imagerel $unwind$lcu_fill_cu_info
$chain$1$lcu_fill_cu_info DD 021H
	DD	imagerel lcu_fill_cu_info
	DD	imagerel lcu_fill_cu_info+39
	DD	imagerel $unwind$lcu_fill_cu_info
$unwind$kvz_lcu_fill_trdepth DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
$unwind$work_tree_copy_down DD 040e01H
	DD	0c00ad20eH
	DD	030075008H
$chain$4$work_tree_copy_down DD 0a1f21H
	DD	0af41fH
	DD	0be41bH
	DD	0cd413H
	DD	0d740fH
	DD	0126404H
	DD	imagerel work_tree_copy_down
	DD	imagerel work_tree_copy_down+51
	DD	imagerel $unwind$work_tree_copy_down
$chain$5$work_tree_copy_down DD 021H
	DD	imagerel work_tree_copy_down
	DD	imagerel work_tree_copy_down+51
	DD	imagerel $unwind$work_tree_copy_down
$unwind$work_tree_copy_up DD 0a1c01H
	DD	0f541cH
	DD	0d341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
$chain$0$work_tree_copy_up DD 020521H
	DD	0c6405H
	DD	imagerel work_tree_copy_up
	DD	imagerel work_tree_copy_up+36
	DD	imagerel $unwind$work_tree_copy_up
$chain$1$work_tree_copy_up DD 021H
	DD	imagerel work_tree_copy_up
	DD	imagerel work_tree_copy_up+36
	DD	imagerel $unwind$work_tree_copy_up
$unwind$copy_cu_coeffs DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
$unwind$copy_cu_pixels DD 081301H
	DD	0c5413H
	DD	0b3413H
	DD	0f00f5213H
	DD	0700be00dH
$chain$0$copy_cu_pixels DD 020521H
	DD	0a6405H
	DD	imagerel copy_cu_pixels
	DD	imagerel copy_cu_pixels+103
	DD	imagerel $unwind$copy_cu_pixels
$chain$1$copy_cu_pixels DD 021H
	DD	imagerel copy_cu_pixels
	DD	imagerel copy_cu_pixels+103
	DD	imagerel $unwind$copy_cu_pixels
$unwind$copy_cu_info DD 030601H
	DD	036406H
	DD	07006H
$chain$0$copy_cu_info DD 020521H
	DD	023405H
	DD	imagerel copy_cu_info
	DD	imagerel copy_cu_info+23
	DD	imagerel $unwind$copy_cu_info
$chain$1$copy_cu_info DD 021H
	DD	imagerel copy_cu_info
	DD	imagerel copy_cu_info+23
	DD	imagerel $unwind$copy_cu_info
$unwind$xy_to_zorder DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$copy_coeffs DD 010401H
	DD	04204H
$unwind$kvz_search_lcu DD 0d2701H
	DD	04b317427H
	DD	04b306427H
	DD	04b2f5427H
	DD	04b2e3427H
	DD	04b2a0127H
	DD	0e018f01aH
	DD	0c016H
	ORG $+6
$SG4294944021 DB 'y', 00H, ' ', 00H, '%', 00H, ' ', 00H, 'L', 00H, 'C', 00H
	DB	'U', 00H, '_', 00H, 'W', 00H, 'I', 00H, 'D', 00H, 'T', 00H, 'H'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+2
$SG4294944022 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944023 DB 'x', 00H, ' ', 00H, '%', 00H, ' ', 00H, 'L', 00H, 'C', 00H
	DB	'U', 00H, '_', 00H, 'W', 00H, 'I', 00H, 'D', 00H, 'T', 00H, 'H'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+10
$SG4294944024 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944025 DB 'c', 00H, 'u', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'u', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'U', 00H, '_', 00H
	DB	'N', 00H, 'O', 00H, 'T', 00H, 'S', 00H, 'E', 00H, 'T', 00H, 00H
	DB	00H
	ORG $+12
$SG4294944026 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944027 DB 'c', 00H, 'u', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'u', 00H
	DB	'-', 00H, '>', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 't', 00H, '_'
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '_'
	DB	00H, '2', 00H, 'N', 00H, 'x', 00H, '2', 00H, 'N', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 'c', 00H, 'u', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'u', 00H, '-', 00H, '>', 00H, 'p', 00H, 'a', 00H
	DB	'r', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'I', 00H
	DB	'Z', 00H, 'E', 00H, '_', 00H, 'N', 00H, 'x', 00H, 'N', 00H, 00H
	DB	00H
	ORG $+14
$SG4294944028 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944029 DB 'c', 00H, 'u', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'u', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'C', 00H, 'U', 00H, '_', 00H
	DB	'I', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H, 00H, 00H
	ORG $+14
$SG4294944030 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944031 DB 'y', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'y', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'L', 00H, 'C', 00H, 'U', 00H, '_', 00H, 'W', 00H, 'I'
	DB	00H, 'D', 00H, 'T', 00H, 'H', 00H, 00H, 00H
	ORG $+4
$SG4294944032 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944033 DB 'x', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'x', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'L', 00H, 'C', 00H, 'U', 00H, '_', 00H, 'W', 00H, 'I'
	DB	00H, 'D', 00H, 'T', 00H, 'H', 00H, 00H, 00H
	ORG $+4
$SG4294944034 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944035 DB 'y', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'y', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'L', 00H, 'C', 00H, 'U', 00H, '_', 00H, 'W', 00H, 'I'
	DB	00H, 'D', 00H, 'T', 00H, 'H', 00H, 00H, 00H
	ORG $+4
$SG4294944036 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944037 DB 'x', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'x', 00H, '_', 00H, 'p', 00H, 'x', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'L', 00H, 'C', 00H, 'U', 00H, '_', 00H, 'W', 00H, 'I'
	DB	00H, 'D', 00H, 'T', 00H, 'H', 00H, 00H, 00H
	ORG $+4
$SG4294944038 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
	ORG $+6
$SG4294944039 DB 'y', 00H, ' ', 00H, '%', 00H, ' ', 00H, '4', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'y', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG4294944040 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'c', 00H
	DB	'u', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+6
$SG4294944041 DB 'x', 00H, ' ', 00H, '%', 00H, ' ', 00H, '4', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
	ORG $+8
$SG4294944042 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'c', 00H
	DB	'u', 00H, '.', 00H, 'h', 00H, 00H, 00H
	ORG $+14
$SG4294944043 DB 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'%', 00H, ' ', 00H, '4', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '4', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '6', 00H, '4', 00H, 00H, 00H
	ORG $+8
$SG4294944044 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'c', 00H
	DB	'u', 00H, '.', 00H, 'h', 00H, 00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\ml_intra_cu_depth_pred.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
work_tree$ = 48
state$ = 153968
x$ = 153976
y$ = 153984
hor_buf$ = 153992
ver_buf$ = 154000
kvz_search_lcu PROC

; 959  : {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	mov	eax, 153936				; 00025950H
	call	__chkstk
	sub	rsp, rax

; 960  :   assert(x % LCU_WIDTH == 0);

	mov	eax, edx
	mov	r15d, edx
	cdq
	mov	rbx, r9
	and	edx, 63					; 0000003fH
	mov	ebp, r8d
	add	eax, edx
	mov	rsi, rcx
	mov	r12d, eax
	and	eax, 63					; 0000003fH
	sar	r12d, 6
	cmp	eax, edx
	je	SHORT $LN8@kvz_search
	mov	r8d, 960				; 000003c0H
	lea	rdx, OFFSET FLAT:$SG4294944024
	lea	rcx, OFFSET FLAT:$SG4294944023
	call	QWORD PTR __imp__wassert
$LN8@kvz_search:

; 961  :   assert(y % LCU_WIDTH == 0);

	mov	eax, ebp
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	mov	r14d, eax
	and	eax, 63					; 0000003fH
	sar	r14d, 6
	cmp	eax, edx
	je	SHORT $LN9@kvz_search
	mov	r8d, 961				; 000003c1H
	lea	rdx, OFFSET FLAT:$SG4294944022
	lea	rcx, OFFSET FLAT:$SG4294944021
	call	QWORD PTR __imp__wassert
$LN9@kvz_search:

; 962  : 
; 963  :   // Initialize the same starting state to every depth. The search process
; 964  :   // will use these as temporary storage for predictions before making
; 965  :   // a decision on which to use, and they get updated during the search
; 966  :   // process.
; 967  :   lcu_t work_tree[MAX_PU_DEPTH + 1];
; 968  :   init_lcu_t(state, x, y, &work_tree[0], hor_buf, ver_buf);

	mov	rax, QWORD PTR ver_buf$[rsp]
	lea	r9, QWORD PTR work_tree$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	r8d, ebp
	mov	edx, r15d
	mov	QWORD PTR [rsp+32], rbx
	mov	rcx, rsi
	call	init_lcu_t
	lea	rbx, QWORD PTR work_tree$[rsp+30776]
	mov	edi, 4
	npad	11
$LL4@kvz_search:

; 969  :   for (int depth = 1; depth <= MAX_PU_DEPTH; ++depth) {
; 970  :     work_tree[depth] = work_tree[0];

	mov	r8d, 30776				; 00007838H
	lea	rdx, QWORD PTR work_tree$[rsp]
	mov	rcx, rbx
	call	memcpy
	add	rbx, 30776				; 00007838H
	sub	rdi, 1
	jne	SHORT $LL4@kvz_search

; 971  :   }
; 972  : 
; 973  :   // If the ML depth prediction is enabled, 
; 974  :   // generate the depth prediction interval 
; 975  :   // for the current lcu
; 976  :   constraint_t* constr = state->constraint;

	mov	rax, QWORD PTR [rsi+416]

; 977  :   if (constr->ml_intra_depth_ctu) {

	mov	rbx, QWORD PTR [rax]
	test	rbx, rbx
	je	SHORT $LN10@kvz_search
; File F:\open_codec_learn_2021\kvazaar-master\src\ml_intra_cu_depth_pred.c

; 1749 : 	os_luma_qt_pred(ml_intra_depth_ctu, luma_px, qp, ml_intra_depth_ctu->_mat_upper_depth);

	mov	r9, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR work_tree$[rsp+392]
	movzx	r8d, BYTE PTR [rsi+384]
	call	os_luma_qt_pred

; 1750 : 
; 1751 : 	// Generate the interval of QT predictions around the first one
; 1752 : 	generate_interval_from_os_pred(ml_intra_depth_ctu, ml_intra_depth_ctu->_mat_upper_depth);

	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, rbx
	call	generate_interval_from_os_pred

; 1753 : 
; 1754 : 	// Apply the extra Upper Expansion pass
; 1755 : 	merge_matrix_64(ml_intra_depth_ctu->_mat_upper_depth, ml_intra_depth_ctu->_mat_upper_depth);

	mov	rcx, QWORD PTR [rbx+8]
	mov	rdx, rcx
	call	merge_matrix_64
$LN10@kvz_search:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 982  :   double cost = search_cu(state, x, y, 0, work_tree);

	lea	rax, QWORD PTR work_tree$[rsp]
	xor	r9d, r9d
	mov	r8d, ebp
	mov	QWORD PTR [rsp+32], rax
	mov	edx, r15d
	mov	rcx, rsi
	call	search_cu

; 983  : 
; 984  :   // Save squared cost for rate control.
; 985  :   if(state->encoder_control->cfg.rc_algorithm == KVZ_LAMBDA) {

	mov	rdx, QWORD PTR [rsi]
	cmp	BYTE PTR [rdx+2484], 1
	jne	SHORT $LN6@kvz_search
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	rax, QWORD PTR [rsi+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 986  :     kvz_get_lcu_stats(state, x / LCU_WIDTH, y / LCU_WIDTH)->weight = cost * cost;

	mulsd	xmm0, xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1598 :   const int index = lcu_x + state->tile->lcu_offset_x +

	mov	ecx, DWORD PTR [rax+16]
	add	ecx, r14d
	imul	ecx, DWORD PTR [rdx+2536]
	add	ecx, DWORD PTR [rax+12]
	lea	eax, DWORD PTR [r12+rcx]

; 1599 :                     (lcu_y + state->tile->lcu_offset_y) *
; 1600 :                     state->encoder_control->in.width_in_lcu;
; 1601 :   return &state->frame->lcu_stats[index];

	cdqe
	lea	rdx, QWORD PTR [rax+rax*8]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 986  :     kvz_get_lcu_stats(state, x / LCU_WIDTH, y / LCU_WIDTH)->weight = cost * cost;

	mov	rax, QWORD PTR [rsi+40]
	mov	rcx, QWORD PTR [rax+160]
	movsd	QWORD PTR [rcx+rdx*8+8], xmm0
$LN6@kvz_search:

; 987  :   }
; 988  : 
; 989  :   // The best decisions through out the LCU got propagated back to depth 0,
; 990  :   // so copy those back to the frame.
; 991  :   copy_lcu_to_cu_data(state, x, y, &work_tree[0]);

	lea	r9, QWORD PTR work_tree$[rsp]
	mov	r8d, ebp
	mov	edx, r15d
	mov	rcx, rsi
	call	copy_lcu_to_cu_data
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	mov	rcx, QWORD PTR [rsi+392]
	lea	rdx, QWORD PTR work_tree$[rsp+12688]
	mov	r8d, 8192				; 00002000H
	call	memcpy
	mov	rcx, QWORD PTR [rsi+392]
	lea	rdx, QWORD PTR work_tree$[rsp+20880]
	add	rcx, 8192				; 00002000H
	mov	r8d, 2048				; 00000800H
	call	memcpy
	mov	rcx, QWORD PTR [rsi+392]
	lea	rdx, QWORD PTR work_tree$[rsp+22928]
	add	rcx, 10240				; 00002800H
	mov	r8d, 2048				; 00000800H
	call	memcpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 997  : }

	lea	r11, QWORD PTR [rsp+153936]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rdi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	ret	0
kvz_search_lcu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
src$ = 48
dest$ = 56
width$ = 64
copy_coeffs PROC

; 369  : {

	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	mov	rdx, rcx
	imul	r8, r8
	mov	rcx, rax
	add	r8, r8
	call	memcpy

; 371  : }

	add	rsp, 40					; 00000028H
	ret	0
copy_coeffs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
width$ = 48
x$ = 56
y$ = 64
xy_to_zorder PROC

; 386  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, r8d
	mov	edi, edx
	mov	esi, ecx

; 387  :   assert(width % 4 == 0 && width >= 4 && width <= 64);

	test	cl, 3
	jne	SHORT $LN10@xy_to_zord
	cmp	ecx, 4
	jae	SHORT $LN11@xy_to_zord
$LN10@xy_to_zord:
	mov	r8d, 387				; 00000183H
	lea	rdx, OFFSET FLAT:$SG4294944044
	lea	rcx, OFFSET FLAT:$SG4294944043
	call	QWORD PTR __imp__wassert
$LN11@xy_to_zord:

; 388  :   assert(x % 4 == 0 && x < width);

	test	dil, 3
	jne	SHORT $LN12@xy_to_zord
	cmp	edi, esi
	jb	SHORT $LN13@xy_to_zord
$LN12@xy_to_zord:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944042
	lea	rcx, OFFSET FLAT:$SG4294944041
	call	QWORD PTR __imp__wassert
$LN13@xy_to_zord:

; 389  :   assert(y % 4 == 0 && y < width);

	test	bl, 3
	jne	SHORT $LN14@xy_to_zord
	cmp	ebx, esi
	jb	SHORT $LN15@xy_to_zord
$LN14@xy_to_zord:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944040
	lea	rcx, OFFSET FLAT:$SG4294944039
	call	QWORD PTR __imp__wassert
$LN15@xy_to_zord:

; 390  : 
; 391  :   unsigned result = 0;

	xor	edx, edx

; 392  : 
; 393  :   switch (width) {

	cmp	esi, 32					; 00000020H
	je	SHORT $LN5@xy_to_zord
	cmp	esi, 64					; 00000040H
	jne	SHORT $LN16@xy_to_zord

; 394  :     case 64:
; 395  :       result += x / 32 * (32*32);
; 396  :       result += y / 32 * (64*32);

	mov	ecx, ebx
	mov	eax, edi
	shr	ecx, 5

; 397  :       x %= 32;

	and	edi, 31
	shr	eax, 5
	lea	edx, DWORD PTR [rax+rcx*2]
	shl	edx, 10

; 398  :       y %= 32;

	and	ebx, 31
$LN5@xy_to_zord:

; 399  :       // fallthrough
; 400  :     case 32:
; 401  :       result += x / 16 * (16*16);
; 402  :       result += y / 16 * (32*16);

	mov	ecx, ebx
	mov	eax, edi
	shr	ecx, 4

; 403  :       x %= 16;

	and	edi, 15
	shr	eax, 4

; 404  :       y %= 16;

	and	ebx, 15
	lea	ecx, DWORD PTR [rax+rcx*2]

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);

	mov	eax, edi
	shl	ecx, 8

; 408  :       result += y / 8 * (16*8);
; 409  :       x %= 8;

	and	edi, 7
	add	edx, ecx
	shr	eax, 3
	mov	ecx, ebx

; 410  :       y %= 8;
; 411  :       // fallthrough
; 412  :     case 8:
; 413  :       result += x / 4 * (4*4);

	shr	edi, 2
	shr	ecx, 3
	and	ebx, 7

; 414  :       result += y / 4 * (8*4);

	shr	ebx, 2
	lea	ecx, DWORD PTR [rax+rcx*2]
	shl	ecx, 6
	lea	eax, DWORD PTR [rdi+rbx*2]
	add	edx, ecx
	shl	eax, 4
	add	eax, edx

; 415  :       // fallthrough
; 416  :     case 4:
; 417  :       break;
; 418  :   }
; 419  : 
; 420  :   return result;
; 421  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN16@xy_to_zord:
	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, edx
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
xy_to_zorder ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_is_set PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	movzx	r9d, cx
	lea	rcx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+r8*4]
	shl	edx, cl
	mov	eax, 0
	test	edx, r9d
	setne	al

; 519  : }

	ret	0
cbf_is_set ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
cbf_is_set_any PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rdx+rax*2]
	test	dx, cx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, edx
	shl	edx, 5
	or	edx, eax
	movzx	eax, cx
	shl	edx, 5
	test	edx, eax

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set
	xor	eax, eax

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
$LN3@cbf_is_set:

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	mov	eax, 1

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
cbf_is_set_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$dead$ = 16
plane$dead$ = 24
cbf_clear PROC

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	mov	eax, 65504				; 0000ffe0H
	and	WORD PTR [rcx], ax

; 560  : }

	ret	0
cbf_clear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
src$ = 16
plane$dead$ = 24
cbf_copy PROC

; 567  :   cbf_clear(cbf, 0, plane);
; 568  :   *cbf |= src & (cbf_masks[0] << (NUM_CBF_DEPTHS * plane));

	movzx	eax, WORD PTR [rcx]
	xor	ax, dx
	and	ax, 31
	xor	WORD PTR [rcx], ax

; 569  : }

	ret	0
cbf_copy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
x_local$ = 16
y_local$ = 24
width$ = 32
from$ = 40
to$ = 48
copy_cu_info PROC

; 72   : {

	mov	QWORD PTR [rsp+16], rsi
	push	rdi

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	lea	esi, DWORD PTR [rdx+r8]
	mov	rdi, r9
	mov	r10d, edx
	mov	r11d, ecx
	cmp	edx, esi
	jge	SHORT $LN3@copy_cu_in
	mov	QWORD PTR [rsp+16], rbx
	add	r8d, ecx
	mov	rbx, QWORD PTR to$[rsp]
$LL4@copy_cu_in:

; 74   :     for (int x = x_local; x < x_local + width; x += SCU_WIDTH) {

	mov	eax, r11d
	cmp	r11d, r8d
	jge	SHORT $LN2@copy_cu_in
	mov	ecx, r10d
	sar	ecx, 2
	imul	r9d, ecx, 17
	npad	10
$LL7@copy_cu_in:

; 75   :       *LCU_GET_CU_AT_PX(to, x, y) = *LCU_GET_CU_AT_PX(from, x, y);

	mov	ecx, eax
	add	eax, 4
	sar	ecx, 2
	add	ecx, r9d
	movsxd	rcx, ecx
	add	rcx, 18
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rdx, QWORD PTR [rbx+rcx*4]
	movups	xmm0, XMMWORD PTR [rdi+rcx*4+24976]
	movups	XMMWORD PTR [rdx+24976], xmm0
	mov	ecx, DWORD PTR [rdi+rcx*4+24992]
	mov	DWORD PTR [rdx+24992], ecx
	cmp	eax, r8d
	jl	SHORT $LL7@copy_cu_in
$LN2@copy_cu_in:

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	add	r10d, 4
	cmp	r10d, esi
	jl	SHORT $LL4@copy_cu_in
	mov	rbx, QWORD PTR [rsp+16]
$LN3@copy_cu_in:

; 76   :     }
; 77   :   }
; 78   : }

	mov	rsi, QWORD PTR [rsp+24]
	pop	rdi
	ret	0
copy_cu_info ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
x_local$ = 80
y_local$ = 88
width$ = 96
from$ = 104
to$ = 112
copy_cu_pixels PROC

; 81   : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 82   :   const int luma_index = x_local + y_local * LCU_WIDTH;
; 83   :   const int chroma_index = (x_local / 2) + (y_local / 2) * (LCU_WIDTH / 2);
; 84   : 
; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	r15, QWORD PTR to$[rsp]
	mov	eax, edx
	shl	eax, 6
	mov	ebp, edx
	add	eax, ecx
	mov	DWORD PTR [rsp+40], 64			; 00000040H
	mov	r14d, ecx
	cdqe
	lea	rcx, QWORD PTR [r9+6540]
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	mov	rdi, r9
	lea	rdx, QWORD PTR [r15+6540]
	add	rdx, rax
	add	rcx, rax
	mov	r9d, r8d
	mov	ebx, r8d
	call	kvz_pixels_blit

; 86   :                   width, width, LCU_WIDTH, LCU_WIDTH);
; 87   :   if (from->rec.chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [rdi+12684], 0
	je	$LN2@copy_cu_pi

; 88   :     kvz_pixels_blit(&from->rec.u[chroma_index], &to->rec.u[chroma_index],

	mov	eax, ebx
	mov	QWORD PTR [rsp+80], rsi
	cdq
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	sub	eax, edx
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	sar	eax, 1
	mov	esi, eax
	mov	eax, ebp
	cdq
	mov	r9d, esi
	sub	eax, edx
	mov	r8d, esi
	sar	eax, 1
	mov	ecx, eax
	mov	eax, r14d
	cdq
	shl	ecx, 5
	sub	eax, edx
	sar	eax, 1
	add	ecx, eax
	movsxd	rcx, ecx
	add	rdi, rcx
	lea	rbx, QWORD PTR [rcx+r15]
	lea	rdx, QWORD PTR [rbx+10636]
	lea	rcx, QWORD PTR [rdi+10636]
	call	kvz_pixels_blit

; 89   :                     width / 2, width / 2, LCU_WIDTH / 2, LCU_WIDTH / 2);
; 90   :     kvz_pixels_blit(&from->rec.v[chroma_index], &to->rec.v[chroma_index],

	lea	rdx, QWORD PTR [rbx+11660]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	lea	rcx, QWORD PTR [rdi+11660]
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	mov	r9d, esi
	mov	r8d, esi
	call	kvz_pixels_blit
	mov	rsi, QWORD PTR [rsp+80]
$LN2@copy_cu_pi:

; 91   :                     width / 2, width / 2, LCU_WIDTH / 2, LCU_WIDTH / 2);
; 92   :   }
; 93   : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
copy_cu_pixels ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
x_local$ = 48
y_local$ = 56
width$ = 64
from$ = 72
to$ = 80
copy_cu_coeffs PROC

; 96   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	movsxd	rsi, r8d
	mov	rbp, r9
	mov	ebx, edx
	mov	edi, ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	test	cl, 3
	jne	SHORT $LN15@copy_cu_co
	cmp	ecx, 64					; 00000040H
	jb	SHORT $LN16@copy_cu_co
$LN15@copy_cu_co:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944042
	lea	rcx, OFFSET FLAT:$SG4294944041
	call	QWORD PTR __imp__wassert
$LN16@copy_cu_co:

; 389  :   assert(y % 4 == 0 && y < width);

	test	bl, 3
	jne	SHORT $LN17@copy_cu_co
	cmp	ebx, 64					; 00000040H
	jb	SHORT $LN18@copy_cu_co
$LN17@copy_cu_co:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944040
	lea	rcx, OFFSET FLAT:$SG4294944039
	call	QWORD PTR __imp__wassert
$LN18@copy_cu_co:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	mov	r14, QWORD PTR to$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 396  :       result += y / 32 * (64*32);

	mov	ecx, ebx
	shr	ecx, 5
	mov	eax, edi
	shr	eax, 5

; 397  :       x %= 32;

	mov	r8d, edi
	and	r8d, 31

; 398  :       y %= 32;

	mov	edx, ebx
	and	edx, 31
	lea	r9d, DWORD PTR [rax+rcx*2]

; 399  :       // fallthrough
; 400  :     case 32:
; 401  :       result += x / 16 * (16*16);

	mov	eax, r8d
	shr	eax, 4

; 402  :       result += y / 16 * (32*16);

	mov	ecx, edx
	shr	ecx, 4

; 403  :       x %= 16;

	and	r8d, 15

; 404  :       y %= 16;

	and	edx, 15
	shl	r9d, 10
	lea	ecx, DWORD PTR [rax+rcx*2]

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);

	mov	eax, r8d
	shl	ecx, 8

; 409  :       x %= 8;

	and	r8d, 7
	add	r9d, ecx
	shr	eax, 3
	mov	ecx, edx

; 411  :       // fallthrough
; 412  :     case 8:
; 413  :       result += x / 4 * (4*4);

	shr	r8d, 2
	shr	ecx, 3
	and	edx, 7

; 414  :       result += y / 4 * (8*4);

	shr	edx, 2
	lea	ecx, DWORD PTR [rax+rcx*2]
	lea	eax, DWORD PTR [r8+rdx*2]
	shl	ecx, 6
	shl	eax, 4
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	lea	rdx, QWORD PTR [rbp+12688]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 408  :       result += y / 8 * (16*8);

	add	r9d, ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	mov	r8, rsi
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 414  :       result += y / 4 * (8*4);

	add	eax, r9d
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	cdqe
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	imul	r8, r8
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	lea	rdx, QWORD PTR [rdx+rax*2]
	add	rax, 6344				; 000018c8H
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	add	r8, r8
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	lea	rcx, QWORD PTR [r14+rax*2]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	call	memcpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 100  :   if (from->rec.chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [rbp+12684], 0
	je	$LN38@copy_cu_co

; 101  :     const int chroma_z = xy_to_zorder(LCU_WIDTH_C, x_local >> 1, y_local >> 1);

	sar	ebx, 1
	sar	edi, 1
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	test	dil, 3
	jne	SHORT $LN32@copy_cu_co
	cmp	edi, 32					; 00000020H
	jb	SHORT $LN33@copy_cu_co
$LN32@copy_cu_co:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944042
	lea	rcx, OFFSET FLAT:$SG4294944041
	call	QWORD PTR __imp__wassert
$LN33@copy_cu_co:

; 389  :   assert(y % 4 == 0 && y < width);

	test	bl, 3
	jne	SHORT $LN34@copy_cu_co
	cmp	ebx, 32					; 00000020H
	jb	SHORT $LN35@copy_cu_co
$LN34@copy_cu_co:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944040
	lea	rcx, OFFSET FLAT:$SG4294944039
	call	QWORD PTR __imp__wassert
$LN35@copy_cu_co:

; 399  :       // fallthrough
; 400  :     case 32:
; 401  :       result += x / 16 * (16*16);

	mov	eax, edi
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 102  :     copy_coeffs(&from->coeff.u[chroma_z], &to->coeff.u[chroma_z], width >> 1);

	sar	esi, 1
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 402  :       result += y / 16 * (32*16);

	mov	ecx, ebx
	shr	eax, 4
	shr	ecx, 4

; 403  :       x %= 16;

	and	edi, 15

; 404  :       y %= 16;

	and	ebx, 15
	lea	edx, DWORD PTR [rax+rcx*2]

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);

	mov	eax, edi

; 408  :       result += y / 8 * (16*8);

	mov	ecx, ebx
	shl	edx, 8
	shr	ecx, 3

; 409  :       x %= 8;

	and	edi, 7
	shr	eax, 3

; 410  :       y %= 8;

	and	ebx, 7

; 411  :       // fallthrough
; 412  :     case 8:
; 413  :       result += x / 4 * (4*4);

	shr	edi, 2

; 414  :       result += y / 4 * (8*4);

	shr	ebx, 2
	lea	ecx, DWORD PTR [rax+rcx*2]
	shl	ecx, 6
	lea	eax, DWORD PTR [rdi+rbx*2]
	add	edx, ecx
	shl	eax, 4
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 102  :     copy_coeffs(&from->coeff.u[chroma_z], &to->coeff.u[chroma_z], width >> 1);

	lea	rcx, QWORD PTR [r14+20880]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 414  :       result += y / 4 * (8*4);

	add	edx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 102  :     copy_coeffs(&from->coeff.u[chroma_z], &to->coeff.u[chroma_z], width >> 1);

	movsxd	rdi, esi
	movsxd	rbx, edx
	lea	rdx, QWORD PTR [rbp+20880]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	imul	rdi, rdi
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 102  :     copy_coeffs(&from->coeff.u[chroma_z], &to->coeff.u[chroma_z], width >> 1);

	lea	rdx, QWORD PTR [rdx+rbx*2]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	add	rdi, rdi
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 102  :     copy_coeffs(&from->coeff.u[chroma_z], &to->coeff.u[chroma_z], width >> 1);

	lea	rcx, QWORD PTR [rcx+rbx*2]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	mov	r8, rdi
	call	memcpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 103  :     copy_coeffs(&from->coeff.v[chroma_z], &to->coeff.v[chroma_z], width >> 1);

	lea	rdx, QWORD PTR [rbp+22928]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	mov	r8, rdi
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 103  :     copy_coeffs(&from->coeff.v[chroma_z], &to->coeff.v[chroma_z], width >> 1);

	lea	rcx, QWORD PTR [r14+22928]
	lea	rdx, QWORD PTR [rdx+rbx*2]
	lea	rcx, QWORD PTR [rcx+rbx*2]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	call	memcpy
$LN38@copy_cu_co:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 105  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
copy_cu_coeffs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
x_local$ = 96
y_local$ = 104
depth$ = 112
work_tree$ = 120
work_tree_copy_up PROC

; 111  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rbp
	mov	DWORD PTR [rsp+24], r8d
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	movsxd	rax, r8d
	mov	r14d, ecx

; 112  :   const int width = LCU_WIDTH >> depth;

	mov	ecx, eax
	mov	QWORD PTR [rsp+96], rsi
	mov	r12d, 64				; 00000040H
	mov	ebp, edx
	sar	r12d, cl

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	mov	r10d, edx
	lea	r13d, DWORD PTR [r12+rdx]
	cmp	edx, r13d
	jge	$LN5@work_tree_
	mov	r15, rax
	lea	r11d, DWORD PTR [r12+r14]
	npad	5
$LL6@work_tree_:

; 74   :     for (int x = x_local; x < x_local + width; x += SCU_WIDTH) {

	mov	eax, r14d
	cmp	r14d, r11d
	jge	SHORT $LN4@work_tree_
	mov	ecx, r10d
	sar	ecx, 2
	imul	ebx, ecx, 17
	lea	rcx, QWORD PTR [r15+1]
	imul	rdi, rcx, 30776				; 00007838H
	imul	rsi, r15, 30776				; 00007838H
$LL9@work_tree_:

; 75   :       *LCU_GET_CU_AT_PX(to, x, y) = *LCU_GET_CU_AT_PX(from, x, y);

	mov	ecx, eax
	add	eax, 4
	sar	ecx, 2
	add	ecx, ebx
	movsxd	rcx, ecx
	add	rcx, 18
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	r8, QWORD PTR [rsi+rcx*4]
	lea	rdx, QWORD PTR [rdi+rcx*4]
	movups	xmm0, XMMWORD PTR [rdx+r9+24976]
	movups	XMMWORD PTR [r8+r9+24976], xmm0
	mov	ecx, DWORD PTR [rdx+r9+24992]
	mov	DWORD PTR [r8+r9+24992], ecx
	cmp	eax, r11d
	jl	SHORT $LL9@work_tree_
$LN4@work_tree_:

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	add	r10d, 4
	cmp	r10d, r13d
	jl	SHORT $LL6@work_tree_
	mov	eax, DWORD PTR depth$[rsp]
$LN5@work_tree_:

; 113  :   copy_cu_info  (x_local, y_local, width, &work_tree[depth + 1], &work_tree[depth]);
; 114  :   copy_cu_pixels(x_local, y_local, width, &work_tree[depth + 1], &work_tree[depth]);

	movsxd	rcx, eax

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	r8d, r12d

; 113  :   copy_cu_info  (x_local, y_local, width, &work_tree[depth + 1], &work_tree[depth]);
; 114  :   copy_cu_pixels(x_local, y_local, width, &work_tree[depth + 1], &work_tree[depth]);

	imul	r13, rcx, 30776				; 00007838H
	lea	rax, QWORD PTR [rcx+1]

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	DWORD PTR [rsp+40], 64			; 00000040H

; 113  :   copy_cu_info  (x_local, y_local, width, &work_tree[depth + 1], &work_tree[depth]);
; 114  :   copy_cu_pixels(x_local, y_local, width, &work_tree[depth + 1], &work_tree[depth]);

	imul	r15, rax, 30776				; 00007838H
	add	r13, r9

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	DWORD PTR [rsp+32], 64			; 00000040H

; 113  :   copy_cu_info  (x_local, y_local, width, &work_tree[depth + 1], &work_tree[depth]);
; 114  :   copy_cu_pixels(x_local, y_local, width, &work_tree[depth + 1], &work_tree[depth]);

	add	r15, r9

; 82   :   const int luma_index = x_local + y_local * LCU_WIDTH;

	mov	eax, ebp
	shl	eax, 6

; 83   :   const int chroma_index = (x_local / 2) + (y_local / 2) * (LCU_WIDTH / 2);
; 84   : 
; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	r9d, r12d
	add	eax, r14d
	cdqe
	lea	rdx, QWORD PTR [rax+6540]
	lea	rcx, QWORD PTR [rax+6540]
	add	rdx, r13
	add	rcx, r15
	call	kvz_pixels_blit

; 86   :                   width, width, LCU_WIDTH, LCU_WIDTH);
; 87   :   if (from->rec.chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [r15+12684], 0
	je	SHORT $LN12@work_tree_

; 88   :     kvz_pixels_blit(&from->rec.u[chroma_index], &to->rec.u[chroma_index],

	mov	eax, r12d
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	cdq
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	mov	eax, ebp
	cdq
	mov	r9d, esi
	sub	eax, edx
	mov	r8d, esi
	sar	eax, 1
	mov	ecx, eax
	mov	eax, r14d
	cdq
	shl	ecx, 5
	sub	eax, edx
	sar	eax, 1
	add	ecx, eax
	movsxd	rcx, ecx
	lea	rbx, QWORD PTR [rcx+r13]
	lea	rdi, QWORD PTR [rcx+r15]
	lea	rdx, QWORD PTR [rbx+10636]
	lea	rcx, QWORD PTR [rdi+10636]
	call	kvz_pixels_blit

; 89   :                     width / 2, width / 2, LCU_WIDTH / 2, LCU_WIDTH / 2);
; 90   :     kvz_pixels_blit(&from->rec.v[chroma_index], &to->rec.v[chroma_index],

	lea	rdx, QWORD PTR [rbx+11660]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	lea	rcx, QWORD PTR [rdi+11660]
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	mov	r9d, esi
	mov	r8d, esi
	call	kvz_pixels_blit
$LN12@work_tree_:
	mov	rsi, QWORD PTR [rsp+96]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	test	r14b, 3
	jne	SHORT $LN28@work_tree_
	cmp	r14d, 64				; 00000040H
	jb	SHORT $LN29@work_tree_
$LN28@work_tree_:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944042
	lea	rcx, OFFSET FLAT:$SG4294944041
	call	QWORD PTR __imp__wassert
$LN29@work_tree_:

; 389  :   assert(y % 4 == 0 && y < width);

	test	bpl, 3
	jne	SHORT $LN30@work_tree_
	cmp	ebp, 64					; 00000040H
	jb	SHORT $LN31@work_tree_
$LN30@work_tree_:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944040
	lea	rcx, OFFSET FLAT:$SG4294944039
	call	QWORD PTR __imp__wassert
$LN31@work_tree_:

; 390  : 
; 391  :   unsigned result = 0;
; 392  : 
; 393  :   switch (width) {
; 394  :     case 64:
; 395  :       result += x / 32 * (32*32);
; 396  :       result += y / 32 * (64*32);

	mov	ecx, ebp
	mov	eax, r14d
	shr	ecx, 5

; 397  :       x %= 32;

	mov	r8d, r14d
	shr	eax, 5
	and	r8d, 31

; 398  :       y %= 32;

	mov	edx, ebp
	and	edx, 31
	lea	r9d, DWORD PTR [rax+rcx*2]

; 399  :       // fallthrough
; 400  :     case 32:
; 401  :       result += x / 16 * (16*16);

	mov	eax, r8d

; 402  :       result += y / 16 * (32*16);

	mov	ecx, edx
	shr	eax, 4
	shr	ecx, 4

; 403  :       x %= 16;

	and	r8d, 15

; 404  :       y %= 16;

	and	edx, 15
	shl	r9d, 10
	lea	ecx, DWORD PTR [rax+rcx*2]

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);

	mov	eax, r8d
	shl	ecx, 8

; 409  :       x %= 8;

	and	r8d, 7
	add	r9d, ecx
	shr	eax, 3
	mov	ecx, edx

; 411  :       // fallthrough
; 412  :     case 8:
; 413  :       result += x / 4 * (4*4);

	shr	r8d, 2
	shr	ecx, 3
	and	edx, 7

; 414  :       result += y / 4 * (8*4);

	shr	edx, 2
	lea	ecx, DWORD PTR [rax+rcx*2]
	lea	eax, DWORD PTR [r8+rdx*2]
	shl	ecx, 6
	add	r9d, ecx
	shl	eax, 4
	add	eax, r9d
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	movsxd	r8, r12d
	cdqe
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	imul	r8, r8
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	lea	rdx, QWORD PTR [rax+6344]
	lea	rcx, QWORD PTR [rax*2+12688]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	add	r8, r8
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 98   :   copy_coeffs(&from->coeff.y[luma_z], &to->coeff.y[luma_z], width);

	lea	rdx, QWORD PTR [r15+rdx*2]
	add	rcx, r13
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	call	memcpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 100  :   if (from->rec.chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [r15+12684], 0
	je	$LN51@work_tree_

; 101  :     const int chroma_z = xy_to_zorder(LCU_WIDTH_C, x_local >> 1, y_local >> 1);

	sar	ebp, 1
	sar	r14d, 1
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	test	r14b, 3
	jne	SHORT $LN45@work_tree_
	cmp	r14d, 32				; 00000020H
	jb	SHORT $LN46@work_tree_
$LN45@work_tree_:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944042
	lea	rcx, OFFSET FLAT:$SG4294944041
	call	QWORD PTR __imp__wassert
$LN46@work_tree_:

; 389  :   assert(y % 4 == 0 && y < width);

	test	bpl, 3
	jne	SHORT $LN47@work_tree_
	cmp	ebp, 32					; 00000020H
	jb	SHORT $LN48@work_tree_
$LN47@work_tree_:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944040
	lea	rcx, OFFSET FLAT:$SG4294944039
	call	QWORD PTR __imp__wassert
$LN48@work_tree_:

; 402  :       result += y / 16 * (32*16);

	mov	ecx, ebp
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 102  :     copy_coeffs(&from->coeff.u[chroma_z], &to->coeff.u[chroma_z], width >> 1);

	sar	r12d, 1
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 402  :       result += y / 16 * (32*16);

	shr	ecx, 4
	mov	eax, r14d
	shr	eax, 4

; 403  :       x %= 16;

	and	r14d, 15

; 404  :       y %= 16;

	and	ebp, 15
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 102  :     copy_coeffs(&from->coeff.u[chroma_z], &to->coeff.u[chroma_z], width >> 1);

	movsxd	rdi, r12d
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	imul	rdi, rdi

; 402  :       result += y / 16 * (32*16);

	lea	edx, DWORD PTR [rax+rcx*2]

; 408  :       result += y / 8 * (16*8);

	mov	ecx, ebp
	shr	ecx, 3
	mov	eax, r14d
	shl	edx, 8

; 409  :       x %= 8;

	and	r14d, 7
	shr	eax, 3

; 410  :       y %= 8;

	and	ebp, 7

; 414  :       result += y / 4 * (8*4);

	shr	ebp, 2

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	add	rdi, rdi

; 413  :       result += x / 4 * (4*4);

	shr	r14d, 2

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	mov	r8, rdi

; 408  :       result += y / 8 * (16*8);

	lea	ecx, DWORD PTR [rax+rcx*2]
	shl	ecx, 6
	add	edx, ecx

; 414  :       result += y / 4 * (8*4);

	lea	eax, DWORD PTR [r14+rbp*2]
	shl	eax, 4
	add	edx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 102  :     copy_coeffs(&from->coeff.u[chroma_z], &to->coeff.u[chroma_z], width >> 1);

	movsxd	rbx, edx
	lea	rdx, QWORD PTR [rbx+10440]
	lea	rcx, QWORD PTR [rbx*2+20880]
	lea	rdx, QWORD PTR [r15+rdx*2]
	add	rcx, r13
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	call	memcpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 103  :     copy_coeffs(&from->coeff.v[chroma_z], &to->coeff.v[chroma_z], width >> 1);

	lea	rdx, QWORD PTR [rbx+11464]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	mov	r8, rdi
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 103  :     copy_coeffs(&from->coeff.v[chroma_z], &to->coeff.v[chroma_z], width >> 1);

	lea	rcx, QWORD PTR [rbx*2+22928]
	lea	rdx, QWORD PTR [r15+rdx*2]
	add	rcx, r13
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 370  :   memcpy(dest, src, width * width * sizeof(coeff_t));

	call	memcpy
$LN51@work_tree_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 116  : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
work_tree_copy_up ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
tv530 = 48
tv527 = 56
tv528 = 64
tv534 = 72
x_local$ = 144
y_local$ = 152
width$1$ = 160
depth$ = 160
work_tree$ = 168
work_tree_copy_down PROC

; 123  : {

	mov	rax, rsp
	mov	DWORD PTR [rax+16], edx
	push	rbx
	push	rbp
	push	r12
	sub	rsp, 112				; 00000070H
	mov	r12d, ecx

; 124  :   const int width = LCU_WIDTH >> depth;

	mov	ebx, 64					; 00000040H
	mov	ecx, r8d
	mov	rbp, r9
	sar	ebx, cl

; 125  :   for (int i = depth + 1; i <= MAX_PU_DEPTH; i++) {

	lea	r9d, DWORD PTR [r8+1]
	mov	DWORD PTR width$1$[rsp], ebx
	cmp	r9d, 4
	jg	$LN3@work_tree_

; 126  :     copy_cu_info  (x_local, y_local, width, &work_tree[depth], &work_tree[i]);
; 127  :     copy_cu_pixels(x_local, y_local, width, &work_tree[depth], &work_tree[i]);

	mov	QWORD PTR [rax+8], rsi
	lea	rsi, QWORD PTR [rbp+6540]
	mov	QWORD PTR [rax-32], rdi
	mov	QWORD PTR [rax-40], r13
	lea	r13d, DWORD PTR [rbx+rdx]
	mov	QWORD PTR [rax-48], r14
	mov	QWORD PTR [rax-56], r15
	movsxd	rax, r8d
	imul	r15, rax, 30776				; 00007838H
	mov	eax, edx
	movsxd	r10, r9d
	shl	eax, 6
	add	rsi, r15
	add	eax, r12d
	movsxd	rcx, eax
	add	rsi, rcx
	imul	r14, r10, 30776				; 00007838H
	lea	rax, QWORD PTR [rcx+6540]
	mov	QWORD PTR tv534[rsp], rsi
	mov	ecx, 5
	mov	QWORD PTR tv528[rsp], rax
	sub	ecx, r9d
	mov	QWORD PTR tv527[rsp], rcx
	lea	rdi, QWORD PTR [r14+rbp]
	mov	QWORD PTR tv530[rsp], rdi
	npad	2
$LL4@work_tree_:

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	mov	r9d, edx
	cmp	edx, r13d
	jge	SHORT $LN8@work_tree_
	lea	r10d, DWORD PTR [rbx+r12]
	npad	4
$LL9@work_tree_:

; 74   :     for (int x = x_local; x < x_local + width; x += SCU_WIDTH) {

	mov	eax, r12d
	cmp	r12d, r10d
	jge	SHORT $LN7@work_tree_
	mov	ecx, r9d
	sar	ecx, 2
	imul	r11d, ecx, 17
$LL12@work_tree_:

; 75   :       *LCU_GET_CU_AT_PX(to, x, y) = *LCU_GET_CU_AT_PX(from, x, y);

	mov	ecx, eax
	add	eax, 4
	sar	ecx, 2
	add	ecx, r11d
	movsxd	rcx, ecx
	add	rcx, 18
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	r8, QWORD PTR [r14+rcx*4]
	lea	rdx, QWORD PTR [r15+rcx*4]
	movups	xmm0, XMMWORD PTR [rdx+rbp+24976]
	movups	XMMWORD PTR [r8+rbp+24976], xmm0
	mov	ecx, DWORD PTR [rdx+rbp+24992]
	mov	DWORD PTR [r8+rbp+24992], ecx
	cmp	eax, r10d
	jl	SHORT $LL12@work_tree_
$LN7@work_tree_:

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	add	r9d, 4
	cmp	r9d, r13d
	jl	SHORT $LL9@work_tree_
$LN8@work_tree_:

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	rdx, QWORD PTR tv528[rsp]
	mov	r9d, ebx
	add	rdx, rdi
	mov	DWORD PTR [rsp+40], 64			; 00000040H
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	mov	rcx, rsi
	call	kvz_pixels_blit

; 86   :                   width, width, LCU_WIDTH, LCU_WIDTH);
; 87   :   if (from->rec.chroma_format != KVZ_CSP_400) {

	lea	r8, QWORD PTR [r15+rbp]
	cmp	DWORD PTR [r8+12684], 0
	je	$LN2@work_tree_

; 88   :     kvz_pixels_blit(&from->rec.u[chroma_index], &to->rec.u[chroma_index],

	mov	eax, ebx
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	cdq
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	mov	eax, DWORD PTR y_local$[rsp]
	cdq
	mov	r9d, esi
	sub	eax, edx
	sar	eax, 1
	mov	ecx, eax
	mov	eax, r12d
	cdq
	shl	ecx, 5
	sub	eax, edx
	sar	eax, 1
	add	ecx, eax
	movsxd	rcx, ecx
	lea	rbx, QWORD PTR [rdi+rcx]
	lea	rdi, QWORD PTR [rcx+r8]
	mov	r8d, esi
	lea	rcx, QWORD PTR [rdi+10636]
	lea	rdx, QWORD PTR [rbx+10636]
	call	kvz_pixels_blit

; 89   :                     width / 2, width / 2, LCU_WIDTH / 2, LCU_WIDTH / 2);
; 90   :     kvz_pixels_blit(&from->rec.v[chroma_index], &to->rec.v[chroma_index],

	lea	rdx, QWORD PTR [rbx+11660]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	lea	rcx, QWORD PTR [rdi+11660]
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	mov	r9d, esi
	mov	r8d, esi
	call	kvz_pixels_blit
	mov	ebx, DWORD PTR width$1$[rsp]
	mov	rdi, QWORD PTR tv530[rsp]
	mov	rsi, QWORD PTR tv534[rsp]
$LN2@work_tree_:

; 125  :   for (int i = depth + 1; i <= MAX_PU_DEPTH; i++) {

	mov	edx, DWORD PTR y_local$[rsp]
	add	rdi, 30776				; 00007838H
	add	r14, 30776				; 00007838H
	mov	QWORD PTR tv530[rsp], rdi
	sub	QWORD PTR tv527[rsp], 1
	jne	$LL4@work_tree_
	mov	r15, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+88]
	mov	r13, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+144]
$LN3@work_tree_:

; 128  :   }
; 129  : }

	add	rsp, 112				; 00000070H
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
work_tree_copy_down ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
lcu$ = 8
x_px$ = 16
y_px$ = 24
depth$ = 32
tr_depth$ = 40
kvz_lcu_fill_trdepth PROC

; 132  : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	esi, r8d
	mov	rdi, rcx

; 133  :   const int x_local = SUB_SCU(x_px);
; 134  :   const int y_local = SUB_SCU(y_px);
; 135  :   const int width = LCU_WIDTH >> depth;

	mov	ecx, r9d
	mov	ebx, edx
	mov	r10d, 64				; 00000040H
	and	ebx, 63					; 0000003fH
	sar	r10d, cl
	and	esi, 63					; 0000003fH
	xor	r8d, r8d

; 136  : 
; 137  :   for (unsigned y = 0; y < width; y += SCU_WIDTH) {

	test	r10d, r10d
	je	SHORT $LN3@kvz_lcu_fi
	movzx	r11d, BYTE PTR tr_depth$[rsp]
	and	r11b, 7
	npad	5
$LL4@kvz_lcu_fi:
	lea	ecx, DWORD PTR [r8+rsi]

; 138  :     for (unsigned x = 0; x < width; x += SCU_WIDTH) {

	xor	eax, eax
	shr	ecx, 2
	imul	r9d, ecx, 17
	npad	3
$LL7@kvz_lcu_fi:

; 139  :       LCU_GET_CU_AT_PX(lcu, x_local + x, y_local + y)->tr_depth = tr_depth;

	lea	ecx, DWORD PTR [rax+rbx]
	add	eax, 4
	shr	ecx, 2
	add	ecx, 18
	add	ecx, r9d
	lea	rcx, QWORD PTR [rcx+rcx*4]
	and	BYTE PTR [rdi+rcx*4+24977], 248		; 000000f8H
	or	BYTE PTR [rdi+rcx*4+24977], r11b
	cmp	eax, r10d
	jb	SHORT $LL7@kvz_lcu_fi

; 136  : 
; 137  :   for (unsigned y = 0; y < width; y += SCU_WIDTH) {

	add	r8d, 4
	cmp	r8d, r10d
	jb	SHORT $LL4@kvz_lcu_fi
$LN3@kvz_lcu_fi:

; 140  :     }
; 141  :   }
; 142  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
kvz_lcu_fill_trdepth ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
lcu$ = 16
x_local$ = 24
y_local$ = 32
width$ = 40
height$ = 48
cu$ = 56
lcu_fill_cu_info PROC

; 145  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi

; 146  :   // Set mode in every CU covered by part_mode in this depth.
; 147  :   for (int y = y_local; y < y_local + height; y += SCU_WIDTH) {

	mov	esi, DWORD PTR height$[rsp]
	mov	r11d, r8d
	add	esi, r8d
	mov	ebx, edx
	mov	rbp, rcx
	cmp	r8d, esi
	jge	$LN3@lcu_fill_c
	lea	r10d, DWORD PTR [rdx+r9]
	mov	QWORD PTR [rsp+16], rdi
	mov	r9, QWORD PTR cu$[rsp]
$LL4@lcu_fill_c:

; 148  :     for (int x = x_local; x < x_local + width; x += SCU_WIDTH) {

	mov	r8d, ebx
	cmp	ebx, r10d
	jge	$LN2@lcu_fill_c
	mov	eax, r11d
	sar	eax, 2
	imul	edi, eax, 17
	npad	10
$LL7@lcu_fill_c:

; 149  :       cu_info_t *to = LCU_GET_CU_AT_PX(lcu, x, y);

	mov	eax, r8d
	sar	eax, 2
	add	eax, edi
	cdqe
	lea	rcx, QWORD PTR [rax+rax*4]

; 150  :       to->type      = cu->type;

	movzx	eax, BYTE PTR [rbp+rcx*4+25336]
	xor	al, BYTE PTR [r9]
	and	al, 3
	xor	BYTE PTR [rbp+rcx*4+25336], al
	movzx	eax, BYTE PTR [rbp+rcx*4+25336]

; 151  :       to->depth     = cu->depth;

	movzx	edx, al
	xor	dl, BYTE PTR [r9]
	and	dl, 28
	xor	dl, al
	mov	BYTE PTR [rbp+rcx*4+25336], dl

; 152  :       to->part_size = cu->part_size;

	xor	dl, BYTE PTR [r9]
	and	dl, 31
	xor	dl, BYTE PTR [r9]
	mov	BYTE PTR [rbp+rcx*4+25336], dl

; 153  :       to->qp        = cu->qp;

	movzx	eax, BYTE PTR [r9+6]
	mov	BYTE PTR [rbp+rcx*4+25342], al

; 154  : 
; 155  :       if (cu->type == CU_INTRA) {

	movzx	eax, BYTE PTR [r9]
	and	al, 3
	cmp	al, 1
	jne	SHORT $LN8@lcu_fill_c

; 156  :         to->intra.mode        = cu->intra.mode;

	movzx	eax, BYTE PTR [r9+8]
	mov	BYTE PTR [rbp+rcx*4+25344], al

; 157  :         to->intra.mode_chroma = cu->intra.mode_chroma;

	movzx	eax, BYTE PTR [r9+9]
	mov	BYTE PTR [rbp+rcx*4+25345], al

; 158  :       } else {

	jmp	SHORT $LN5@lcu_fill_c
$LN8@lcu_fill_c:

; 159  :         to->skipped   = cu->skipped;

	movzx	eax, BYTE PTR [rbp+rcx*4+25337]
	xor	al, BYTE PTR [r9+1]
	and	al, 8
	xor	BYTE PTR [rbp+rcx*4+25337], al
	movzx	eax, BYTE PTR [rbp+rcx*4+25337]

; 160  :         to->merged    = cu->merged;

	movzx	edx, al
	xor	dl, BYTE PTR [r9+1]
	and	dl, 16
	xor	dl, al
	mov	BYTE PTR [rbp+rcx*4+25337], dl

; 161  :         to->merge_idx = cu->merge_idx;

	xor	dl, BYTE PTR [r9+1]
	and	dl, 31
	xor	dl, BYTE PTR [r9+1]
	mov	BYTE PTR [rbp+rcx*4+25337], dl

; 162  :         to->inter     = cu->inter;

	movsd	xmm0, QWORD PTR [r9+8]
	movsd	QWORD PTR [rbp+rcx*4+25344], xmm0
	mov	eax, DWORD PTR [r9+16]
	mov	DWORD PTR [rbp+rcx*4+25352], eax
$LN5@lcu_fill_c:

; 148  :     for (int x = x_local; x < x_local + width; x += SCU_WIDTH) {

	add	r8d, 4
	cmp	r8d, r10d
	jl	$LL7@lcu_fill_c
$LN2@lcu_fill_c:

; 146  :   // Set mode in every CU covered by part_mode in this depth.
; 147  :   for (int y = y_local; y < y_local + height; y += SCU_WIDTH) {

	add	r11d, 4
	cmp	r11d, esi
	jl	$LL4@lcu_fill_c
	mov	rdi, QWORD PTR [rsp+16]
$LN3@lcu_fill_c:

; 163  :       }
; 164  :     }
; 165  :   }
; 166  : }

	mov	rbx, QWORD PTR [rsp+24]
	mov	rbp, QWORD PTR [rsp+32]
	pop	rsi
	ret	0
lcu_fill_cu_info ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
lcu$ = 96
x_local$ = 104
y_local$ = 112
cu_width$ = 120
lcu_fill_inter PROC

; 169  : {

	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 170  :   const part_mode_t part_mode = LCU_GET_CU_AT_PX(lcu, x_local, y_local)->part_size;

	mov	eax, r8d

; 171  :   const int num_pu = kvz_part_mode_num_parts[part_mode];

	lea	r13, OFFSET FLAT:__ImageBase
	sar	eax, 2
	mov	edi, r9d
	imul	r10d, eax, 17
	mov	r14d, r8d
	mov	eax, edx
	mov	r15d, edx
	sar	eax, 2
	mov	rsi, rcx
	add	eax, r10d
	cdqe
	lea	r10, QWORD PTR [rax+rax*4]
	movzx	eax, BYTE PTR [rcx+r10*4+25336]
	shr	rax, 5

; 172  : 
; 173  :   for (int i = 0; i < num_pu; ++i) {

	movzx	r12d, BYTE PTR kvz_part_mode_num_parts[rax+r13]
	test	r12, r12
	je	$LN3@lcu_fill_i
	mov	QWORD PTR [rsp+96], rbx
	lea	rbx, QWORD PTR [rax*8]
	mov	QWORD PTR [rsp+104], rbp
	xor	ebp, ebp
$LL4@lcu_fill_i:

; 174  :     const int x_pu      = PU_GET_X(part_mode, cu_width, x_local, i);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[rbx+r13]
	imul	eax, edi
	cdq
	and	edx, 3
	lea	r11d, DWORD PTR [rdx+rax]

; 175  :     const int y_pu      = PU_GET_Y(part_mode, cu_width, y_local, i);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[rbx+r13+1]
	imul	eax, edi
	sar	r11d, 2
	add	r11d, r15d
	cdq
	and	edx, 3
	lea	r8d, DWORD PTR [rdx+rax]
	sar	r8d, 2
	add	r8d, r14d

; 176  :     const int width_pu  = PU_GET_W(part_mode, cu_width, i);
; 177  :     const int height_pu = PU_GET_H(part_mode, cu_width, i);
; 178  : 
; 179  :     cu_info_t *pu  = LCU_GET_CU_AT_PX(lcu, x_pu, y_pu);

	mov	eax, r8d
	sar	eax, 2
	imul	ecx, eax, 17
	mov	eax, r11d
	sar	eax, 2
	add	eax, ecx
	cdqe
	lea	r10, QWORD PTR [rax*4+6334]
	add	r10, rax
	movzx	eax, BYTE PTR kvz_part_mode_sizes[rbx+r13+1]

; 180  :     pu->type = CU_INTER;

	and	BYTE PTR [rsi+r10*4], 254		; 000000feH
	lea	r10, QWORD PTR [rsi+r10*4]
	or	BYTE PTR [r10], 2
	imul	eax, edi

; 181  :     lcu_fill_cu_info(lcu, x_pu, y_pu, width_pu, height_pu, pu);

	mov	QWORD PTR [rsp+40], r10
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [rdx+rax]
	movzx	eax, BYTE PTR kvz_part_mode_sizes[rbx+r13]
	imul	eax, edi
	sar	ecx, 2
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, rsi
	cdq
	and	edx, 3
	lea	r9d, DWORD PTR [rdx+rax]
	mov	edx, r11d
	sar	r9d, 2
	call	lcu_fill_cu_info
	inc	rbp
	lea	rbx, QWORD PTR [rbx+2]
	cmp	rbp, r12
	jl	$LL4@lcu_fill_i

; 172  : 
; 173  :   for (int i = 0; i < num_pu; ++i) {

	mov	rbp, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]
$LN3@lcu_fill_i:

; 182  :   }
; 183  : }

	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
lcu_fill_inter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
lcu$ = 32
x_local$ = 40
y_local$ = 48
width$ = 56
cur_cu$ = 64
lcu_fill_cbf PROC

; 186  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r15

; 187  :   const uint32_t tr_split = cur_cu->tr_depth - cur_cu->depth;

	mov	rax, QWORD PTR cur_cu$[rsp]

; 188  :   const uint32_t mask = ~((width >> tr_split)-1);
; 189  : 
; 190  :   // Set coeff flags in every CU covered by part_mode in this depth.
; 191  :   for (uint32_t y = y_local; y < y_local + width; y += SCU_WIDTH) {

	lea	r15d, DWORD PTR [r8+r9]
	mov	rdi, rcx
	mov	r12d, r9d
	mov	ebx, r8d
	mov	esi, edx
	movzx	r10d, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+1]
	shr	r10d, 2
	and	ecx, 7
	and	r10d, 7
	sub	ecx, r10d
	sar	r12d, cl
	neg	r12d
	cmp	r8d, r15d
	jae	$LN3@lcu_fill_c
	mov	QWORD PTR [rsp+32], rbp
	lea	r10d, DWORD PTR [rdx+r9]
	mov	QWORD PTR [rsp+40], r14
$LL4@lcu_fill_c:

; 192  :     for (uint32_t x = x_local; x < x_local + width; x += SCU_WIDTH) {

	mov	eax, esi
	cmp	esi, r10d
	jae	SHORT $LN2@lcu_fill_c
	mov	r11d, r12d
	mov	edx, ebx
	shr	r11d, 2
	shr	edx, 2
	mov	ecx, r11d
	and	ecx, edx
	imul	ebp, ecx, 17
	imul	r14d, edx, 17
	npad	11
$LL7@lcu_fill_c:

; 193  :       // Use TU top-left CU to propagate coeff flags
; 194  :       cu_info_t *cu_from = LCU_GET_CU_AT_PX(lcu, x & mask, y & mask);

	mov	r8d, eax
	shr	r8d, 2
	mov	ecx, r8d
	and	ecx, r11d
	add	ecx, 18
	add	ecx, ebp
	lea	r9, QWORD PTR [rcx+1561]
	lea	r9, QWORD PTR [rcx+r9*4]

; 195  :       cu_info_t *cu_to   = LCU_GET_CU_AT_PX(lcu, x, y);

	lea	ecx, DWORD PTR [r8+18]
	add	ecx, r14d
	lea	r9, QWORD PTR [rdi+r9*4]
	lea	rdx, QWORD PTR [rcx+1561]
	lea	rdx, QWORD PTR [rcx+rdx*4]
	lea	rdx, QWORD PTR [rdi+rdx*4]

; 196  :       if (cu_from != cu_to) {

	cmp	r9, rdx
	je	SHORT $LN5@lcu_fill_c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 568  :   *cbf |= src & (cbf_masks[0] << (NUM_CBF_DEPTHS * plane));

	movzx	ecx, WORD PTR [rdx+4]
	xor	cx, WORD PTR [r9+4]
	and	cx, 31
	xor	WORD PTR [rdx+4], cx
$LN5@lcu_fill_c:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 192  :     for (uint32_t x = x_local; x < x_local + width; x += SCU_WIDTH) {

	add	eax, 4
	cmp	eax, r10d
	jb	SHORT $LL7@lcu_fill_c
$LN2@lcu_fill_c:

; 188  :   const uint32_t mask = ~((width >> tr_split)-1);
; 189  : 
; 190  :   // Set coeff flags in every CU covered by part_mode in this depth.
; 191  :   for (uint32_t y = y_local; y < y_local + width; y += SCU_WIDTH) {

	add	ebx, 4
	cmp	ebx, r15d
	jb	$LL4@lcu_fill_c
	mov	r14, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+32]
$LN3@lcu_fill_c:

; 197  :         // Chroma coeff data is not used, luma is needed for deblocking
; 198  :         cbf_copy(&cu_to->cbf, cu_from->cbf, COLOR_Y);
; 199  :       }
; 200  :     }
; 201  :   }
; 202  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	pop	r15
	pop	r12
	pop	rdi
	ret	0
lcu_fill_cbf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
state$ = 128
work_tree$ = 136
x$ = 144
y$ = 152
depth$ = 160
cu_zero_coeff_cost PROC

; 208  : {

	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	mov	QWORD PTR [rax+16], rdx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	movaps	XMMWORD PTR [rax-72], xmm7

; 209  :   int x_local = SUB_SCU(x);
; 210  :   int y_local = SUB_SCU(y);

	mov	r10d, r9d
	mov	QWORD PTR [rax+8], r12
	and	r10d, 63				; 0000003fH
	mov	QWORD PTR [rax+24], r13
	mov	r11d, r8d

; 211  :   int cu_width = LCU_WIDTH >> depth;

	movsxd	r13, DWORD PTR depth$[rsp]
	mov	rsi, rcx

; 212  :   lcu_t *const lcu = &work_tree[depth];
; 213  : 
; 214  :   const int luma_index = y_local * LCU_WIDTH + x_local;
; 215  :   const int chroma_index = (y_local / 2) * LCU_WIDTH_C + (x_local / 2);

	mov	r15d, r10d
	and	r11d, 63				; 0000003fH
	shl	r10d, 6
	mov	ecx, r13d
	mov	ebx, r9d
	shr	r15d, 1
	mov	eax, r11d
	shl	r15d, 5

; 216  : 
; 217  :   double ssd = 0.0;
; 218  :   ssd += LUMA_MULT * kvz_pixels_calc_ssd(

	mov	r9d, 64					; 00000040H
	shr	eax, 1
	lea	r12d, DWORD PTR [r11+r10]
	mov	edi, r8d
	imul	rbp, r13, 30776				; 00007838H
	mov	r14d, 64				; 00000040H
	mov	r8d, r9d
	add	rbp, rdx
	sar	r14d, cl
	add	r15d, eax
	mov	DWORD PTR [rsp+32], r14d
	lea	rdx, QWORD PTR [rbp+6540]
	lea	rcx, QWORD PTR [rbp+392]
	add	rdx, r12
	add	rcx, r12
	call	QWORD PTR kvz_pixels_calc_ssd
	xorps	xmm7, xmm7
	mov	eax, eax
	cvtsi2sd xmm7, rax
	mulsd	xmm7, QWORD PTR __real@3fe999999999999a

; 219  :     &lcu->ref.y[luma_index], &lcu->rec.y[luma_index],
; 220  :     LCU_WIDTH, LCU_WIDTH, cu_width
; 221  :     );
; 222  :   if (x % 8 == 0 && y % 8 == 0 && state->encoder_control->chroma_format != KVZ_CSP_400) {

	and	edi, -2147483641			; ffffffff80000007H
	jge	SHORT $LN8@cu_zero_co
	dec	edi
	or	edi, -8
	inc	edi
$LN8@cu_zero_co:
	test	edi, edi
	jne	$LN2@cu_zero_co
	and	ebx, -2147483641			; ffffffff80000007H
	jge	SHORT $LN7@cu_zero_co
	dec	ebx
	or	ebx, -8
	inc	ebx
$LN7@cu_zero_co:
	test	ebx, ebx
	jne	$LN2@cu_zero_co
	mov	rax, QWORD PTR [rsi]
	cmp	DWORD PTR [rax+2596], ebx
	je	$LN2@cu_zero_co

; 223  :     ssd += CHROMA_MULT * kvz_pixels_calc_ssd(

	mov	eax, r14d
	mov	ebx, r15d
	cdq
	movaps	XMMWORD PTR [rsp+64], xmm6
	sub	eax, edx
	lea	rcx, QWORD PTR [rbp+4488]
	sar	eax, 1
	lea	rdx, QWORD PTR [rbp+10636]
	mov	r9d, 32					; 00000020H
	mov	DWORD PTR [rsp+32], eax
	add	rdx, rbx
	add	rcx, rbx
	mov	r8d, r9d
	mov	edi, eax
	call	QWORD PTR kvz_pixels_calc_ssd

; 224  :       &lcu->ref.u[chroma_index], &lcu->rec.u[chroma_index],
; 225  :       LCU_WIDTH_C, LCU_WIDTH_C, cu_width / 2
; 226  :       );
; 227  :     ssd += CHROMA_MULT * kvz_pixels_calc_ssd(

	mov	r9d, 32					; 00000020H
	mov	DWORD PTR [rsp+32], edi
	mov	eax, eax
	lea	rdx, QWORD PTR [rbp+11660]
	lea	rcx, QWORD PTR [rbp+5512]
	xorps	xmm6, xmm6
	add	rdx, rbx
	add	rcx, rbx
	mov	r8d, r9d
	cvtsi2sd xmm6, rax
	call	QWORD PTR kvz_pixels_calc_ssd
	mulsd	xmm6, QWORD PTR __real@3ff8000000000000
	xorps	xmm1, xmm1
	mov	eax, eax
	cvtsi2sd xmm1, rax
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	addsd	xmm1, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+64]
	addsd	xmm7, xmm1
$LN2@cu_zero_co:

; 228  :       &lcu->ref.v[chroma_index], &lcu->rec.v[chroma_index],
; 229  :       LCU_WIDTH_C, LCU_WIDTH_C, cu_width / 2
; 230  :       );
; 231  :   }
; 232  :   // Save the pixels at a lower level of the working tree.
; 233  :   copy_cu_pixels(x_local, y_local, cu_width, lcu, &work_tree[depth + 1]);

	lea	edx, DWORD PTR [r13+1]

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	DWORD PTR [rsp+40], 64			; 00000040H

; 228  :       &lcu->ref.v[chroma_index], &lcu->rec.v[chroma_index],
; 229  :       LCU_WIDTH_C, LCU_WIDTH_C, cu_width / 2
; 230  :       );
; 231  :   }
; 232  :   // Save the pixels at a lower level of the working tree.
; 233  :   copy_cu_pixels(x_local, y_local, cu_width, lcu, &work_tree[depth + 1]);

	movsxd	r8, edx

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	lea	rcx, QWORD PTR [rbp+6540]

; 228  :       &lcu->ref.v[chroma_index], &lcu->rec.v[chroma_index],
; 229  :       LCU_WIDTH_C, LCU_WIDTH_C, cu_width / 2
; 230  :       );
; 231  :   }
; 232  :   // Save the pixels at a lower level of the working tree.
; 233  :   copy_cu_pixels(x_local, y_local, cu_width, lcu, &work_tree[depth + 1]);

	imul	rsi, r8, 30776				; 00007838H

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	r9d, r14d
	mov	DWORD PTR [rsp+32], 64			; 00000040H

; 228  :       &lcu->ref.v[chroma_index], &lcu->rec.v[chroma_index],
; 229  :       LCU_WIDTH_C, LCU_WIDTH_C, cu_width / 2
; 230  :       );
; 231  :   }
; 232  :   // Save the pixels at a lower level of the working tree.
; 233  :   copy_cu_pixels(x_local, y_local, cu_width, lcu, &work_tree[depth + 1]);

	add	rsi, QWORD PTR work_tree$[rsp]

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	r8d, r14d
	add	rcx, r12
	lea	rdx, QWORD PTR [rsi+6540]
	add	rdx, r12
	call	kvz_pixels_blit

; 86   :                   width, width, LCU_WIDTH, LCU_WIDTH);
; 87   :   if (from->rec.chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [rbp+12684], 0
	mov	r13, QWORD PTR [rsp+144]
	mov	r12, QWORD PTR [rsp+128]
	je	SHORT $LN9@cu_zero_co

; 88   :     kvz_pixels_blit(&from->rec.u[chroma_index], &to->rec.u[chroma_index],

	mov	eax, r14d
	mov	ebx, r15d
	cdq
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	sub	eax, edx
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	sar	eax, 1
	lea	rdx, QWORD PTR [rsi+10636]
	lea	rcx, QWORD PTR [rbp+10636]
	mov	r9d, eax
	mov	r8d, eax
	add	rdx, rbx
	add	rcx, rbx
	mov	edi, eax
	call	kvz_pixels_blit

; 89   :                     width / 2, width / 2, LCU_WIDTH / 2, LCU_WIDTH / 2);
; 90   :     kvz_pixels_blit(&from->rec.v[chroma_index], &to->rec.v[chroma_index],

	lea	rdx, QWORD PTR [rsi+11660]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	lea	rcx, QWORD PTR [rbp+11660]
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	add	rdx, rbx
	add	rcx, rbx
	mov	r9d, edi
	mov	r8d, edi
	call	kvz_pixels_blit
$LN9@cu_zero_co:

; 234  : 
; 235  :   return ssd;
; 236  : }

	mov	rbx, QWORD PTR [rsp+152]
	movaps	xmm0, xmm7
	movaps	xmm7, XMMWORD PTR [rsp+48]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
cu_zero_coeff_cost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
tv1054 = 48
state$ = 144
width$1$ = 152
x_px$ = 152
y_px$ = 160
depth$ = 168
pred_cu$ = 176
lcu$ = 184
kvz_cu_rd_cost_luma PROC

; 252  : {

$LN129:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H

; 253  :   const int width = LCU_WIDTH >> depth;
; 254  : 
; 255  :   // cur_cu is used for TU parameters.
; 256  :   cu_info_t *const tr_cu = LCU_GET_CU_AT_PX(lcu, x_px, y_px);

	mov	r12, QWORD PTR lcu$[rsp]
	mov	r14d, edx
	mov	eax, r8d
	movsxd	rdi, r9d
	sar	eax, 2
	mov	r13, rcx
	imul	edx, eax, 17
	mov	ebx, 64					; 00000040H
	mov	eax, r14d
	movaps	XMMWORD PTR [rsp+64], xmm7
	sar	eax, 2
	mov	ecx, edi
	sar	ebx, cl
	mov	ebp, r8d
	mov	DWORD PTR width$1$[rsp], ebx
	xorps	xmm7, xmm7
	add	eax, edx
	cdqe
	add	rax, 18
	lea	rsi, QWORD PTR [rax+rax*4]
	mov	QWORD PTR tv1054[rsp], rsi

; 257  : 
; 258  :   double coeff_bits = 0;
; 259  :   double tr_tree_bits = 0;
; 260  : 
; 261  :   // Check that lcu is not in 
; 262  :   assert(x_px >= 0 && x_px < LCU_WIDTH);

	cmp	r14d, 63				; 0000003fH
	jbe	SHORT $LN9@kvz_cu_rd_
	mov	r8d, 262				; 00000106H
	lea	rdx, OFFSET FLAT:$SG4294944038
	lea	rcx, OFFSET FLAT:$SG4294944037
	call	QWORD PTR __imp__wassert
$LN9@kvz_cu_rd_:

; 263  :   assert(y_px >= 0 && y_px < LCU_WIDTH);

	cmp	ebp, 63					; 0000003fH
	jbe	SHORT $LN11@kvz_cu_rd_
	mov	r8d, 263				; 00000107H
	lea	rdx, OFFSET FLAT:$SG4294944036
	lea	rcx, OFFSET FLAT:$SG4294944035
	call	QWORD PTR __imp__wassert
$LN11@kvz_cu_rd_:

; 264  : 
; 265  :   const uint8_t tr_depth = tr_cu->tr_depth - depth;

	movzx	r9d, BYTE PTR [r12+rsi*4+24977]

; 266  : 
; 267  :   // Add transform_tree split_transform_flag bit cost.
; 268  :   bool intra_split_flag = pred_cu->type == CU_INTRA && pred_cu->part_size == SIZE_NxN && depth == 3;

	xor	esi, esi
	mov	r15, QWORD PTR pred_cu$[rsp]
	and	r9b, 7
	sub	r9b, dil
	movzx	r8d, BYTE PTR [r15]
	movzx	r10d, r8b
	and	r10b, 3
	cmp	r10b, 1
	jne	SHORT $LN12@kvz_cu_rd_
	movzx	eax, r8b
	and	al, 224					; 000000e0H
	cmp	al, 96					; 00000060H
	jne	SHORT $LN12@kvz_cu_rd_
	lea	ecx, QWORD PTR [rsi+1]
	cmp	edi, 3
	je	SHORT $LN13@kvz_cu_rd_
$LN12@kvz_cu_rd_:
	mov	ecx, esi
$LN13@kvz_cu_rd_:

; 269  :   if (width <= TR_MAX_WIDTH
; 270  :       && width > TR_MIN_WIDTH
; 271  :       && !intra_split_flag)

	lea	eax, DWORD PTR [rbx-5]
	lea	r11, OFFSET FLAT:__ImageBase
	cmp	eax, 27
	ja	SHORT $LN2@kvz_cu_rd_
	test	ecx, ecx
	jne	SHORT $LN2@kvz_cu_rd_

; 272  :   {
; 273  :     const cabac_ctx_t *ctx = &(state->cabac.ctx.trans_subdiv_model[5 - (6 - depth)]);
; 274  :     tr_tree_bits += CTX_ENTROPY_FBITS(ctx, tr_depth > 0);

	movzx	edx, BYTE PTR [rdi+r13+180]
	test	r9b, r9b
	mov	rcx, rsi
	setne	cl
	xor	rdx, rcx
	movss	xmm7, DWORD PTR kvz_f_entropy_bits[r11+rdx*4]
	cvtps2pd xmm7, xmm7
$LN2@kvz_cu_rd_:

; 275  :   }
; 276  : 
; 277  :   if (tr_depth > 0) {

	test	r9b, r9b
	je	$LN3@kvz_cu_rd_

; 278  :     int offset = width / 2;

	mov	eax, ebx

; 279  :     double sum = 0;
; 280  : 
; 281  :     sum += kvz_cu_rd_cost_luma(state, x_px, y_px, depth + 1, pred_cu, lcu);

	mov	QWORD PTR [rsp+40], r12
	cdq
	movaps	XMMWORD PTR [rsp+80], xmm6
	sub	eax, edx
	mov	QWORD PTR [rsp+32], r15
	sar	eax, 1
	lea	esi, DWORD PTR [rdi+1]
	mov	r9d, esi
	mov	r8d, ebp
	mov	edx, r14d
	mov	rcx, r13
	mov	ebx, eax
	call	kvz_cu_rd_cost_luma

; 282  :     sum += kvz_cu_rd_cost_luma(state, x_px + offset, y_px, depth + 1, pred_cu, lcu);

	lea	edi, DWORD PTR [rbx+r14]
	mov	QWORD PTR [rsp+40], r12
	mov	edx, edi
	mov	QWORD PTR [rsp+32], r15
	mov	r9d, esi
	mov	r8d, ebp
	mov	rcx, r13
	movaps	xmm6, xmm0
	call	kvz_cu_rd_cost_luma

; 283  :     sum += kvz_cu_rd_cost_luma(state, x_px, y_px + offset, depth + 1, pred_cu, lcu);

	add	ebx, ebp
	mov	QWORD PTR [rsp+40], r12
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], r15
	mov	r9d, esi
	addsd	xmm6, xmm0
	mov	edx, r14d
	mov	rcx, r13
	call	kvz_cu_rd_cost_luma

; 284  :     sum += kvz_cu_rd_cost_luma(state, x_px + offset, y_px + offset, depth + 1, pred_cu, lcu);

	mov	r9d, esi
	mov	QWORD PTR [rsp+40], r12
	mov	r8d, ebx
	mov	QWORD PTR [rsp+32], r15
	mov	edx, edi
	addsd	xmm6, xmm0
	mov	rcx, r13
	call	kvz_cu_rd_cost_luma

; 285  : 
; 286  :     return sum + tr_tree_bits * state->lambda;

	mulsd	xmm7, QWORD PTR [r13+368]
	addsd	xmm6, xmm0
	addsd	xmm7, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm0, xmm7
	jmp	$LN1@kvz_cu_rd_
$LN3@kvz_cu_rd_:

; 292  :       cbf_is_set(tr_cu->cbf, depth, COLOR_U) ||

	mov	rdx, rdi
	cmp	r10b, 1
	je	SHORT $LN5@kvz_cu_rd_
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[r11+rdi*2]
	mov	ecx, eax
	shl	ecx, 5
	or	ecx, eax
	mov	rax, QWORD PTR tv1054[rsp]
	shl	ecx, 5
	movzx	eax, WORD PTR [r12+rax*4+24980]
	test	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 292  :       cbf_is_set(tr_cu->cbf, depth, COLOR_U) ||

	je	SHORT $LN4@kvz_cu_rd_
$LN5@kvz_cu_rd_:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[r11+rdx*2]
	mov	rcx, rsi
	test	ax, WORD PTR [r15+4]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 296  :     tr_tree_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_Y));

	movzx	eax, BYTE PTR [r13+185]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	setne	cl
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 296  :     tr_tree_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_Y));

	xor	rcx, rax
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[r11+rcx*4]
	cvtps2pd xmm0, xmm0
	addsd	xmm7, xmm0
$LN4@kvz_cu_rd_:

; 297  :   }
; 298  : 
; 299  :   // SSD between reconstruction and original
; 300  :   int ssd = 0;
; 301  :   if (!state->encoder_control->cfg.lossless) {

	mov	rax, QWORD PTR [r13]
	cmp	DWORD PTR [rax+2392], esi
	jne	SHORT $LN6@kvz_cu_rd_

; 302  :     int index = y_px * LCU_WIDTH + x_px;

	mov	eax, ebp

; 303  :     ssd = kvz_pixels_calc_ssd(&lcu->ref.y[index], &lcu->rec.y[index],

	mov	DWORD PTR [rsp+32], ebx
	shl	eax, 6
	lea	rdx, QWORD PTR [r12+6540]
	add	eax, r14d
	lea	rcx, QWORD PTR [r12+392]
	cdqe
	mov	r9d, 64					; 00000040H
	add	rdx, rax
	add	rcx, rax
	mov	r8d, r9d
	call	QWORD PTR kvz_pixels_calc_ssd
	movzx	r8d, BYTE PTR [r15]
	mov	esi, eax
$LN6@kvz_cu_rd_:

; 304  :                                         LCU_WIDTH,          LCU_WIDTH,
; 305  :                                         width);
; 306  :   }
; 307  : 
; 308  :   {
; 309  :     int8_t luma_scan_mode = kvz_get_scan_order(pred_cu->type, pred_cu->intra.mode, depth);

	movzx	edx, BYTE PTR [r15+8]
	and	r8b, 3
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1585 :   if (cu_type == CU_INTRA && depth >= 3) {

	cmp	r8b, 1
	jne	SHORT $LN104@kvz_cu_rd_
	cmp	edi, 3
	jl	SHORT $LN104@kvz_cu_rd_

; 1586 :     if (intra_mode >= 6 && intra_mode <= 14) {

	lea	ecx, DWORD PTR [rdx-6]
	cmp	cl, 8
	ja	SHORT $LN102@kvz_cu_rd_

; 1587 :       return SCAN_VER;

	mov	bl, 2
	jmp	SHORT $LN100@kvz_cu_rd_
$LN102@kvz_cu_rd_:

; 1588 :     } else if (intra_mode >= 22 && intra_mode <= 30) {

	sub	dl, 22
	cmp	dl, 8
	ja	SHORT $LN104@kvz_cu_rd_

; 1589 :       return SCAN_HOR;

	mov	bl, 1
	jmp	SHORT $LN100@kvz_cu_rd_
$LN104@kvz_cu_rd_:

; 1590 :     }
; 1591 :   }
; 1592 : 
; 1593 :   return SCAN_DIAG;

	xor	bl, bl
$LN100@kvz_cu_rd_:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	test	r14b, 3
	jne	SHORT $LN117@kvz_cu_rd_
	cmp	r14d, 64				; 00000040H
	jb	SHORT $LN118@kvz_cu_rd_
$LN117@kvz_cu_rd_:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944042
	lea	rcx, OFFSET FLAT:$SG4294944041
	call	QWORD PTR __imp__wassert
$LN118@kvz_cu_rd_:

; 389  :   assert(y % 4 == 0 && y < width);

	test	bpl, 3
	jne	SHORT $LN119@kvz_cu_rd_
	cmp	ebp, 64					; 00000040H
	jb	SHORT $LN120@kvz_cu_rd_
$LN119@kvz_cu_rd_:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944040
	lea	rcx, OFFSET FLAT:$SG4294944039
	call	QWORD PTR __imp__wassert
$LN120@kvz_cu_rd_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 312  :     coeff_bits += kvz_get_coeff_cost(state, coeffs, width, 0, luma_scan_mode);

	mov	r8d, DWORD PTR width$1$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 396  :       result += y / 32 * (64*32);

	mov	ecx, ebp
	shr	ecx, 5
	mov	eax, r14d
	shr	eax, 5

; 397  :       x %= 32;

	and	r14d, 31

; 398  :       y %= 32;

	and	ebp, 31
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 312  :     coeff_bits += kvz_get_coeff_cost(state, coeffs, width, 0, luma_scan_mode);

	mov	BYTE PTR [rsp+32], bl
	xor	r9d, r9d
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 396  :       result += y / 32 * (64*32);

	lea	edx, DWORD PTR [rax+rcx*2]

; 399  :       // fallthrough
; 400  :     case 32:
; 401  :       result += x / 16 * (16*16);
; 402  :       result += y / 16 * (32*16);

	mov	ecx, ebp
	shr	ecx, 4
	mov	eax, r14d
	shr	eax, 4

; 403  :       x %= 16;

	and	r14d, 15
	shl	edx, 10

; 404  :       y %= 16;

	and	ebp, 15
	lea	ecx, DWORD PTR [rax+rcx*2]

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);

	mov	eax, r14d
	shl	ecx, 8

; 408  :       result += y / 8 * (16*8);
; 409  :       x %= 8;

	and	r14d, 7
	add	edx, ecx
	shr	eax, 3
	mov	ecx, ebp

; 410  :       y %= 8;
; 411  :       // fallthrough
; 412  :     case 8:
; 413  :       result += x / 4 * (4*4);

	shr	r14d, 2
	shr	ecx, 3
	and	ebp, 7

; 414  :       result += y / 4 * (8*4);

	shr	ebp, 2
	lea	ecx, DWORD PTR [rax+rcx*2]
	shl	ecx, 6
	lea	eax, DWORD PTR [r14+rbp*2]
	add	edx, ecx
	shl	eax, 4
	add	eax, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 312  :     coeff_bits += kvz_get_coeff_cost(state, coeffs, width, 0, luma_scan_mode);

	mov	rcx, r13
	add	rax, 6344				; 000018c8H
	lea	rdx, QWORD PTR [r12+rax*2]
	call	kvz_get_coeff_cost
	xorps	xmm0, xmm0
	mov	eax, eax
	movd	xmm1, esi

; 313  :   }
; 314  : 
; 315  :   double bits = tr_tree_bits + coeff_bits;
; 316  :   return (double)ssd * LUMA_MULT + bits * state->lambda;

	cvtdq2pd xmm1, xmm1
	cvtsi2sd xmm0, rax
	mulsd	xmm1, QWORD PTR __real@3fe999999999999a
	addsd	xmm0, xmm7
	mulsd	xmm0, QWORD PTR [r13+368]
	addsd	xmm0, xmm1
$LN1@kvz_cu_rd_:

; 317  : }

	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
kvz_cu_rd_cost_luma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
tv65 = 48
tv1092 = 56
state$ = 160
x_px$ = 168
y_px$ = 176
depth$ = 184
pred_cu$ = 192
tv952 = 200
lcu$ = 200
kvz_cu_rd_cost_chroma PROC

; 324  : {

$LN154:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 96					; 00000060H

; 325  :   const vector2d_t lcu_px = { x_px / 2, y_px / 2 };

	mov	eax, edx
	movsxd	rsi, r9d
	mov	ebx, edx
	movaps	XMMWORD PTR [rsp+64], xmm7
	cdq
	mov	edi, r8d
	sub	eax, edx

; 326  :   const int width = (depth <= MAX_DEPTH) ? LCU_WIDTH >> (depth + 1) : LCU_WIDTH >> depth;

	mov	ebp, 64					; 00000040H
	sar	eax, 1
	lea	ecx, DWORD PTR [rsi+1]
	mov	r15d, eax
	mov	eax, r8d
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r12d, eax
	cmp	esi, 3
	jle	SHORT $LN152@kvz_cu_rd_
	mov	ecx, esi
$LN152@kvz_cu_rd_:

; 327  :   cu_info_t *const tr_cu = LCU_GET_CU_AT_PX(lcu, x_px, y_px);

	mov	r13, QWORD PTR lcu$[rsp]
	mov	eax, edi
	sar	eax, 2
	xorps	xmm7, xmm7
	sar	ebp, cl
	imul	ecx, eax, 17
	mov	eax, ebx
	sar	eax, 2
	add	eax, ecx
	cdqe
	add	rax, 18
	lea	rax, QWORD PTR [rax+rax*4]
	mov	QWORD PTR tv1092[rsp], rax

; 328  : 
; 329  :   double tr_tree_bits = 0;
; 330  :   double coeff_bits = 0;
; 331  : 
; 332  :   assert(x_px >= 0 && x_px < LCU_WIDTH);

	cmp	ebx, 63					; 0000003fH
	jbe	SHORT $LN15@kvz_cu_rd_
	mov	r8d, 332				; 0000014cH
	lea	rdx, OFFSET FLAT:$SG4294944034
	lea	rcx, OFFSET FLAT:$SG4294944033
	call	QWORD PTR __imp__wassert
$LN15@kvz_cu_rd_:

; 333  :   assert(y_px >= 0 && y_px < LCU_WIDTH);

	cmp	edi, 63					; 0000003fH
	jbe	SHORT $LN17@kvz_cu_rd_
	mov	r8d, 333				; 0000014dH
	lea	rdx, OFFSET FLAT:$SG4294944032
	lea	rcx, OFFSET FLAT:$SG4294944031
	call	QWORD PTR __imp__wassert
$LN17@kvz_cu_rd_:

; 334  : 
; 335  :   if (x_px % 8 != 0 || y_px % 8 != 0) {

	mov	eax, ebx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN148@kvz_cu_rd_
	dec	eax
	or	eax, -8
	inc	eax
$LN148@kvz_cu_rd_:
	test	eax, eax
	jne	$LN3@kvz_cu_rd_
	mov	eax, edi
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN147@kvz_cu_rd_
	dec	eax
	or	eax, -8
	inc	eax
$LN147@kvz_cu_rd_:
	test	eax, eax
	jne	$LN3@kvz_cu_rd_

; 336  :     // For MAX_PU_DEPTH calculate chroma for previous depth for the first
; 337  :     // block and return 0 cost for all others.
; 338  :     return 0;
; 339  :   }
; 340  : 
; 341  :   if (depth < MAX_PU_DEPTH) {

	xor	r10d, r10d
	mov	QWORD PTR [rsp+176], r14
	mov	r14, QWORD PTR pred_cu$[rsp]
	mov	QWORD PTR tv952[rsp], r10
	cmp	esi, 4
	jge	$LN150@kvz_cu_rd_

; 342  :     const int tr_depth = depth - pred_cu->depth;

	movzx	eax, BYTE PTR [r14]
	lea	rcx, OFFSET FLAT:__ImageBase
	shr	eax, 2
	mov	r9d, esi
	and	eax, 7

; 344  :     if (tr_depth == 0 || cbf_is_set(pred_cu->cbf, depth - 1, COLOR_U)) {

	mov	r8, rsi
	sub	r9d, eax
	movsxd	r11, r9d
	mov	QWORD PTR tv65[rsp], r11
	je	SHORT $LN139@kvz_cu_rd_
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[rcx+rsi*2-2]
	movzx	edx, WORD PTR [r14+4]
	shl	eax, 5
	test	eax, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 344  :     if (tr_depth == 0 || cbf_is_set(pred_cu->cbf, depth - 1, COLOR_U)) {

	jne	SHORT $LN139@kvz_cu_rd_
	mov	r11, rsi
	jmp	SHORT $LN143@kvz_cu_rd_
$LN139@kvz_cu_rd_:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[rcx+r8*2]
	mov	rcx, r10
	movzx	edx, WORD PTR [r14+4]
	shl	eax, 5
	test	eax, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 345  :       tr_tree_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_U));

	mov	rax, QWORD PTR state$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	setne	cl
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 345  :       tr_tree_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_U));

	movzx	eax, BYTE PTR [r11+rax+188]

; 347  :     if (tr_depth == 0 || cbf_is_set(pred_cu->cbf, depth - 1, COLOR_V)) {

	mov	r11, r8
	xor	rcx, rax
	lea	rax, OFFSET FLAT:__ImageBase
	movss	xmm7, DWORD PTR kvz_f_entropy_bits[rax+rcx*4]
	cvtps2pd xmm7, xmm7
	test	r9d, r9d
	je	SHORT $LN8@kvz_cu_rd_
	lea	rcx, OFFSET FLAT:__ImageBase
$LN143@kvz_cu_rd_:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	ecx, WORD PTR cbf_masks[rcx+r8*2-2]
	shl	ecx, 10
	movzx	eax, dx
	test	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 347  :     if (tr_depth == 0 || cbf_is_set(pred_cu->cbf, depth - 1, COLOR_V)) {

	je	SHORT $LN150@kvz_cu_rd_
$LN8@kvz_cu_rd_:

; 348  :       tr_tree_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_V));

	movzx	eax, dx
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	r8, OFFSET FLAT:__ImageBase
	movzx	ecx, WORD PTR cbf_masks[r8+r11*2]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 348  :       tr_tree_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_V));

	mov	rdx, QWORD PTR state$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	shl	ecx, 10
	test	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 348  :       tr_tree_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_V));

	mov	rax, QWORD PTR tv65[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	rcx, r10
	setne	cl
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 348  :       tr_tree_bits += CTX_ENTROPY_FBITS(ctx, cbf_is_set(pred_cu->cbf, depth, COLOR_V));

	movzx	eax, BYTE PTR [rax+rdx+188]
	xor	rcx, rax
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[r8+rcx*4]
	cvtps2pd xmm0, xmm0
	addsd	xmm7, xmm0
	jmp	SHORT $LN7@kvz_cu_rd_
$LN150@kvz_cu_rd_:

; 349  :     }
; 350  :   }
; 351  : 
; 352  :   if (tr_cu->tr_depth > depth) {

	mov	rdx, QWORD PTR state$[rsp]
$LN7@kvz_cu_rd_:
	mov	rax, QWORD PTR tv1092[rsp]
	movzx	eax, BYTE PTR [r13+rax*4+24977]
	and	eax, 7
	cmp	eax, esi
	jle	$LN9@kvz_cu_rd_

; 353  :     int offset = LCU_WIDTH >> (depth + 1);

	lea	ebp, DWORD PTR [rsi+1]

; 354  :     int sum = 0;
; 355  : 
; 356  :     sum += kvz_cu_rd_cost_chroma(state, x_px, y_px, depth + 1, pred_cu, lcu);

	mov	QWORD PTR [rsp+40], r13
	mov	ecx, ebp
	mov	QWORD PTR [rsp+32], r14
	mov	r12d, 64				; 00000040H
	mov	r9d, ebp
	sar	r12d, cl
	mov	r8d, edi
	mov	rcx, QWORD PTR state$[rsp]
	mov	edx, ebx
	call	kvz_cu_rd_cost_chroma

; 357  :     sum += kvz_cu_rd_cost_chroma(state, x_px + offset, y_px, depth + 1, pred_cu, lcu);

	mov	r15d, DWORD PTR x_px$[rsp]
	mov	r9d, ebp
	mov	rcx, QWORD PTR state$[rsp]
	mov	r8d, edi
	mov	QWORD PTR [rsp+40], r13
	cvttsd2si ebx, xmm0
	lea	esi, DWORD PTR [r12+r15]
	mov	QWORD PTR [rsp+32], r14
	mov	edx, esi
	call	kvz_cu_rd_cost_chroma

; 358  :     sum += kvz_cu_rd_cost_chroma(state, x_px, y_px + offset, depth + 1, pred_cu, lcu);

	mov	edx, r15d
	mov	r15, QWORD PTR state$[rsp]
	add	edi, r12d
	mov	QWORD PTR [rsp+40], r13
	mov	r9d, ebp
	mov	r8d, edi
	movd	xmm1, ebx
	mov	rcx, r15
	cvtdq2pd xmm1, xmm1
	mov	QWORD PTR [rsp+32], r14
	addsd	xmm0, xmm1
	cvttsd2si ebx, xmm0
	call	kvz_cu_rd_cost_chroma

; 359  :     sum += kvz_cu_rd_cost_chroma(state, x_px + offset, y_px + offset, depth + 1, pred_cu, lcu);

	mov	r9d, ebp
	mov	QWORD PTR [rsp+40], r13
	mov	r8d, edi
	mov	edx, esi
	mov	rcx, r15
	mov	QWORD PTR [rsp+32], r14
	movd	xmm1, ebx
	cvtdq2pd xmm1, xmm1
	addsd	xmm0, xmm1
	cvttsd2si ebx, xmm0
	call	kvz_cu_rd_cost_chroma

; 360  : 
; 361  :     return sum + tr_tree_bits * state->lambda;

	mulsd	xmm7, QWORD PTR [r15+368]
	movd	xmm1, ebx
	cvtdq2pd xmm1, xmm1
	addsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	addsd	xmm7, xmm0
	movaps	xmm0, xmm7
$LN151@kvz_cu_rd_:
	mov	r14, QWORD PTR [rsp+176]
$LN1@kvz_cu_rd_:

; 387  : }

	movaps	xmm7, XMMWORD PTR [rsp+64]
	add	rsp, 96					; 00000060H
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN9@kvz_cu_rd_:

; 362  :   }
; 363  : 
; 364  :   // Chroma SSD
; 365  :   int ssd = 0;
; 366  :   if (!state->encoder_control->cfg.lossless) {

	mov	rax, QWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+80], xmm6
	cmp	DWORD PTR [rax+2392], r10d
	jne	SHORT $LN10@kvz_cu_rd_

; 367  :     int index = lcu_px.y * LCU_WIDTH_C + lcu_px.x;

	mov	eax, r12d

; 368  :     int ssd_u = kvz_pixels_calc_ssd(&lcu->ref.u[index], &lcu->rec.u[index],

	mov	DWORD PTR [rsp+32], ebp
	shl	eax, 5
	lea	rdx, QWORD PTR [r13+10636]
	add	eax, r15d
	lea	rcx, QWORD PTR [r13+4488]
	movsxd	rdi, eax
	mov	r9d, 32					; 00000020H
	add	rdx, rdi
	add	rcx, rdi
	mov	r8d, r9d
	call	QWORD PTR kvz_pixels_calc_ssd

; 369  :                                     LCU_WIDTH_C,         LCU_WIDTH_C,
; 370  :                                     width);
; 371  :     int ssd_v = kvz_pixels_calc_ssd(&lcu->ref.v[index], &lcu->rec.v[index],

	mov	r9d, 32					; 00000020H
	mov	DWORD PTR [rsp+32], ebp
	lea	rdx, QWORD PTR [r13+11660]
	mov	r8d, r9d
	lea	rcx, QWORD PTR [r13+5512]
	add	rdx, rdi
	add	rcx, rdi
	mov	ebx, eax
	call	QWORD PTR kvz_pixels_calc_ssd

; 372  :                                     LCU_WIDTH_C,        LCU_WIDTH_C,
; 373  :                                     width);
; 374  :     ssd = ssd_u + ssd_v;

	add	eax, ebx
	mov	DWORD PTR tv952[rsp], eax
$LN10@kvz_cu_rd_:

; 375  :   }
; 376  : 
; 377  :   {
; 378  :     int8_t scan_order = kvz_get_scan_order(pred_cu->type, pred_cu->intra.mode_chroma, depth);

	movzx	eax, BYTE PTR [r14]
	movzx	ecx, BYTE PTR [r14+9]
	and	al, 3
; File F:\open_codec_learn_2021\kvazaar-master\src\encoderstate.c

; 1585 :   if (cu_type == CU_INTRA && depth >= 3) {

	cmp	al, 1
	jne	SHORT $LN122@kvz_cu_rd_
	cmp	esi, 3
	jl	SHORT $LN122@kvz_cu_rd_

; 1586 :     if (intra_mode >= 6 && intra_mode <= 14) {

	lea	eax, DWORD PTR [rcx-6]
	cmp	al, 8
	ja	SHORT $LN120@kvz_cu_rd_

; 1587 :       return SCAN_VER;

	mov	dil, 2
	jmp	SHORT $LN118@kvz_cu_rd_
$LN120@kvz_cu_rd_:

; 1588 :     } else if (intra_mode >= 22 && intra_mode <= 30) {

	sub	cl, 22
	cmp	cl, 8
	ja	SHORT $LN122@kvz_cu_rd_

; 1589 :       return SCAN_HOR;

	mov	dil, 1
	jmp	SHORT $LN118@kvz_cu_rd_
$LN122@kvz_cu_rd_:

; 1590 :     }
; 1591 :   }
; 1592 : 
; 1593 :   return SCAN_DIAG;

	xor	dil, dil
$LN118@kvz_cu_rd_:
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 388  :   assert(x % 4 == 0 && x < width);

	test	r15b, 3
	jne	SHORT $LN135@kvz_cu_rd_
	cmp	r15d, 32				; 00000020H
	jb	SHORT $LN136@kvz_cu_rd_
$LN135@kvz_cu_rd_:
	mov	r8d, 388				; 00000184H
	lea	rdx, OFFSET FLAT:$SG4294944042
	lea	rcx, OFFSET FLAT:$SG4294944041
	call	QWORD PTR __imp__wassert
$LN136@kvz_cu_rd_:

; 389  :   assert(y % 4 == 0 && y < width);

	test	r12b, 3
	jne	SHORT $LN137@kvz_cu_rd_
	cmp	r12d, 32				; 00000020H
	jb	SHORT $LN138@kvz_cu_rd_
$LN137@kvz_cu_rd_:
	mov	r8d, 389				; 00000185H
	lea	rdx, OFFSET FLAT:$SG4294944040
	lea	rcx, OFFSET FLAT:$SG4294944039
	call	QWORD PTR __imp__wassert
$LN138@kvz_cu_rd_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 381  :     coeff_bits += kvz_get_coeff_cost(state, &lcu->coeff.u[index], width, 2, scan_order);

	mov	rsi, QWORD PTR state$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 402  :       result += y / 16 * (32*16);

	mov	ecx, r12d
	shr	ecx, 4
	mov	eax, r15d
	shr	eax, 4

; 403  :       x %= 16;

	and	r15d, 15

; 404  :       y %= 16;

	and	r12d, 15
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 381  :     coeff_bits += kvz_get_coeff_cost(state, &lcu->coeff.u[index], width, 2, scan_order);

	mov	BYTE PTR [rsp+32], dil
	mov	r9d, 2
	mov	r8d, ebp
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 402  :       result += y / 16 * (32*16);

	lea	edx, DWORD PTR [rax+rcx*2]

; 405  :       // fallthrough
; 406  :     case 16:
; 407  :       result += x / 8 * ( 8*8);
; 408  :       result += y / 8 * (16*8);

	mov	ecx, r12d
	shl	edx, 8
	mov	eax, r15d
	shr	ecx, 3

; 409  :       x %= 8;

	and	r15d, 7
	shr	eax, 3

; 410  :       y %= 8;

	and	r12d, 7

; 414  :       result += y / 4 * (8*4);

	shr	r12d, 2
	shr	r15d, 2
	lea	ecx, DWORD PTR [rax+rcx*2]
	shl	ecx, 6
	add	edx, ecx
	lea	eax, DWORD PTR [r15+r12*2]
	shl	eax, 4
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 381  :     coeff_bits += kvz_get_coeff_cost(state, &lcu->coeff.u[index], width, 2, scan_order);

	mov	rcx, rsi
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 414  :       result += y / 4 * (8*4);

	add	edx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 381  :     coeff_bits += kvz_get_coeff_cost(state, &lcu->coeff.u[index], width, 2, scan_order);

	movsxd	rbx, edx
	lea	rdx, QWORD PTR [r13+20880]
	lea	rdx, QWORD PTR [rdx+rbx*2]
	call	kvz_get_coeff_cost
	mov	eax, eax

; 382  :     coeff_bits += kvz_get_coeff_cost(state, &lcu->coeff.v[index], width, 2, scan_order);

	lea	rdx, QWORD PTR [r13+22928]
	xorps	xmm6, xmm6
	mov	BYTE PTR [rsp+32], dil
	lea	rdx, QWORD PTR [rdx+rbx*2]
	mov	r9d, 2
	mov	r8d, ebp
	mov	rcx, rsi
	cvtsi2sd xmm6, rax
	call	kvz_get_coeff_cost
	mov	eax, eax
	movd	xmm1, DWORD PTR tv952[rsp]
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax

; 383  :   }
; 384  : 
; 385  :   double bits = tr_tree_bits + coeff_bits;
; 386  :   return (double)ssd * CHROMA_MULT + bits * state->lambda;

	cvtdq2pd xmm1, xmm1
	addsd	xmm0, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+80]
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	addsd	xmm0, xmm7
	mulsd	xmm0, QWORD PTR [rsi+368]
	addsd	xmm0, xmm1
	jmp	$LN151@kvz_cu_rd_
$LN3@kvz_cu_rd_:
	xorps	xmm0, xmm0
	jmp	$LN1@kvz_cu_rd_
kvz_cu_rd_cost_chroma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
state$ = 64
lcu$ = 72
cur_cu$ = 80
x$ = 88
y$ = 96
calc_mode_bits PROC

; 395  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 396  :   int x_local = SUB_SCU(x);
; 397  :   int y_local = SUB_SCU(y);

	mov	ebx, DWORD PTR y$[rsp]
	mov	esi, r9d

; 398  : 
; 399  :   assert(cur_cu->type == CU_INTRA);

	movzx	eax, BYTE PTR [r8]
	mov	ebp, ebx
	and	ebp, 63					; 0000003fH
	and	esi, 63					; 0000003fH
	and	al, 3
	mov	edi, r9d
	mov	r12, r8
	mov	r14, rdx
	mov	r15, rcx
	cmp	al, 1
	je	SHORT $LN4@calc_mode_
	mov	r8d, 399				; 0000018fH
	lea	rdx, OFFSET FLAT:$SG4294944030
	lea	rcx, OFFSET FLAT:$SG4294944029
	call	QWORD PTR __imp__wassert
$LN4@calc_mode_:

; 400  : 
; 401  :   int8_t candidate_modes[3];
; 402  :   {
; 403  :     const cu_info_t *left_cu  = ((x >= SCU_WIDTH) ? LCU_GET_CU_AT_PX(lcu, x_local - SCU_WIDTH, y_local) : NULL);

	xor	r10d, r10d
	cmp	edi, 4
	jl	SHORT $LN5@calc_mode_
	mov	eax, ebp
	shr	eax, 2
	imul	ecx, eax, 17
	lea	eax, DWORD PTR [rsi-4]
	sar	eax, 2
	add	ecx, 18
	add	eax, ecx
	movsxd	rcx, eax
	lea	r9, QWORD PTR [rcx+1561]
	lea	r9, QWORD PTR [rcx+r9*4]
	lea	r9, QWORD PTR [r14+r9*4]
	jmp	SHORT $LN6@calc_mode_
$LN5@calc_mode_:
	mov	r9, r10
$LN6@calc_mode_:

; 404  :     const cu_info_t *above_cu = ((y >= SCU_WIDTH) ? LCU_GET_CU_AT_PX(lcu, x_local, y_local - SCU_WIDTH) : NULL);

	cmp	ebx, 4
	jl	SHORT $LN7@calc_mode_
	sar	esi, 2
	lea	eax, DWORD PTR [rbp-4]
	sar	eax, 2
	imul	ecx, eax, 17
	lea	eax, DWORD PTR [rsi+18]
	add	eax, ecx
	movsxd	rcx, eax
	lea	rdx, QWORD PTR [rcx+1561]
	lea	rdx, QWORD PTR [rcx+rdx*4]
	lea	rdx, QWORD PTR [r14+rdx*4]
	jmp	SHORT $LN8@calc_mode_
$LN7@calc_mode_:
	mov	rdx, r10
$LN8@calc_mode_:
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 93   :   int8_t left_intra_dir  = 1;

	mov	r8b, 1

; 94   :   if (left_pu && left_pu->type == CU_INTRA) {

	test	r9, r9
	je	SHORT $LN10@calc_mode_
	movzx	eax, BYTE PTR [r9]
	and	al, 3
	cmp	al, r8b
	jne	SHORT $LN10@calc_mode_

; 95   :     left_intra_dir = left_pu->intra.mode;

	movzx	r8d, BYTE PTR [r9+8]
$LN10@calc_mode_:

; 96   :   }
; 97   : 
; 98   :   int8_t above_intra_dir = 1;

	mov	cl, 1

; 99   :   if (above_pu && above_pu->type == CU_INTRA && y % LCU_WIDTH != 0) {

	test	rdx, rdx
	je	SHORT $LN11@calc_mode_
	movzx	eax, BYTE PTR [rdx]
	and	al, 3
	cmp	al, cl
	jne	SHORT $LN11@calc_mode_
	test	ebp, ebp
	je	SHORT $LN11@calc_mode_

; 100  :     above_intra_dir = above_pu->intra.mode;

	movzx	ecx, BYTE PTR [rdx+8]
$LN11@calc_mode_:

; 101  :   }
; 102  : 
; 103  :   // If the predictions are the same, add new predictions
; 104  :   if (left_intra_dir == above_intra_dir) {

	mov	esi, 1
	cmp	r8b, cl
	jne	SHORT $LN12@calc_mode_

; 105  :     if (left_intra_dir > 1) { // angular modes

	cmp	r8b, sil
	jle	SHORT $LN14@calc_mode_

; 106  :       preds[0] = left_intra_dir;
; 107  :       preds[1] = ((left_intra_dir + 29) % 32) + 2;

	movsx	ecx, r8b
	movzx	r9d, r8b
	lea	edx, DWORD PTR [rcx+29]
	and	edx, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN43@calc_mode_
	dec	edx
	or	edx, -32				; ffffffffffffffe0H
	inc	edx
$LN43@calc_mode_:
	add	dl, 2

; 108  :       preds[2] = ((left_intra_dir - 1 ) % 32) + 2;

	dec	ecx
	and	ecx, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN42@calc_mode_
	dec	ecx
	or	ecx, -32				; ffffffffffffffe0H
	inc	ecx
$LN42@calc_mode_:
	add	cl, 2

; 109  :     } else { //non-angular

	jmp	SHORT $LN17@calc_mode_
$LN14@calc_mode_:

; 110  :       preds[0] = 0;//PLANAR_IDX;

	xor	r9b, r9b

; 111  :       preds[1] = 1;//DC_IDX;

	movzx	edx, sil

; 112  :       preds[2] = 26;//VER_IDX;

	mov	cl, 26

; 113  :     }
; 114  :   } else { // If we have two distinct predictions

	jmp	SHORT $LN17@calc_mode_
$LN12@calc_mode_:

; 115  :     preds[0] = left_intra_dir;

	movzx	r9d, r8b

; 116  :     preds[1] = above_intra_dir;

	movzx	edx, cl

; 117  : 
; 118  :     // add planar mode if it's not yet present
; 119  :     if (left_intra_dir && above_intra_dir ) {

	test	r8b, r8b
	je	SHORT $LN16@calc_mode_
	test	cl, cl
	je	SHORT $LN16@calc_mode_

; 120  :       preds[2] = 0; // PLANAR_IDX;

	xor	cl, cl

; 121  :     } else {  // Add DC mode if it's not present, otherwise 26.

	jmp	SHORT $LN17@calc_mode_
$LN16@calc_mode_:

; 122  :       preds[2] =  (left_intra_dir+above_intra_dir)<2? 26 : 1;

	movsx	eax, r8b
	mov	r8d, 26
	movsx	ecx, cl
	add	ecx, eax
	mov	eax, esi
	cmp	ecx, 2
	cmovl	eax, r8d
	movzx	ecx, al
$LN17@calc_mode_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 408  :   double mode_bits = kvz_luma_mode_bits(state, cur_cu->intra.mode, candidate_modes);

	movzx	r8d, BYTE PTR [r12+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 649  :     if (luma_mode == intra_preds[i]) {

	cmp	r8b, r9b
	sete	al
	cmp	r8b, dl
	movzx	r11d, al
	lea	rdx, OFFSET FLAT:kvz_f_entropy_bits
	cmove	r11d, esi
	cmp	r8b, cl
	jne	SHORT $LN36@calc_mode_

; 650  :       mode_in_preds = true;

	movzx	eax, BYTE PTR [r15+173]
	xor	rax, rsi
	movss	xmm0, DWORD PTR [rdx+rax*4]
	cvtps2pd xmm0, xmm0
	jmp	SHORT $LN39@calc_mode_
$LN36@calc_mode_:

; 651  :     }
; 652  :   }
; 653  : 
; 654  :   const cabac_ctx_t *ctx = &(state->cabac.ctx.intra_mode_model);
; 655  :   mode_bits = CTX_ENTROPY_FBITS(ctx, mode_in_preds);

	movzx	ecx, BYTE PTR [r15+173]
	movzx	eax, r11b
	xor	rcx, rax
	movss	xmm0, DWORD PTR [rdx+rcx*4]
	cvtps2pd xmm0, xmm0

; 656  : 
; 657  :   if (mode_in_preds) {

	test	r11b, r11b
	je	SHORT $LN24@calc_mode_
$LN39@calc_mode_:

; 658  :     mode_bits += ((luma_mode == intra_preds[0]) ? 1 : 2);

	cmp	r8b, r9b
	setne	r10b
	inc	r10d
	movd	xmm1, r10d
	cvtdq2pd xmm1, xmm1

; 659  :   } else {

	jmp	SHORT $LN25@calc_mode_
$LN24@calc_mode_:

; 660  :     mode_bits += 5;

	movsd	xmm1, QWORD PTR __real@4014000000000000
$LN25@calc_mode_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 408  :   double mode_bits = kvz_luma_mode_bits(state, cur_cu->intra.mode, candidate_modes);

	addsd	xmm0, xmm1

; 409  : 
; 410  :   if (x % 8 == 0 && y % 8 == 0 && state->encoder_control->chroma_format != KVZ_CSP_400) {

	and	edi, -2147483641			; ffffffff80000007H
	jge	SHORT $LN41@calc_mode_
	dec	edi
	or	edi, -8
	inc	edi
$LN41@calc_mode_:
	test	edi, edi
	jne	SHORT $LN44@calc_mode_
	and	ebx, -2147483641			; ffffffff80000007H
	jge	SHORT $LN40@calc_mode_
	dec	ebx
	or	ebx, -8
	inc	ebx
$LN40@calc_mode_:
	test	ebx, ebx
	jne	SHORT $LN44@calc_mode_
	mov	rax, QWORD PTR [r15]
	cmp	DWORD PTR [rax+2596], ebx
	je	SHORT $LN44@calc_mode_
; File F:\open_codec_learn_2021\kvazaar-master\src\search_intra.c

; 671  :   if (chroma_mode == luma_mode) {

	movzx	eax, BYTE PTR [r15+174]
	cmp	BYTE PTR [r12+9], r8b
	jne	SHORT $LN28@calc_mode_
	movss	xmm1, DWORD PTR [rdx+rax*4]

; 672  :     mode_bits = CTX_ENTROPY_FBITS(ctx, 0);

	cvtps2pd xmm1, xmm1

; 673  :   } else {

	jmp	SHORT $LN29@calc_mode_
$LN28@calc_mode_:

; 674  :     mode_bits = 2.0 + CTX_ENTROPY_FBITS(ctx, 1);

	xor	rax, rsi
	movss	xmm1, DWORD PTR [rdx+rax*4]
	cvtps2pd xmm1, xmm1
	addsd	xmm1, QWORD PTR __real@4000000000000000
$LN29@calc_mode_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 411  :     mode_bits += kvz_chroma_mode_bits(state, cur_cu->intra.mode_chroma, cur_cu->intra.mode);

	addsd	xmm0, xmm1
$LN44@calc_mode_:

; 412  :   }
; 413  : 
; 414  :   return mode_bits;
; 415  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
calc_mode_bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
modes$ = 16
costs$ = 24
length$ = 32
kvz_sort_modes PROC

; 422  : {

$LN17:
	push	rsi

; 423  :   // Length for intra is always between 5 and 23, and is either 21, 17, 9 or 8 about
; 424  :   // 60% of the time, so there should be no need for anything more complex
; 425  :   // than insertion sort.
; 426  :   // Length for merge is 5 or less.
; 427  :   for (uint8_t i = 1; i < length; ++i) {

	mov	r10b, 1
	movzx	esi, r8b
	mov	r9, rcx
	cmp	r8b, r10b
	jbe	SHORT $LN3@kvz_sort_m
	mov	QWORD PTR [rsp+16], rbx
	lea	r11, QWORD PTR [rcx+1]
	mov	QWORD PTR [rsp+24], rdi
	lea	rbx, QWORD PTR [rdx+8]
	npad	13
$LL4@kvz_sort_m:

; 428  :     const double cur_cost = costs[i];

	movsd	xmm1, QWORD PTR [rbx]

; 429  :     const int8_t cur_mode = modes[i];
; 430  :     uint8_t j = i;

	movzx	r8d, r10b
	movzx	edi, BYTE PTR [r11]
	npad	4
$LL5@kvz_sort_m:

; 431  :     while (j > 0 && cur_cost < costs[j - 1]) {

	movzx	ecx, r8b
	movsd	xmm0, QWORD PTR [rdx+rcx*8-8]
	comisd	xmm1, xmm0
	jae	SHORT $LN6@kvz_sort_m

; 432  :       costs[j] = costs[j - 1];
; 433  :       modes[j] = modes[j - 1];

	movzx	eax, BYTE PTR [rcx+r9-1]
	mov	BYTE PTR [rcx+r9], al
	movsd	QWORD PTR [rdx+rcx*8], xmm0

; 434  :       --j;

	add	r8b, 255				; 000000ffH
	jne	SHORT $LL5@kvz_sort_m
$LN6@kvz_sort_m:

; 435  :     }
; 436  :     costs[j] = cur_cost;

	movzx	eax, r8b
	inc	r10b
	add	rbx, 8
	inc	r11
	movsd	QWORD PTR [rdx+rax*8], xmm1

; 437  :     modes[j] = cur_mode;

	mov	BYTE PTR [rax+r9], dil
	cmp	r10b, sil
	jb	SHORT $LL4@kvz_sort_m

; 423  :   // Length for intra is always between 5 and 23, and is either 21, 17, 9 or 8 about
; 424  :   // 60% of the time, so there should be no need for anything more complex
; 425  :   // than insertion sort.
; 426  :   // Length for merge is 5 or less.
; 427  :   for (uint8_t i = 1; i < length; ++i) {

	mov	rdi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]
$LN3@kvz_sort_m:

; 438  :   }
; 439  : }

	pop	rsi
	ret	0
kvz_sort_modes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
lcu$ = 8
x$ = 16
y$ = 24
depth$ = 32
get_ctx_cu_split_model PROC

; 443  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 444  :   vector2d_t lcu_cu = { SUB_SCU(x), SUB_SCU(y) };

	mov	r10d, edx
	mov	r11d, r8d
	and	r10d, 63				; 0000003fH
	and	r11d, 63				; 0000003fH
	mov	ebx, r9d
	mov	rdi, rcx

; 445  :   bool condA = x >= 8 && LCU_GET_CU_AT_PX(lcu, lcu_cu.x - 1, lcu_cu.y    )->depth > depth;

	mov	r9d, 1
	cmp	edx, 8
	jl	SHORT $LN3@get_ctx_cu
	mov	eax, r11d
	shr	eax, 2
	imul	ecx, eax, 17
	lea	eax, DWORD PTR [r10-1]
	sar	eax, 2
	add	eax, ecx
	cdqe
	lea	rcx, QWORD PTR [rax+rax*4]
	movzx	eax, BYTE PTR [rdi+rcx*4+25336]
	shr	eax, 2
	and	eax, 7
	cmp	eax, ebx
	jle	SHORT $LN3@get_ctx_cu
	mov	edx, r9d
	jmp	SHORT $LN4@get_ctx_cu
$LN3@get_ctx_cu:
	xor	edx, edx
$LN4@get_ctx_cu:

; 446  :   bool condL = y >= 8 && LCU_GET_CU_AT_PX(lcu, lcu_cu.x,     lcu_cu.y - 1)->depth > depth;

	cmp	r8d, 8
	jl	SHORT $LN5@get_ctx_cu
	lea	eax, DWORD PTR [r11-1]
	shr	r10d, 2
	sar	eax, 2
	imul	eax, eax, 17
	add	eax, r10d
	cdqe
	lea	rcx, QWORD PTR [rax+rax*4]
	movzx	eax, BYTE PTR [rdi+rcx*4+25336]
	shr	eax, 2
	and	eax, 7
	cmp	eax, ebx
	jg	SHORT $LN6@get_ctx_cu
$LN5@get_ctx_cu:
	xor	r9d, r9d
$LN6@get_ctx_cu:

; 447  :   return condA + condL;
; 448  : }

	mov	rbx, QWORD PTR [rsp+8]
	lea	eax, DWORD PTR [rdx+r9]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
get_ctx_cu_split_model ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
cu_width$1$ = 80
y_local$1$ = 84
intra_mode$1 = 88
inter_bitcost$1$ = 92
mode_bitcost$2 = 96
pu_depth_intra$$sroa$1527$1$ = 100
ctrl$1$ = 104
pu_depth_intra$$sroa$1528$1$ = 112
pu_depth_inter$$sroa$1520$1$ = 116
mode_cost$3 = 120
$T4 = 128
intra_cost$5 = 128
tv3866 = 136
tv3665 = 140
frame$1$ = 144
$T6 = 152
cur_cu$1$ = 160
tv3703 = 168
tv3641 = 176
state$ = 320
x$ = 328
y$ = 336
half_cu$1$ = 344
depth$ = 344
from$1$ = 352
work_tree$ = 352
search_cu PROC

; 461  : {

	mov	rax, rsp
	mov	DWORD PTR [rax+32], r9d
	mov	DWORD PTR [rax+24], r8d
	mov	DWORD PTR [rax+16], edx
	mov	QWORD PTR [rax+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r15
	sub	rsp, 256				; 00000100H

; 462  :   const encoder_control_t* ctrl = state->encoder_control;

	mov	r10, QWORD PTR [rcx]
	mov	r13, rcx

; 463  :   const videoframe_t * const frame = state->tile->frame;
; 464  :   int cu_width = LCU_WIDTH >> depth;
; 465  :   double cost = MAX_INT;
; 466  :   double inter_zero_coeff_cost = MAX_INT;
; 467  :   uint32_t inter_bitcost = MAX_INT;
; 468  :   cu_info_t *cur_cu;
; 469  : 
; 470  :   struct {
; 471  :     int32_t min;
; 472  :     int32_t max;
; 473  :   } pu_depth_inter, pu_depth_intra;
; 474  : 
; 475  :   lcu_t *const lcu = &work_tree[depth];

	mov	rbp, QWORD PTR work_tree$[rsp]
	mov	ebx, 64					; 00000040H
	movaps	XMMWORD PTR [rax-88], xmm6

; 476  : 
; 477  :   int x_local = SUB_SCU(x);

	mov	r12d, edx
	movaps	XMMWORD PTR [rax-104], xmm7

; 478  :   int y_local = SUB_SCU(y);

	mov	edi, r8d
	movsxd	r15, r9d
	and	edi, 63					; 0000003fH
	movaps	XMMWORD PTR [rax-120], xmm8
	and	r12d, 63				; 0000003fH
	mov	rax, QWORD PTR [rcx+48]
	mov	r11d, r8d
	movsd	xmm8, QWORD PTR __real@41dfffffffc00000
	mov	ecx, r15d
	imul	rsi, r15, 30776				; 00007838H
	movaps	xmm7, xmm8
	movaps	xmm6, xmm8
	sar	ebx, cl
	mov	r9d, edx
	mov	rax, QWORD PTR [rax]
	add	rsi, rbp
	mov	QWORD PTR ctrl$1$[rsp], r10
	mov	QWORD PTR frame$1$[rsp], rax
	mov	DWORD PTR cu_width$1$[rsp], ebx
	mov	DWORD PTR inter_bitcost$1$[rsp], 2147483647 ; 7fffffffH
	mov	DWORD PTR y_local$1$[rsp], edi

; 479  : 
; 480  :   // Stop recursion if the CU is completely outside the frame.
; 481  :   if (x >= frame->width || y >= frame->height) {

	cmp	edx, DWORD PTR [rax+16]
	jge	$LN6@search_cu
	cmp	r8d, DWORD PTR [rax+20]
	jge	$LN6@search_cu

; 482  :     // Return zero cost because this CU does not have to be coded.
; 483  :     return 0;
; 484  :   }
; 485  : 
; 486  :   int gop_layer = ctrl->cfg.gop_len != 0 ? ctrl->cfg.gop[state->frame->gop_offset].layer - 1 : 0;

	xor	eax, eax
	mov	QWORD PTR [rsp+248], r14
	cmp	BYTE PTR [r10+300], al
	je	SHORT $LN54@search_cu
	mov	rax, QWORD PTR [r13+40]
	movsx	rcx, BYTE PTR [rax+16]
	shl	rcx, 6
	movsx	edx, BYTE PTR [rcx+r10+314]
	dec	edx
	jmp	SHORT $LN55@search_cu
$LN54@search_cu:
	mov	edx, eax
$LN55@search_cu:

; 487  : 
; 488  :   // Assign correct depth limit
; 489  :   constraint_t* constr = state->constraint;

	mov	rax, QWORD PTR [r13+416]

; 490  :  if(constr->ml_intra_depth_ctu) {

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	je	SHORT $LN7@search_cu

; 491  :     pu_depth_intra.min = constr->ml_intra_depth_ctu->_mat_upper_depth[(x_local >> 3) + (y_local >> 3) * 8];

	mov	ecx, r12d
	mov	eax, edi
	shr	ecx, 3
	and	eax, -8					; fffffff8H
	add	ecx, eax
	mov	rax, QWORD PTR [r8+8]
	movzx	r14d, BYTE PTR [rax+rcx]

; 492  :     pu_depth_intra.max = constr->ml_intra_depth_ctu->_mat_lower_depth[(x_local >> 3) + (y_local >> 3) * 8];

	mov	rax, QWORD PTR [r8+16]
	mov	DWORD PTR pu_depth_intra$$sroa$1528$1$[rsp], r14d
	movzx	ecx, BYTE PTR [rax+rcx]
	mov	DWORD PTR pu_depth_intra$$sroa$1527$1$[rsp], ecx

; 493  :   }

	jmp	SHORT $LN59@search_cu
$LN7@search_cu:

; 494  :   else {
; 495  :     pu_depth_intra.min = ctrl->cfg.pu_depth_intra.min[gop_layer] >= 0 ? ctrl->cfg.pu_depth_intra.min[gop_layer] : ctrl->cfg.pu_depth_intra.min[0];

	movsxd	rax, edx
	mov	r14d, DWORD PTR [r10+rax*4+248]
	mov	DWORD PTR pu_depth_intra$$sroa$1528$1$[rsp], r14d
	test	r14d, r14d
	jns	SHORT $LN57@search_cu
	mov	ecx, DWORD PTR [r10+248]
	mov	DWORD PTR pu_depth_intra$$sroa$1528$1$[rsp], ecx
$LN57@search_cu:

; 496  :     pu_depth_intra.max = ctrl->cfg.pu_depth_intra.max[gop_layer] >= 0 ? ctrl->cfg.pu_depth_intra.max[gop_layer] : ctrl->cfg.pu_depth_intra.max[0];

	mov	ecx, DWORD PTR [r10+rax*4+272]
	mov	DWORD PTR pu_depth_intra$$sroa$1527$1$[rsp], ecx
	test	ecx, ecx
	jns	SHORT $LN59@search_cu
	mov	eax, DWORD PTR [r10+272]
	mov	DWORD PTR pu_depth_intra$$sroa$1527$1$[rsp], eax
$LN59@search_cu:

; 497  :   }
; 498  :   pu_depth_inter.min = ctrl->cfg.pu_depth_inter.min[gop_layer] >= 0 ? ctrl->cfg.pu_depth_inter.min[gop_layer] : ctrl->cfg.pu_depth_inter.min[0];

	movsxd	rax, edx
	mov	r8d, DWORD PTR [r10+rax*4+200]
	test	r8d, r8d
	jns	SHORT $LN61@search_cu
	mov	r8d, DWORD PTR [r10+200]
$LN61@search_cu:

; 499  :   pu_depth_inter.max = ctrl->cfg.pu_depth_inter.max[gop_layer] >= 0 ? ctrl->cfg.pu_depth_inter.max[gop_layer] : ctrl->cfg.pu_depth_inter.max[0];

	mov	edx, DWORD PTR [r10+rax*4+224]
	mov	DWORD PTR pu_depth_inter$$sroa$1520$1$[rsp], edx
	test	edx, edx
	jns	SHORT $LN63@search_cu
	mov	eax, DWORD PTR [r10+224]
	mov	DWORD PTR pu_depth_inter$$sroa$1520$1$[rsp], eax
$LN63@search_cu:

; 500  : 
; 501  :   cur_cu = LCU_GET_CU_AT_PX(lcu, x_local, y_local);

	mov	eax, edi
	lea	r14, QWORD PTR [rsi+24976]
	shr	eax, 2
	imul	ecx, eax, 17
	mov	eax, r12d
	shr	eax, 2
	add	eax, ecx

; 502  :   // Assign correct depth
; 503  :   cur_cu->depth = depth > MAX_DEPTH ? MAX_DEPTH : depth;

	movzx	ecx, r15b
	add	rax, 18
	mov	DWORD PTR tv3866[rsp], ecx
	lea	rax, QWORD PTR [rax+rax*4]
	lea	rax, QWORD PTR [rax*4]
	add	r14, rax
	mov	QWORD PTR tv3641[rsp], rax

; 504  :   cur_cu->tr_depth = depth > 0 ? depth : 1;

	mov	eax, 1
	mov	QWORD PTR cur_cu$1$[rsp], r14
	mov	QWORD PTR tv3703[rsp], rax
	and	BYTE PTR [r14+1], 248			; 000000f8H
	test	r15d, r15d
	cmovg	eax, ecx
	and	al, 7
	or	BYTE PTR [r14+1], al
	mov	eax, ecx
	mov	ecx, 3
	cmp	r15d, ecx
	cmovg	eax, ecx

; 505  :   cur_cu->type = CU_NOTSET;
; 506  :   cur_cu->part_size = SIZE_2Nx2N;
; 507  :   cur_cu->qp = state->qp;
; 508  : 
; 509  :   // If the CU is completely inside the frame at this depth, search for
; 510  :   // prediction modes at this depth.
; 511  :   if (x + cu_width <= frame->width &&

	lea	ecx, DWORD PTR [rbx+r9]
	and	al, 7
	mov	DWORD PTR tv3665[rsp], ecx
	shl	al, 2
	mov	BYTE PTR [r14], al
	movzx	eax, BYTE PTR [r13+384]
	mov	BYTE PTR [r14+6], al
	mov	rax, QWORD PTR frame$1$[rsp]
	mov	r10d, DWORD PTR [rax+16]
	cmp	ecx, r10d
	jg	$LN21@search_cu
	mov	r9d, DWORD PTR [rax+20]
	lea	eax, DWORD PTR [rbx+r11]
	cmp	eax, r9d
	jg	$LN21@search_cu

; 512  :       y + cu_width <= frame->height)
; 513  :   {
; 514  :     int cu_width_inter_min = LCU_WIDTH >> pu_depth_inter.max;
; 515  :     bool can_use_inter =

	mov	rax, QWORD PTR [r13+40]
	mov	edx, 64					; 00000040H
	mov	ecx, DWORD PTR pu_depth_inter$$sroa$1520$1$[rsp]
	sar	edx, cl
	cmp	DWORD PTR [rax+88], 2
	je	$LN296@search_cu
	cmp	r15d, 3
	jg	$LN296@search_cu
	cmp	r8d, r15d
	jg	SHORT $LN65@search_cu
	cmp	r15d, ecx
	jle	SHORT $LN268@search_cu
$LN65@search_cu:
	lea	ecx, DWORD PTR [rdx-1]
	not	ecx
	mov	eax, ecx
	and	eax, DWORD PTR x$[rsp]
	add	eax, edx
	cmp	eax, r10d
	jg	SHORT $LN268@search_cu
	and	ecx, r11d
	add	ecx, edx
	cmp	ecx, r9d
	jle	$LN296@search_cu
$LN268@search_cu:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1996 :   search_pu_inter(state,

	mov	edx, DWORD PTR x$[rsp]
	lea	rax, QWORD PTR mode_bitcost$2[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	r9d, r15d
	lea	rax, QWORD PTR mode_cost$3[rsp]
	mov	r8d, r11d
	mov	QWORD PTR [rsp+56], rax
	mov	rcx, r13
	xor	eax, eax
	mov	QWORD PTR [rsp+48], rsi
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], eax
	call	search_pu_inter

; 1997 :                   x, y, depth,
; 1998 :                   SIZE_2Nx2N, 0,
; 1999 :                   lcu,
; 2000 :                   inter_cost,
; 2001 :                   inter_bitcost);
; 2002 : 
; 2003 :   // Calculate more accurate cost when needed
; 2004 :   if (state->encoder_control->cfg.rdo >= 2) {

	mov	rax, QWORD PTR [r13]
	cmp	DWORD PTR [rax+64], 2
	jl	SHORT $LN85@search_cu

; 2005 :     kvz_cu_cost_inter_rd2(state,

	mov	r8d, DWORD PTR y$[rsp]
	lea	rax, QWORD PTR mode_bitcost$2[rsp]
	mov	edx, DWORD PTR x$[rsp]
	mov	r9d, r15d
	mov	QWORD PTR [rsp+48], rax
	mov	rcx, r13
	lea	rax, QWORD PTR mode_cost$3[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	QWORD PTR [rsp+32], rsi
	call	kvz_cu_cost_inter_rd2
$LN85@search_cu:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 535  :       if (mode_cost < cost) {

	movsd	xmm0, QWORD PTR mode_cost$3[rsp]
	comisd	xmm0, xmm8
	jae	SHORT $LN272@search_cu

; 536  :         cost = mode_cost;
; 537  :         inter_bitcost = mode_bitcost;
; 538  :         cur_cu->type = CU_INTER;

	and	BYTE PTR [r14], 254			; 000000feH
	movaps	xmm7, xmm0
	mov	eax, DWORD PTR mode_bitcost$2[rsp]
	or	BYTE PTR [r14], 2
	mov	DWORD PTR inter_bitcost$1$[rsp], eax
$LN272@search_cu:

; 539  :       }
; 540  : 
; 541  :       if (!(ctrl->cfg.early_skip && cur_cu->skipped)) {

	mov	rdx, QWORD PTR ctrl$1$[rsp]
	cmp	BYTE PTR [rdx+2474], 0
	je	SHORT $LN273@search_cu
	test	BYTE PTR [r14+1], 8
	jne	$LN287@search_cu
$LN273@search_cu:

; 542  :         // Try SMP and AMP partitioning.
; 543  :         static const part_mode_t mp_modes[] = {
; 544  :           // SMP
; 545  :           SIZE_2NxN, SIZE_Nx2N,
; 546  :           // AMP
; 547  :           SIZE_2NxnU, SIZE_2NxnD,
; 548  :           SIZE_nLx2N, SIZE_nRx2N,
; 549  :         };
; 550  : 
; 551  :         const int first_mode = ctrl->cfg.smp_enable ? 0 : 2;
; 552  :         const int last_mode = (ctrl->cfg.amp_enable && cu_width >= 16) ? 5 : 1;

	cmp	DWORD PTR [rdx+60], 0
	je	SHORT $LN68@search_cu
	mov	eax, 5
	cmp	ebx, 16
	jge	SHORT $LN299@search_cu
$LN68@search_cu:
	mov	eax, 1
$LN299@search_cu:

; 553  :         for (int i = first_mode; i <= last_mode; ++i) {

	cmp	DWORD PTR [rdx+56], 0
	mov	ecx, 2
	mov	r8d, 0
	mov	QWORD PTR $T4[rsp], rax
	cmovne	ecx, r8d
	mov	QWORD PTR $T6[rsp], rcx
	cmp	rcx, rax
	ja	$LN287@search_cu
	mov	r14d, DWORD PTR cu_width$1$[rsp]
	lea	rax, QWORD PTR [r15+1]
	imul	rbx, rax, 30776				; 00007838H
	lea	rax, QWORD PTR [rbx+rbp]
	npad	4
$LL4@search_cu:

; 554  :           kvz_search_cu_smp(state,

	mov	r8d, DWORD PTR y$[rsp]
	lea	rdx, QWORD PTR mode_bitcost$2[rsp]
	mov	QWORD PTR [rsp+56], rdx
	mov	r9d, r15d
	lea	rdx, QWORD PTR mode_cost$3[rsp]
	mov	QWORD PTR [rsp+48], rdx
	mov	edx, DWORD PTR x$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR ?mp_modes@?8??search_cu@@9@9[rax+rcx*4]
	mov	rcx, r13
	mov	DWORD PTR [rsp+32], eax
	call	kvz_search_cu_smp

; 555  :                             x, y,
; 556  :                             depth,
; 557  :                             mp_modes[i],
; 558  :                             &work_tree[depth + 1],
; 559  :                             &mode_cost, &mode_bitcost);
; 560  :           if (mode_cost < cost) {

	movsd	xmm0, QWORD PTR mode_cost$3[rsp]
	comisd	xmm0, xmm7
	jae	SHORT $LN2@search_cu

; 561  :             cost = mode_cost;
; 562  :             inter_bitcost = mode_bitcost;

	mov	eax, DWORD PTR mode_bitcost$2[rsp]

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	lea	r11d, DWORD PTR [rdi+r14]

; 561  :             cost = mode_cost;
; 562  :             inter_bitcost = mode_bitcost;

	mov	DWORD PTR inter_bitcost$1$[rsp], eax
	movaps	xmm7, xmm0

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	mov	r10d, edi
	cmp	edi, r11d
	jge	SHORT $LN2@search_cu
	lea	r9d, DWORD PTR [r12+r14]
	npad	4
$LL90@search_cu:

; 74   :     for (int x = x_local; x < x_local + width; x += SCU_WIDTH) {

	mov	edx, r12d
	cmp	r12d, r9d
	jge	SHORT $LN88@search_cu
	mov	eax, r10d
	sar	eax, 2
	imul	r8d, eax, 17
$LL93@search_cu:

; 75   :       *LCU_GET_CU_AT_PX(to, x, y) = *LCU_GET_CU_AT_PX(from, x, y);

	mov	eax, edx
	add	edx, 4
	sar	eax, 2
	add	eax, r8d
	cdqe
	add	rax, 18
	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, QWORD PTR [rbx+rcx*4]
	movups	xmm0, XMMWORD PTR [rax+rbp+24976]
	movups	XMMWORD PTR [rsi+rcx*4+24976], xmm0
	mov	eax, DWORD PTR [rax+rbp+24992]
	mov	DWORD PTR [rsi+rcx*4+24992], eax
	cmp	edx, r9d
	jl	SHORT $LL93@search_cu
$LN88@search_cu:

; 73   :   for   (int y = y_local; y < y_local + width; y += SCU_WIDTH) {

	add	r10d, 4
	cmp	r10d, r11d
	jl	SHORT $LL90@search_cu
$LN2@search_cu:

; 553  :         for (int i = first_mode; i <= last_mode; ++i) {

	mov	rcx, QWORD PTR $T6[rsp]
	lea	rax, QWORD PTR [rbx+rbp]
	inc	rcx
	mov	QWORD PTR $T6[rsp], rcx
	cmp	rcx, QWORD PTR $T4[rsp]
	jle	$LL4@search_cu
	mov	r14, QWORD PTR cur_cu$1$[rsp]
	mov	ebx, DWORD PTR cu_width$1$[rsp]
	mov	r11d, DWORD PTR y$[rsp]
$LN296@search_cu:

; 563  :             // Copy inter prediction info to current level.
; 564  :             copy_cu_info(x_local, y_local, cu_width, &work_tree[depth + 1], lcu);
; 565  :           }
; 566  :         }
; 567  :       }
; 568  :     }
; 569  : 
; 570  :     // Try to skip intra search in rd==0 mode.
; 571  :     // This can be quite severe on bdrate. It might be better to do this
; 572  :     // decision after reconstructing the inter frame.
; 573  :     bool skip_intra = (state->encoder_control->cfg.rdo == 0

	mov	rdx, QWORD PTR ctrl$1$[rsp]
$LN3@search_cu:
	mov	rax, QWORD PTR [r13]
	cmp	DWORD PTR [rax+64], 0
	jne	SHORT $LN70@search_cu
	test	BYTE PTR [r14], 3
	je	SHORT $LN70@search_cu
	mov	eax, ebx
	movaps	xmm1, xmm7
	imul	eax, ebx
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm1, xmm0
	comisd	xmm1, QWORD PTR __real@4020000000000000
	jb	SHORT $LN72@search_cu
$LN70@search_cu:
	cmp	BYTE PTR [rdx+2474], 0
	je	SHORT $LN274@search_cu
	test	BYTE PTR [r14+1], 8
	je	SHORT $LN274@search_cu
$LN72@search_cu:
	mov	r8b, 1
	jmp	SHORT $LN73@search_cu
$LN287@search_cu:
	mov	r11d, DWORD PTR y$[rsp]
	jmp	SHORT $LN3@search_cu
$LN274@search_cu:
	xor	r8b, r8b
$LN73@search_cu:

; 574  :                       && cur_cu->type != CU_NOTSET
; 575  :                       && cost / (cu_width * cu_width) < INTRA_THRESHOLD)
; 576  :                       || (ctrl->cfg.early_skip && cur_cu->skipped);
; 577  : 
; 578  :     int32_t cu_width_intra_min = LCU_WIDTH >> pu_depth_intra.max;

	mov	eax, DWORD PTR pu_depth_intra$$sroa$1527$1$[rsp]
	mov	edx, 64					; 00000040H
	mov	ecx, eax
	sar	edx, cl

; 579  :     bool can_use_intra =

	cmp	DWORD PTR pu_depth_intra$$sroa$1528$1$[rsp], r15d
	jg	SHORT $LN74@search_cu
	cmp	r15d, eax
	jle	SHORT $LN293@search_cu
$LN74@search_cu:
	mov	r10d, DWORD PTR x$[rsp]
	lea	ecx, DWORD PTR [rdx-1]
	mov	r9, QWORD PTR frame$1$[rsp]
	not	ecx
	mov	eax, ecx
	and	eax, r10d
	add	eax, edx
	cmp	eax, DWORD PTR [r9+16]
	jg	SHORT $LN75@search_cu
	and	ecx, r11d
	add	ecx, edx
	cmp	ecx, DWORD PTR [r9+20]
	jle	SHORT $LN16@search_cu
	jmp	SHORT $LN75@search_cu
$LN293@search_cu:
	mov	r10d, DWORD PTR x$[rsp]
$LN75@search_cu:

; 580  :         WITHIN(depth, pu_depth_intra.min, pu_depth_intra.max) ||
; 581  :         // When the split was forced because the CTU is partially outside
; 582  :         // the frame, we permit intra coding even if pu_depth_intra would
; 583  :         // otherwise forbid it.
; 584  :         (x & ~(cu_width_intra_min - 1)) + cu_width_intra_min > frame->width ||
; 585  :         (y & ~(cu_width_intra_min - 1)) + cu_width_intra_min > frame->height;
; 586  : 
; 587  :     if (can_use_intra && !skip_intra) {

	test	r8b, r8b
	jne	SHORT $LN16@search_cu

; 588  :       int8_t intra_mode;
; 589  :       double intra_cost;
; 590  :       kvz_search_cu_intra(state, x, y, depth, lcu,

	lea	rax, QWORD PTR intra_cost$5[rsp]
	mov	r9d, r15d
	mov	QWORD PTR [rsp+48], rax
	mov	r8d, r11d
	lea	rax, QWORD PTR intra_mode$1[rsp]
	mov	edx, r10d
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, r13
	mov	QWORD PTR [rsp+32], rsi
	call	kvz_search_cu_intra

; 591  :                           &intra_mode, &intra_cost);
; 592  :       if (intra_cost < cost) {

	movsd	xmm0, QWORD PTR intra_cost$5[rsp]
	comisd	xmm0, xmm7
	jae	SHORT $LN16@search_cu

; 593  :         cost = intra_cost;
; 594  :         cur_cu->type = CU_INTRA;

	movzx	ecx, BYTE PTR [r14]

; 595  :         cur_cu->part_size = depth > MAX_DEPTH ? SIZE_NxN : SIZE_2Nx2N;

	xor	eax, eax
	and	cl, 253					; 000000fdH
	mov	edx, 96					; 00000060H
	or	cl, 1
	movaps	xmm7, xmm0
	cmp	r15d, 3
	cmovg	eax, edx
	and	cl, 31
	or	al, cl
	mov	BYTE PTR [r14], al

; 596  :         cur_cu->intra.mode = intra_mode;

	movzx	eax, BYTE PTR intra_mode$1[rsp]
	mov	BYTE PTR [r14+8], al
$LN16@search_cu:

; 597  :       }
; 598  :     }
; 599  : 
; 600  :     // Reconstruct best mode because we need the reconstructed pixels for
; 601  :     // mode search of adjacent CUs.
; 602  :     if (cur_cu->type == CU_INTRA) {

	movzx	edx, BYTE PTR [r14]
	movzx	eax, dl
	and	al, 3
	cmp	al, 1
	jne	$LN17@search_cu

; 603  :       assert(cur_cu->part_size == SIZE_2Nx2N || cur_cu->part_size == SIZE_NxN);

	shr	dl, 5
	test	dl, dl
	je	SHORT $LN77@search_cu
	cmp	dl, 3
	je	SHORT $LN77@search_cu
	mov	r8d, 603				; 0000025bH
	lea	rdx, OFFSET FLAT:$SG4294944028
	lea	rcx, OFFSET FLAT:$SG4294944027
	call	QWORD PTR __imp__wassert
$LN77@search_cu:

; 604  :       cur_cu->intra.mode_chroma = cur_cu->intra.mode;

	movzx	eax, BYTE PTR [r14+8]

; 605  :       lcu_fill_cu_info(lcu, x_local, y_local, cu_width, cu_width, cur_cu);

	mov	r9d, ebx
	mov	QWORD PTR [rsp+40], r14
	mov	r8d, edi
	mov	edx, r12d
	mov	BYTE PTR [r14+9], al
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], ebx
	call	lcu_fill_cu_info

; 606  :       kvz_intra_recon_cu(state,

	mov	r8d, DWORD PTR y$[rsp]
	xor	eax, eax
	mov	edx, DWORD PTR x$[rsp]
	mov	r9d, r15d
	mov	QWORD PTR [rsp+56], rsi
	mov	rcx, r13
	mov	QWORD PTR [rsp+48], rax
	movzx	eax, BYTE PTR [r14+8]
	mov	BYTE PTR [rsp+40], -1
	mov	BYTE PTR [rsp+32], al
	call	kvz_intra_recon_cu

; 607  :                          x, y,
; 608  :                          depth,
; 609  :                          cur_cu->intra.mode, -1, // skip chroma
; 610  :                          NULL, lcu);
; 611  : 
; 612  :       if (x % 8 == 0 && y % 8 == 0 && state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	ecx, DWORD PTR x$[rsp]
	mov	eax, ecx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN278@search_cu
	dec	eax
	or	eax, -8
	inc	eax
$LN278@search_cu:
	test	eax, eax
	jne	$LN21@search_cu
	mov	r11d, DWORD PTR y$[rsp]
	mov	eax, r11d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN277@search_cu
	dec	eax
	or	eax, -8
	inc	eax
$LN277@search_cu:
	test	eax, eax
	jne	$LN21@search_cu
	mov	rax, QWORD PTR [r13]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN21@search_cu

; 613  :         // There is almost no benefit to doing the chroma mode search for
; 614  :         // rd2. Possibly because the luma mode search already takes chroma
; 615  :         // into account, so there is less of a chanse of luma mode being
; 616  :         // really bad for chroma.
; 617  :         if (ctrl->cfg.rdo == 3) {

	mov	rax, QWORD PTR ctrl$1$[rsp]
	cmp	DWORD PTR [rax+64], 3
	jne	SHORT $LN20@search_cu

; 618  :           cur_cu->intra.mode_chroma = kvz_search_cu_intra_chroma(state, x, y, depth, lcu);

	mov	edx, ecx
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, r13
	mov	r9d, r15d
	mov	r8d, r11d
	call	kvz_search_cu_intra_chroma

; 619  :           lcu_fill_cu_info(lcu, x_local, y_local, cu_width, cu_width, cur_cu);

	mov	r9d, ebx
	mov	QWORD PTR [rsp+40], r14
	mov	r8d, edi
	mov	BYTE PTR [r14+9], al
	mov	edx, r12d
	mov	DWORD PTR [rsp+32], ebx
	mov	rcx, rsi
	call	lcu_fill_cu_info
	mov	r11d, DWORD PTR y$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
$LN20@search_cu:

; 620  :         }
; 621  : 
; 622  :         kvz_intra_recon_cu(state,

	xor	eax, eax
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+48], rax
	mov	edx, ecx
	movzx	eax, BYTE PTR [r14+9]
	mov	r9d, r15d
	mov	BYTE PTR [rsp+40], al
	mov	r8d, r11d
	mov	rcx, r13
	mov	BYTE PTR [rsp+32], -1
	call	kvz_intra_recon_cu

; 623  :                            x, y,
; 624  :                            depth,
; 625  :                            -1, cur_cu->intra.mode_chroma, // skip luma
; 626  :                            NULL, lcu);
; 627  :       }

	jmp	$LN21@search_cu
$LN17@search_cu:

; 628  :     } else if (cur_cu->type == CU_INTER) {

	cmp	al, 2
	jne	$LN21@search_cu

; 629  : 
; 630  :       if (!cur_cu->skipped) {

	test	BYTE PTR [r14+1], 8
	jne	$LN297@search_cu

; 631  :         // Reset transform depth because intra messes with them.
; 632  :         // This will no longer be necessary if the transform depths are not shared.
; 633  :         int tr_depth = MAX(1, depth);
; 634  :         if (cur_cu->part_size != SIZE_2Nx2N) {
; 635  :           tr_depth = depth + 1;
; 636  :         }
; 637  :         kvz_lcu_fill_trdepth(lcu, x, y, depth, tr_depth);

	mov	edi, DWORD PTR y$[rsp]
	mov	eax, 1
	cmp	r15d, 1
	mov	ecx, r15d
	mov	r9d, r15d
	mov	r8d, edi
	cmovl	ecx, eax
	cmp	dl, 32					; 00000020H
	mov	edx, DWORD PTR x$[rsp]
	lea	eax, DWORD PTR [r15+1]
	cmovb	eax, ecx
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], eax
	call	kvz_lcu_fill_trdepth

; 638  : 
; 639  :         const bool has_chroma = state->encoder_control->chroma_format != KVZ_CSP_400;

	mov	rdx, QWORD PTR [r13]

; 640  :         kvz_inter_recon_cu(state, lcu, x, y, cu_width, true, has_chroma);

	mov	r9d, edi
	mov	eax, DWORD PTR cu_width$1$[rsp]
	mov	rcx, r13
	mov	r8d, DWORD PTR x$[rsp]
	cmp	DWORD PTR [rdx+2596], 0
	mov	rdx, rsi
	setne	bl
	mov	BYTE PTR [rsp+48], bl
	mov	BYTE PTR [rsp+40], 1
	mov	DWORD PTR [rsp+32], eax
	call	kvz_inter_recon_cu

; 641  : 
; 642  :         if (ctrl->cfg.zero_coeff_rdo && !ctrl->cfg.lossless && !ctrl->cfg.rdoq_enable) {

	mov	rax, QWORD PTR ctrl$1$[rsp]
	cmp	BYTE PTR [rax+2482], 0
	je	SHORT $LN24@search_cu
	cmp	DWORD PTR [rax+2392], 0
	jne	SHORT $LN24@search_cu
	cmp	DWORD PTR [rax+48], 0
	jne	SHORT $LN24@search_cu

; 643  :           //Calculate cost for zero coeffs
; 644  :           inter_zero_coeff_cost = cu_zero_coeff_cost(state, work_tree, x, y, depth) + inter_bitcost * state->lambda;

	mov	r8d, DWORD PTR x$[rsp]
	mov	r9d, edi
	mov	rdx, rbp
	mov	DWORD PTR [rsp+32], r15d
	mov	rcx, r13
	call	cu_zero_coeff_cost
	mov	eax, DWORD PTR inter_bitcost$1$[rsp]
	xorps	xmm6, xmm6
	cvtsi2sd xmm6, rax
	mulsd	xmm6, QWORD PTR [r13+368]
	addsd	xmm6, xmm0
$LN24@search_cu:

; 645  : 
; 646  :         }
; 647  : 
; 648  :         kvz_quantize_lcu_residual(state,

	mov	r9d, DWORD PTR x$[rsp]
	xor	eax, eax
	mov	BYTE PTR [rsp+64], 0
	movzx	r8d, bl
	mov	QWORD PTR [rsp+56], rsi
	mov	dl, 1
	mov	QWORD PTR [rsp+48], rax
	mov	rcx, r13
	mov	eax, DWORD PTR tv3866[rsp]
	mov	BYTE PTR [rsp+40], al
	mov	DWORD PTR [rsp+32], edi
	call	kvz_quantize_lcu_residual

; 649  :           true, has_chroma,
; 650  :           x, y, depth,
; 651  :           NULL,
; 652  :           lcu,
; 653  :           false);
; 654  : 
; 655  :         int cbf = cbf_is_set_any(cur_cu->cbf, depth);

	movzx	edx, WORD PTR [r14+4]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	r8, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR cbf_masks[r8+r15*2]
	test	ax, dx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN97@search_cu

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	ecx, eax
	shl	ecx, 5
	or	ecx, eax
	shl	ecx, 5
	test	ecx, edx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN97@search_cu
	xor	eax, eax
	mov	ecx, eax
	jmp	SHORT $LN98@search_cu
$LN97@search_cu:
	mov	ecx, 1
$LN98@search_cu:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 657  :         if (cur_cu->merged && !cbf && cur_cu->part_size == SIZE_2Nx2N) {

	movzx	eax, BYTE PTR [r14+1]
	test	al, 16
	je	SHORT $LN26@search_cu
	test	ecx, ecx
	jne	SHORT $LN26@search_cu
	cmp	BYTE PTR [r14], 32			; 00000020H
	jae	SHORT $LN26@search_cu

; 658  :           cur_cu->merged = 0;

	and	al, 239					; 000000efH

; 659  :           cur_cu->skipped = 1;

	or	al, 8
	mov	BYTE PTR [r14+1], al

; 660  :           // Selecting skip reduces bits needed to code the CU
; 661  :           if (inter_bitcost > 1) {

	mov	eax, DWORD PTR inter_bitcost$1$[rsp]
	cmp	eax, 1
	jbe	SHORT $LN26@search_cu

; 662  :             inter_bitcost -= 1;

	dec	eax
	mov	DWORD PTR inter_bitcost$1$[rsp], eax
	jmp	SHORT $LN26@search_cu
$LN297@search_cu:

; 629  : 
; 630  :       if (!cur_cu->skipped) {

	lea	r8, OFFSET FLAT:__ImageBase
$LN26@search_cu:

; 170  :   const part_mode_t part_mode = LCU_GET_CU_AT_PX(lcu, x_local, y_local)->part_size;

	movzx	eax, BYTE PTR [r14]
	shr	rax, 5

; 171  :   const int num_pu = kvz_part_mode_num_parts[part_mode];
; 172  : 
; 173  :   for (int i = 0; i < num_pu; ++i) {

	movzx	edi, BYTE PTR kvz_part_mode_num_parts[rax+r8]
	test	rdi, rdi
	je	$LN107@search_cu

; 563  :             // Copy inter prediction info to current level.
; 564  :             copy_cu_info(x_local, y_local, cu_width, &work_tree[depth + 1], lcu);
; 565  :           }
; 566  :         }
; 567  :       }
; 568  :     }
; 569  : 
; 570  :     // Try to skip intra search in rd==0 mode.
; 571  :     // This can be quite severe on bdrate. It might be better to do this
; 572  :     // decision after reconstructing the inter frame.
; 573  :     bool skip_intra = (state->encoder_control->cfg.rdo == 0

	mov	r15d, DWORD PTR y_local$1$[rsp]
	lea	rbx, QWORD PTR [rax*8]
	mov	r13d, DWORD PTR cu_width$1$[rsp]
	lea	r14, OFFSET FLAT:__ImageBase
	xor	ecx, ecx
	mov	ebp, ecx
$LL108@search_cu:

; 174  :     const int x_pu      = PU_GET_X(part_mode, cu_width, x_local, i);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[rbx+r14]
	imul	eax, r13d
	cdq
	and	edx, 3
	lea	r11d, DWORD PTR [rdx+rax]

; 175  :     const int y_pu      = PU_GET_Y(part_mode, cu_width, y_local, i);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[rbx+r14+1]
	imul	eax, r13d
	sar	r11d, 2
	add	r11d, r12d
	cdq
	and	edx, 3
	lea	r8d, DWORD PTR [rdx+rax]
	sar	r8d, 2
	add	r8d, r15d

; 176  :     const int width_pu  = PU_GET_W(part_mode, cu_width, i);
; 177  :     const int height_pu = PU_GET_H(part_mode, cu_width, i);
; 178  : 
; 179  :     cu_info_t *pu  = LCU_GET_CU_AT_PX(lcu, x_pu, y_pu);

	mov	eax, r8d
	sar	eax, 2
	imul	ecx, eax, 17
	mov	eax, r11d
	sar	eax, 2
	add	eax, ecx
	cdqe
	lea	r10, QWORD PTR [rax*4+6334]
	add	r10, rax
	movzx	eax, BYTE PTR kvz_part_mode_sizes[rbx+r14+1]

; 180  :     pu->type = CU_INTER;

	and	BYTE PTR [rsi+r10*4], 254		; 000000feH
	lea	r10, QWORD PTR [rsi+r10*4]
	or	BYTE PTR [r10], 2
	imul	eax, r13d

; 181  :     lcu_fill_cu_info(lcu, x_pu, y_pu, width_pu, height_pu, pu);

	mov	QWORD PTR [rsp+40], r10
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [rdx+rax]
	movzx	eax, BYTE PTR kvz_part_mode_sizes[rbx+r14]
	imul	eax, r13d
	sar	ecx, 2
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, rsi
	cdq
	and	edx, 3
	lea	r9d, DWORD PTR [rdx+rax]
	mov	edx, r11d
	sar	r9d, 2
	call	lcu_fill_cu_info
	inc	rbp
	lea	rbx, QWORD PTR [rbx+2]
	cmp	rbp, rdi
	jl	$LL108@search_cu
	mov	rbp, QWORD PTR work_tree$[rsp]
	mov	r14, QWORD PTR cur_cu$1$[rsp]
	mov	r15d, DWORD PTR depth$[rsp]
	mov	r13, QWORD PTR state$[rsp]
$LN107@search_cu:

; 663  :           }
; 664  :         }
; 665  :       }
; 666  :       lcu_fill_inter(lcu, x_local, y_local, cu_width);
; 667  :       lcu_fill_cbf(lcu, x_local, y_local, cu_width, cur_cu);

	mov	edi, DWORD PTR y_local$1$[rsp]
	mov	edx, r12d
	mov	r9d, DWORD PTR cu_width$1$[rsp]
	mov	r8d, edi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], r14
	call	lcu_fill_cbf
$LN21@search_cu:

; 668  :     }
; 669  :   }
; 670  : 
; 671  :   if (cur_cu->type == CU_INTRA || cur_cu->type == CU_INTER) {

	movzx	ebx, BYTE PTR [r14]
	movzx	eax, bl
	and	al, 3
	cmp	al, 1
	je	SHORT $LN28@search_cu
	cmp	al, 2
	jne	$LN32@search_cu
$LN28@search_cu:

; 672  :     cost = kvz_cu_rd_cost_luma(state, x_local, y_local, depth, cur_cu, lcu);

	mov	QWORD PTR [rsp+40], rsi
	mov	r9d, r15d
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], r14
	mov	edx, r12d
	mov	rcx, r13
	call	kvz_cu_rd_cost_luma

; 673  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r13]
	movaps	xmm7, xmm0
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN29@search_cu

; 674  :       cost += kvz_cu_rd_cost_chroma(state, x_local, y_local, depth, cur_cu, lcu);

	mov	QWORD PTR [rsp+40], rsi
	mov	r9d, r15d
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], r14
	mov	edx, r12d
	mov	rcx, r13
	call	kvz_cu_rd_cost_chroma
	addsd	xmm7, xmm0
$LN29@search_cu:

; 675  :     }
; 676  : 
; 677  :     double mode_bits;
; 678  :     if (cur_cu->type == CU_INTRA) {

	movzx	ebx, BYTE PTR [r14]
	movzx	eax, bl
	and	al, 3
	cmp	al, 1
	jne	SHORT $LN30@search_cu

; 679  :       mode_bits = calc_mode_bits(state, lcu, cur_cu, x, y);

	mov	eax, DWORD PTR y$[rsp]
	mov	r8, r14
	mov	r9d, DWORD PTR x$[rsp]
	mov	rdx, rsi
	mov	rcx, r13
	mov	DWORD PTR [rsp+32], eax
	call	calc_mode_bits
	movzx	ebx, BYTE PTR [r14]

; 680  :     } else {

	jmp	SHORT $LN31@search_cu
$LN30@search_cu:

; 681  :       mode_bits = inter_bitcost;

	mov	eax, DWORD PTR inter_bitcost$1$[rsp]
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
$LN31@search_cu:

; 682  :     }
; 683  : 
; 684  :     cost += mode_bits * state->lambda;

	mulsd	xmm0, QWORD PTR [r13+368]

; 685  : 
; 686  :     if (ctrl->cfg.zero_coeff_rdo && inter_zero_coeff_cost <= cost) {

	mov	rax, QWORD PTR ctrl$1$[rsp]
	cmp	BYTE PTR [rax+2482], 0
	addsd	xmm7, xmm0
	je	$LN32@search_cu
	comisd	xmm6, xmm7
	ja	$LN32@search_cu

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	r9d, DWORD PTR cu_width$1$[rsp]
	lea	rdx, QWORD PTR [rsi+6540]

; 687  :       cost = inter_zero_coeff_cost;
; 688  : 
; 689  :       // Restore saved pixels from lower level of the working tree.
; 690  :       copy_cu_pixels(x_local, y_local, cu_width, &work_tree[depth + 1], lcu);

	movsxd	rax, r15d

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	r8d, r9d

; 687  :       cost = inter_zero_coeff_cost;
; 688  : 
; 689  :       // Restore saved pixels from lower level of the working tree.
; 690  :       copy_cu_pixels(x_local, y_local, cu_width, &work_tree[depth + 1], lcu);

	inc	rax

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	DWORD PTR [rsp+40], 64			; 00000040H

; 687  :       cost = inter_zero_coeff_cost;
; 688  : 
; 689  :       // Restore saved pixels from lower level of the working tree.
; 690  :       copy_cu_pixels(x_local, y_local, cu_width, &work_tree[depth + 1], lcu);

	imul	rbx, rax, 30776				; 00007838H
	movaps	xmm7, xmm6

; 82   :   const int luma_index = x_local + y_local * LCU_WIDTH;

	mov	eax, edi

; 84   : 
; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	mov	DWORD PTR [rsp+32], 64			; 00000040H
	shl	eax, 6

; 687  :       cost = inter_zero_coeff_cost;
; 688  : 
; 689  :       // Restore saved pixels from lower level of the working tree.
; 690  :       copy_cu_pixels(x_local, y_local, cu_width, &work_tree[depth + 1], lcu);

	add	rbx, rbp

; 82   :   const int luma_index = x_local + y_local * LCU_WIDTH;

	add	eax, r12d

; 687  :       cost = inter_zero_coeff_cost;
; 688  : 
; 689  :       // Restore saved pixels from lower level of the working tree.
; 690  :       copy_cu_pixels(x_local, y_local, cu_width, &work_tree[depth + 1], lcu);

	mov	QWORD PTR from$1$[rsp], rbx

; 85   :   kvz_pixels_blit(&from->rec.y[luma_index], &to->rec.y[luma_index],

	add	rdx, rax
	lea	rcx, QWORD PTR [rax+6540]
	add	rcx, rbx
	call	kvz_pixels_blit

; 86   :                   width, width, LCU_WIDTH, LCU_WIDTH);
; 87   :   if (from->rec.chroma_format != KVZ_CSP_400) {

	cmp	DWORD PTR [rbx+12684], 0
	je	$LN111@search_cu

; 83   :   const int chroma_index = (x_local / 2) + (y_local / 2) * (LCU_WIDTH / 2);

	mov	ebx, DWORD PTR y_local$1$[rsp]
	mov	ecx, r12d

; 88   :     kvz_pixels_blit(&from->rec.u[chroma_index], &to->rec.u[chroma_index],

	mov	eax, DWORD PTR cu_width$1$[rsp]
	shr	ecx, 1
	cdq
	shr	ebx, 1
	sub	eax, edx
	sar	eax, 1
	lea	rdx, QWORD PTR [rsi+10636]
	shl	ebx, 5
	mov	r9d, eax
	add	ebx, ecx
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	rcx, QWORD PTR from$1$[rsp]
	add	rdx, rbx
	add	rcx, 10636				; 0000298cH
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	add	rcx, rbx
	mov	r8d, eax
	mov	edi, eax
	call	kvz_pixels_blit

; 89   :                     width / 2, width / 2, LCU_WIDTH / 2, LCU_WIDTH / 2);
; 90   :     kvz_pixels_blit(&from->rec.v[chroma_index], &to->rec.v[chroma_index],

	mov	rcx, QWORD PTR from$1$[rsp]
	lea	rdx, QWORD PTR [rsi+11660]
	add	rcx, 11660				; 00002d8cH
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	add	rcx, rbx
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	add	rdx, rbx
	mov	r9d, edi
	mov	r8d, edi
	call	kvz_pixels_blit
	mov	edi, DWORD PTR y_local$1$[rsp]
$LN111@search_cu:

; 691  : 
; 692  :       if (cur_cu->merged && cur_cu->part_size == SIZE_2Nx2N) {

	movzx	eax, BYTE PTR [r14+1]
	mov	ebx, DWORD PTR cu_width$1$[rsp]
	movzx	ecx, al
	test	al, 16
	je	SHORT $LN33@search_cu
	cmp	BYTE PTR [r14], 32			; 00000020H
	jae	SHORT $LN33@search_cu

; 693  :         cur_cu->merged = 0;

	and	al, 239					; 000000efH

; 694  :         cur_cu->skipped = 1;
; 695  :         lcu_fill_cu_info(lcu, x_local, y_local, cu_width, cu_width, cur_cu);

	mov	QWORD PTR [rsp+40], r14
	or	al, 8
	mov	DWORD PTR [rsp+32], ebx
	mov	r9d, ebx
	mov	BYTE PTR [r14+1], al
	mov	r8d, edi
	mov	edx, r12d
	mov	rcx, rsi
	call	lcu_fill_cu_info
	movzx	ecx, BYTE PTR [r14+1]
$LN33@search_cu:

; 696  :       }
; 697  : 
; 698  :       if (cur_cu->tr_depth != depth) {

	movzx	eax, cl
	and	eax, 7
	cmp	eax, r15d
	je	SHORT $LN34@search_cu

; 699  :         // Reset transform depth since there are no coefficients. This
; 700  :         // ensures that CBF is cleared for the whole area of the CU.
; 701  :         kvz_lcu_fill_trdepth(lcu, x, y, depth, depth);

	mov	r8d, DWORD PTR y$[rsp]
	mov	r9d, r15d
	mov	edx, DWORD PTR x$[rsp]
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], r15d
	call	kvz_lcu_fill_trdepth
$LN34@search_cu:

; 702  :       }
; 703  : 
; 704  :       cur_cu->cbf = 0;

	xor	eax, eax

; 705  :       lcu_fill_cbf(lcu, x_local, y_local, cu_width, cur_cu);

	mov	QWORD PTR [rsp+32], r14
	mov	r9d, ebx
	mov	WORD PTR [r14+4], ax
	mov	r8d, edi
	mov	edx, r12d
	mov	rcx, rsi
	call	lcu_fill_cbf
	movzx	ebx, BYTE PTR [r14]
$LN32@search_cu:

; 706  :     }
; 707  :   }
; 708  : 
; 709  :   bool can_split_cu =

	and	bl, 3
	je	SHORT $LN78@search_cu
	cmp	r15d, DWORD PTR pu_depth_intra$$sroa$1527$1$[rsp]
	jl	SHORT $LN78@search_cu
	mov	rax, QWORD PTR [r13+40]
	cmp	DWORD PTR [rax+88], 2
	je	SHORT $LN35@search_cu
	cmp	r15d, DWORD PTR pu_depth_inter$$sroa$1520$1$[rsp]
	jl	SHORT $LN78@search_cu
$LN35@search_cu:

; 804  :       // Copy this CU's mode all the way down for use in adjacent CUs mode
; 805  :       // search.
; 806  :       work_tree_copy_down(x_local, y_local, depth, work_tree);
; 807  :     }
; 808  :   } else if (depth >= 0 && depth < MAX_PU_DEPTH) {

	cmp	r15d, 3
	ja	$LN52@search_cu

; 809  :     // Need to copy modes down since the lower level of the work tree is used
; 810  :     // when searching SMP and AMP blocks.
; 811  :     work_tree_copy_down(x_local, y_local, depth, work_tree);

	jmp	$LN301@search_cu
$LN78@search_cu:

; 710  :     // If the CU is partially outside the frame, we need to split it even
; 711  :     // if pu_depth_intra and pu_depth_inter would not permit it.
; 712  :     cur_cu->type == CU_NOTSET ||
; 713  :     depth < pu_depth_intra.max ||
; 714  :     (state->frame->slicetype != KVZ_SLICE_I &&
; 715  :       depth < pu_depth_inter.max);
; 716  : 
; 717  :   // Recursively split all the way to max search depth.
; 718  :   if (can_split_cu) {
; 719  :     int half_cu = cu_width / 2;

	mov	eax, DWORD PTR cu_width$1$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	rcx, OFFSET FLAT:__ImageBase
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 721  :     int cbf = cbf_is_set_any(cur_cu->cbf, depth);

	movzx	r8d, WORD PTR [r14+4]
	cdq
	sub	eax, edx
	xorps	xmm6, xmm6
	sar	eax, 1
	mov	edi, eax
	mov	DWORD PTR half_cu$1$[rsp], eax
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, r15d
	movzx	ecx, WORD PTR cbf_masks[rcx+rax*2]
	test	cx, r8w

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN115@search_cu

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	edx, ecx
	shl	edx, 5
	or	edx, ecx
	shl	edx, 5
	test	edx, r8d

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN115@search_cu
	xor	eax, eax
	mov	DWORD PTR tv3703[rsp], eax
$LN115@search_cu:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 723  :     if (depth < MAX_DEPTH) {

	cmp	r15d, 3
	jge	SHORT $LN298@search_cu

; 724  :       // Add cost of cu_split_flag.
; 725  :       uint8_t split_model = get_ctx_cu_split_model(lcu, x, y, depth);

	mov	edx, DWORD PTR x$[rsp]
	mov	r9d, r15d
	mov	r8d, DWORD PTR y$[rsp]
	mov	rcx, rsi
	call	get_ctx_cu_split_model

; 726  :       const cabac_ctx_t *ctx = &(state->cabac.ctx.split_flag_model[split_model]);
; 727  :       cost += CTX_ENTROPY_FBITS(ctx, 0) * state->lambda;

	movsd	xmm1, QWORD PTR [r13+368]
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	r8d, al
	movzx	eax, BYTE PTR [r8+r13+170]
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[rdx+rax*4]

; 728  :       split_cost += CTX_ENTROPY_FBITS(ctx, 1) * state->lambda;

	xor	rax, 1
	cvtps2pd xmm0, xmm0
	movss	xmm6, DWORD PTR kvz_f_entropy_bits[rdx+rax*4]
	cvtps2pd xmm6, xmm6
	mulsd	xmm0, xmm1
	mulsd	xmm6, xmm1
	addsd	xmm7, xmm0
	jmp	SHORT $LN275@search_cu
$LN298@search_cu:

; 723  :     if (depth < MAX_DEPTH) {

	lea	rdx, OFFSET FLAT:__ImageBase
$LN275@search_cu:

; 729  :     }
; 730  : 
; 731  :     if (cur_cu->type == CU_INTRA && depth == MAX_DEPTH) {

	cmp	bl, 1
	jne	SHORT $LN38@search_cu
	cmp	r15d, 3
	jne	SHORT $LN271@search_cu

; 732  :       // Add cost of intra part_size.
; 733  :       const cabac_ctx_t *ctx = &(state->cabac.ctx.part_size_model[0]);
; 734  :       cost += CTX_ENTROPY_FBITS(ctx, 1) * state->lambda;  // 2Nx2N

	movzx	ecx, BYTE PTR [r13+196]
	movsd	xmm1, QWORD PTR [r13+368]
	mov	eax, ecx
	xor	rax, 1
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[rdx+rax*4]
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm1
	addsd	xmm7, xmm0
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[rdx+rcx*4]

; 735  :       split_cost += CTX_ENTROPY_FBITS(ctx, 0) * state->lambda;  // NxN

	cvtps2pd xmm0, xmm0
	mulsd	xmm0, xmm1
	addsd	xmm6, xmm0

; 736  :     }
; 737  : 
; 738  :     // If skip mode was selected for the block, skip further search.
; 739  :     // Skip mode means there's no coefficients in the block, so splitting
; 740  :     // might not give any better results but takes more time to do.
; 741  :     // It is ok to interrupt the search as soon as it is known that
; 742  :     // the split costs at least as much as not splitting.
; 743  :     if (cur_cu->type == CU_NOTSET || cbf || state->encoder_control->cfg.cu_split_termination == KVZ_CU_SPLIT_TERMINATION_OFF) {

	jmp	SHORT $LN271@search_cu
$LN38@search_cu:
	test	bl, bl
	je	$LN41@search_cu
$LN271@search_cu:
	cmp	DWORD PTR tv3703[rsp], 0
	jne	$LN41@search_cu
	mov	rax, QWORD PTR [r13]
	cmp	DWORD PTR [rax+2368], 1
	je	$LN41@search_cu

; 748  :     } else {
; 749  :       split_cost = INT_MAX;

	movaps	xmm6, xmm8
$LN292@search_cu:

; 750  :     }
; 751  : 
; 752  :     // If no search is not performed for this depth, try just the best mode
; 753  :     // of the top left CU from the next depth. This should ensure that 64x64
; 754  :     // gets used, at least in the most obvious cases, while avoiding any
; 755  :     // searching.
; 756  :     if (cur_cu->type == CU_NOTSET && depth < MAX_PU_DEPTH
; 757  :         && x + cu_width <= frame->width && y + cu_width <= frame->height)

	mov	edi, DWORD PTR x$[rsp]
$LN45@search_cu:
	movzx	ecx, BYTE PTR [r14]
	test	cl, 3
	jne	$LN284@search_cu
	cmp	r15d, 4
	jge	$LN284@search_cu
	mov	rdx, QWORD PTR frame$1$[rsp]
	mov	eax, DWORD PTR tv3665[rsp]
	cmp	eax, DWORD PTR [rdx+16]
	jg	$LN284@search_cu
	mov	ebx, DWORD PTR cu_width$1$[rsp]
	mov	r10d, DWORD PTR y$[rsp]
	lea	eax, DWORD PTR [rbx+r10]
	cmp	eax, DWORD PTR [rdx+20]
	jg	$LN284@search_cu

; 758  :     {
; 759  :       cu_info_t *cu_d1 = LCU_GET_CU_AT_PX(&work_tree[depth + 1], x_local, y_local);

	movsxd	rax, r15d
	lea	r9d, DWORD PTR [r15+1]
	imul	rdx, rax, 30776				; 00007838H
	add	rdx, QWORD PTR tv3641[rsp]

; 760  : 
; 761  :       // If the best CU in depth+1 is intra and the biggest it can be, try it.
; 762  :       if (cu_d1->type == CU_INTRA && cu_d1->depth == depth + 1) {

	movzx	r8d, BYTE PTR [rdx+rbp+55752]
	movzx	eax, r8b
	and	al, 3
	cmp	al, 1
	jne	$LN284@search_cu
	mov	eax, r8d
	shr	eax, 2
	and	eax, 7
	cmp	eax, r9d
	jne	$LN284@search_cu

; 763  :         cost = 0;
; 764  : 
; 765  :         cur_cu->intra = cu_d1->intra;

	movzx	eax, WORD PTR [rdx+rbp+55760]

; 766  :         cur_cu->type = CU_INTRA;

	and	cl, 253					; 000000fdH
	or	cl, 1
	mov	WORD PTR [r14+8], ax

; 767  :         cur_cu->part_size = SIZE_2Nx2N;
; 768  : 
; 769  :         kvz_lcu_fill_trdepth(lcu, x, y, depth, cur_cu->tr_depth);

	movzx	eax, BYTE PTR [r14+1]
	and	cl, 31
	mov	BYTE PTR [r14], cl
	and	eax, 7
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, r15d
	mov	r8d, r10d
	mov	edx, edi
	call	kvz_lcu_fill_trdepth

; 770  :         lcu_fill_cu_info(lcu, x_local, y_local, cu_width, cu_width, cur_cu);

	mov	edi, DWORD PTR y_local$1$[rsp]
	mov	r9d, ebx
	mov	r8d, edi
	mov	QWORD PTR [rsp+40], r14
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], ebx
	mov	edx, r12d
	call	lcu_fill_cu_info

; 771  : 
; 772  :         const bool has_chroma = state->encoder_control->chroma_format != KVZ_CSP_400;

	mov	rax, QWORD PTR [r13]
	mov	ebx, DWORD PTR [rax+2596]

; 773  :         const int8_t mode_chroma = has_chroma ? cur_cu->intra.mode_chroma : -1;

	test	ebx, ebx
	je	$LN81@search_cu
	movzx	eax, BYTE PTR [r14+9]
	jmp	$LN82@search_cu
$LN41@search_cu:

; 744  :       if (split_cost < cost) split_cost += search_cu(state, x,           y,           depth + 1, work_tree);

	comisd	xmm6, xmm7
	jae	$LN292@search_cu
	mov	r8d, DWORD PTR y$[rsp]
	lea	r9d, DWORD PTR [r15+1]
	mov	edx, DWORD PTR x$[rsp]
	mov	rcx, r13
	mov	QWORD PTR [rsp+32], rbp
	call	search_cu
	addsd	xmm6, xmm0

; 745  :       if (split_cost < cost) split_cost += search_cu(state, x + half_cu, y,           depth + 1, work_tree);

	comisd	xmm6, xmm7
	jae	$LN292@search_cu
	mov	edx, DWORD PTR x$[rsp]
	lea	r9d, DWORD PTR [r15+1]
	mov	r8d, DWORD PTR y$[rsp]
	add	edx, edi
	mov	rcx, r13
	mov	QWORD PTR [rsp+32], rbp
	call	search_cu
	addsd	xmm6, xmm0

; 746  :       if (split_cost < cost) split_cost += search_cu(state, x,           y + half_cu, depth + 1, work_tree);

	comisd	xmm6, xmm7
	jae	$LN292@search_cu
	add	edi, DWORD PTR y$[rsp]
	lea	r9d, DWORD PTR [r15+1]
	mov	edx, DWORD PTR x$[rsp]
	mov	r8d, edi
	mov	rcx, r13
	mov	QWORD PTR [rsp+32], rbp
	call	search_cu
	addsd	xmm6, xmm0

; 747  :       if (split_cost < cost) split_cost += search_cu(state, x + half_cu, y + half_cu, depth + 1, work_tree);

	comisd	xmm6, xmm7
	jae	$LN292@search_cu
	mov	edx, DWORD PTR half_cu$1$[rsp]
	lea	r9d, DWORD PTR [r15+1]
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rbp
	mov	edi, DWORD PTR x$[rsp]
	mov	rcx, r13
	add	edx, edi
	call	search_cu
	addsd	xmm6, xmm0
	jmp	$LN45@search_cu
$LN81@search_cu:

; 773  :         const int8_t mode_chroma = has_chroma ? cur_cu->intra.mode_chroma : -1;

	mov	al, -1
$LN82@search_cu:

; 774  :         kvz_intra_recon_cu(state,

	mov	r8d, DWORD PTR y$[rsp]
	xor	ecx, ecx
	mov	edx, DWORD PTR x$[rsp]
	mov	r9d, r15d
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, r13
	mov	BYTE PTR [rsp+40], al
	movzx	eax, BYTE PTR [r14+8]
	mov	BYTE PTR [rsp+32], al
	call	kvz_intra_recon_cu

; 775  :                            x, y,
; 776  :                            depth,
; 777  :                            cur_cu->intra.mode, mode_chroma,
; 778  :                            NULL, lcu);
; 779  : 
; 780  :         cost += kvz_cu_rd_cost_luma(state, x_local, y_local, depth, cur_cu, lcu);

	mov	r9d, r15d
	mov	QWORD PTR [rsp+40], rsi
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], r14
	mov	edx, r12d
	mov	rcx, r13
	call	kvz_cu_rd_cost_luma
	movaps	xmm7, xmm0

; 781  :         if (has_chroma) {

	test	ebx, ebx
	je	SHORT $LN48@search_cu

; 782  :           cost += kvz_cu_rd_cost_chroma(state, x_local, y_local, depth, cur_cu, lcu);

	mov	QWORD PTR [rsp+40], rsi
	mov	r9d, r15d
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], r14
	mov	edx, r12d
	mov	rcx, r13
	call	kvz_cu_rd_cost_chroma
	addsd	xmm7, xmm0
$LN48@search_cu:

; 783  :         }
; 784  : 
; 785  :         // Add the cost of coding no-split.
; 786  :         uint8_t split_model = get_ctx_cu_split_model(lcu, x, y, depth);

	mov	ebx, DWORD PTR y$[rsp]
	mov	r9d, r15d
	mov	edx, DWORD PTR x$[rsp]
	mov	r8d, ebx
	mov	rcx, rsi
	call	get_ctx_cu_split_model

; 787  :         const cabac_ctx_t *ctx = &(state->cabac.ctx.split_flag_model[split_model]);
; 788  :         cost += CTX_ENTROPY_FBITS(ctx, 0) * state->lambda;
; 789  : 
; 790  :         // Add the cost of coding intra mode only once.
; 791  :         double mode_bits = calc_mode_bits(state, lcu, cur_cu, x, y);

	mov	r9d, DWORD PTR x$[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	r8d, al
	mov	rdx, rsi
	mov	DWORD PTR [rsp+32], ebx
	movzx	eax, BYTE PTR [r8+r13+170]
	mov	r8, r14
	movss	xmm0, DWORD PTR kvz_f_entropy_bits[rcx+rax*4]
	mov	rcx, r13
	cvtps2pd xmm0, xmm0
	mulsd	xmm0, QWORD PTR [r13+368]
	addsd	xmm7, xmm0
	call	calc_mode_bits

; 792  :         cost += mode_bits * state->lambda;

	mulsd	xmm0, QWORD PTR [r13+368]
	addsd	xmm7, xmm0
	jmp	SHORT $LN47@search_cu
$LN284@search_cu:

; 793  :       }
; 794  :     }
; 795  : 
; 796  :     if (split_cost < cost) {

	mov	edi, DWORD PTR y_local$1$[rsp]
$LN47@search_cu:
	comisd	xmm6, xmm7
	jae	SHORT $LN49@search_cu

; 797  :       // Copy split modes to this depth.
; 798  :       cost = split_cost;
; 799  :       work_tree_copy_up(x_local, y_local, depth, work_tree);

	mov	r9, rbp
	mov	r8d, r15d
	mov	edx, edi
	mov	ecx, r12d
	movaps	xmm7, xmm6
	call	work_tree_copy_up
	jmp	SHORT $LN52@search_cu
$LN49@search_cu:

; 800  : #if KVZ_DEBUG
; 801  :       debug_split = 1;
; 802  : #endif
; 803  :     } else if (depth > 0) {

	test	r15d, r15d
	jle	SHORT $LN52@search_cu
$LN301@search_cu:

; 812  :   }
; 813  : 
; 814  :   assert(cur_cu->type != CU_NOTSET);

	mov	r9, rbp
	mov	r8d, r15d
	mov	edx, edi
	mov	ecx, r12d
	call	work_tree_copy_down
$LN52@search_cu:
	test	BYTE PTR [r14], 3
	mov	r14, QWORD PTR [rsp+248]
	jne	SHORT $LN83@search_cu
	mov	r8d, 814				; 0000032eH
	lea	rdx, OFFSET FLAT:$SG4294944026
	lea	rcx, OFFSET FLAT:$SG4294944025
	call	QWORD PTR __imp__wassert
$LN83@search_cu:

; 815  : 
; 816  :   return cost;

	movaps	xmm0, xmm7
	jmp	SHORT $LN1@search_cu
$LN6@search_cu:
	xorps	xmm0, xmm0
$LN1@search_cu:

; 817  : }

	lea	r11, QWORD PTR [rsp+256]
	movaps	xmm6, XMMWORD PTR [r11-32]
	movaps	xmm7, XMMWORD PTR [r11-48]
	movaps	xmm8, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	r15
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
search_cu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
state$ = 112
tv1151 = 120
x$ = 120
y$ = 128
lcu$ = 136
hor_buf$ = 144
ver_buf$ = 152
init_lcu_t PROC

; 827  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 828  :   const videoframe_t * const frame = state->tile->frame;

	mov	rax, QWORD PTR [rcx+48]
	mov	ebp, r8d
	mov	r15d, edx
	mov	rbx, rcx

; 829  : 
; 830  :   FILL(*lcu, 0);

	xor	edx, edx
	mov	r8d, 30776				; 00007838H
	mov	rcx, r9
	mov	r13, r9
	mov	r14, QWORD PTR [rax]
	call	memset

; 831  :   
; 832  :   lcu->rec.chroma_format = state->encoder_control->chroma_format;

	mov	rax, QWORD PTR [rbx]
	mov	r8d, DWORD PTR [rax+2596]
	mov	DWORD PTR [r13+12684], r8d

; 833  :   lcu->ref.chroma_format = state->encoder_control->chroma_format;

	mov	rax, QWORD PTR [rbx]
	mov	ecx, DWORD PTR [rax+2596]

; 834  : 
; 835  :   // Copy reference cu_info structs from neighbouring LCUs.
; 836  : 
; 837  :   // Copy top CU row.
; 838  :   if (y > 0) {

	xor	eax, eax
	mov	DWORD PTR [r13+6536], ecx
	test	ebp, ebp
	jle	$LN3@init_lcu_t

; 839  :     for (int i = 0; i < LCU_WIDTH; i += SCU_WIDTH) {

	mov	esi, eax
	lea	r12d, DWORD PTR [rbp-1]
	npad	3
$LL4@init_lcu_t:

; 840  :       const cu_info_t *from_cu = kvz_cu_array_at_const(frame->cu_array, x + i, y - 1);

	mov	rbx, QWORD PTR [r14+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	lea	edi, DWORD PTR [rsi+r15]
	cmp	edi, DWORD PTR [rbx+16]
	jb	SHORT $LN26@init_lcu_t
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN26@init_lcu_t:

; 102  :   assert(y_px < cua->height);

	cmp	r12d, DWORD PTR [rbx+20]
	jb	SHORT $LN27@init_lcu_t
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN27@init_lcu_t:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rbx+24]
	mov	eax, r12d
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 842  :       memcpy(to_cu, from_cu, sizeof(*to_cu));

	mov	rdx, QWORD PTR [rbx+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	shr	eax, 2
	sar	ecx, 2
	imul	ecx, eax
	shr	edi, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 841  :       cu_info_t *to_cu = LCU_GET_CU_AT_PX(lcu, i, -1);

	mov	eax, esi
	add	esi, 4
	shr	rax, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	add	ecx, edi
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 841  :       cu_info_t *to_cu = LCU_GET_CU_AT_PX(lcu, i, -1);

	lea	rax, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	lea	r8, QWORD PTR [rcx+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 842  :       memcpy(to_cu, from_cu, sizeof(*to_cu));

	lea	rcx, QWORD PTR [rax*4]
	movups	xmm0, XMMWORD PTR [rdx+r8*4]
	movups	XMMWORD PTR [rcx+r13+24996], xmm0
	mov	eax, DWORD PTR [rdx+r8*4+16]
	mov	DWORD PTR [rcx+r13+25012], eax
	cmp	esi, 64					; 00000040H
	jl	$LL4@init_lcu_t
	xor	eax, eax
$LN3@init_lcu_t:

; 843  :     }
; 844  :   }
; 845  :   // Copy left CU column.
; 846  :   if (x > 0) {

	test	r15d, r15d
	jle	$LN48@init_lcu_t

; 847  :     for (int i = 0; i < LCU_WIDTH; i += SCU_WIDTH) {

	mov	esi, eax
	lea	r12d, DWORD PTR [r15-1]
	npad	3
$LL7@init_lcu_t:

; 848  :       const cu_info_t *from_cu = kvz_cu_array_at_const(frame->cu_array, x - 1, y + i);

	mov	rbx, QWORD PTR [r14+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r12d, DWORD PTR [rbx+16]
	jb	SHORT $LN30@init_lcu_t
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN30@init_lcu_t:

; 102  :   assert(y_px < cua->height);

	lea	edi, DWORD PTR [rsi+rbp]
	cmp	edi, DWORD PTR [rbx+20]
	jb	SHORT $LN31@init_lcu_t
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN31@init_lcu_t:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rbx+24]
	mov	ecx, r12d
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 850  :       memcpy(to_cu, from_cu, sizeof(*to_cu));

	mov	rdx, QWORD PTR [rbx+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	sar	eax, 2
	shr	ecx, 2
	shr	edi, 2
	imul	eax, edi
	mov	DWORD PTR tv1151[rsp], ecx
	add	eax, ecx
	lea	r8, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 849  :       cu_info_t *to_cu = LCU_GET_CU_AT_PX(lcu, -1, i);

	mov	eax, esi

; 850  :       memcpy(to_cu, from_cu, sizeof(*to_cu));

	movups	xmm0, XMMWORD PTR [rdx+r8*4]
	shr	eax, 2
	add	esi, 4
	imul	eax, eax, 17
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rcx+rcx*4]
	lea	rcx, QWORD PTR [rax*4]
	movups	XMMWORD PTR [rcx+r13+25316], xmm0
	mov	eax, DWORD PTR [rdx+r8*4+16]
	mov	DWORD PTR [rcx+r13+25332], eax
	cmp	esi, 64					; 00000040H
	jl	$LL7@init_lcu_t

; 851  :     }
; 852  :   }
; 853  :   // Copy top-left CU.
; 854  :   if (x > 0 && y > 0) {

	test	ebp, ebp
	jle	$LN11@init_lcu_t

; 855  :     const cu_info_t *from_cu = kvz_cu_array_at_const(frame->cu_array, x - 1, y - 1);

	mov	rbx, QWORD PTR [r14+32]
	lea	edi, DWORD PTR [rbp-1]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r12d, DWORD PTR [rbx+16]
	jb	SHORT $LN34@init_lcu_t
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN34@init_lcu_t:

; 102  :   assert(y_px < cua->height);

	cmp	edi, DWORD PTR [rbx+20]
	jb	SHORT $LN35@init_lcu_t
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN35@init_lcu_t:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rbx+24]
	sar	eax, 2
	shr	edi, 2
	imul	eax, edi
	add	eax, DWORD PTR tv1151[rsp]
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 857  :     memcpy(to_cu, from_cu, sizeof(*to_cu));

	mov	rax, QWORD PTR [rbx+8]
	movups	xmm0, XMMWORD PTR [rax+rcx*4]
	movups	XMMWORD PTR [r13+24976], xmm0
	mov	eax, DWORD PTR [rax+rcx*4+16]
	mov	DWORD PTR [r13+24992], eax
	jmp	SHORT $LN50@init_lcu_t
$LN48@init_lcu_t:

; 858  :   }
; 859  : 
; 860  :   // Copy top-right CU.
; 861  :   if (y > 0 && x + LCU_WIDTH < frame->width) {

	test	ebp, ebp
	jle	$LN11@init_lcu_t
$LN50@init_lcu_t:
	lea	ebx, DWORD PTR [r15+64]
	cmp	ebx, DWORD PTR [r14+16]
	jge	SHORT $LN11@init_lcu_t

; 862  :     const cu_info_t *from_cu = kvz_cu_array_at_const(frame->cu_array, x + LCU_WIDTH, y - 1);

	mov	rdi, QWORD PTR [r14+32]
	lea	esi, DWORD PTR [rbp-1]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	ebx, DWORD PTR [rdi+16]
	jb	SHORT $LN38@init_lcu_t
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN38@init_lcu_t:

; 102  :   assert(y_px < cua->height);

	cmp	esi, DWORD PTR [rdi+20]
	jb	SHORT $LN39@init_lcu_t
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN39@init_lcu_t:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
	sar	eax, 2
	shr	esi, 2
	imul	eax, esi
	shr	ebx, 2
	add	eax, ebx
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 864  :     memcpy(to_cu, from_cu, sizeof(*to_cu));

	mov	rax, QWORD PTR [rdi+8]
	movups	xmm0, XMMWORD PTR [rax+rcx*4]
	movups	XMMWORD PTR [r13+30756], xmm0
	mov	eax, DWORD PTR [rax+rcx*4+16]
	mov	DWORD PTR [r13+30772], eax
	mov	ecx, DWORD PTR [r14+16]
	jmp	SHORT $LN49@init_lcu_t
$LN11@init_lcu_t:

; 865  :   }
; 866  : 
; 867  :   // Copy reference pixels.
; 868  :   {
; 869  :     const int pic_width = frame->width;

	mov	ecx, DWORD PTR [r14+16]

; 870  :     // Copy top reference pixels.
; 871  :     if (y > 0) {

	test	ebp, ebp
	jle	$LN13@init_lcu_t
$LN49@init_lcu_t:

; 872  :       // hor_buf is of size pic_width so there might not be LCU_REF_PX_WIDTH
; 873  :       // number of allocated pixels left.
; 874  :       int x_max = MIN(LCU_REF_PX_WIDTH, pic_width - x);

	mov	edi, ecx

; 875  :       int x_min_in_lcu = (x>0) ? 0 : 1;
; 876  :       int luma_offset = OFFSET_HOR_BUF(x, y, frame, x_min_in_lcu - 1);

	lea	edx, DWORD PTR [r15-1]
	mov	eax, 96					; 00000060H
	sub	edi, r15d
	cmp	edi, eax

; 877  :       int chroma_offset = OFFSET_HOR_BUF_C(x, y, frame, x_min_in_lcu - 1);

	mov	ebx, ebp
	cmovg	edi, eax
	xor	eax, eax
	test	r15d, r15d
	setle	al
	shr	ebx, 6
	mov	esi, eax
	dec	ebx
	imul	ebx, ecx
	mov	ecx, edi
	sub	ecx, eax

; 880  : 
; 881  :       memcpy(&lcu->top_ref.y[x_min_in_lcu], &hor_buf->y[luma_offset], luma_bytes);

	mov	rax, QWORD PTR hor_buf$[rsp]
	inc	ecx
	movsxd	r8, ecx
	lea	r12, QWORD PTR [rsi+r13]
	lea	ecx, DWORD PTR [rbx+rsi]
	add	edx, ecx
	mov	rcx, r12
	movsxd	rdx, edx
	add	rdx, QWORD PTR [rax+8]
	call	memcpy

; 882  :       if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+2596], 0
	je	SHORT $LN13@init_lcu_t

; 878  :       int luma_bytes = (x_max + (1 - x_min_in_lcu))*sizeof(kvz_pixel);
; 879  :       int chroma_bytes = (x_max / 2 + (1 - x_min_in_lcu))*sizeof(kvz_pixel);

	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1

; 883  :         memcpy(&lcu->top_ref.u[x_min_in_lcu], &hor_buf->u[chroma_offset], chroma_bytes);

	sub	eax, esi
	inc	eax
	movsxd	rdi, eax
	mov	eax, ebx
	cdq
	mov	r8, rdi
	sub	eax, edx
	sar	eax, 1
	lea	ecx, DWORD PTR [rsi+rax]
	mov	rsi, QWORD PTR hor_buf$[rsp]
	mov	eax, r15d
	cdq
	sub	eax, edx
	mov	rdx, QWORD PTR [rsi+16]
	sar	eax, 1
	dec	eax
	add	eax, ecx
	lea	rcx, QWORD PTR [r12+97]
	movsxd	rbx, eax
	add	rdx, rbx
	call	memcpy

; 884  :         memcpy(&lcu->top_ref.v[x_min_in_lcu], &hor_buf->v[chroma_offset], chroma_bytes);

	mov	rdx, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [r12+146]
	add	rdx, rbx
	mov	r8, rdi
	call	memcpy
$LN13@init_lcu_t:

; 885  :       }
; 886  :     }
; 887  :     // Copy left reference pixels.
; 888  :     if (x > 0) {

	test	r15d, r15d
	jle	$LN51@init_lcu_t

; 889  :       int y_min_in_lcu = (y>0) ? 0 : 1;

	mov	eax, 0

; 890  :       int luma_offset = OFFSET_VER_BUF(x, y, frame, y_min_in_lcu - 1);

	lea	ecx, DWORD PTR [rbp-1]
	test	ebp, ebp

; 891  :       int chroma_offset = OFFSET_VER_BUF_C(x, y, frame, y_min_in_lcu - 1);

	mov	ebx, r15d

; 892  :       int luma_bytes = (LCU_WIDTH + (1 - y_min_in_lcu)) * sizeof(kvz_pixel);
; 893  :       int chroma_bytes = (LCU_WIDTH / 2 + (1 - y_min_in_lcu)) * sizeof(kvz_pixel);
; 894  : 
; 895  :       memcpy(&lcu->left_ref.y[y_min_in_lcu], &ver_buf->y[luma_offset], luma_bytes);

	mov	r8d, 65					; 00000041H
	setle	al
	shr	ebx, 6
	mov	esi, eax
	dec	ebx
	imul	ebx, DWORD PTR [r14+20]
	sub	r8, rsi
	mov	r14, QWORD PTR ver_buf$[rsp]
	lea	eax, DWORD PTR [rbx+rsi]
	add	ecx, eax
	movsxd	rdx, ecx
	lea	rcx, QWORD PTR [r13+195]
	add	rdx, QWORD PTR [r14+8]
	add	rcx, rsi
	call	memcpy

; 896  :       if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	r12, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR [r12]
	cmp	DWORD PTR [rcx+2596], 0
	je	SHORT $LN15@init_lcu_t

; 897  :         memcpy(&lcu->left_ref.u[y_min_in_lcu], &ver_buf->u[chroma_offset], chroma_bytes);

	mov	eax, ebx
	mov	edi, 33					; 00000021H
	cdq
	sub	rdi, rsi
	sub	eax, edx
	mov	r8, rdi
	sar	eax, 1
	lea	ecx, DWORD PTR [rsi+rax]
	mov	eax, ebp
	cdq
	sub	eax, edx
	mov	rdx, QWORD PTR [r14+16]
	sar	eax, 1
	dec	eax
	add	eax, ecx
	lea	rcx, QWORD PTR [r13+292]
	movsxd	rbx, eax
	add	rcx, rsi
	add	rdx, rbx
	call	memcpy

; 898  :         memcpy(&lcu->left_ref.v[y_min_in_lcu], &ver_buf->v[chroma_offset], chroma_bytes);

	mov	rdx, QWORD PTR [r14+24]
	lea	rcx, QWORD PTR [r13+341]
	add	rdx, rbx
	add	rcx, rsi
	mov	r8, rdi
	call	memcpy
	jmp	SHORT $LN15@init_lcu_t
$LN51@init_lcu_t:

; 885  :       }
; 886  :     }
; 887  :     // Copy left reference pixels.
; 888  :     if (x > 0) {

	mov	r12, QWORD PTR state$[rsp]
$LN15@init_lcu_t:

; 899  :       }
; 900  :     }
; 901  :   }
; 902  : 
; 903  :   // Copy LCU pixels.
; 904  :   {
; 905  :     const videoframe_t * const frame = state->tile->frame;

	mov	rax, QWORD PTR [r12+48]

; 906  :     int x_max = MIN(x + LCU_WIDTH, frame->width) - x;

	lea	r8d, DWORD PTR [r15+64]

; 907  :     int y_max = MIN(y + LCU_WIDTH, frame->height) - y;

	lea	r9d, DWORD PTR [rbp+64]

; 908  : 
; 909  :     int x_c = x / 2;
; 910  :     int y_c = y / 2;
; 911  :     int x_max_c = x_max / 2;
; 912  :     int y_max_c = y_max / 2;
; 913  : 
; 914  :     kvz_pixels_blit(&frame->source->y[x + y * frame->source->stride], lcu->ref.y,

	mov	DWORD PTR [rsp+40], 64			; 00000040H
	mov	rbx, QWORD PTR [rax]
	mov	eax, r15d
	cdq
	cmp	r8d, DWORD PTR [rbx+16]
	mov	r10, QWORD PTR [rbx]
	cmovge	r8d, DWORD PTR [rbx+16]
	sub	r8d, r15d
	cmp	r9d, DWORD PTR [rbx+20]
	mov	r11d, DWORD PTR [r10+72]
	mov	ecx, r11d
	cmovge	r9d, DWORD PTR [rbx+20]
	sub	eax, edx
	sar	eax, 1
	sub	r9d, ebp
	mov	edi, eax
	imul	ecx, ebp
	mov	eax, ebp
	mov	DWORD PTR [rsp+32], r11d
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	add	ecx, r15d
	mov	eax, r8d
	movsxd	rcx, ecx
	add	rcx, QWORD PTR [r10+16]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r14d, eax
	mov	eax, r9d
	cdq
	sub	eax, edx
	lea	rdx, QWORD PTR [r13+392]
	sar	eax, 1
	mov	r12d, eax
	call	kvz_pixels_blit

; 915  :                         x_max, y_max, frame->source->stride, LCU_WIDTH);
; 916  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rcx, QWORD PTR state$[rsp]
	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN16@init_lcu_t

; 917  :       kvz_pixels_blit(&frame->source->u[x_c + y_c * frame->source->stride / 2], lcu->ref.u,

	mov	r9, QWORD PTR [rbx]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	ecx, DWORD PTR [r9+72]
	mov	eax, ecx
	cdq
	imul	ecx, esi
	sub	eax, edx
	sar	eax, 1
	mov	r8d, eax
	mov	DWORD PTR [rsp+32], r8d
	mov	r8d, r14d
	mov	eax, ecx
	cdq
	sub	eax, edx
	lea	rdx, QWORD PTR [r13+4488]
	sar	eax, 1
	add	eax, edi
	movsxd	rcx, eax
	add	rcx, QWORD PTR [r9+24]
	mov	r9d, r12d
	call	kvz_pixels_blit

; 918  :                       x_max_c, y_max_c, frame->source->stride / 2, LCU_WIDTH / 2);
; 919  :       kvz_pixels_blit(&frame->source->v[x_c + y_c * frame->source->stride / 2], lcu->ref.v,

	mov	r9, QWORD PTR [rbx]
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	mov	ecx, DWORD PTR [r9+72]
	mov	eax, ecx
	cdq
	imul	ecx, esi
	sub	eax, edx
	sar	eax, 1
	mov	r8d, eax
	mov	DWORD PTR [rsp+32], r8d
	mov	r8d, r14d
	mov	eax, ecx
	cdq
	sub	eax, edx
	lea	rdx, QWORD PTR [r13+5512]
	sar	eax, 1
	add	eax, edi
	movsxd	rcx, eax
	add	rcx, QWORD PTR [r9+32]
	mov	r9d, r12d
	call	kvz_pixels_blit
$LN16@init_lcu_t:

; 920  :                       x_max_c, y_max_c, frame->source->stride / 2, LCU_WIDTH / 2);
; 921  :     }
; 922  :   }
; 923  : }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
init_lcu_t ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
_TEXT	SEGMENT
state$ = 96
x_px$ = 104
y_px$ = 112
lcu$ = 120
copy_lcu_to_cu_data PROC

; 930  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H

; 932  :   kvz_cu_array_copy_from_lcu(state->tile->frame->cu_array, x_px, y_px, lcu);

	mov	rax, QWORD PTR [rcx+48]
	mov	r15, r9
	mov	r13d, r8d
	mov	r14d, edx
	mov	rbp, rcx
	mov	r10, QWORD PTR [rax]
	mov	rdi, QWORD PTR [r10+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 219  :   const int dst_stride = dst->stride >> 2;

	mov	esi, DWORD PTR [rdi+24]
	sar	esi, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 932  :   kvz_cu_array_copy_from_lcu(state->tile->frame->cu_array, x_px, y_px, lcu);

	xor	r11d, r11d
	npad	4
$LL11@copy_lcu_t:
	mov	ecx, r11d
	lea	r10d, DWORD PTR [r11+r13]
	sar	ecx, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 221  :     for (int x = 0; x < LCU_WIDTH; x += SCU_WIDTH) {

	xor	eax, eax
	imul	ebx, ecx, 17
	sar	r10d, 2
	imul	r10d, esi
	npad	9
$LL14@copy_lcu_t:

; 222  :       const cu_info_t *from_cu = LCU_GET_CU_AT_PX(src, x, y);

	mov	ecx, eax
	sar	ecx, 2
	add	ecx, ebx
	movsxd	rcx, ecx
	lea	r9, QWORD PTR [rcx+rcx*4]

; 223  :       const int x_scu = (dst_x + x) >> 2;
; 224  :       const int y_scu = (dst_y + y) >> 2;
; 225  :       cu_info_t *to_cu = &dst->data[x_scu + y_scu * dst_stride];
; 226  :       memcpy(to_cu,                  from_cu, sizeof(*to_cu));

	movups	xmm0, XMMWORD PTR [r15+r9*4+25336]
	lea	ecx, DWORD PTR [rax+r14]
	add	eax, 4
	sar	ecx, 2
	add	ecx, r10d
	movsxd	rcx, ecx
	lea	rdx, QWORD PTR [rcx+rcx*4]
	mov	rcx, QWORD PTR [rdi+8]
	movups	XMMWORD PTR [rcx+rdx*4], xmm0
	lea	r8, QWORD PTR [rcx+rdx*4]
	mov	ecx, DWORD PTR [r15+r9*4+25352]
	mov	DWORD PTR [r8+16], ecx
	cmp	eax, 64					; 00000040H
	jl	SHORT $LL14@copy_lcu_t

; 220  :   for (int y = 0; y < LCU_WIDTH; y += SCU_WIDTH) {

	add	r11d, 4
	cmp	r11d, 64				; 00000040H
	jl	SHORT $LL11@copy_lcu_t
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 937  :     const int pic_width = pic->width;

	mov	rax, QWORD PTR [rbp+48]
	lea	ebx, DWORD PTR [r14+64]

; 938  :     const int x_max = MIN(x_px + LCU_WIDTH, pic_width) - x_px;
; 939  :     const int y_max = MIN(y_px + LCU_WIDTH, pic->height) - y_px;

	lea	edi, DWORD PTR [r13+64]
	mov	r12, QWORD PTR [rax]
	cmp	ebx, DWORD PTR [r12+16]

; 940  : 
; 941  :     kvz_pixels_blit(lcu->rec.y, &pic->rec->y[x_px + y_px * pic->rec->stride],

	mov	rcx, QWORD PTR [r12+8]
	cmovge	ebx, DWORD PTR [r12+16]
	sub	ebx, r14d
	cmp	edi, DWORD PTR [r12+20]
	mov	r8d, DWORD PTR [rcx+72]
	mov	eax, r8d
	cmovge	edi, DWORD PTR [r12+20]
	mov	DWORD PTR [rsp+40], r8d
	sub	edi, r13d
	imul	eax, r13d
	mov	r9d, edi
	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	add	eax, r14d
	movsxd	rdx, eax
	add	rdx, QWORD PTR [rcx+16]
	lea	rcx, QWORD PTR [r15+6540]
	call	kvz_pixels_blit

; 942  :                         x_max, y_max, LCU_WIDTH, pic->rec->stride);
; 943  : 
; 944  :     if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rcx, QWORD PTR [rbp]
	cmp	DWORD PTR [rcx+2596], 0
	je	$LN2@copy_lcu_t

; 945  :       kvz_pixels_blit(lcu->rec.u, &pic->rec->u[(x_px / 2) + (y_px / 2) * (pic->rec->stride / 2)],

	mov	r9, QWORD PTR [r12+8]
	mov	eax, DWORD PTR [r9+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	r8d, eax
	mov	eax, edi
	cdq
	mov	DWORD PTR [rsp+40], r8d
	sub	eax, edx
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	sar	eax, 1
	mov	ecx, r8d
	mov	ebp, eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	mov	eax, r13d
	cdq
	mov	r8d, esi
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
	mov	eax, r14d
	cdq
	imul	ecx, edi
	sub	eax, edx
	sar	eax, 1
	mov	ebx, eax
	add	ecx, eax
	movsxd	rdx, ecx
	lea	rcx, QWORD PTR [r15+10636]
	add	rdx, QWORD PTR [r9+24]
	mov	r9d, ebp
	call	kvz_pixels_blit

; 946  :                       x_max / 2, y_max / 2, LCU_WIDTH / 2, pic->rec->stride / 2);
; 947  :       kvz_pixels_blit(lcu->rec.v, &pic->rec->v[(x_px / 2) + (y_px / 2) * (pic->rec->stride / 2)],

	mov	r8, QWORD PTR [r12+8]
	mov	r9d, ebp
	mov	eax, DWORD PTR [r8+72]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, eax
	mov	DWORD PTR [rsp+40], eax
	imul	ecx, edi
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	add	ecx, ebx
	movsxd	rdx, ecx
	lea	rcx, QWORD PTR [r15+11660]
	add	rdx, QWORD PTR [r8+32]
	mov	r8d, esi
	call	kvz_pixels_blit
$LN2@copy_lcu_t:

; 948  :                       x_max / 2, y_max / 2, LCU_WIDTH / 2, pic->rec->stride / 2);
; 949  :     }
; 950  :   }
; 951  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
copy_lcu_to_cu_data ENDP
_TEXT	ENDS
END
