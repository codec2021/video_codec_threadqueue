; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
?diamond@?1??diamond_search@@9@9 DD 00H			; `diamond_search'::`2'::diamond
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
?small_hexbs@?1??hexagon_search@@9@9 DD 00H		; `hexagon_search'::`2'::small_hexbs
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
	ORG $+8
?large_hexbs@?1??hexagon_search@@9@9 DD 00H		; `hexagon_search'::`2'::large_hexbs
	DD	00H
	DD	01H
	DD	0fffffffeH
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	0ffffffffH
	DD	02H
	DD	0fffffffeH
	DD	00H
	DD	0ffffffffH
	DD	0fffffffeH
	DD	01H
	DD	0fffffffeH
	DD	02H
	DD	00H
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	ORG $+8
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
?priorityList1@?1??search_pu_inter_bipred@@9@9 DB 01H	; `search_pu_inter_bipred'::`2'::priorityList1
	DB	00H
	DB	02H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	02H
	ORG $+4
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
?small_hexbs@?1??early_terminate@@9@9 DD 00H		; `early_terminate'::`2'::small_hexbs
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
?square@?1??search_frac@@9@9 DD 00H			; `search_frac'::`2'::square
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
	ORG $+8
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
?priorityList0@?1??search_pu_inter_bipred@@9@9 DB 00H	; `search_pu_inter_bipred'::`2'::priorityList0
	DB	01H
	DB	00H
	DB	02H
	DB	01H
	DB	02H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	02H
	DB	03H
PUBLIC	kvz_cu_cost_inter_rd2
PUBLIC	kvz_tz_raster_search
PUBLIC	kvz_tz_pattern_search
PUBLIC	kvz_search_cu_smp
PUBLIC	kvz_search_cu_inter
pdata	SEGMENT
$pdata$kvz_cu_cost_inter_rd2 DD imagerel $LN7
	DD	imagerel $LN7+379
	DD	imagerel $unwind$kvz_cu_cost_inter_rd2
$pdata$search_pu_inter DD imagerel search_pu_inter
	DD	imagerel search_pu_inter+5000
	DD	imagerel $unwind$search_pu_inter
$pdata$merge_candidate_in_list DD imagerel merge_candidate_in_list
	DD	imagerel merge_candidate_in_list+129
	DD	imagerel $unwind$merge_candidate_in_list
$pdata$search_pu_inter_bipred DD imagerel search_pu_inter_bipred
	DD	imagerel search_pu_inter_bipred+139
	DD	imagerel $unwind$search_pu_inter_bipred
$pdata$7$search_pu_inter_bipred DD imagerel search_pu_inter_bipred+139
	DD	imagerel search_pu_inter_bipred+2494
	DD	imagerel $chain$7$search_pu_inter_bipred
$pdata$8$search_pu_inter_bipred DD imagerel search_pu_inter_bipred+2494
	DD	imagerel search_pu_inter_bipred+2504
	DD	imagerel $chain$8$search_pu_inter_bipred
$pdata$search_pu_inter_ref DD imagerel search_pu_inter_ref
	DD	imagerel search_pu_inter_ref+4253
	DD	imagerel $unwind$search_pu_inter_ref
$pdata$search_frac DD imagerel search_frac
	DD	imagerel search_frac+2555
	DD	imagerel $unwind$search_frac
$pdata$search_mv_full DD imagerel search_mv_full
	DD	imagerel search_mv_full+213
	DD	imagerel $unwind$search_mv_full
$pdata$1$search_mv_full DD imagerel search_mv_full+213
	DD	imagerel search_mv_full+985
	DD	imagerel $chain$1$search_mv_full
$pdata$2$search_mv_full DD imagerel search_mv_full+985
	DD	imagerel search_mv_full+1003
	DD	imagerel $chain$2$search_mv_full
$pdata$3$search_mv_full DD imagerel search_mv_full+1003
	DD	imagerel search_mv_full+1010
	DD	imagerel $chain$3$search_mv_full
$pdata$diamond_search DD imagerel diamond_search
	DD	imagerel diamond_search+65
	DD	imagerel $unwind$diamond_search
$pdata$5$diamond_search DD imagerel diamond_search+65
	DD	imagerel diamond_search+203
	DD	imagerel $chain$5$diamond_search
$pdata$6$diamond_search DD imagerel diamond_search+203
	DD	imagerel diamond_search+338
	DD	imagerel $chain$6$diamond_search
$pdata$7$diamond_search DD imagerel diamond_search+338
	DD	imagerel diamond_search+368
	DD	imagerel $chain$7$diamond_search
$pdata$8$diamond_search DD imagerel diamond_search+368
	DD	imagerel diamond_search+375
	DD	imagerel $chain$8$diamond_search
$pdata$hexagon_search DD imagerel hexagon_search
	DD	imagerel hexagon_search+60
	DD	imagerel $unwind$hexagon_search
$pdata$0$hexagon_search DD imagerel hexagon_search+60
	DD	imagerel hexagon_search+65
	DD	imagerel $chain$0$hexagon_search
$pdata$4$hexagon_search DD imagerel hexagon_search+65
	DD	imagerel hexagon_search+168
	DD	imagerel $chain$4$hexagon_search
$pdata$5$hexagon_search DD imagerel hexagon_search+168
	DD	imagerel hexagon_search+289
	DD	imagerel $chain$5$hexagon_search
$pdata$6$hexagon_search DD imagerel hexagon_search+289
	DD	imagerel hexagon_search+320
	DD	imagerel $chain$6$hexagon_search
$pdata$7$hexagon_search DD imagerel hexagon_search+320
	DD	imagerel hexagon_search+368
	DD	imagerel $chain$7$hexagon_search
$pdata$8$hexagon_search DD imagerel hexagon_search+368
	DD	imagerel hexagon_search+377
	DD	imagerel $chain$8$hexagon_search
$pdata$tz_search DD imagerel tz_search
	DD	imagerel tz_search+65
	DD	imagerel $unwind$tz_search
$pdata$0$tz_search DD imagerel tz_search+65
	DD	imagerel tz_search+70
	DD	imagerel $chain$0$tz_search
$pdata$2$tz_search DD imagerel tz_search+70
	DD	imagerel tz_search+88
	DD	imagerel $chain$2$tz_search
$pdata$4$tz_search DD imagerel tz_search+88
	DD	imagerel tz_search+203
	DD	imagerel $chain$4$tz_search
$pdata$5$tz_search DD imagerel tz_search+203
	DD	imagerel tz_search+288
	DD	imagerel $chain$5$tz_search
$pdata$6$tz_search DD imagerel tz_search+288
	DD	imagerel tz_search+383
	DD	imagerel $chain$6$tz_search
$pdata$7$tz_search DD imagerel tz_search+383
	DD	imagerel tz_search+391
	DD	imagerel $chain$7$tz_search
$pdata$kvz_tz_raster_search DD imagerel $LN18
	DD	imagerel $LN18+139
	DD	imagerel $unwind$kvz_tz_raster_search
$pdata$kvz_tz_pattern_search DD imagerel $LN61
	DD	imagerel $LN61+438
	DD	imagerel $unwind$kvz_tz_pattern_search
$pdata$early_terminate DD imagerel early_terminate
	DD	imagerel early_terminate+332
	DD	imagerel $unwind$early_terminate
$pdata$calc_mvd_cost DD imagerel calc_mvd_cost
	DD	imagerel calc_mvd_cost+174
	DD	imagerel $unwind$calc_mvd_cost
$pdata$0$calc_mvd_cost DD imagerel calc_mvd_cost+174
	DD	imagerel calc_mvd_cost+321
	DD	imagerel $chain$0$calc_mvd_cost
$pdata$1$calc_mvd_cost DD imagerel calc_mvd_cost+321
	DD	imagerel calc_mvd_cost+380
	DD	imagerel $chain$1$calc_mvd_cost
$pdata$select_mv_cand DD imagerel select_mv_cand
	DD	imagerel select_mv_cand+104
	DD	imagerel $unwind$select_mv_cand
$pdata$1$select_mv_cand DD imagerel select_mv_cand+104
	DD	imagerel select_mv_cand+209
	DD	imagerel $chain$1$select_mv_cand
$pdata$2$select_mv_cand DD imagerel select_mv_cand+209
	DD	imagerel select_mv_cand+248
	DD	imagerel $chain$2$select_mv_cand
$pdata$get_mvd_coding_cost DD imagerel get_mvd_coding_cost
	DD	imagerel get_mvd_coding_cost+200
	DD	imagerel $unwind$get_mvd_coding_cost
$pdata$select_starting_point DD imagerel select_starting_point
	DD	imagerel select_starting_point+199
	DD	imagerel $unwind$select_starting_point
$pdata$mv_in_merge DD imagerel mv_in_merge
	DD	imagerel mv_in_merge+148
	DD	imagerel $unwind$mv_in_merge
$pdata$check_mv_cost DD imagerel check_mv_cost
	DD	imagerel check_mv_cost+972
	DD	imagerel $unwind$check_mv_cost
$pdata$intmv_within_tile DD imagerel intmv_within_tile
	DD	imagerel intmv_within_tile+400
	DD	imagerel $unwind$intmv_within_tile
$pdata$fracmv_within_tile DD imagerel fracmv_within_tile
	DD	imagerel fracmv_within_tile+472
	DD	imagerel $unwind$fracmv_within_tile
$pdata$kvz_search_cu_smp DD imagerel $LN32
	DD	imagerel $LN32+942
	DD	imagerel $unwind$kvz_search_cu_smp
$pdata$kvz_search_cu_inter DD imagerel $LN5
	DD	imagerel $LN5+162
	DD	imagerel $unwind$kvz_search_cu_inter
pdata	ENDS
xdata	SEGMENT
$unwind$kvz_cu_cost_inter_rd2 DD 0c1c01H
	DD	012641cH
	DD	011541cH
	DD	010341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	07010c012H
$unwind$search_pu_inter DD 0e4401H
	DD	01c7844H
	DD	01d683eH
	DD	03d012cH
	DD	0e01cf01eH
	DD	0c018d01aH
	DD	060157016H
	DD	050133014H
$unwind$merge_candidate_in_list DD 020501H
	DD	013405H
$unwind$search_pu_inter_bipred DD 041201H
	DD	0270112H
	DD	0500a600bH
$chain$7$search_pu_inter_bipred DD 0105521H
	DD	0106855H
	DD	0f7845H
	DD	022f43dH
	DD	023e435H
	DD	024d42dH
	DD	025c422H
	DD	0267417H
	DD	02d3408H
	DD	imagerel search_pu_inter_bipred
	DD	imagerel search_pu_inter_bipred+139
	DD	imagerel $unwind$search_pu_inter_bipred
$chain$8$search_pu_inter_bipred DD 021H
	DD	imagerel search_pu_inter_bipred
	DD	imagerel search_pu_inter_bipred+139
	DD	imagerel $unwind$search_pu_inter_bipred
$unwind$search_pu_inter_ref DD 0a2f01H
	DD	021f012fH
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	0500f3010H
$unwind$search_frac DD 0d3101H
	DD	021ac7425H
	DD	021ab6425H
	DD	021aa3425H
	DD	021a40125H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
$unwind$search_mv_full DD 098101H
	DD	09e481H
	DD	0f00da211H
	DD	07009c00bH
	DD	050076008H
	DD	03006H
$chain$1$search_mv_full DD 020521H
	DD	0ad405H
	DD	imagerel search_mv_full
	DD	imagerel search_mv_full+213
	DD	imagerel $unwind$search_mv_full
$chain$2$search_mv_full DD 021H
	DD	imagerel search_mv_full
	DD	imagerel search_mv_full+213
	DD	imagerel $unwind$search_mv_full
$chain$3$search_mv_full DD 020021H
	DD	0ad400H
	DD	imagerel search_mv_full
	DD	imagerel search_mv_full+213
	DD	imagerel $unwind$search_mv_full
$unwind$diamond_search DD 021001H
	DD	0f00c9210H
$chain$5$diamond_search DD 0c3321H
	DD	04e433H
	DD	05d427H
	DD	06c41bH
	DD	07740fH
	DD	08640aH
	DD	0d3405H
	DD	imagerel diamond_search
	DD	imagerel diamond_search+65
	DD	imagerel $unwind$diamond_search
$chain$6$diamond_search DD 020521H
	DD	095405H
	DD	imagerel diamond_search+65
	DD	imagerel diamond_search+203
	DD	imagerel $chain$5$diamond_search
$chain$7$diamond_search DD 021H
	DD	imagerel diamond_search+65
	DD	imagerel diamond_search+203
	DD	imagerel $chain$5$diamond_search
$chain$8$diamond_search DD 021H
	DD	imagerel diamond_search
	DD	imagerel diamond_search+65
	DD	imagerel $unwind$diamond_search
$unwind$hexagon_search DD 030801H
	DD	0f0046208H
	DD	0d002H
$chain$0$hexagon_search DD 020521H
	DD	0a3405H
	DD	imagerel hexagon_search
	DD	imagerel hexagon_search+60
	DD	imagerel $unwind$hexagon_search
$chain$4$hexagon_search DD 082221H
	DD	04e422H
	DD	06741dH
	DD	0c6411H
	DD	0b5405H
	DD	imagerel hexagon_search+60
	DD	imagerel hexagon_search+65
	DD	imagerel $chain$0$hexagon_search
$chain$5$hexagon_search DD 020521H
	DD	05c405H
	DD	imagerel hexagon_search+65
	DD	imagerel hexagon_search+168
	DD	imagerel $chain$4$hexagon_search
$chain$6$hexagon_search DD 021H
	DD	imagerel hexagon_search+65
	DD	imagerel hexagon_search+168
	DD	imagerel $chain$4$hexagon_search
$chain$7$hexagon_search DD 060021H
	DD	04e400H
	DD	067400H
	DD	0c6400H
	DD	imagerel hexagon_search+60
	DD	imagerel hexagon_search+65
	DD	imagerel $chain$0$hexagon_search
$chain$8$hexagon_search DD 021H
	DD	imagerel hexagon_search
	DD	imagerel hexagon_search+60
	DD	imagerel $unwind$hexagon_search
$unwind$tz_search DD 030801H
	DD	0c0048208H
	DD	06002H
$chain$0$tz_search DD 020521H
	DD	0d3405H
	DD	imagerel tz_search
	DD	imagerel tz_search+65
	DD	imagerel $unwind$tz_search
$chain$2$tz_search DD 040d21H
	DD	08740dH
	DD	0f5405H
	DD	imagerel tz_search+65
	DD	imagerel tz_search+70
	DD	imagerel $chain$0$tz_search
$chain$4$tz_search DD 041121H
	DD	06f411H
	DD	07e405H
	DD	imagerel tz_search+70
	DD	imagerel tz_search+88
	DD	imagerel $chain$2$tz_search
$chain$5$tz_search DD 020021H
	DD	06f400H
	DD	imagerel tz_search+70
	DD	imagerel tz_search+88
	DD	imagerel $chain$2$tz_search
$chain$6$tz_search DD 020021H
	DD	087400H
	DD	imagerel tz_search+65
	DD	imagerel tz_search+70
	DD	imagerel $chain$0$tz_search
$chain$7$tz_search DD 021H
	DD	imagerel tz_search
	DD	imagerel tz_search+65
	DD	imagerel $unwind$tz_search
$unwind$kvz_tz_raster_search DD 0a1a01H
	DD	09e41aH
	DD	08741aH
	DD	07641aH
	DD	06341aH
	DD	0f016321aH
$unwind$kvz_tz_pattern_search DD 0d2901H
	DD	02c7429H
	DD	02b6429H
	DD	02a3429H
	DD	0240129H
	DD	0e01bf01dH
	DD	0c017d019H
	DD	05015H
$unwind$early_terminate DD 0104801H
	DD	027848H
	DD	036843H
	DD	011641cH
	DD	010541cH
	DD	0f341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
$unwind$calc_mvd_cost DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0c00ee010H
	DD	0600b700cH
$chain$0$calc_mvd_cost DD 020521H
	DD	0ad405H
	DD	imagerel calc_mvd_cost
	DD	imagerel calc_mvd_cost+174
	DD	imagerel $unwind$calc_mvd_cost
$chain$1$calc_mvd_cost DD 021H
	DD	imagerel calc_mvd_cost
	DD	imagerel calc_mvd_cost+174
	DD	imagerel $unwind$calc_mvd_cost
$unwind$select_mv_cand DD 0a6801H
	DD	0a7468H
	DD	0c3411H
	DD	0f00d3211H
	DD	0c009e00bH
	DD	050066007H
$chain$1$select_mv_cand DD 020521H
	DD	0bd405H
	DD	imagerel select_mv_cand
	DD	imagerel select_mv_cand+104
	DD	imagerel $unwind$select_mv_cand
$chain$2$select_mv_cand DD 021H
	DD	imagerel select_mv_cand
	DD	imagerel select_mv_cand+104
	DD	imagerel $unwind$select_mv_cand
$unwind$get_mvd_coding_cost DD 020501H
	DD	013405H
$unwind$select_starting_point DD 061401H
	DD	086414H
	DD	063414H
	DD	070103214H
$unwind$mv_in_merge DD 061b01H
	DD	04740fH
	DD	03640aH
	DD	013405H
$unwind$check_mv_cost DD 0e8c01H
	DD	0de48cH
	DD	0e7487H
	DD	0f6482H
	DD	010547dH
	DD	0110117H
	DD	0d00ef010H
	DD	0300ac00cH
$unwind$intmv_within_tile DD 096601H
	DD	03f466H
	DD	026461H
	DD	05740cH
	DD	04340cH
	DD	0e00cH
$unwind$fracmv_within_tile DD 0b8b01H
	DD	07c48bH
	DD	055486H
	DD	06745eH
	DD	04342aH
	DD	0e004f006H
	DD	06002H
$unwind$kvz_search_cu_smp DD 0c5c01H
	DD	09685cH
	DD	0150125H
	DD	0e01cf01eH
	DD	0c018d01aH
	DD	060157016H
	DD	030135014H
$unwind$kvz_search_cu_inter DD 0c1d01H
	DD	011741dH
	DD	010641dH
	DD	0f541dH
	DD	0e341dH
	DD	0f019921dH
	DD	0c015e017H
	ORG $+10
$SG4294942468 DB 'f', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'm', 00H, 'v', 00H
	DB	'_', 00H, 'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'i', 00H, 'n'
	DB	00H, '_', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '(', 00H
	DB	'&', 00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, ',', 00H, ' '
	DB	00H, 'c', 00H, 'u', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'u', 00H
	DB	'-', 00H, '>', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '.', 00H, 'm', 00H, 'v', 00H, '[', 00H, '0', 00H, ']', 00H
	DB	'[', 00H, '0', 00H, ']', 00H, ',', 00H, ' ', 00H, 'c', 00H, 'u'
	DB	00H, 'r', 00H, '_', 00H, 'c', 00H, 'u', 00H, '-', 00H, '>', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'm'
	DB	00H, 'v', 00H, '[', 00H, '0', 00H, ']', 00H, '[', 00H, '1', 00H
	DB	']', 00H, ')', 00H, 00H, 00H
	ORG $+12
$SG4294942469 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '_', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
	ORG $+2
$SG4294942470 DB 'L', 00H, 'X', 00H, '_', 00H, 'i', 00H, 'd', 00H, 'x', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'L', 00H, 'X', 00H, '_', 00H, 'I'
	DB	00H, 'D', 00H, 'X', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'X', 00H
	DB	'_', 00H, 'P', 00H, 'L', 00H, 'U', 00H, 'S', 00H, '_', 00H, '1'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294942471 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 's', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, '_', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
state$ = 112
x$ = 120
y$ = 128
depth$ = 136
lcu$ = 144
inter_cost$ = 152
inter_bitcost$ = 160
kvz_search_cu_inter PROC

; 1995 : {

$LN5:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 1996 :   search_pu_inter(state,

	mov	r14, QWORD PTR inter_bitcost$[rsp]
	mov	edi, r9d
	mov	r15, QWORD PTR inter_cost$[rsp]
	mov	esi, r8d
	mov	r12, QWORD PTR lcu$[rsp]
	mov	ebp, edx
	mov	QWORD PTR [rax-40], r14
	mov	rbx, rcx
	mov	QWORD PTR [rax-48], r15
	mov	QWORD PTR [rax-56], r12
	xor	eax, eax
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], eax
	call	search_pu_inter

; 1997 :                   x, y, depth,
; 1998 :                   SIZE_2Nx2N, 0,
; 1999 :                   lcu,
; 2000 :                   inter_cost,
; 2001 :                   inter_bitcost);
; 2002 : 
; 2003 :   // Calculate more accurate cost when needed
; 2004 :   if (state->encoder_control->cfg.rdo >= 2) {

	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [rax+64], 2
	jl	SHORT $LN2@kvz_search

; 2005 :     kvz_cu_cost_inter_rd2(state,

	mov	QWORD PTR [rsp+48], r14
	mov	r9d, edi
	mov	QWORD PTR [rsp+40], r15
	mov	r8d, esi
	mov	edx, ebp
	mov	QWORD PTR [rsp+32], r12
	mov	rcx, rbx
	call	kvz_cu_cost_inter_rd2
$LN2@kvz_search:

; 2006 :       x, y, depth,
; 2007 :       lcu,
; 2008 :       inter_cost,
; 2009 :       inter_bitcost);
; 2010 :   }
; 2011 : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rdi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	ret	0
kvz_search_cu_inter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
bitcost$1 = 80
width$1$ = 84
y_local$1$ = 88
x_local$1$ = 92
cost$2 = 96
tv928 = 104
$T3 = 112
tv915 = 120
tv924 = 128
state$ = 240
x$ = 248
y$ = 256
depth$ = 264
part_mode$ = 272
lcu$ = 280
tv1123 = 288
inter_cost$ = 288
tv1108 = 296
inter_bitcost$ = 296
kvz_search_cu_smp PROC

; 2036 : {

$LN32:
	mov	rax, rsp
	mov	DWORD PTR [rax+32], r9d
	mov	DWORD PTR [rax+24], r8d
	mov	DWORD PTR [rax+16], edx
	mov	QWORD PTR [rax+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 168				; 000000a8H

; 2037 :   const int num_pu  = kvz_part_mode_num_parts[part_mode];
; 2038 :   const int width   = LCU_WIDTH >> depth;
; 2039 :   const int y_local = SUB_SCU(y);
; 2040 :   const int x_local = SUB_SCU(x);
; 2041 : 
; 2042 :   *inter_cost    = 0;

	mov	r12, QWORD PTR inter_cost$[rsp]
	lea	rbp, OFFSET FLAT:__ImageBase

; 2043 :   *inter_bitcost = 0;

	mov	r13, QWORD PTR inter_bitcost$[rsp]
	mov	r11d, r9d
	movsxd	r9, DWORD PTR part_mode$[rsp]
	mov	r10, rcx

; 2044 : 
; 2045 :   for (int i = 0; i < num_pu; ++i) {

	mov	rbx, QWORD PTR lcu$[rsp]
	mov	ecx, r11d
	mov	r14d, r8d
	movaps	XMMWORD PTR [rax-88], xmm6
	and	r14d, 63				; 0000003fH
	mov	edi, 64					; 00000040H
	sar	edi, cl
	mov	r15d, edx
	movzx	ecx, BYTE PTR kvz_part_mode_num_parts[r9+rbp]
	and	r15d, 63				; 0000003fH
	mov	esi, r8d
	mov	DWORD PTR width$1$[rsp], edi
	xor	r8d, r8d
	mov	DWORD PTR y_local$1$[rsp], r14d
	mov	DWORD PTR x_local$1$[rsp], r15d
	mov	QWORD PTR tv928[rsp], r8
	mov	QWORD PTR [r12], r8
	mov	DWORD PTR [r13], r8d
	mov	QWORD PTR tv924[rsp], rcx
	test	rcx, rcx
	je	$LN3@kvz_search
	movsd	xmm6, QWORD PTR __real@41dfffffffc00000
	movzx	ecx, r9b
	shl	cl, 5
	and	r11b, 7
	mov	BYTE PTR tv1123[rsp], cl
	lea	rcx, QWORD PTR [r9*8]
	shl	r11b, 2
	mov	QWORD PTR tv915[rsp], rcx
	mov	QWORD PTR $T3[rsp], r8
	mov	BYTE PTR tv1108[rsp], r11b
$LL4@kvz_search:

; 2046 :     const int x_pu      = PU_GET_X(part_mode, width, x_local, i);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[rcx+rbp]
	imul	eax, edi
	cdq
	and	edx, 3
	lea	ebp, DWORD PTR [rdx+rax]
	sar	ebp, 2
	add	ebp, r15d

; 2047 :     const int y_pu      = PU_GET_Y(part_mode, width, y_local, i);

	lea	r15, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR kvz_part_mode_offsets[rcx+r15+1]
	imul	eax, edi
	cdq
	and	edx, 3
	lea	esi, DWORD PTR [rdx+rax]

; 2048 :     const int width_pu  = PU_GET_W(part_mode, width, i);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[rcx+r15]
	imul	eax, edi
	sar	esi, 2
	add	esi, r14d
	cdq
	and	edx, 3
	lea	r14d, DWORD PTR [rdx+rax]

; 2049 :     const int height_pu = PU_GET_H(part_mode, width, i);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[rcx+r15+1]
	imul	eax, edi

; 2050 :     cu_info_t *cur_pu   = LCU_GET_CU_AT_PX(lcu, x_pu, y_pu);

	mov	ecx, esi
	sar	ecx, 2
	sar	r14d, 2
	cdq
	and	edx, 3
	lea	r15d, DWORD PTR [rdx+rax]
	imul	edx, ecx, 17
	mov	ecx, ebp
	sar	r15d, 2
	sar	ecx, 2
	add	edx, ecx
	movsxd	rcx, edx

; 2051 : 
; 2052 :     cur_pu->type      = CU_INTER;
; 2053 :     cur_pu->part_size = part_mode;
; 2054 :     cur_pu->depth     = depth;
; 2055 :     cur_pu->qp        = state->qp;
; 2056 : 
; 2057 :     double cost      = MAX_INT;
; 2058 :     uint32_t bitcost = MAX_INT;
; 2059 : 
; 2060 :     search_pu_inter(state, x, y, depth, part_mode, i, lcu, &cost, &bitcost);

	mov	edx, DWORD PTR x$[rsp]
	lea	rdi, QWORD PTR [rcx+rcx*4]
	movzx	ecx, BYTE PTR tv1123[rsp]
	and	cl, 227					; 000000e3H
	or	cl, r11b
	or	cl, 2
	mov	BYTE PTR [rbx+rdi*4+25336], cl
	mov	rcx, r10
	movzx	eax, BYTE PTR [r10+384]
	mov	BYTE PTR [rbx+rdi*4+25342], al
	lea	rax, QWORD PTR bitcost$1[rsp]
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR cost$2[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], rbx
	mov	DWORD PTR [rsp+40], r8d
	mov	r8d, DWORD PTR y$[rsp]
	mov	DWORD PTR [rsp+32], r9d
	mov	r9d, DWORD PTR depth$[rsp]
	movsd	QWORD PTR cost$2[rsp], xmm6
	mov	DWORD PTR bitcost$1[rsp], 2147483647	; 7fffffffH
	call	search_pu_inter

; 2061 : 
; 2062 :     if (cost >= MAX_INT) {

	movsd	xmm0, QWORD PTR cost$2[rsp]
	comisd	xmm0, xmm6
	jae	$LN21@kvz_search

; 2067 :     }
; 2068 : 
; 2069 :     *inter_cost    += cost;

	addsd	xmm0, QWORD PTR [r12]

; 2070 :     *inter_bitcost += bitcost;

	mov	eax, DWORD PTR bitcost$1[rsp]

; 2071 : 
; 2072 :     for (int y = y_pu; y < y_pu + height_pu; y += SCU_WIDTH) {

	lea	r10d, DWORD PTR [r15+rsi]
	add	DWORD PTR [r13], eax
	movsd	QWORD PTR [r12], xmm0
	cmp	esi, r10d
	jge	SHORT $LN2@kvz_search
	lea	r8d, DWORD PTR [r14+rbp]
$LL7@kvz_search:

; 2073 :       for (int x = x_pu; x < x_pu + width_pu; x += SCU_WIDTH) {

	mov	edx, ebp
	cmp	ebp, r8d
	jge	SHORT $LN5@kvz_search
	mov	eax, esi
	sar	eax, 2
	imul	r9d, eax, 17
	npad	9
$LL10@kvz_search:

; 2074 :         cu_info_t *scu = LCU_GET_CU_AT_PX(lcu, x, y);

	mov	eax, edx
	add	edx, 4
	sar	eax, 2
	add	eax, r9d
	cdqe
	lea	rcx, QWORD PTR [rax+rax*4]

; 2075 :         scu->type = CU_INTER;

	and	BYTE PTR [rbx+rcx*4+25336], 254		; 000000feH
	or	BYTE PTR [rbx+rcx*4+25336], 2

; 2076 :         scu->inter = cur_pu->inter;

	movsd	xmm0, QWORD PTR [rbx+rdi*4+25344]
	movsd	QWORD PTR [rbx+rcx*4+25344], xmm0
	mov	eax, DWORD PTR [rbx+rdi*4+25352]
	mov	DWORD PTR [rbx+rcx*4+25352], eax
	cmp	edx, r8d
	jl	SHORT $LL10@kvz_search
$LN5@kvz_search:

; 2071 : 
; 2072 :     for (int y = y_pu; y < y_pu + height_pu; y += SCU_WIDTH) {

	add	esi, 4
	cmp	esi, r10d
	jl	SHORT $LL7@kvz_search
$LN2@kvz_search:

; 2044 : 
; 2045 :   for (int i = 0; i < num_pu; ++i) {

	mov	r8, QWORD PTR tv928[rsp]
	lea	rbp, OFFSET FLAT:__ImageBase
	mov	rax, QWORD PTR $T3[rsp]
	inc	r8d
	mov	rcx, QWORD PTR tv915[rsp]
	inc	rax
	mov	r10, QWORD PTR state$[rsp]
	add	rcx, 2
	mov	r9d, DWORD PTR part_mode$[rsp]
	movzx	r11d, BYTE PTR tv1108[rsp]
	mov	edi, DWORD PTR width$1$[rsp]
	mov	r14d, DWORD PTR y_local$1$[rsp]
	mov	r15d, DWORD PTR x_local$1$[rsp]
	mov	QWORD PTR tv928[rsp], r8
	mov	QWORD PTR $T3[rsp], rax
	mov	QWORD PTR tv915[rsp], rcx
	cmp	rax, QWORD PTR tv924[rsp]
	jl	$LL4@kvz_search

; 2061 : 
; 2062 :     if (cost >= MAX_INT) {

	mov	r11d, DWORD PTR depth$[rsp]
	mov	esi, DWORD PTR y$[rsp]
	mov	edx, DWORD PTR x$[rsp]
$LN3@kvz_search:

; 2077 :       }
; 2078 :     }
; 2079 :   }
; 2080 : 
; 2081 :   // Calculate more accurate cost when needed
; 2082 :   if (state->encoder_control->cfg.rdo >= 2) {

	mov	rcx, QWORD PTR [r10]
	cmp	DWORD PTR [rcx+64], 2
	jl	SHORT $LN12@kvz_search

; 2083 :     kvz_cu_cost_inter_rd2(state,

	mov	QWORD PTR [rsp+48], r13
	mov	r9d, r11d
	mov	QWORD PTR [rsp+40], r12
	mov	r8d, esi
	mov	rcx, r10
	mov	QWORD PTR [rsp+32], rbx
	call	kvz_cu_cost_inter_rd2
	mov	r10, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR [r10]
$LN12@kvz_search:

; 2084 :       x, y, depth,
; 2085 :       lcu,
; 2086 :       inter_cost,
; 2087 :       inter_bitcost);
; 2088 :   }
; 2089 : 
; 2090 :   // Count bits spent for coding the partition mode.
; 2091 :   int smp_extra_bits = 1; // horizontal or vertical
; 2092 :   if (state->encoder_control->cfg.amp_enable) {

	cmp	DWORD PTR [rcx+60], 0
	mov	eax, 1
	je	SHORT $LN14@kvz_search

; 2093 :     smp_extra_bits += 1; // symmetric or asymmetric
; 2094 :     if (part_mode != SIZE_2NxN && part_mode != SIZE_Nx2N) {

	mov	edx, DWORD PTR part_mode$[rsp]
	mov	eax, 2
	cmp	edx, 1
	je	SHORT $LN14@kvz_search
	cmp	edx, eax
	mov	r8d, 3
	cmovne	eax, r8d
$LN14@kvz_search:

; 2095 :       smp_extra_bits += 1; // U,L or D,R
; 2096 :     }
; 2097 :   }
; 2098 :   // The transform is split for SMP and AMP blocks so we need more bits for
; 2099 :   // coding the CBF.
; 2100 :   smp_extra_bits += 6;

	add	eax, 6

; 2101 : 
; 2102 :   *inter_cost += (state->encoder_control->cfg.rdo >= 2 ? state->lambda : state->lambda_sqrt) * smp_extra_bits;

	cmp	DWORD PTR [rcx+64], 2
	jl	SHORT $LN16@kvz_search
	movsd	xmm1, QWORD PTR [r10+368]
	jmp	SHORT $LN17@kvz_search
$LN21@kvz_search:

; 2063 :       // Could not find any motion vector.
; 2064 :       *inter_cost    = MAX_INT;

	mov	rax, 4746794007244308480		; 41dfffffffc00000H

; 2065 :       *inter_bitcost = MAX_INT;

	mov	DWORD PTR [r13], 2147483647		; 7fffffffH
	mov	QWORD PTR [r12], rax

; 2066 :       return;

	jmp	SHORT $LN1@kvz_search
$LN16@kvz_search:

; 2101 : 
; 2102 :   *inter_cost += (state->encoder_control->cfg.rdo >= 2 ? state->lambda : state->lambda_sqrt) * smp_extra_bits;

	movsd	xmm1, QWORD PTR [r10+376]
$LN17@kvz_search:

; 2103 :   *inter_bitcost += smp_extra_bits;

	add	DWORD PTR [r13], eax
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR [r12]
	movsd	QWORD PTR [r12], xmm0
$LN1@kvz_search:

; 2104 : }

	movaps	xmm6, XMMWORD PTR [rsp+144]
	add	rsp, 168				; 000000a8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
kvz_search_cu_smp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_is_set PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	movzx	r9d, cx
	lea	rcx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+r8*4]
	shl	edx, cl
	mov	eax, 0
	test	edx, r9d
	setne	al

; 519  : }

	ret	0
cbf_is_set ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
cbf_is_set_any PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rdx+rax*2]
	test	dx, cx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	eax, edx
	shl	edx, 5
	or	edx, eax
	movzx	eax, cx
	shl	edx, 5
	test	edx, eax

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN3@cbf_is_set
	xor	eax, eax

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
$LN3@cbf_is_set:

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	mov	eax, 1

; 527  :          cbf_is_set(cbf, depth, COLOR_U) ||
; 528  :          cbf_is_set(cbf, depth, COLOR_V);
; 529  : }

	ret	0
cbf_is_set_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
info$ = 32
x$ = 40
y$ = 48
fracmv_within_tile PROC

; 107  : {

	push	rsi
	push	r14
	push	r15

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r15, QWORD PTR [rcx]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, edx
	mov	esi, r8d
	mov	r14d, edx
	mov	r11, rcx
	mov	r10, QWORD PTR [r15]
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN27@fracmv_wit
	dec	eax
	or	eax, -4
	inc	eax
$LN27@fracmv_wit:
	mov	QWORD PTR [rsp+32], rbx
	test	eax, eax
	jne	SHORT $LN17@fracmv_wit
	mov	eax, esi
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN26@fracmv_wit
	dec	eax
	or	eax, -4
	inc	eax
$LN26@fracmv_wit:
	test	eax, eax
	jne	SHORT $LN17@fracmv_wit
	xor	bl, bl
	jmp	SHORT $LN18@fracmv_wit
$LN17@fracmv_wit:
	mov	bl, 1
$LN18@fracmv_wit:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, r14d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN25@fracmv_wit
	dec	eax
	or	eax, -8
	inc	eax
$LN25@fracmv_wit:
	mov	QWORD PTR [rsp+48], rdi
	test	eax, eax
	jne	SHORT $LN19@fracmv_wit
	mov	eax, esi
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN24@fracmv_wit
	dec	eax
	or	eax, -8
	inc	eax
$LN24@fracmv_wit:
	test	eax, eax
	jne	SHORT $LN19@fracmv_wit
	xor	dil, dil
	jmp	SHORT $LN20@fracmv_wit
$LN19@fracmv_wit:
	mov	dil, 1
$LN20@fracmv_wit:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	xor	r9d, r9d
	mov	QWORD PTR [rsp+40], rbp
	mov	QWORD PTR [rsp+56], r12
	cmp	DWORD PTR [r10+172], r9d
	je	$LN10@fracmv_wit
	cmp	DWORD PTR [r10+168], r9d
	je	$LN10@fracmv_wit

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	bl, bl
	je	SHORT $LN3@fracmv_wit

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	lea	r8d, QWORD PTR [r9+4]
	jmp	SHORT $LN5@fracmv_wit
$LN3@fracmv_wit:

; 122  :     } else if (is_frac_chroma) {

	test	dil, dil
	mov	r8d, r9d
	mov	eax, 2
	cmovne	r8d, eax
$LN5@fracmv_wit:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r10+44], r9d
	je	SHORT $LN6@fracmv_wit

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r8d, 10
	jmp	SHORT $LN8@fracmv_wit
$LN6@fracmv_wit:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r10+40], r9d
	je	SHORT $LN8@fracmv_wit

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r8d, 8
$LN8@fracmv_wit:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	eax, DWORD PTR [rcx+40]
	add	eax, DWORD PTR [rcx+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	r12d, DWORD PTR [r10+6536]
	add	eax, r8d
	lea	eax, DWORD PTR [rsi+rax*4]
	cdq
	movzx	ebp, dl
	add	ebp, eax
	mov	eax, DWORD PTR [rcx+32]
	cdq
	sar	ebp, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	ebp, eax
	cmp	ebp, r12d
	jg	$LN21@fracmv_wit

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	ecx, DWORD PTR [rcx+36]
	add	ecx, DWORD PTR [r11+28]
	add	ecx, r8d
	lea	eax, DWORD PTR [r14+rcx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, DWORD PTR [r11+28]
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r10+6532]
	sar	eax, 6
	add	edx, r12d
	sub	r8d, eax
	add	r8d, ebp
	cmp	r8d, edx
	jg	SHORT $LN21@fracmv_wit
$LN10@fracmv_wit:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r10+2360]
	test	eax, eax
	je	SHORT $LN28@fracmv_wit

; 162  :     return true;
; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;
; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN15@fracmv_wit

; 168  :     if (is_frac_luma) {

	test	bl, bl
	je	SHORT $LN13@fracmv_wit

; 169  :       margin = 4 << 2;

	lea	r9d, QWORD PTR [rax+12]
	jmp	SHORT $LN15@fracmv_wit
$LN13@fracmv_wit:

; 170  :     } else if (is_frac_chroma) {

	test	dil, dil
	mov	eax, 8
	cmovne	r9d, eax
$LN15@fracmv_wit:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [r11+28]
	lea	r8d, DWORD PTR [r14+rax*4]
	mov	eax, DWORD PTR [r11+32]
	lea	edx, DWORD PTR [rsi+rax*4]
	cmp	r8d, r9d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	SHORT $LN21@fracmv_wit
	cmp	edx, r9d
	jl	SHORT $LN21@fracmv_wit

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [r15+48]
	mov	r10, QWORD PTR [rax]
	mov	eax, DWORD PTR [r11+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r10+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, r9d
	jl	SHORT $LN21@fracmv_wit

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	ecx, DWORD PTR [r10+20]
	mov	eax, DWORD PTR [r11+40]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, r9d
	jl	SHORT $LN21@fracmv_wit
$LN28@fracmv_wit:

; 188  :          abs_mv.y >= margin &&
; 189  :          from_right >= margin &&
; 190  :          from_bottom >= margin;
; 191  : }

	mov	al, 1
	jmp	SHORT $LN22@fracmv_wit
$LN21@fracmv_wit:
	xor	al, al
$LN22@fracmv_wit:
	mov	r12, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+32]
	pop	r15
	pop	r14
	pop	rsi
	ret	0
fracmv_within_tile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
info$ = 16
x$ = 24
y$ = 32
intmv_within_tile PROC

; 198  : {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rdi
	push	r14

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r14, QWORD PTR [rcx]

; 199  :   return fracmv_within_tile(info, x * 4, y * 4);

	lea	edi, DWORD PTR [rdx*4]

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, edi

; 199  :   return fracmv_within_tile(info, x * 4, y * 4);

	lea	ebx, DWORD PTR [r8*4]
	mov	r10, rcx

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r9, QWORD PTR [r14]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;
; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN27@intmv_with
	dec	eax
	or	eax, -8
	inc	eax
$LN27@intmv_with:
	test	eax, eax
	jne	SHORT $LN21@intmv_with
	mov	eax, ebx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN26@intmv_with
	dec	eax
	or	eax, -8
	inc	eax
$LN26@intmv_with:
	test	eax, eax
	jne	SHORT $LN21@intmv_with
	xor	r11b, r11b
	jmp	SHORT $LN22@intmv_with
$LN21@intmv_with:
	mov	r11b, 1
$LN22@intmv_with:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r9+172], 0
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], r15
	je	$LN12@intmv_with
	cmp	DWORD PTR [r9+168], 0
	je	$LN12@intmv_with

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {
; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;
; 122  :     } else if (is_frac_chroma) {
; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	movzx	r8d, r11b
	add	r8d, r8d
	cmp	DWORD PTR [r9+44], 0
	je	SHORT $LN8@intmv_with

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r8d, 10
	jmp	SHORT $LN10@intmv_with
$LN8@intmv_with:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r9+40], 0
	je	SHORT $LN10@intmv_with

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r8d, 8
$LN10@intmv_with:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	eax, DWORD PTR [rcx+40]
	add	eax, DWORD PTR [rcx+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	r15d, DWORD PTR [r9+6536]
	add	eax, r8d
	lea	eax, DWORD PTR [rbx+rax*4]
	cdq
	movzx	esi, dl
	add	esi, eax
	mov	eax, DWORD PTR [rcx+32]
	cdq
	sar	esi, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	esi, eax
	cmp	esi, r15d
	jg	$LN23@intmv_with

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	ecx, DWORD PTR [rcx+36]
	add	ecx, DWORD PTR [r10+28]
	add	ecx, r8d
	lea	eax, DWORD PTR [rdi+rcx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, DWORD PTR [r10+28]
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r9+6532]
	sar	eax, 6
	add	edx, r15d
	sub	r8d, eax
	add	r8d, esi
	cmp	r8d, edx
	jg	SHORT $LN23@intmv_with
$LN12@intmv_with:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r9+2360]
	test	eax, eax
	je	SHORT $LN28@intmv_with

; 162  :     return true;
; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	xor	edx, edx

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN17@intmv_with

; 168  :     if (is_frac_luma) {
; 169  :       margin = 4 << 2;
; 170  :     } else if (is_frac_chroma) {

	test	r11b, r11b
	mov	eax, 8
	cmovne	edx, eax
$LN17@intmv_with:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [r10+28]
	lea	r9d, DWORD PTR [rdi+rax*4]
	mov	eax, DWORD PTR [r10+32]
	lea	r8d, DWORD PTR [rbx+rax*4]
	cmp	r9d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	SHORT $LN23@intmv_with
	cmp	r8d, edx
	jl	SHORT $LN23@intmv_with

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [r14+48]
	mov	r11, QWORD PTR [rax]
	mov	eax, DWORD PTR [r10+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r11+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r9d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN23@intmv_with

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	ecx, DWORD PTR [r11+20]
	mov	eax, DWORD PTR [r10+40]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN23@intmv_with
$LN28@intmv_with:

; 200  : }

	mov	al, 1
	jmp	SHORT $LN24@intmv_with
$LN23@intmv_with:
	xor	al, al
$LN24@intmv_with:
	mov	r15, QWORD PTR [rsp+24]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rbx, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+40]
	pop	r14
	ret	0
intmv_within_tile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
pic$1$ = 80
optimized_sad$1$ = 88
y$1$ = 176
info$ = 176
x$ = 184
y$ = 192
bitcost$ = 200
check_mv_cost PROC

; 215  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	push	rbx
	push	r12
	push	r13
	push	r15
	sub	rsp, 136				; 00000088H

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r15, QWORD PTR [rcx]

; 199  :   return fracmv_within_tile(info, x * 4, y * 4);

	lea	r12d, DWORD PTR [rdx*4]

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, r12d

; 199  :   return fracmv_within_tile(info, x * 4, y * 4);

	lea	r11d, DWORD PTR [r8*4]
	mov	DWORD PTR y$1$[rsp], r11d

; 215  : {

	mov	r13d, r8d
	mov	rbx, rcx

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r9, QWORD PTR [r15]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;
; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN46@check_mv_c
	dec	eax
	or	eax, -8
	inc	eax
$LN46@check_mv_c:
	test	eax, eax
	jne	SHORT $LN26@check_mv_c
	mov	eax, r11d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN45@check_mv_c
	dec	eax
	or	eax, -8
	inc	eax
$LN45@check_mv_c:
	test	eax, eax
	jne	SHORT $LN26@check_mv_c
	xor	r10b, r10b
	jmp	SHORT $LN27@check_mv_c
$LN26@check_mv_c:
	mov	r10b, 1
$LN27@check_mv_c:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r9+172], 0
	mov	QWORD PTR [rsp+128], rbp
	mov	QWORD PTR [rsp+120], rsi
	mov	QWORD PTR [rsp+112], rdi
	mov	QWORD PTR [rsp+104], r14
	je	$LN17@check_mv_c
	cmp	DWORD PTR [r9+168], 0
	je	$LN17@check_mv_c

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {
; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;
; 122  :     } else if (is_frac_chroma) {
; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	movzx	r8d, r10b
	add	r8d, r8d
	cmp	DWORD PTR [r9+44], 0
	je	SHORT $LN13@check_mv_c

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r8d, 10
	jmp	SHORT $LN15@check_mv_c
$LN13@check_mv_c:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r9+40], 0
	je	SHORT $LN15@check_mv_c

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r8d, 8
$LN15@check_mv_c:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	eax, DWORD PTR [rcx+40]
	add	eax, DWORD PTR [rcx+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	edi, DWORD PTR [r9+6536]
	add	eax, r8d
	mov	esi, DWORD PTR [rcx+28]
	lea	eax, DWORD PTR [r11+rax*4]
	cdq
	movzx	r11d, dl
	add	r11d, eax
	mov	eax, DWORD PTR [rcx+32]
	cdq
	sar	r11d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	r11d, eax
	cmp	r11d, edi
	jg	$LN44@check_mv_c

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	ecx, DWORD PTR [rcx+36]
	add	ecx, esi
	add	ecx, r8d
	lea	eax, DWORD PTR [r12+rcx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, esi
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r9+6532]
	sar	eax, 6
	add	edx, edi
	sub	r8d, eax
	add	r8d, r11d
	cmp	r8d, edx
	jg	$LN44@check_mv_c
	mov	r11d, DWORD PTR y$1$[rsp]
$LN17@check_mv_c:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r9+2360]
	test	eax, eax
	jne	SHORT $LN18@check_mv_c

; 162  :     return true;

	mov	edi, DWORD PTR [rbx+40]
	mov	ebp, DWORD PTR [rbx+36]
	mov	esi, DWORD PTR [rbx+32]
	mov	r14d, DWORD PTR [rbx+28]
	jmp	SHORT $LN2@check_mv_c
$LN18@check_mv_c:

; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	xor	edx, edx

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN22@check_mv_c

; 168  :     if (is_frac_luma) {
; 169  :       margin = 4 << 2;
; 170  :     } else if (is_frac_chroma) {

	test	r10b, r10b
	mov	eax, 8
	cmovne	edx, eax
$LN22@check_mv_c:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	r14d, DWORD PTR [rbx+28]
	mov	esi, DWORD PTR [rbx+32]
	lea	r9d, DWORD PTR [r12+r14*4]
	lea	r8d, DWORD PTR [r11+rsi*4]
	cmp	r9d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	$LN44@check_mv_c
	cmp	r8d, edx
	jl	$LN44@check_mv_c

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [r15+48]
	mov	ebp, DWORD PTR [rbx+36]
	mov	r10, QWORD PTR [rax]
	lea	eax, DWORD PTR [rbp*4]
	mov	ecx, DWORD PTR [r10+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r9d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN44@check_mv_c

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	edi, DWORD PTR [rbx+40]
	mov	ecx, DWORD PTR [r10+20]
	shl	ecx, 2
	lea	eax, DWORD PTR [rdi*4]
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN44@check_mv_c
$LN2@check_mv_c:

; 216  :   if (!intmv_within_tile(info, x, y)) return false;
; 217  : 
; 218  :   uint32_t bitcost = 0;
; 219  :   uint32_t cost = kvz_image_calc_sad(

	mov	rax, QWORD PTR [rbx+144]
	mov	rcx, QWORD PTR [rbx+8]
	mov	DWORD PTR bitcost$[rsp], 0
	mov	QWORD PTR optimized_sad$1$[rsp], rax
	mov	rax, QWORD PTR [r15+48]
	mov	QWORD PTR pic$1$[rsp], rcx
	mov	r15d, DWORD PTR [rax+24]
	mov	r12d, DWORD PTR [rax+20]
	add	r15d, esi
	add	r12d, r14d
	add	r15d, r13d
	add	r12d, DWORD PTR x$[rsp]
	mov	r13, QWORD PTR [rbx+16]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 410  :   assert(pic_x >= 0 && pic_x <= pic->width - block_width);

	test	r14d, r14d
	js	SHORT $LN34@check_mv_c
	mov	eax, DWORD PTR [rcx+64]
	sub	eax, ebp
	cmp	r14d, eax
	jle	SHORT $LN35@check_mv_c
$LN34@check_mv_c:
	mov	r8d, 410				; 0000019aH
	lea	rdx, OFFSET FLAT:$SG4294955948
	lea	rcx, OFFSET FLAT:$SG4294955947
	call	QWORD PTR __imp__wassert
	mov	rcx, QWORD PTR pic$1$[rsp]
$LN35@check_mv_c:

; 411  :   assert(pic_y >= 0 && pic_y <= pic->height - block_height);

	test	esi, esi
	js	SHORT $LN36@check_mv_c
	mov	eax, DWORD PTR [rcx+68]
	sub	eax, edi
	cmp	esi, eax
	jle	SHORT $LN37@check_mv_c
$LN36@check_mv_c:
	mov	r8d, 411				; 0000019bH
	lea	rdx, OFFSET FLAT:$SG4294955946
	lea	rcx, OFFSET FLAT:$SG4294955945
	call	QWORD PTR __imp__wassert
	mov	rcx, QWORD PTR pic$1$[rsp]
$LN37@check_mv_c:

; 412  : 
; 413  :   uint32_t res;
; 414  : 
; 415  :   if (ref_x >= 0 && ref_x <= ref->width  - block_width &&
; 416  :       ref_y >= 0 && ref_y <= ref->height - block_height)

	test	r12d, r12d
	js	SHORT $LN31@check_mv_c
	mov	eax, DWORD PTR [r13+64]
	sub	eax, ebp
	cmp	r12d, eax
	jg	SHORT $LN31@check_mv_c
	test	r15d, r15d
	js	SHORT $LN31@check_mv_c
	mov	eax, DWORD PTR [r13+68]
	sub	eax, edi
	cmp	r15d, eax
	jg	SHORT $LN31@check_mv_c

; 417  :   {
; 418  :     // Reference block is completely inside the frame, so just calculate the
; 419  :     // SAD directly. This is the most common case, which is why it's first.
; 420  :     const kvz_pixel *pic_data = &pic->y[pic_y * pic->stride + pic_x];

	mov	r8d, DWORD PTR [rcx+72]
	mov	eax, r8d
	imul	eax, esi
	add	eax, r14d
	movsxd	r10, eax
	add	r10, QWORD PTR [rcx+16]

; 421  :     const kvz_pixel *ref_data = &ref->y[ref_y * ref->stride + ref_x];

	mov	ecx, DWORD PTR [r13+72]
	mov	eax, ecx
	imul	eax, r15d
	add	eax, r12d
	movsxd	rdx, eax
	add	rdx, QWORD PTR [r13+16]

; 225  :   if (optimized_sad != NULL)

	mov	rax, QWORD PTR optimized_sad$1$[rsp]
	test	rax, rax
	je	SHORT $LN39@check_mv_c

; 226  :     return optimized_sad(data1, data2, height, stride1, stride2);

	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, r8d
	mov	r8d, edi
	mov	rcx, r10
	call	rax
	jmp	SHORT $LN47@check_mv_c
$LN39@check_mv_c:

; 227  :   else
; 228  :     return kvz_reg_sad(data1, data2, width, height, stride1, stride2);

	mov	DWORD PTR [rsp+40], ecx
	mov	r9d, edi
	mov	DWORD PTR [rsp+32], r8d
	mov	rcx, r10
	mov	r8d, ebp
	call	QWORD PTR kvz_reg_sad

; 430  :   } else {

	jmp	SHORT $LN47@check_mv_c
$LN31@check_mv_c:

; 431  :     // Call a routine that knows how to interpolate pixels outside the frame.
; 432  :     res = image_interpolated_sad(pic, ref, pic_x, pic_y, ref_x, ref_y, block_width, block_height, optimized_sad);

	mov	rax, QWORD PTR optimized_sad$1$[rsp]
	mov	r9d, esi
	mov	QWORD PTR [rsp+64], rax
	mov	r8d, r14d
	mov	DWORD PTR [rsp+56], edi
	mov	rdx, r13
	mov	DWORD PTR [rsp+48], ebp
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], r12d
	call	image_interpolated_sad
$LN47@check_mv_c:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 231  :   if (cost >= info->best_cost) return false;

	mov	edi, eax
	cmp	eax, DWORD PTR [rbx+136]
	jae	$LN44@check_mv_c

; 232  : 
; 233  :   cost += info->mvd_cost_func(

	mov	esi, DWORD PTR x$[rsp]
	lea	rax, QWORD PTR bitcost$[rsp]
	mov	r8d, DWORD PTR y$[rsp]
	lea	rdx, QWORD PTR [rbx+44]
	mov	QWORD PTR [rsp+64], rax
	lea	rcx, QWORD PTR [rbx+52]
	mov	eax, DWORD PTR [rbx+24]
	mov	r9d, 2
	mov	DWORD PTR [rsp+56], eax
	movzx	eax, WORD PTR [rbx+112]
	mov	WORD PTR [rsp+48], ax
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR [rbx]
	mov	QWORD PTR [rsp+32], rdx
	mov	edx, esi
	call	QWORD PTR [rbx+120]
	add	eax, edi

; 234  :       info->state,
; 235  :       x, y, 2,
; 236  :       info->mv_cand,
; 237  :       info->merge_cand,
; 238  :       info->num_merge_cand,
; 239  :       info->ref_idx,
; 240  :       &bitcost
; 241  :   );
; 242  : 
; 243  :   if (cost >= info->best_cost) return false;

	cmp	eax, DWORD PTR [rbx+136]
	jae	SHORT $LN44@check_mv_c

; 244  : 
; 245  :   // Set to motion vector in quarter pixel precision.
; 246  :   info->best_mv.x = x * 4;

	lea	ecx, DWORD PTR [rsi*4]

; 247  :   info->best_mv.y = y * 4;
; 248  :   info->best_cost = cost;

	mov	DWORD PTR [rbx+136], eax

; 249  :   info->best_bitcost = bitcost;

	mov	eax, DWORD PTR bitcost$[rsp]
	mov	DWORD PTR [rbx+128], ecx
	mov	ecx, DWORD PTR y$1$[rsp]
	mov	DWORD PTR [rbx+140], eax

; 250  : 
; 251  :   return true;

	mov	al, 1
	mov	DWORD PTR [rbx+132], ecx
	jmp	SHORT $LN1@check_mv_c
$LN44@check_mv_c:

; 234  :       info->state,
; 235  :       x, y, 2,
; 236  :       info->mv_cand,
; 237  :       info->merge_cand,
; 238  :       info->num_merge_cand,
; 239  :       info->ref_idx,
; 240  :       &bitcost
; 241  :   );
; 242  : 
; 243  :   if (cost >= info->best_cost) return false;

	xor	al, al
$LN1@check_mv_c:
	mov	r14, QWORD PTR [rsp+104]

; 252  : }

	mov	rdi, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+128]
	add	rsp, 136				; 00000088H
	pop	r15
	pop	r13
	pop	r12
	pop	rbx
	ret	0
check_mv_cost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
symbol$ = 8
get_ep_ex_golomb_bitcost PROC

; 257  :   // Calculate 2 * log2(symbol + 2)
; 258  : 
; 259  :   unsigned bins = 0;

	add	ecx, 2

; 260  :   symbol += 2;
; 261  :   if (symbol >= 1 << 8) { bins += 16; symbol >>= 8; }
; 262  :   if (symbol >= 1 << 4) { bins += 8; symbol >>= 4; }

	mov	r8d, 16
	mov	eax, ecx
	shr	eax, 8
	cmp	ecx, 256				; 00000100H
	cmovb	eax, ecx
	xor	edx, edx
	cmp	ecx, 256				; 00000100H
	cmovb	r8d, edx
	cmp	eax, 16
	jb	SHORT $LN3@get_ep_ex_
	add	r8d, 8
	shr	eax, 4
$LN3@get_ep_ex_:

; 263  :   if (symbol >= 1 << 2) { bins += 4; symbol >>= 2; }
; 264  :   if (symbol >= 1 << 1) { bins += 2; }

	cmp	eax, 4
	lea	edx, DWORD PTR [r8+4]
	mov	ecx, eax
	cmovb	edx, r8d
	shr	ecx, 2
	cmp	eax, 4
	cmovb	ecx, eax

; 265  : 
; 266  :   // TODO: It might be a good idea to put a small slope on this function to
; 267  :   // make sure any search function that follows the gradient heads towards
; 268  :   // a smaller MVD, but that would require fractinal costs and bits being
; 269  :   // used everywhere in inter search.
; 270  :   // return num_bins + 0.001 * symbol;
; 271  : 
; 272  :   return bins;

	cmp	ecx, 2
	lea	eax, DWORD PTR [rdx+2]
	cmovb	eax, edx

; 273  : }

	ret	0
get_ep_ex_golomb_bitcost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
info$ = 8
mv$ = 16
mv_in_merge PROC

; 281  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi

; 282  :   for (int i = 0; i < info->num_merge_cand; ++i) {

	movsxd	rdi, DWORD PTR [rcx+112]
	mov	rbx, rcx
	mov	QWORD PTR [rsp+16], rdx
	test	rdi, rdi
	jle	SHORT $LN13@mv_in_merg
	mov	esi, DWORD PTR mv$[rsp+4]
	lea	r9, QWORD PTR [rcx+52]
	xor	eax, eax
	mov	r11d, eax
	npad	3
$LL4@mv_in_merg:

; 283  :     if (info->merge_cand[i].dir == 3) continue;

	movzx	r8d, BYTE PTR [r9]
	cmp	r8b, 3
	je	SHORT $LN2@mv_in_merg

; 284  :     const vector2d_t merge_mv = {

	add	r8, r11
	movsx	r10d, WORD PTR [rbx+r8*4+54]
	movsx	ecx, WORD PTR [rbx+r8*4+52]
	add	r10d, 2
	add	ecx, 2
	sar	r10d, 2
	sar	ecx, 2
	cmp	ecx, edx

; 285  :       (info->merge_cand[i].mv[info->merge_cand[i].dir - 1][0] + 2) >> 2,
; 286  :       (info->merge_cand[i].mv[info->merge_cand[i].dir - 1][1] + 2) >> 2
; 287  :     };
; 288  :     if (merge_mv.x == mv.x && merge_mv.y == mv.y) {

	jne	SHORT $LN2@mv_in_merg
	cmp	r10d, esi
	je	SHORT $LN9@mv_in_merg
$LN2@mv_in_merg:

; 282  :   for (int i = 0; i < info->num_merge_cand; ++i) {

	inc	rax
	add	r9, 12
	add	r11, 3
	cmp	rax, rdi
	jl	SHORT $LL4@mv_in_merg
$LN13@mv_in_merg:

; 289  :       return true;
; 290  :     }
; 291  :   }
; 292  :   return false;

	xor	al, al

; 293  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+24]
	mov	rdi, QWORD PTR [rsp+32]
	ret	0
$LN9@mv_in_merg:
	mov	rbx, QWORD PTR [rsp+8]
	mov	al, 1
	mov	rsi, QWORD PTR [rsp+24]
	mov	rdi, QWORD PTR [rsp+32]
	ret	0
mv_in_merge ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
info$ = 48
extra_mv$ = 56
select_starting_point PROC

; 303  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+16], rdx
	push	rdi
	sub	rsp, 32					; 00000020H

; 304  :   // Check the 0-vector, so we can ignore all 0-vectors in the merge cand list.
; 305  :   check_mv_cost(info, 0, 0);

	xor	r8d, r8d
	xor	edx, edx
	mov	rdi, rcx
	call	check_mv_cost

; 306  : 
; 307  :   // Change to integer precision.
; 308  :   extra_mv.x >>= 2;

	mov	esi, DWORD PTR extra_mv$[rsp]

; 309  :   extra_mv.y >>= 2;

	mov	ebx, DWORD PTR extra_mv$[rsp+4]
	sar	esi, 2
	sar	ebx, 2
	mov	DWORD PTR extra_mv$[rsp], esi
	mov	DWORD PTR extra_mv$[rsp+4], ebx
	test	esi, esi

; 310  : 
; 311  :   // Check mv_in if it's not one of the merge candidates.
; 312  :   if ((extra_mv.x != 0 || extra_mv.y != 0) && !mv_in_merge(info, extra_mv)) {

	jne	SHORT $LN6@select_sta
	test	ebx, ebx
	je	SHORT $LN5@select_sta
$LN6@select_sta:
	mov	rdx, QWORD PTR extra_mv$[rsp]
	mov	rcx, rdi
	call	mv_in_merge
	test	al, al
	jne	SHORT $LN5@select_sta

; 313  :     check_mv_cost(info, extra_mv.x, extra_mv.y);

	mov	r8d, ebx
	mov	edx, esi
	mov	rcx, rdi
	call	check_mv_cost
$LN5@select_sta:

; 314  :   }
; 315  : 
; 316  :   // Go through candidates
; 317  :   for (unsigned i = 0; i < info->num_merge_cand; ++i) {

	xor	ebx, ebx
	cmp	DWORD PTR [rdi+112], ebx
	jbe	SHORT $LN3@select_sta
	npad	12
$LL4@select_sta:

; 318  :     if (info->merge_cand[i].dir == 3) continue;

	lea	rax, QWORD PTR [rbx+rbx*2]
	movzx	edx, BYTE PTR [rdi+rax*4+52]
	cmp	dl, 3
	je	SHORT $LN2@select_sta

; 319  : 
; 320  :     int x = (info->merge_cand[i].mv[info->merge_cand[i].dir - 1][0] + 2) >> 2;

	lea	r8, QWORD PTR [rbx+rbx*2]
	add	r8, rdx
	movsx	edx, WORD PTR [rdi+r8*4+52]

; 321  :     int y = (info->merge_cand[i].mv[info->merge_cand[i].dir - 1][1] + 2) >> 2;

	movsx	r8d, WORD PTR [rdi+r8*4+54]
	add	edx, 2
	add	r8d, 2
	sar	edx, 2
	sar	r8d, 2

; 322  : 
; 323  :     if (x == 0 && y == 0) continue;

	test	edx, edx
	jne	SHORT $LN8@select_sta
	test	r8d, r8d
	je	SHORT $LN2@select_sta
$LN8@select_sta:

; 324  : 
; 325  :     check_mv_cost(info, x, y);

	mov	rcx, rdi
	call	check_mv_cost
$LN2@select_sta:

; 314  :   }
; 315  : 
; 316  :   // Go through candidates
; 317  :   for (unsigned i = 0; i < info->num_merge_cand; ++i) {

	inc	ebx
	cmp	ebx, DWORD PTR [rdi+112]
	jb	SHORT $LL4@select_sta
$LN3@select_sta:

; 326  :   }
; 327  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
select_starting_point ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
state$ = 8
cabac$ = 16
mvd_hor$ = 24
mvd_ver$ = 32
get_mvd_coding_cost PROC

; 334  : {

	mov	QWORD PTR [rsp+8], rbx

; 262  :   if (symbol >= 1 << 4) { bins += 8; symbol >>= 4; }

	xor	ebx, ebx

; 335  :   unsigned bitcost = 0;
; 336  :   const vector2d_t abs_mvd = { abs(mvd_hor), abs(mvd_ver) };

	mov	eax, r9d
	cdq

; 262  :   if (symbol >= 1 << 4) { bins += 8; symbol >>= 4; }

	mov	r9d, 16

; 335  :   unsigned bitcost = 0;
; 336  :   const vector2d_t abs_mvd = { abs(mvd_hor), abs(mvd_ver) };

	mov	r11d, eax
	mov	eax, r8d
	xor	r11d, edx

; 262  :   if (symbol >= 1 << 4) { bins += 8; symbol >>= 4; }

	mov	r8d, r9d

; 335  :   unsigned bitcost = 0;
; 336  :   const vector2d_t abs_mvd = { abs(mvd_hor), abs(mvd_ver) };

	sub	r11d, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 259  :   unsigned bins = 0;

	add	eax, 2

; 260  :   symbol += 2;
; 261  :   if (symbol >= 1 << 8) { bins += 16; symbol >>= 8; }
; 262  :   if (symbol >= 1 << 4) { bins += 8; symbol >>= 4; }

	cmp	eax, 256				; 00000100H
	mov	edx, eax
	cmovb	r8d, ebx
	shr	edx, 8
	cmp	eax, 256				; 00000100H
	cmovb	edx, eax
	cmp	edx, r9d
	jb	SHORT $LN5@get_mvd_co
	add	r8d, 8
	shr	edx, 4
$LN5@get_mvd_co:

; 263  :   if (symbol >= 1 << 2) { bins += 4; symbol >>= 2; }
; 264  :   if (symbol >= 1 << 1) { bins += 2; }

	cmp	edx, 4
	lea	ecx, DWORD PTR [r8+4]
	mov	eax, edx
	cmovb	ecx, r8d
	shr	eax, 2
	cmp	edx, 4
	cmovb	eax, edx

; 337  : 
; 338  :   bitcost += get_ep_ex_golomb_bitcost(abs_mvd.x) << CTX_FRAC_BITS;

	cmp	eax, 2
	lea	r10d, DWORD PTR [rcx+2]

; 259  :   unsigned bins = 0;

	lea	eax, DWORD PTR [r11+2]

; 337  : 
; 338  :   bitcost += get_ep_ex_golomb_bitcost(abs_mvd.x) << CTX_FRAC_BITS;

	cmovb	r10d, ecx

; 262  :   if (symbol >= 1 << 4) { bins += 8; symbol >>= 4; }

	mov	r8d, eax
	cmp	eax, 256				; 00000100H
	cmovb	r9d, ebx
	shr	r8d, 8
	cmp	eax, 256				; 00000100H
	cmovb	r8d, eax
	cmp	r8d, 16
	jb	SHORT $LN11@get_mvd_co
	add	r9d, 8
	shr	r8d, 4
$LN11@get_mvd_co:

; 343  : }

	mov	rbx, QWORD PTR [rsp+8]

; 264  :   if (symbol >= 1 << 1) { bins += 2; }

	lea	edx, DWORD PTR [r9+4]
	cmp	r8d, 4
	mov	ecx, r8d
	cmovb	edx, r9d
	shr	ecx, 2
	cmp	r8d, 4
	cmovb	ecx, r8d

; 339  :   bitcost += get_ep_ex_golomb_bitcost(abs_mvd.y) << CTX_FRAC_BITS;

	cmp	ecx, 2
	lea	eax, DWORD PTR [rdx+2]
	cmovb	eax, edx

; 340  : 
; 341  :   // Round and shift back to integer bits.
; 342  :   return (bitcost + CTX_FRAC_HALF_BIT) >> CTX_FRAC_BITS;

	add	eax, r10d
	shl	eax, 15
	shr	eax, 15

; 343  : }

	ret	0
get_mvd_coding_cost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
state$ = 80
mv_cand$ = 88
mv_x$ = 96
mv_y$ = 104
cost_out$ = 112
select_mv_cand PROC

; 351  : {

	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 352  :   const bool same_cand =

	mov	rsi, QWORD PTR cost_out$[rsp]
	mov	r12, rcx
	movsx	ecx, WORD PTR [rdx]
	mov	ebp, r9d
	mov	r14d, r8d
	mov	rbx, rdx
	cmp	cx, WORD PTR [rdx+4]
	jne	SHORT $LN13@select_mv_
	movzx	edx, WORD PTR [rdx+2]
	cmp	dx, WORD PTR [rbx+6]
	jne	SHORT $LN13@select_mv_
	mov	r15b, 1

; 353  :     (mv_cand[0][0] == mv_cand[1][0] && mv_cand[0][1] == mv_cand[1][1]);
; 354  : 
; 355  :   if (same_cand && !cost_out) {

	test	rsi, rsi
	jne	SHORT $LN2@select_mv_

; 356  :     // Pick the first one if both candidates are the same.
; 357  :     return 0;

	xor	eax, eax

; 386  :   }
; 387  : 
; 388  :   // Pick the second candidate if it has lower cost.
; 389  :   return cand2_cost < cand1_cost ? 1 : 0;
; 390  : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN13@select_mv_:

; 352  :   const bool same_cand =

	movzx	edx, WORD PTR [rbx+2]
	xor	r15b, r15b
$LN2@select_mv_:

; 358  :   }
; 359  : 
; 360  :   uint32_t (*mvd_coding_cost)(const encoder_state_t * const state,
; 361  :                               const cabac_data_t*,
; 362  :                               int32_t, int32_t);
; 363  :   if (state->encoder_control->cfg.mv_rdo) {
; 364  :     mvd_coding_cost = kvz_get_mvd_coding_cost_cabac;
; 365  :   } else {
; 366  :     mvd_coding_cost = get_mvd_coding_cost;
; 367  :   }
; 368  : 
; 369  :   uint32_t cand1_cost = mvd_coding_cost(

	mov	rax, QWORD PTR [r12]
	lea	r8, OFFSET FLAT:get_mvd_coding_cost
	mov	QWORD PTR [rsp+80], rdi
	mov	QWORD PTR [rsp+88], r13
	lea	r13, OFFSET FLAT:kvz_get_mvd_coding_cost_cabac
	cmp	BYTE PTR [rax+2356], 0
	movsx	eax, dx
	lea	rdx, QWORD PTR [r12+128]
	cmove	r13, r8
	mov	r8d, r14d
	sub	r8d, ecx
	sub	r9d, eax
	mov	rcx, r12
	call	r13
	mov	edi, eax

; 370  :       state, &state->cabac,
; 371  :       mv_x - mv_cand[0][0],
; 372  :       mv_y - mv_cand[0][1]);
; 373  : 
; 374  :   uint32_t cand2_cost;
; 375  :   if (same_cand) {

	test	r15b, r15b
	je	SHORT $LN5@select_mv_

; 376  :     cand2_cost = cand1_cost;

	mov	edx, eax

; 377  :   } else {

	jmp	SHORT $LN6@select_mv_
$LN5@select_mv_:

; 378  :     cand2_cost = mvd_coding_cost(

	movsx	eax, WORD PTR [rbx+6]
	lea	rdx, QWORD PTR [r12+128]
	sub	ebp, eax
	mov	rcx, r12
	movsx	eax, WORD PTR [rbx+4]
	mov	r9d, ebp
	sub	r14d, eax
	mov	r8d, r14d
	call	r13
	mov	edx, eax
$LN6@select_mv_:

; 379  :       state, &state->cabac,
; 380  :       mv_x - mv_cand[1][0],
; 381  :       mv_y - mv_cand[1][1]);
; 382  :   }
; 383  : 
; 384  :   if (cost_out) {

	mov	r13, QWORD PTR [rsp+88]
	test	rsi, rsi
	je	SHORT $LN7@select_mv_

; 385  :     *cost_out = MIN(cand1_cost, cand2_cost);

	cmp	edi, edx
	mov	ecx, edx
	cmovb	ecx, edi
	mov	DWORD PTR [rsi], ecx
$LN7@select_mv_:

; 386  :   }
; 387  : 
; 388  :   // Pick the second candidate if it has lower cost.
; 389  :   return cand2_cost < cand1_cost ? 1 : 0;
; 390  : }

	mov	rbx, QWORD PTR [rsp+96]
	xor	eax, eax
	cmp	edx, edi
	mov	rdi, QWORD PTR [rsp+80]
	setb	al
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
select_mv_cand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
state$ = 80
x$ = 88
y$ = 96
mv_shift$ = 104
mv_cand$ = 112
merge_cand$ = 120
num_cand$ = 128
ref_idx$ = 136
bitcost$ = 144
calc_mvd_cost PROC

; 402  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 403  :   uint32_t temp_bitcost = 0;
; 404  :   uint32_t merge_idx;
; 405  :   int8_t merged      = 0;
; 406  : 
; 407  :   x *= 1 << mv_shift;
; 408  :   y *= 1 << mv_shift;
; 409  : 
; 410  :   // Check every candidate to find a match
; 411  :   for(merge_idx = 0; merge_idx < (uint32_t)num_cand; merge_idx++) {

	movsx	r15d, WORD PTR num_cand$[rsp]
	mov	r14, rcx
	mov	rdi, QWORD PTR mv_cand$[rsp]
	mov	ecx, r9d
	mov	esi, r8d
	mov	ebp, edx
	shl	ebp, cl
	xor	r9d, r9d
	shl	esi, cl
	test	r15d, r15d
	je	SHORT $LN27@calc_mvd_c

; 413  :     if (merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][0] == x &&
; 414  :         merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][1] == y &&

	mov	r12d, DWORD PTR ref_idx$[rsp]
	mov	r8, QWORD PTR merge_cand$[rsp]
	npad	8
$LL4@calc_mvd_c:

; 412  :     if (merge_cand[merge_idx].dir == 3) continue;

	lea	rax, QWORD PTR [r9+r9*2]
	mov	ecx, r9d
	lea	r10, QWORD PTR [r8+rax*4]
	movzx	eax, BYTE PTR [r8+rax*4]
	cmp	al, 3
	je	SHORT $LN2@calc_mvd_c

; 413  :     if (merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][0] == x &&
; 414  :         merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][1] == y &&

	lea	rdx, QWORD PTR [rax-1]
	mov	ebx, eax
	lea	r11, QWORD PTR [rdx+r9*2]
	add	r11, rcx
	movsx	eax, WORD PTR [r8+r11*4+4]
	cmp	eax, ebp
	jne	SHORT $LN2@calc_mvd_c
	movsx	eax, WORD PTR [r8+r11*4+6]
	cmp	eax, esi
	jne	SHORT $LN2@calc_mvd_c
	movzx	ecx, BYTE PTR [rbx+r10]
	mov	rax, QWORD PTR [r14+40]
	shl	rdx, 4
	add	rcx, rdx
	movzx	ecx, BYTE PTR [rcx+rax+49]
	cmp	ecx, r12d
	je	$LN7@calc_mvd_c
$LN2@calc_mvd_c:

; 403  :   uint32_t temp_bitcost = 0;
; 404  :   uint32_t merge_idx;
; 405  :   int8_t merged      = 0;
; 406  : 
; 407  :   x *= 1 << mv_shift;
; 408  :   y *= 1 << mv_shift;
; 409  : 
; 410  :   // Check every candidate to find a match
; 411  :   for(merge_idx = 0; merge_idx < (uint32_t)num_cand; merge_idx++) {

	inc	r9d
	cmp	r9d, r15d
	jb	SHORT $LL4@calc_mvd_c
$LN27@calc_mvd_c:

; 352  :   const bool same_cand =

	movsx	edx, WORD PTR [rdi]
	mov	QWORD PTR [rsp+80], r13
	cmp	dx, WORD PTR [rdi+4]
	jne	SHORT $LN26@calc_mvd_c
	movzx	ecx, WORD PTR [rdi+2]
	cmp	cx, WORD PTR [rdi+6]
	jne	SHORT $LN26@calc_mvd_c
	mov	r15b, 1
	jmp	SHORT $LN18@calc_mvd_c
$LN26@calc_mvd_c:
	movzx	ecx, WORD PTR [rdi+2]
	xor	r15b, r15b
$LN18@calc_mvd_c:

; 353  :     (mv_cand[0][0] == mv_cand[1][0] && mv_cand[0][1] == mv_cand[1][1]);
; 354  : 
; 355  :   if (same_cand && !cost_out) {
; 356  :     // Pick the first one if both candidates are the same.
; 357  :     return 0;
; 358  :   }
; 359  : 
; 360  :   uint32_t (*mvd_coding_cost)(const encoder_state_t * const state,
; 361  :                               const cabac_data_t*,
; 362  :                               int32_t, int32_t);
; 363  :   if (state->encoder_control->cfg.mv_rdo) {
; 364  :     mvd_coding_cost = kvz_get_mvd_coding_cost_cabac;
; 365  :   } else {
; 366  :     mvd_coding_cost = get_mvd_coding_cost;
; 367  :   }
; 368  : 
; 369  :   uint32_t cand1_cost = mvd_coding_cost(

	mov	rax, QWORD PTR [r14]
	lea	r8, OFFSET FLAT:get_mvd_coding_cost
	mov	r9d, esi
	lea	r12, OFFSET FLAT:kvz_get_mvd_coding_cost_cabac
	cmp	BYTE PTR [rax+2356], 0
	movsx	eax, cx
	mov	rcx, r14
	cmove	r12, r8
	mov	r8d, ebp
	sub	r8d, edx
	sub	r9d, eax
	lea	rdx, QWORD PTR [r14+128]
	call	r12
	mov	ebx, eax

; 370  :       state, &state->cabac,
; 371  :       mv_x - mv_cand[0][0],
; 372  :       mv_y - mv_cand[0][1]);
; 373  : 
; 374  :   uint32_t cand2_cost;
; 375  :   if (same_cand) {

	test	r15b, r15b
	je	SHORT $LN13@calc_mvd_c

; 376  :     cand2_cost = cand1_cost;

	mov	r9d, eax

; 377  :   } else {

	jmp	SHORT $LN14@calc_mvd_c
$LN13@calc_mvd_c:

; 378  :     cand2_cost = mvd_coding_cost(

	movsx	eax, WORD PTR [rdi+6]
	lea	rdx, QWORD PTR [r14+128]
	sub	esi, eax
	mov	rcx, r14
	movsx	eax, WORD PTR [rdi+4]
	mov	r9d, esi
	sub	ebp, eax
	mov	r8d, ebp
	call	r12
	mov	r9d, eax
$LN14@calc_mvd_c:

; 379  :       state, &state->cabac,
; 380  :       mv_x - mv_cand[1][0],
; 381  :       mv_y - mv_cand[1][1]);
; 382  :   }
; 383  : 
; 384  :   if (cost_out) {
; 385  :     *cost_out = MIN(cand1_cost, cand2_cost);

	mov	r13, QWORD PTR [rsp+80]
	cmp	ebx, r9d
	cmovb	r9d, ebx
$LN7@calc_mvd_c:

; 415  :         state->frame->ref_LX[merge_cand[merge_idx].dir - 1][
; 416  :           merge_cand[merge_idx].ref[merge_cand[merge_idx].dir - 1]
; 417  :         ] == ref_idx) {
; 418  :       temp_bitcost += merge_idx;
; 419  :       merged = 1;
; 420  :       break;
; 421  :     }
; 422  :   }
; 423  : 
; 424  :   // Check mvd cost only if mv is not merged
; 425  :   if (!merged) {
; 426  :     uint32_t mvd_cost = 0;
; 427  :     select_mv_cand(state, mv_cand, x, y, &mvd_cost);
; 428  :     temp_bitcost += mvd_cost;
; 429  :   }
; 430  :   *bitcost = temp_bitcost;

	mov	rcx, QWORD PTR bitcost$[rsp]

; 431  :   return temp_bitcost*(int32_t)(state->lambda_sqrt + 0.5);
; 432  : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	DWORD PTR [rcx], r9d
	movsd	xmm0, QWORD PTR [r14+376]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si eax, xmm0
	imul	eax, r9d
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
calc_mvd_cost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
k$1$ = 112
info$ = 112
early_terminate PROC

; 436  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 437  :   static const vector2d_t small_hexbs[7] = {
; 438  :       { 0, -1 }, { -1, 0 }, { 0, 1 }, { 1, 0 },
; 439  :       { 0, -1 }, { -1, 0 }, { 0, 0 },
; 440  :   };
; 441  : 
; 442  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	r15d, DWORD PTR [rcx+128]

; 443  : 
; 444  :   int first_index = 0;
; 445  :   int last_index = 3;
; 446  : 
; 447  :   for (int k = 0; k < 2; ++k) {

	lea	r9, OFFSET FLAT:?small_hexbs@?1??early_terminate@@9@9
	mov	r12d, DWORD PTR [rcx+132]
	mov	r14, rcx
	sar	r15d, 2
	sar	r12d, 2
	xor	ebx, ebx
	movaps	XMMWORD PTR [rsp+48], xmm6
	movaps	XMMWORD PTR [rsp+32], xmm7
	mov	r13d, ebx
	movsd	xmm7, QWORD PTR __real@3fee666666666666
	mov	DWORD PTR k$1$[rsp], ebx
	lea	r8d, QWORD PTR [rbx+3]
	npad	5
$LL4@early_term:

; 448  :     double threshold;
; 449  :     if (info->state->encoder_control->cfg.me_early_termination ==

	mov	rax, QWORD PTR [r14]
	xorps	xmm6, xmm6
	mov	edx, DWORD PTR [r14+136]
	mov	rcx, QWORD PTR [rax]
	cvtsi2sd xmm6, rdx
	cmp	DWORD PTR [rcx+2384], 2
	jne	SHORT $LN8@early_term

; 450  :         KVZ_ME_EARLY_TERMINATION_SENSITIVE)
; 451  :     {
; 452  :       threshold = info->best_cost * 0.95;

	mulsd	xmm6, xmm7
$LN8@early_term:

; 453  :     } else {
; 454  :       threshold = info->best_cost;
; 455  :     }
; 456  : 
; 457  :     int best_index = 6;
; 458  :     for (int i = first_index; i <= last_index; i++) {

	movsxd	rsi, ebx
	mov	edi, 6
	movsxd	rbp, r8d
	cmp	rsi, rbp
	jg	SHORT $LN22@early_term
	lea	r13, OFFSET FLAT:?small_hexbs@?1??early_terminate@@9@9
	npad	7
$LL7@early_term:

; 459  :       int x = mv.x + small_hexbs[i].x;

	mov	edx, DWORD PTR [r13+rsi*8]

; 460  :       int y = mv.y + small_hexbs[i].y;
; 461  : 
; 462  :       if (check_mv_cost(info, x, y)) {

	mov	rcx, r14
	mov	r8d, DWORD PTR [r13+rsi*8+4]
	add	edx, r15d
	add	r8d, r12d
	call	check_mv_cost
	test	al, al
	cmovne	edi, ebx
	inc	ebx
	inc	rsi
	cmp	rsi, rbp
	jle	SHORT $LL7@early_term
	mov	r13d, DWORD PTR k$1$[rsp]
	lea	r9, OFFSET FLAT:?small_hexbs@?1??early_terminate@@9@9
	mov	edx, DWORD PTR [r14+136]
$LN22@early_term:

; 463  :         best_index = i;
; 464  :       }
; 465  :     }
; 466  : 
; 467  :     // Adjust the movement vector
; 468  :     mv.x += small_hexbs[best_index].x;

	movsxd	rax, edi
	xorps	xmm0, xmm0
	add	r15d, DWORD PTR [r9+rax*8]

; 469  :     mv.y += small_hexbs[best_index].y;

	add	r12d, DWORD PTR [r9+rax*8+4]

; 470  : 
; 471  :     // If best match is not better than threshold, we stop the search.
; 472  :     if (info->best_cost >= threshold) {

	mov	eax, edx
	cvtsi2sd xmm0, rax
	comisd	xmm0, xmm6
	jae	SHORT $LN15@early_term

; 474  :     }
; 475  : 
; 476  :     first_index = (best_index + 3) % 4;

	lea	ebx, DWORD PTR [rdi+3]
	and	ebx, -2147483645			; ffffffff80000003H
	jge	SHORT $LN23@early_term
	dec	ebx
	or	ebx, -4
	inc	ebx
$LN23@early_term:

; 477  :     last_index = first_index + 2;

	inc	r13d
	lea	r8d, DWORD PTR [rbx+2]
	mov	DWORD PTR k$1$[rsp], r13d
	cmp	r13d, 2
	jl	$LL4@early_term

; 478  :   }
; 479  :   return false;

	xor	al, al
	jmp	SHORT $LN1@early_term
$LN15@early_term:

; 473  :       return true;

	mov	al, 1
$LN1@early_term:

; 480  : }

	movaps	xmm6, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	movaps	xmm7, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
early_terminate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
pattern$ = 32
info$ = 336
pattern_type$dead$ = 344
iDist$ = 352
mv$ = 360
best_dist$ = 368
kvz_tz_pattern_search PROC

; 488  : {

$LN61:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H

; 489  :   assert(pattern_type < 4);
; 490  : 
; 491  :   //implemented search patterns
; 492  :   const vector2d_t pattern[4][8] = {

	xor	esi, esi
	mov	DWORD PTR pattern$[rsp+4], r8d
	mov	eax, r8d
	mov	DWORD PTR pattern$[rsp], esi
	cdq
	mov	DWORD PTR pattern$[rsp+8], r8d
	sub	eax, edx
	mov	QWORD PTR pattern$[rsp+12], rsi
	sar	eax, 1
	mov	rbx, r9
	mov	DWORD PTR pattern$[rsp+32], eax
	mov	r13, rcx
	mov	ecx, eax
	mov	DWORD PTR pattern$[rsp+36], eax
	mov	DWORD PTR pattern$[rsp+40], eax
	mov	r9d, r8d
	neg	r9d
	mov	DWORD PTR pattern$[rsp+28], esi
	mov	eax, r8d
	mov	DWORD PTR pattern$[rsp+20], r9d
	cdq
	mov	DWORD PTR pattern$[rsp+24], r9d
	sub	eax, edx
	mov	DWORD PTR pattern$[rsp+60], ecx
	sar	eax, 1
	xorps	xmm0, xmm0
	neg	eax
	mov	DWORD PTR pattern$[rsp+64], esi
	mov	DWORD PTR pattern$[rsp+44], eax

; 493  :       //diamond (8 points)
; 494  :       //[ ][ ][ ][ ][1][ ][ ][ ][ ]
; 495  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 496  :       //[ ][ ][8][ ][ ][ ][5][ ][ ]
; 497  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 498  :       //[4][ ][ ][ ][o][ ][ ][ ][2]
; 499  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 500  :       //[ ][ ][7][ ][ ][ ][6][ ][ ]
; 501  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 502  :       //[ ][ ][ ][ ][3][ ][ ][ ][ ]
; 503  :       {
; 504  :         { 0, iDist }, { iDist, 0 }, { 0, -iDist }, { -iDist, 0 },
; 505  :         { iDist / 2, iDist / 2 }, { iDist / 2, -iDist / 2 }, { -iDist / 2, -iDist / 2 }, { -iDist / 2, iDist / 2 }
; 506  :       },
; 507  : 
; 508  :       //square (8 points)
; 509  :       //[8][ ][ ][ ][1][ ][ ][ ][2]
; 510  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 511  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 512  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 513  :       //[7][ ][ ][ ][o][ ][ ][ ][3]
; 514  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 515  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 516  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 517  :       //[6][ ][ ][ ][5][ ][ ][ ][4]
; 518  :       {
; 519  :         { 0, iDist }, { iDist, iDist }, { iDist, 0 }, { iDist, -iDist }, { 0, -iDist },
; 520  :         { -iDist, -iDist }, { -iDist, 0 }, { -iDist, iDist }
; 521  :       },
; 522  : 
; 523  :       //octagon (8 points)
; 524  :       //[ ][ ][5][ ][ ][ ][1][ ][ ]
; 525  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 526  :       //[ ][ ][ ][ ][ ][ ][ ][ ][2]
; 527  :       //[4][ ][ ][ ][ ][ ][ ][ ][ ]
; 528  :       //[ ][ ][ ][ ][o][ ][ ][ ][ ]
; 529  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 530  :       //[8][ ][ ][ ][ ][ ][ ][ ][6]
; 531  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 532  :       //[ ][ ][7][ ][ ][ ][3][ ][ ]
; 533  :       {
; 534  :         { iDist / 2, iDist }, { iDist, iDist / 2 }, { iDist / 2, -iDist }, { -iDist, iDist / 2 },
; 535  :         { -iDist / 2, iDist }, { iDist, -iDist / 2 }, { -iDist / 2, -iDist }, { -iDist, -iDist / 2 }
; 536  :       },
; 537  : 
; 538  :       //hexagon (6 points)
; 539  :       //[ ][ ][5][ ][ ][ ][1][ ][ ]
; 540  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 541  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 542  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 543  :       //[4][ ][ ][ ][o][ ][ ][ ][2]
; 544  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 545  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 546  :       //[ ][ ][ ][ ][ ][ ][ ][ ][ ]
; 547  :       //[ ][ ][6][ ][ ][ ][3][ ][ ]
; 548  :       {
; 549  :         { iDist / 2, iDist }, { iDist, 0 }, { iDist / 2, -iDist }, { -iDist, 0 },
; 550  :         { iDist / 2, iDist }, { -iDist / 2, -iDist }, { 0, 0 }, { 0, 0 }
; 551  :       }
; 552  :   };
; 553  : 
; 554  :   // Set the number of points to be checked.
; 555  :   int n_points;
; 556  :   if (iDist == 1) {
; 557  :     switch (pattern_type) {
; 558  :       case 0:
; 559  :         n_points = 4;
; 560  :         break;
; 561  :       case 2:
; 562  :         n_points = 4;
; 563  :         break;
; 564  :       case 3:
; 565  :         n_points = 4;
; 566  :         break;
; 567  :       default:
; 568  :         n_points = 8;
; 569  :         break;
; 570  :     };
; 571  :   } else {
; 572  :     switch (pattern_type) {
; 573  :       case 3:
; 574  :         n_points = 6;
; 575  :         break;
; 576  :       default:
; 577  :         n_points = 8;
; 578  :         break;
; 579  :     };
; 580  :   }
; 581  : 
; 582  :   // Compute SAD values for all chosen points.
; 583  :   int best_index = -1;

	cmp	r8d, 1
	mov	DWORD PTR pattern$[rsp+48], eax
	mov	r12d, 4
	mov	DWORD PTR pattern$[rsp+52], eax
	mov	r15d, r8d
	mov	DWORD PTR pattern$[rsp+56], eax
	mov	DWORD PTR pattern$[rbp-96], eax
	mov	DWORD PTR pattern$[rbp-84], eax
	mov	DWORD PTR pattern$[rbp-80], eax
	mov	DWORD PTR pattern$[rbp-68], eax
	mov	DWORD PTR pattern$[rbp-24], eax
	mov	eax, 8
	cmovne	r12d, eax
	mov	DWORD PTR pattern$[rsp+68], r8d
	mov	DWORD PTR pattern$[rsp+72], r8d
	mov	DWORD PTR pattern$[rsp+76], r8d
	mov	DWORD PTR pattern$[rsp+80], r8d
	mov	DWORD PTR pattern$[rsp+84], esi
	mov	DWORD PTR pattern$[rsp+88], r8d
	mov	DWORD PTR pattern$[rsp+92], r9d
	mov	DWORD PTR pattern$[rbp-160], esi
	mov	DWORD PTR pattern$[rbp-156], r9d
	mov	DWORD PTR pattern$[rbp-152], r9d
	mov	DWORD PTR pattern$[rbp-148], r9d
	mov	DWORD PTR pattern$[rbp-144], r9d
	mov	DWORD PTR pattern$[rbp-140], esi
	mov	DWORD PTR pattern$[rbp-136], r9d
	mov	DWORD PTR pattern$[rbp-132], r8d
	mov	DWORD PTR pattern$[rbp-128], ecx
	mov	DWORD PTR pattern$[rbp-124], r8d
	mov	DWORD PTR pattern$[rbp-120], r8d
	mov	DWORD PTR pattern$[rbp-116], ecx
	mov	DWORD PTR pattern$[rbp-112], ecx
	mov	DWORD PTR pattern$[rbp-108], r9d
	mov	DWORD PTR pattern$[rbp-104], r9d
	mov	DWORD PTR pattern$[rbp-100], ecx
	mov	DWORD PTR pattern$[rbp-92], r8d
	mov	DWORD PTR pattern$[rbp-88], r8d
	mov	DWORD PTR pattern$[rbp-76], r9d
	mov	DWORD PTR pattern$[rbp-72], r9d
	mov	DWORD PTR pattern$[rbp-64], ecx
	mov	DWORD PTR pattern$[rbp-60], r8d
	mov	DWORD PTR pattern$[rbp-56], r8d
	mov	DWORD PTR pattern$[rbp-52], esi
	mov	DWORD PTR pattern$[rbp-48], ecx
	mov	DWORD PTR pattern$[rbp-44], r9d
	mov	DWORD PTR pattern$[rbp-40], r9d
	mov	DWORD PTR pattern$[rbp-36], esi
	mov	DWORD PTR pattern$[rbp-32], ecx
	mov	DWORD PTR pattern$[rbp-28], r8d
	mov	DWORD PTR pattern$[rbp-20], r9d
	movdqa	XMMWORD PTR pattern$[rbp-16], xmm0
	lea	edi, QWORD PTR [rsi-1]
	mov	r14d, esi
	npad	10
$LL8@kvz_tz_pat:

; 584  :   for (int i = 0; i < n_points; i++) {
; 585  :     vector2d_t offset = pattern[pattern_type][i];

	mov	rax, QWORD PTR pattern$[rsp+r14*8]

; 586  :     int x = mv.x + offset.x;
; 587  :     int y = mv.y + offset.y;
; 588  : 
; 589  :     if (check_mv_cost(info, x, y)) {

	mov	rcx, r13
	mov	r8, rax
	shr	r8, 32					; 00000020H
	add	r8d, DWORD PTR mv$[rbp-252]
	lea	edx, DWORD PTR [rax+rbx]
	call	check_mv_cost
	test	al, al
	cmovne	edi, esi
	inc	esi
	inc	r14
	cmp	r14, r12
	jl	SHORT $LL8@kvz_tz_pat

; 590  :       best_index = i;
; 591  :     }
; 592  :   }
; 593  : 
; 594  :   if (best_index >= 0) {

	test	edi, edi
	js	SHORT $LN18@kvz_tz_pat

; 595  :     *best_dist = iDist;

	mov	rax, QWORD PTR best_dist$[rbp-256]
	mov	DWORD PTR [rax], r15d
$LN18@kvz_tz_pat:

; 596  :   }
; 597  : }

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
kvz_tz_pattern_search ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
info$ = 48
iSearchRange$dead$ = 56
iRaster$dead$ = 64
kvz_tz_raster_search PROC

; 603  : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 32					; 00000020H

; 604  :   const vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	r14d, DWORD PTR [rcx+128]
	mov	rsi, rcx
	mov	r15d, DWORD PTR [rcx+132]

; 605  : 
; 606  :   //compute SAD values for every point in the iRaster downsampled version of the current search area
; 607  :   for (int y = iSearchRange; y >= -iSearchRange; y -= iRaster) {

	mov	edi, 96					; 00000060H
	sar	r14d, 2
	sar	r15d, 2
	npad	8
$LL4@kvz_tz_ras:

; 608  :     for (int x = -iSearchRange; x <= iSearchRange; x += iRaster) {

	mov	ebx, -96				; ffffffffffffffa0H
	npad	11
$LL7@kvz_tz_ras:

; 609  :       check_mv_cost(info, mv.x + x, mv.y + y);

	lea	r8d, DWORD PTR [r15+rdi]
	mov	rcx, rsi
	lea	edx, DWORD PTR [r14+rbx]
	call	check_mv_cost
	add	ebx, 5
	cmp	ebx, 96					; 00000060H
	jle	SHORT $LL7@kvz_tz_ras

; 605  : 
; 606  :   //compute SAD values for every point in the iRaster downsampled version of the current search area
; 607  :   for (int y = iSearchRange; y >= -iSearchRange; y -= iRaster) {

	sub	edi, 5
	cmp	edi, -96				; ffffffffffffffa0H
	jge	SHORT $LL4@kvz_tz_ras

; 610  :     }
; 611  :   }
; 612  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
kvz_tz_raster_search ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
best_dist$ = 96
info$ = 96
extra_mv$ = 104
start$ = 112
tz_search PROC

; 616  : {

	push	rsi
	push	r12
	sub	rsp, 72					; 00000048H

; 617  :   //TZ parameters
; 618  :   const int iSearchRange = 96;  // search range for each stage
; 619  :   const int iRaster = 5;  // search distance limit and downsampling factor for step 3
; 620  :   const unsigned step2_type = 0;  // search patterns for steps 2 and 4
; 621  :   const unsigned step4_type = 0;
; 622  :   const bool use_raster_scan = false;  // enable step 3
; 623  :   const bool use_raster_refinement = false;  // enable step 4 mode 1
; 624  :   const bool use_star_refinement = true;   // enable step 4 mode 2 (only one mode will be executed)
; 625  : 
; 626  :   int best_dist = 0;

	xor	r12d, r12d

; 627  :   info->best_cost = UINT32_MAX;

	mov	DWORD PTR [rcx+136], -1			; ffffffffH
	mov	DWORD PTR best_dist$[rsp], r12d
	mov	rsi, rcx

; 628  : 
; 629  :   // Select starting point from among merge candidates. These should
; 630  :   // include both mv_cand vectors and (0, 0).
; 631  :   select_starting_point(info, extra_mv);

	call	select_starting_point

; 632  : 
; 633  :   // Check if we should stop search
; 634  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	rax, QWORD PTR [rsi]
	mov	rdx, QWORD PTR [rax]
	cmp	DWORD PTR [rdx+2384], r12d
	je	SHORT $LN16@tz_search
	mov	rcx, rsi
	call	early_terminate
	test	al, al
	jne	$LN81@tz_search
$LN16@tz_search:
	mov	QWORD PTR [rsp+104], rbx
	mov	QWORD PTR [rsp+120], rbp

; 635  :       early_terminate(info))
; 636  :   {
; 637  :     return;
; 638  :   }
; 639  : 
; 640  :   vector2d_t start = { info->best_mv.x >> 2, info->best_mv.y >> 2 };
; 641  : 
; 642  :   // step 2, grid search
; 643  :   int rounds_without_improvement = 0;

	mov	ebp, r12d
	mov	QWORD PTR [rsp+64], rdi

; 644  :   for (int iDist = 1; iDist <= iSearchRange; iDist *= 2) {

	mov	edi, 1
	mov	QWORD PTR [rsp+56], r14
	mov	r14d, DWORD PTR [rsi+128]
	mov	QWORD PTR [rsp+48], r15
	mov	r15d, DWORD PTR [rsi+132]
	sar	r14d, 2
	sar	r15d, 2
	mov	DWORD PTR start$[rsp+4], r15d
	mov	DWORD PTR start$[rsp], r14d
	mov	rbx, QWORD PTR start$[rsp]
	npad	9
$LL4@tz_search:

; 645  :     kvz_tz_pattern_search(info, step2_type, iDist, start, &best_dist);

	lea	rax, QWORD PTR best_dist$[rsp]
	mov	r9, rbx
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, rsi
	call	kvz_tz_pattern_search

; 646  : 
; 647  :     // Break the loop if the last three rounds didn't produce a better MV.
; 648  :     if (best_dist != iDist) rounds_without_improvement++;

	mov	ecx, DWORD PTR best_dist$[rsp]
	cmp	ecx, edi
	je	SHORT $LN69@tz_search
	lea	eax, DWORD PTR [rbp+1]
	mov	ebp, eax

; 649  :     if (rounds_without_improvement >= 3) break;

	cmp	eax, 3
	jge	SHORT $LN41@tz_search
$LN69@tz_search:

; 644  :   for (int iDist = 1; iDist <= iSearchRange; iDist *= 2) {

	add	edi, edi
	cmp	edi, 96					; 00000060H
	jle	SHORT $LL4@tz_search
$LN41@tz_search:

; 650  :   }
; 651  : 
; 652  :   if (start.x != 0 || start.y != 0) {

	test	r14d, r14d
	mov	r14, QWORD PTR [rsp+56]
	jne	SHORT $LN20@tz_search
	test	r15d, r15d
	je	SHORT $LN82@tz_search
$LN20@tz_search:

; 653  :     // repeat step 2 starting from the zero MV
; 654  :     start.x = 0;

	mov	QWORD PTR start$[rsp], r12

; 655  :     start.y = 0;
; 656  :     rounds_without_improvement = 0;

	mov	ebp, r12d

; 657  :     for (int iDist = 1; iDist <= iSearchRange/2; iDist *= 2) {

	mov	edi, 1
	mov	rbx, r12
$LL7@tz_search:

; 658  :       kvz_tz_pattern_search(info, step2_type, iDist, start, &best_dist);

	lea	rax, QWORD PTR best_dist$[rsp]
	mov	r9, rbx
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, rsi
	call	kvz_tz_pattern_search

; 659  : 
; 660  :       if (best_dist != iDist) rounds_without_improvement++;

	mov	ecx, DWORD PTR best_dist$[rsp]
	cmp	ecx, edi
	je	SHORT $LN68@tz_search
	lea	eax, DWORD PTR [rbp+1]
	mov	ebp, eax

; 661  :       if (rounds_without_improvement >= 3) break;

	cmp	eax, 3
	jge	SHORT $LN82@tz_search
$LN68@tz_search:

; 657  :     for (int iDist = 1; iDist <= iSearchRange/2; iDist *= 2) {

	add	edi, edi
	cmp	edi, 48					; 00000030H
	jle	SHORT $LL7@tz_search
$LN82@tz_search:
	mov	r15, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+120]
	npad	5
$LL11@tz_search:

; 662  :     }
; 663  :   }
; 664  : 
; 665  :   //step 3, raster scan
; 666  :   if (use_raster_scan && best_dist > iRaster) {
; 667  :     best_dist = iRaster;
; 668  :     kvz_tz_raster_search(info, iSearchRange, iRaster);
; 669  :   }
; 670  : 
; 671  :   //step 4
; 672  : 
; 673  :   //raster refinement
; 674  :   if (use_raster_refinement && best_dist > 0) {
; 675  :     for (int iDist = best_dist >> 1; iDist > 0; iDist >>= 1) {
; 676  :       start.x = info->best_mv.x >> 2;
; 677  :       start.y = info->best_mv.y >> 2;
; 678  :       kvz_tz_pattern_search(info, step4_type, iDist, start, &best_dist);
; 679  :     }
; 680  :   }
; 681  : 
; 682  :   //star refinement (repeat step 2 for the current starting point)
; 683  :   while (use_star_refinement && best_dist > 0) {

	test	ecx, ecx
	jle	SHORT $LN85@tz_search

; 684  :     best_dist = 0;
; 685  :     start.x = info->best_mv.x >> 2;

	mov	eax, DWORD PTR [rsi+128]

; 686  :     start.y = info->best_mv.y >> 2;
; 687  :     for (int iDist = 1; iDist <= iSearchRange; iDist *= 2) {

	mov	edi, 1
	sar	eax, 2
	mov	DWORD PTR start$[rsp], eax
	mov	eax, DWORD PTR [rsi+132]
	sar	eax, 2
	mov	DWORD PTR start$[rsp+4], eax
	mov	rbx, QWORD PTR start$[rsp]
	mov	DWORD PTR best_dist$[rsp], r12d
	npad	3
$LL15@tz_search:

; 688  :       kvz_tz_pattern_search(info, step4_type, iDist, start, &best_dist);

	lea	rax, QWORD PTR best_dist$[rsp]
	mov	r9, rbx
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, rsi
	call	kvz_tz_pattern_search
	add	edi, edi
	cmp	edi, 96					; 00000060H
	jle	SHORT $LL15@tz_search
	mov	ecx, DWORD PTR best_dist$[rsp]
	jmp	SHORT $LL11@tz_search
$LN85@tz_search:
	mov	rbx, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+64]
$LN81@tz_search:

; 689  :     }
; 690  :   }
; 691  : }

	add	rsp, 72					; 00000048H
	pop	r12
	pop	rsi
	ret	0
tz_search ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
info$ = 80
extra_mv$ = 88
steps$ = 96
hexagon_search PROC

; 711  : {

	push	r13
	push	r15
	sub	rsp, 56					; 00000038H
	mov	r13d, r8d

; 712  :   // The start of the hexagonal pattern has been repeated at the end so that
; 713  :   // the indices between 1-6 can be used as the start of a 3-point list of new
; 714  :   // points to search.
; 715  :   //   6--1,7
; 716  :   //  /     \    =)
; 717  :   // 5   0  2,8
; 718  :   //  \     /
; 719  :   //   4---3
; 720  :   static const vector2d_t large_hexbs[9] = {
; 721  :       { 0, 0 },
; 722  :       { 1, -2 }, { 2, 0 }, { 1, 2 }, { -1, 2 }, { -2, 0 }, { -1, -2 },
; 723  :       { 1, -2 }, { 2, 0 }
; 724  :   };
; 725  :   // This is used as the last step of the hexagon search.
; 726  :   //   1
; 727  :   // 2 0 3
; 728  :   //   4
; 729  :   static const vector2d_t small_hexbs[9] = {
; 730  :       { 0, 0 },
; 731  :       { 0, -1 }, { -1, 0 }, { 1, 0 }, { 0, 1 },
; 732  :       { -1, -1 }, { 1, -1 }, { -1, 1 }, { 1, 1 }
; 733  :   };
; 734  : 
; 735  :   info->best_cost = UINT32_MAX;

	mov	DWORD PTR [rcx+136], -1			; ffffffffH
	mov	r15, rcx

; 736  : 
; 737  :   // Select starting point from among merge candidates. These should
; 738  :   // include both mv_cand vectors and (0, 0).
; 739  :   select_starting_point(info, extra_mv);

	call	select_starting_point

; 740  : 
; 741  :   // Check if we should stop search
; 742  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	rax, QWORD PTR [r15]
	mov	rdx, QWORD PTR [rax]
	cmp	DWORD PTR [rdx+2384], 0
	je	SHORT $LN13@hexagon_se
	mov	rcx, r15
	call	early_terminate
	test	al, al
	jne	$LN11@hexagon_se
$LN13@hexagon_se:
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+88], rbp

; 743  :       early_terminate(info))
; 744  :   {
; 745  :     return;
; 746  :   }
; 747  : 
; 748  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	lea	rbp, OFFSET FLAT:?large_hexbs@?1??hexagon_search@@9@9+8
	mov	QWORD PTR [rsp+96], rsi
	mov	esi, DWORD PTR [r15+128]
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+32], r14
	mov	r14d, DWORD PTR [r15+132]
	sar	r14d, 2
	sar	esi, 2

; 749  : 
; 750  :   // Current best index, either to merge_cands, large_hexbs or small_hexbs.
; 751  :   int best_index = 0;

	xor	ebx, ebx
	lea	edi, QWORD PTR [rbx+1]
	npad	10
$LL4@hexagon_se:

; 752  : 
; 753  :   // Search the initial 7 points of the hexagon.
; 754  :   for (int i = 1; i < 7; ++i) {
; 755  :     if (check_mv_cost(info, mv.x + large_hexbs[i].x, mv.y + large_hexbs[i].y)) {

	mov	r8d, DWORD PTR [rbp+4]
	mov	rcx, r15
	mov	edx, DWORD PTR [rbp]
	add	r8d, r14d
	add	edx, esi
	call	check_mv_cost
	test	al, al
	lea	rbp, QWORD PTR [rbp+8]
	cmovne	ebx, edi
	inc	edi
	cmp	edi, 7
	jl	SHORT $LL4@hexagon_se

; 756  :       best_index = i;
; 757  :     }
; 758  :   }
; 759  : 
; 760  :   // Iteratively search the 3 new points around the best match, until the best
; 761  :   // match is in the center.
; 762  :   while (best_index != 0 && steps != 0) {

	test	ebx, ebx
	je	SHORT $LN37@hexagon_se
	mov	QWORD PTR [rsp+40], r12
	lea	r12, OFFSET FLAT:?large_hexbs@?1??hexagon_search@@9@9
$LL5@hexagon_se:
	test	r13d, r13d
	je	SHORT $LN38@hexagon_se

; 763  :     // decrement count if enabled
; 764  :     if (steps > 0) steps -= 1;
; 765  : 
; 766  :     // Starting point of the 3 offsets to be searched.
; 767  :     unsigned start;
; 768  :     if (best_index == 1) {

	dec	r13d
	cmp	ebx, 1
	jne	SHORT $LN16@hexagon_se

; 769  :       start = 6;

	lea	edi, QWORD PTR [rbx+5]
	jmp	SHORT $LN19@hexagon_se
$LN16@hexagon_se:

; 770  :     } else if (best_index == 8) {
; 771  :       start = 1;

	mov	edi, 1
	cmp	ebx, 8
	je	SHORT $LN19@hexagon_se

; 772  :     } else {
; 773  :       start = best_index - 1;

	lea	edi, DWORD PTR [rbx-1]
$LN19@hexagon_se:

; 774  :     }
; 775  : 
; 776  :     // Move the center to the best match.
; 777  :     mv.x += large_hexbs[best_index].x;

	movsxd	rax, ebx
	add	esi, DWORD PTR [r12+rax*8]

; 778  :     mv.y += large_hexbs[best_index].y;

	add	r14d, DWORD PTR [r12+rax*8+4]

; 779  :     best_index = 0;

	xor	ebx, ebx
	lea	ebp, QWORD PTR [rbx+3]
	npad	12
$LL9@hexagon_se:

; 780  : 
; 781  :     // Iterate through the next 3 points.
; 782  :     for (int i = 0; i < 3; ++i) {
; 783  :       vector2d_t offset = large_hexbs[start + i];

	mov	eax, edi
	mov	rcx, QWORD PTR [r12+rax*8]
	mov	r8, rcx
	shr	r8, 32					; 00000020H
	add	r8d, r14d

; 784  :       if (check_mv_cost(info, mv.x + offset.x, mv.y + offset.y)) {

	lea	edx, DWORD PTR [rcx+rsi]
	mov	rcx, r15
	call	check_mv_cost
	test	al, al
	cmovne	ebx, edi
	inc	edi
	sub	rbp, 1
	jne	SHORT $LL9@hexagon_se

; 756  :       best_index = i;
; 757  :     }
; 758  :   }
; 759  : 
; 760  :   // Iteratively search the 3 new points around the best match, until the best
; 761  :   // match is in the center.
; 762  :   while (best_index != 0 && steps != 0) {

	test	ebx, ebx
	jne	SHORT $LL5@hexagon_se
$LN38@hexagon_se:
	mov	r12, QWORD PTR [rsp+40]
$LN37@hexagon_se:
	mov	rbp, QWORD PTR [rsp+88]
	lea	rbx, OFFSET FLAT:?small_hexbs@?1??hexagon_search@@9@9+8
	lea	rdi, OFFSET FLAT:?small_hexbs@?1??hexagon_search@@9@9+72
	npad	12
$LL12@hexagon_se:

; 796  :     check_mv_cost(info, mv.x + small_hexbs[i].x, mv.y + small_hexbs[i].y);

	mov	r8d, DWORD PTR [rbx+4]
	mov	rcx, r15
	mov	edx, DWORD PTR [rbx]
	add	r8d, r14d
	add	edx, esi
	call	check_mv_cost
	add	rbx, 8
	cmp	rbx, rdi
	jl	SHORT $LL12@hexagon_se

; 785  :         best_index = start + i;
; 786  :       }
; 787  :     }
; 788  :   }
; 789  : 
; 790  :   // Move the center to the best match.
; 791  :   //mv.x += large_hexbs[best_index].x;
; 792  :   //mv.y += large_hexbs[best_index].y;
; 793  : 
; 794  :   // Do the final step of the search with a small pattern.
; 795  :   for (int i = 1; i < 9; ++i) {

	mov	r14, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [rsp+80]
$LN11@hexagon_se:

; 797  :   }
; 798  : }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r13
	ret	0
hexagon_search ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
info$ = 96
extra_mv$ = 104
steps$ = 112
diamond_search PROC

; 817  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+8], rcx
	push	r15
	sub	rsp, 80					; 00000050H
	mov	r15, rcx

; 818  :   enum diapos {
; 819  :     DIA_UP = 0,
; 820  :     DIA_RIGHT = 1,
; 821  :     DIA_LEFT = 2,
; 822  :     DIA_DOWN = 3,
; 823  :     DIA_CENTER = 4,
; 824  :   };
; 825  : 
; 826  :   // a diamond shape with the center included
; 827  :   //   0
; 828  :   // 2 4 1
; 829  :   //   3
; 830  :   static const vector2d_t diamond[5] = {
; 831  :     {0, -1}, {1, 0}, {0, 1}, {-1, 0},
; 832  :     {0, 0}
; 833  :   };
; 834  : 
; 835  :   info->best_cost = UINT32_MAX;

	mov	DWORD PTR [rcx+136], -1			; ffffffffH

; 836  : 
; 837  :   // Select starting point from among merge candidates. These should
; 838  :   // include both mv_cand vectors and (0, 0).
; 839  :   select_starting_point(info, extra_mv);

	call	select_starting_point

; 840  : 
; 841  :   // Check if we should stop search
; 842  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	rax, QWORD PTR [r15]
	mov	rdx, QWORD PTR [rax]
	cmp	DWORD PTR [rdx+2384], 0
	je	SHORT $LN11@diamond_se
	mov	rcx, r15
	call	early_terminate
	test	al, al
	jne	$LN6@diamond_se
$LN11@diamond_se:
	mov	QWORD PTR [rsp+104], rbx
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+56], rdi

; 843  :     early_terminate(info))
; 844  :   {
; 845  :     return;
; 846  :   }
; 847  :   
; 848  :   // current motion vector
; 849  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	lea	rdi, OFFSET FLAT:?diamond@?1??diamond_search@@9@9
	mov	QWORD PTR [rsp+48], r12
	mov	r12d, DWORD PTR [r15+128]
	mov	QWORD PTR [rsp+40], r13
	mov	r13d, DWORD PTR [r15+132]
	mov	QWORD PTR [rsp+32], r14

; 850  : 
; 851  :   // current best index
; 852  :   enum diapos best_index = DIA_CENTER;

	mov	r14d, 4
	sar	r13d, 2
	mov	esi, r14d
	sar	r12d, 2
	xor	ebx, ebx
	npad	9
$LL4@diamond_se:

; 853  : 
; 854  :   // initial search of the points of the diamond
; 855  :   for (int i = 0; i < 5; ++i) {
; 856  :     if (check_mv_cost(info, mv.x + diamond[i].x, mv.y + diamond[i].y)) {

	mov	r8d, DWORD PTR [rdi+4]
	mov	rcx, r15
	mov	edx, DWORD PTR [rdi]
	add	r8d, r13d
	add	edx, r12d
	call	check_mv_cost
	test	al, al
	lea	rdi, QWORD PTR [rdi+8]
	cmovne	esi, ebx
	inc	ebx
	cmp	ebx, 5
	jl	SHORT $LL4@diamond_se

; 857  :       best_index = i;
; 858  :     }
; 859  :   }
; 860  : 
; 861  :   if (best_index == DIA_CENTER) {

	cmp	esi, r14d
	je	$LN37@diamond_se

; 862  :     // the center point was the best in initial check
; 863  :     return;
; 864  :   }
; 865  : 
; 866  :   // Move the center to the best match.
; 867  :   mv.x += diamond[best_index].x;

	mov	ecx, DWORD PTR steps$[rsp]
	lea	rdx, OFFSET FLAT:?diamond@?1??diamond_search@@9@9
	movsxd	r15, esi
	mov	QWORD PTR [rsp+72], rbp
	add	r12d, DWORD PTR [rdx+r15*8]

; 868  :   mv.y += diamond[best_index].y;

	add	r13d, DWORD PTR [rdx+r15*8+4]
	npad	7
$LL7@diamond_se:

; 869  : 
; 870  :   // the arrival direction, the index of the diamond member that will be excluded
; 871  :   enum diapos from_dir = DIA_CENTER;
; 872  : 
; 873  :   // whether we found a better candidate this iteration
; 874  :   uint8_t better_found;
; 875  : 
; 876  :   do {
; 877  :     better_found = 0;

	xor	bpl, bpl

; 883  :       // this is where we came from so it's checked already
; 884  :       if (i == from_dir) continue;

	movsxd	r14, r14d
	test	ecx, ecx
	lea	eax, DWORD PTR [rcx-1]
	cmove	eax, ecx
	xor	edi, edi
	xor	ebx, ebx
	mov	DWORD PTR steps$[rsp], eax
$LL10@diamond_se:
	cmp	rbx, r14
	je	SHORT $LN8@diamond_se

; 885  : 
; 886  :       if (check_mv_cost(info, mv.x + diamond[i].x, mv.y + diamond[i].y)) {

	mov	r8d, DWORD PTR [rdx+rbx*8+4]
	mov	edx, DWORD PTR [rdx+rbx*8]
	add	r8d, r13d
	mov	rcx, QWORD PTR info$[rsp]
	add	edx, r12d
	call	check_mv_cost
	lea	rdx, OFFSET FLAT:?diamond@?1??diamond_search@@9@9
	test	al, al
	je	SHORT $LN8@diamond_se

; 887  :         best_index = i;

	mov	esi, edi
	mov	r15, rbx

; 888  :         better_found = 1;

	mov	bpl, 1
$LN8@diamond_se:

; 878  :     // decrement count if enabled
; 879  :     if (steps > 0) steps -= 1;
; 880  : 
; 881  :     // search the points of the diamond
; 882  :     for (int i = 0; i < 4; ++i) {

	inc	edi
	inc	rbx
	cmp	edi, 4
	jl	SHORT $LL10@diamond_se

; 889  :       }
; 890  :     }
; 891  : 
; 892  :     if (better_found) {

	test	bpl, bpl
	je	SHORT $LN18@diamond_se

; 893  :       // Move the center to the best match.
; 894  :       mv.x += diamond[best_index].x;

	add	r12d, DWORD PTR [rdx+r15*8]

; 895  :       mv.y += diamond[best_index].y;
; 896  : 
; 897  :       // record where we came from to the next iteration
; 898  :       // the xor operation flips the orientation
; 899  :       from_dir = best_index ^ 0x3;

	mov	r14d, esi
	add	r13d, DWORD PTR [rdx+r15*8+4]
	xor	r14d, 3

; 900  :     }
; 901  :   } while (better_found && steps != 0);

	mov	ecx, DWORD PTR steps$[rsp]
	test	ecx, ecx
	jne	SHORT $LL7@diamond_se
$LN18@diamond_se:
	mov	rbp, QWORD PTR [rsp+72]
$LN37@diamond_se:
	mov	r13, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+104]
	mov	r14, QWORD PTR [rsp+32]
$LN6@diamond_se:

; 902  :   // and we're done
; 903  : }

	add	rsp, 80					; 00000050H
	pop	r15
	ret	0
diamond_search ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
$T3 = 32
tv1514 = 40
tv1515 = 48
min_mv$1$sroa$713$1$ = 144
info$ = 144
i$1$ = 152
search_range$ = 152
max_mv$2$sroa$714$1$ = 160
extra_mv$ = 160
max_mv$2$sroa$715$1$ = 168
search_mv_full PROC

; 909  : {

	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 88					; 00000058H

; 910  :   // Search around the 0-vector.
; 911  :   for (int y = -search_range; y <= search_range; y++) {

	mov	r12d, edx
	mov	ebx, edx
	neg	r12d
	mov	rsi, rcx
	mov	ebp, r12d
	cmp	r12d, edx
	jg	SHORT $LN3@search_mv_
	npad	12
$LL4@search_mv_:

; 912  :     for (int x = -search_range; x <= search_range; x++) {

	mov	edi, r12d
$LL7@search_mv_:

; 913  :       check_mv_cost(info, x, y);

	mov	r8d, ebp
	mov	edx, edi
	mov	rcx, rsi
	call	check_mv_cost
	inc	edi
	cmp	edi, ebx
	jle	SHORT $LL7@search_mv_

; 910  :   // Search around the 0-vector.
; 911  :   for (int y = -search_range; y <= search_range; y++) {

	inc	ebp
	cmp	ebp, ebx
	jle	SHORT $LL4@search_mv_
$LN3@search_mv_:

; 914  :     }
; 915  :   }
; 916  : 
; 917  :   // Change to integer precision.
; 918  :   extra_mv.x >>= 2;

	mov	ebp, DWORD PTR extra_mv$[rsp]

; 919  :   extra_mv.y >>= 2;
; 920  : 
; 921  :   // Check around extra_mv if it's not one of the merge candidates.
; 922  :   if (!mv_in_merge(info, extra_mv)) {

	mov	rcx, rsi
	mov	r15d, DWORD PTR extra_mv$[rsp+4]
	sar	ebp, 2
	sar	r15d, 2
	mov	DWORD PTR extra_mv$[rsp], ebp
	mov	DWORD PTR extra_mv$[rsp+4], r15d
	mov	rdx, QWORD PTR extra_mv$[rsp]
	mov	QWORD PTR [rsp+72], r14
	call	mv_in_merge
	test	al, al
	jne	SHORT $LN9@search_mv_

; 923  :     for (int y = -search_range; y <= search_range; y++) {

	mov	r14d, r12d
	cmp	r12d, ebx
	jg	SHORT $LN9@search_mv_
$LL10@search_mv_:

; 924  :       for (int x = -search_range; x <= search_range; x++) {

	mov	edi, r12d
	npad	11
$LL13@search_mv_:

; 925  :         check_mv_cost(info, extra_mv.x + x, extra_mv.y + y);

	lea	r8d, DWORD PTR [r14+r15]
	mov	rcx, rsi
	lea	edx, DWORD PTR [rdi+rbp]
	call	check_mv_cost
	inc	edi
	cmp	edi, ebx
	jle	SHORT $LL13@search_mv_

; 923  :     for (int y = -search_range; y <= search_range; y++) {

	inc	r14d
	cmp	r14d, ebx
	jle	SHORT $LL10@search_mv_
$LN9@search_mv_:

; 926  :       }
; 927  :     }
; 928  :   }
; 929  : 
; 930  :   // Select starting point from among merge candidates. These should include
; 931  :   // both mv_cand vectors and (0, 0).
; 932  :   for (int i = 0; i < info->num_merge_cand; ++i) {

	xor	r8d, r8d
	mov	DWORD PTR i$1$[rsp], r8d
	cmp	DWORD PTR [rsi+112], r8d
	jle	$LN15@search_mv_
	xor	r11d, r11d
	mov	QWORD PTR [rsp+80], r13
	xor	r9d, r9d
	mov	QWORD PTR $T3[rsp], r11
	lea	rax, QWORD PTR [rsi+52]
	mov	QWORD PTR tv1515[rsp], r9
	mov	QWORD PTR tv1514[rsp], rax
	lea	ebp, QWORD PTR [r8+8]
$LL16@search_mv_:

; 933  :     if (info->merge_cand[i].dir == 3) continue;

	movzx	eax, BYTE PTR [rax]
	cmp	al, 3
	je	$LN14@search_mv_

; 934  : 
; 935  :     vector2d_t mv = {

	lea	rcx, QWORD PTR [r9+rax]
	movsx	eax, WORD PTR [rsi+rcx*4+52]
	movsx	r14d, WORD PTR [rsi+rcx*4+54]
	sar	eax, 2
	sar	r14d, 2
	test	eax, eax

; 936  :       .x = info->merge_cand[i].mv[info->merge_cand[i].dir - 1][0] >> 2,
; 937  :       .y = info->merge_cand[i].mv[info->merge_cand[i].dir - 1][1] >> 2,
; 938  :     };
; 939  : 
; 940  :     // Ignore 0-vector because it has already been checked.
; 941  :     if (mv.x == 0 && mv.y == 0) continue;

	jne	SHORT $LN28@search_mv_
	test	r14d, r14d
	je	$LN14@search_mv_
$LN28@search_mv_:

; 942  : 
; 943  :     vector2d_t min_mv = { mv.x - search_range, mv.y - search_range };
; 944  :     vector2d_t max_mv = { mv.x + search_range, mv.y + search_range };

	lea	edx, DWORD PTR [r14+rbx]
	mov	ecx, eax
	sub	ecx, ebx
	mov	DWORD PTR max_mv$2$sroa$715$1$[rsp], edx
	add	eax, ebx
	mov	DWORD PTR min_mv$1$sroa$713$1$[rsp], ecx
	sub	r14d, ebx
	mov	DWORD PTR max_mv$2$sroa$714$1$[rsp], eax
	cmp	r14d, edx

; 945  : 
; 946  :     for (int y = min_mv.y; y <= max_mv.y; ++y) {

	jg	$LN14@search_mv_
	npad	3
$LL19@search_mv_:

; 947  :       for (int x = min_mv.x; x <= max_mv.x; ++x) {

	mov	edi, ecx
	cmp	ecx, eax
	jg	$LN17@search_mv_

; 199  :   return fracmv_within_tile(info, x * 4, y * 4);

	lea	ecx, DWORD PTR [r14*4]
$LL22@search_mv_:

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r13, QWORD PTR [rsi]

; 199  :   return fracmv_within_tile(info, x * 4, y * 4);

	lea	r12d, DWORD PTR [rdi*4]

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, r12d
	mov	r9, QWORD PTR [r13]
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN97@search_mv_
	dec	eax
	or	eax, -8
	inc	eax
$LN97@search_mv_:
	test	eax, eax
	jne	SHORT $LN55@search_mv_
	mov	eax, ecx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN96@search_mv_
	dec	eax
	or	eax, -8
	inc	eax
$LN96@search_mv_:
	test	eax, eax
	jne	SHORT $LN55@search_mv_
	xor	r10b, r10b
	jmp	SHORT $LN56@search_mv_
$LN55@search_mv_:
	mov	r10b, 1
$LN56@search_mv_:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r9+172], 0
	je	$LN46@search_mv_
	cmp	DWORD PTR [r9+168], 0
	je	$LN46@search_mv_

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {
; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;
; 122  :     } else if (is_frac_chroma) {
; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	movzx	r8d, r10b
	add	r8d, r8d
	cmp	DWORD PTR [r9+44], 0
	je	SHORT $LN42@search_mv_

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r8d, 10
	jmp	SHORT $LN44@search_mv_
$LN42@search_mv_:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r9+40], 0
	je	SHORT $LN44@search_mv_

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r8d, 8
$LN44@search_mv_:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	eax, DWORD PTR [rsi+40]
	add	eax, DWORD PTR [rsi+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	r15d, DWORD PTR [r9+6536]
	add	eax, r8d
	mov	ebp, DWORD PTR [rsi+28]
	add	eax, r14d
	shl	eax, 2
	cdq
	movzx	r11d, dl
	add	r11d, eax
	mov	eax, DWORD PTR [rsi+32]
	cdq
	sar	r11d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	r11d, eax
	cmp	r11d, r15d
	jg	$LN20@search_mv_

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	ecx, DWORD PTR [rsi+36]
	add	ecx, ebp
	add	ecx, r8d
	lea	eax, DWORD PTR [r12+rcx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, ebp
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r9+6532]
	sar	eax, 6
	add	edx, r15d
	sub	r8d, eax
	add	r8d, r11d
	cmp	r8d, edx
	jg	$LN20@search_mv_
	mov	r11, QWORD PTR $T3[rsp]
	mov	ebp, 8
$LN46@search_mv_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r9+2360]
	test	eax, eax
	jne	SHORT $LN47@search_mv_

; 162  :     return true;

	lea	r9, QWORD PTR [rsi+40]
	jmp	SHORT $LN93@search_mv_
$LN47@search_mv_:

; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	xor	edx, edx

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN51@search_mv_

; 168  :     if (is_frac_luma) {
; 169  :       margin = 4 << 2;
; 170  :     } else if (is_frac_chroma) {

	test	r10b, r10b
	cmovne	edx, ebp
$LN51@search_mv_:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [rsi+28]
	mov	r8d, DWORD PTR [rsi+32]
	add	r8d, r14d
	shl	r8d, 2
	lea	r9d, DWORD PTR [r12+rax*4]
	cmp	r9d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	$LN20@search_mv_
	cmp	r8d, edx
	jl	$LN20@search_mv_

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [r13+48]
	mov	r10, QWORD PTR [rax]
	mov	eax, DWORD PTR [rsi+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r10+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r9d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN20@search_mv_

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	eax, DWORD PTR [rsi+40]
	lea	r9, QWORD PTR [rsi+40]
	mov	ecx, DWORD PTR [r10+20]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN20@search_mv_
$LN93@search_mv_:

; 948  :         if (!intmv_within_tile(info, x, y)) {
; 949  :           continue;
; 950  :         }
; 951  : 
; 952  :         // Avoid calculating the same points over and over again.
; 953  :         bool already_tested = false;
; 954  :         for (int j = -1; j < i; ++j) {

	mov	r8, -1
	cmp	r8, r11
	jge	SHORT $LN95@search_mv_
	lea	r10, QWORD PTR [r8-2]
	npad	3
$LL25@search_mv_:

; 955  :           int xx = 0;

	xor	eax, eax

; 956  :           int yy = 0;

	xor	edx, edx

; 957  :           if (j >= 0) {

	test	r8, r8
	js	SHORT $LN30@search_mv_

; 958  :             if (info->merge_cand[j].dir == 3) continue;

	movzx	eax, BYTE PTR [r9]
	cmp	al, 3
	je	SHORT $LN23@search_mv_

; 959  :             xx = info->merge_cand[j].mv[info->merge_cand[j].dir - 1][0] >> 2;

	lea	rcx, QWORD PTR [r10+rax]
	movsx	eax, WORD PTR [rsi+rcx*4+52]

; 960  :             yy = info->merge_cand[j].mv[info->merge_cand[j].dir - 1][1] >> 2;

	movsx	edx, WORD PTR [rsi+rcx*4+54]
	sar	eax, 2
	sar	edx, 2
$LN30@search_mv_:

; 961  :           }
; 962  :           if (x >= xx - search_range && x <= xx + search_range &&
; 963  :               y >= yy - search_range && y <= yy + search_range)

	mov	ecx, eax
	sub	ecx, ebx
	cmp	edi, ecx
	jl	SHORT $LN23@search_mv_
	lea	ecx, DWORD PTR [rax+rbx]
	cmp	edi, ecx
	jg	SHORT $LN23@search_mv_
	mov	eax, edx
	sub	eax, ebx
	cmp	r14d, eax
	jl	SHORT $LN23@search_mv_
	lea	eax, DWORD PTR [rdx+rbx]
	cmp	r14d, eax
	jle	$LN67@search_mv_
$LN23@search_mv_:

; 948  :         if (!intmv_within_tile(info, x, y)) {
; 949  :           continue;
; 950  :         }
; 951  : 
; 952  :         // Avoid calculating the same points over and over again.
; 953  :         bool already_tested = false;
; 954  :         for (int j = -1; j < i; ++j) {

	inc	r8
	add	r9, 12
	add	r10, 3
	cmp	r8, r11
	jl	SHORT $LL25@search_mv_
$LN95@search_mv_:

; 971  : 
; 972  :         check_mv_cost(info, x, y);

	mov	r8d, r14d
	mov	edx, edi
	mov	rcx, rsi
	call	check_mv_cost
$LN20@search_mv_:

; 947  :       for (int x = min_mv.x; x <= max_mv.x; ++x) {

	mov	eax, DWORD PTR max_mv$2$sroa$714$1$[rsp]
	lea	ecx, DWORD PTR [r14*4]
	mov	r11, QWORD PTR $T3[rsp]
	inc	edi
	mov	ebp, 8
	cmp	edi, eax
	jle	$LL22@search_mv_
	mov	ecx, DWORD PTR min_mv$1$sroa$713$1$[rsp]
	mov	edx, DWORD PTR max_mv$2$sroa$715$1$[rsp]
$LN17@search_mv_:

; 945  : 
; 946  :     for (int y = min_mv.y; y <= max_mv.y; ++y) {

	inc	r14d
	cmp	r14d, edx
	jle	$LL19@search_mv_
	mov	r8d, DWORD PTR i$1$[rsp]
	mov	r9, QWORD PTR tv1515[rsp]
$LN14@search_mv_:

; 926  :       }
; 927  :     }
; 928  :   }
; 929  : 
; 930  :   // Select starting point from among merge candidates. These should include
; 931  :   // both mv_cand vectors and (0, 0).
; 932  :   for (int i = 0; i < info->num_merge_cand; ++i) {

	mov	rax, QWORD PTR tv1514[rsp]
	inc	r8d
	add	rax, 12
	mov	DWORD PTR i$1$[rsp], r8d
	inc	r11
	mov	QWORD PTR tv1514[rsp], rax
	add	r9, 3
	mov	QWORD PTR $T3[rsp], r11
	mov	QWORD PTR tv1515[rsp], r9
	cmp	r8d, DWORD PTR [rsi+112]
	jl	$LL16@search_mv_
	mov	r13, QWORD PTR [rsp+80]
$LN15@search_mv_:
	mov	r14, QWORD PTR [rsp+72]

; 973  :       }
; 974  :     }
; 975  :   }
; 976  : }

	add	rsp, 88					; 00000058H
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN67@search_mv_:

; 964  :           {
; 965  :             already_tested = true;
; 966  :             x = xx + search_range;

	mov	edi, ecx

; 967  :             break;
; 968  :           }
; 969  :         }
; 970  :         if (already_tested) continue;

	jmp	$LN20@search_mv_
search_mv_full ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
sample_off_x$1$ = 0
sample_off_y$1$ = 1
best_cost$1$ = 4
best_index$1$ = 8
mv$ = 16
within_tile$1 = 24
best_bitcost$1$ = 28
i$1$ = 32
ext_s$ = 36
step$1$ = 40
tv2777 = 44
height$1$ = 48
width$1$ = 52
tv2769 = 56
fme_level$1$ = 60
costs$ = 64
internal_height$1$ = 80
internal_width$1$ = 84
tmp_stride$1$ = 88
mv_shift$1$ = 92
ext_origin$ = 96
tv2750 = 104
tv2751 = 112
bitcosts$ = 120
tv2802 = 136
state$1$ = 144
$T2 = 152
ext$ = 160
tmp_pic$1$ = 168
epol_args$ = 176
pattern$3 = 272
filter_steps$ = 304
filtered_pos$4 = 336
hor_first_cols$ = 368
ext_buffer$ = 1088
filtered$ = 6272
intermediate$ = 22656
info$ = 68944
search_frac PROC

; 986  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	mov	eax, 68896				; 00010d20H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+160]
	and	rbp, -64				; ffffffffffffffc0H

; 987  :   // Map indexes to relative coordinates in the following way:
; 988  :   // 5 3 6
; 989  :   // 1 0 2
; 990  :   // 7 4 8
; 991  :   static const vector2d_t square[9] = {
; 992  :       {  0,  0 },  { -1,  0 },  {  1,  0 },
; 993  :       {  0, -1 },  {  0,  1 },  { -1, -1 },
; 994  :       {  1, -1 },  { -1,  1 },  {  1,  1 }
; 995  :   };
; 996  : 
; 997  :   // Set mv to pixel precision
; 998  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	r15d, DWORD PTR [rcx+128]
	mov	r12, rcx
	mov	r14d, DWORD PTR [rcx+132]

; 999  : 
; 1000 :   unsigned best_cost = UINT32_MAX;
; 1001 :   uint32_t best_bitcost = 0;
; 1002 :   uint32_t bitcosts[4] = { 0 };
; 1003 :   unsigned best_index = 0;

	xor	r10d, r10d

; 1004 : 
; 1005 :   unsigned costs[4] = { 0 };
; 1006 : 
; 1007 :   ALIGNED(64) kvz_pixel filtered[4][LCU_LUMA_SIZE];
; 1008 : 
; 1009 :   // Storage buffers for intermediate horizontally filtered results.
; 1010 :   // Have the first columns in contiguous memory for vectorization.
; 1011 :   ALIGNED(64) int16_t intermediate[5][KVZ_IPOL_MAX_IM_SIZE_LUMA_SIMD];
; 1012 :   int16_t hor_first_cols[5][KVZ_EXT_BLOCK_W_LUMA + 1];
; 1013 : 
; 1014 :   const kvz_picture *ref = info->ref;

	mov	rcx, QWORD PTR [rcx+16]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR bitcosts$[rbp], xmm0

; 1015 :   const kvz_picture *pic = info->pic;
; 1016 :   vector2d_t orig = info->origin;
; 1017 :   const int width = info->width;
; 1018 :   const int height = info->height;
; 1019 :   const int internal_width  = ((width  + 7) >> 3) << 3; // Round up to closest 8
; 1020 :   const int internal_height = ((height + 7) >> 3) << 3;
; 1021 : 
; 1022 :   const encoder_state_t *state = info->state;

	mov	r13, QWORD PTR [r12]
	mov	eax, DWORD PTR [r12+36]
	mov	edx, DWORD PTR [r12+40]
	mov	rdi, QWORD PTR [r12+28]
	mov	rsi, QWORD PTR [r12+8]
	mov	rbx, rdi
	lea	r8d, DWORD PTR [rax+7]
	mov	DWORD PTR width$1$[rbp], eax
	movups	XMMWORD PTR costs$[rbp], xmm0

; 1023 :   int fme_level = state->encoder_control->cfg.fme_level;

	mov	rax, QWORD PTR [r13]
	lea	r9d, DWORD PTR [rdx+7]
	and	r8d, -8
	mov	DWORD PTR height$1$[rbp], edx
	and	r9d, -8
	sar	r15d, 2
	shr	rbx, 32					; 00000020H
	mov	edx, DWORD PTR [rax+84]

; 1024 :   int8_t sample_off_x = 0;
; 1025 :   int8_t sample_off_y = 0;
; 1026 : 
; 1027 :   // Space for (possibly) extrapolated pixels and the part from the picture
; 1028 :   // One extra row and column compared to normal interpolation and some extra for AVX2.
; 1029 :   // The extrapolation function will set the pointers and stride.
; 1030 :   kvz_pixel ext_buffer[KVZ_FME_MAX_INPUT_SIZE_SIMD];
; 1031 :   kvz_pixel *ext = NULL;

	mov	QWORD PTR ext$[rbp], r10

; 1032 :   kvz_pixel *ext_origin = NULL;

	mov	QWORD PTR ext_origin$[rbp], r10

; 1033 :   int ext_s = 0;

	mov	DWORD PTR ext_s$[rbp], r10d

; 1034 :   kvz_epol_args epol_args = {

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR epol_args$[rbp], rax
	mov	eax, DWORD PTR [rcx+64]
	mov	DWORD PTR epol_args$[rbp+8], eax
	mov	eax, DWORD PTR [rcx+68]
	mov	DWORD PTR epol_args$[rbp+12], eax
	mov	eax, DWORD PTR [rcx+72]
	mov	DWORD PTR epol_args$[rbp+16], eax
	mov	rax, QWORD PTR [r13+48]
	sar	r14d, 2
	mov	DWORD PTR best_index$1$[rbp], r10d
	mov	DWORD PTR internal_width$1$[rbp], r8d
	mov	ecx, DWORD PTR [rax+20]
	lea	eax, DWORD PTR [r15-1]
	add	ecx, edi
	mov	DWORD PTR internal_height$1$[rbp], r9d
	add	eax, ecx
	mov	QWORD PTR state$1$[rbp], r13
	mov	DWORD PTR epol_args$[rbp+20], eax
	mov	rax, QWORD PTR [r13+48]
	mov	DWORD PTR fme_level$1$[rbp], edx
	mov	BYTE PTR sample_off_x$1$[rbp], r10b
	mov	BYTE PTR sample_off_y$1$[rbp], r10b
	mov	ecx, DWORD PTR [rax+24]
	lea	eax, DWORD PTR [rbx-1]
	add	ecx, r14d
	mov	DWORD PTR epol_args$[rbp+36], 3
	add	eax, ecx
	mov	DWORD PTR epol_args$[rbp+40], 4
	mov	DWORD PTR epol_args$[rbp+24], eax

; 1035 :     .src = ref->y,
; 1036 :     .src_w = ref->width,
; 1037 :     .src_h = ref->height,
; 1038 :     .src_s = ref->stride,
; 1039 :     .blk_x = state->tile->offset_x + orig.x + mv.x - 1,
; 1040 :     .blk_y = state->tile->offset_y + orig.y + mv.y - 1,
; 1041 :     .blk_w = internal_width + 1,  // TODO: real width
; 1042 :     .blk_h = internal_height + 1, // TODO: real height
; 1043 :     .pad_l = KVZ_LUMA_FILTER_OFFSET,
; 1044 :     .pad_r = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 1045 :     .pad_t = KVZ_LUMA_FILTER_OFFSET,
; 1046 :     .pad_b = KVZ_EXT_PADDING_LUMA - KVZ_LUMA_FILTER_OFFSET,
; 1047 :     .pad_b_simd = 0 // AVX2 padding unnecessary because of blk_h
; 1048 :   };
; 1049 : 
; 1050 :   // Initialize separately. Gets rid of warning
; 1051 :   // about using nonstandard extension.
; 1052 :   epol_args.buf = ext_buffer;
; 1053 :   epol_args.ext = &ext;
; 1054 :   epol_args.ext_origin = &ext_origin;
; 1055 :   epol_args.ext_s = &ext_s;
; 1056 : 
; 1057 :   kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$[rbp]
	lea	eax, DWORD PTR [r8+1]
	mov	DWORD PTR epol_args$[rbp+44], 3
	mov	DWORD PTR epol_args$[rbp+28], eax
	lea	eax, DWORD PTR [r9+1]
	mov	DWORD PTR epol_args$[rbp+32], eax
	lea	rax, QWORD PTR ext_buffer$[rbp]
	mov	QWORD PTR epol_args$[rbp+56], rax
	lea	rax, QWORD PTR ext$[rbp]
	mov	QWORD PTR epol_args$[rbp+64], rax
	lea	rax, QWORD PTR ext_origin$[rbp]
	mov	QWORD PTR epol_args$[rbp+72], rax
	lea	rax, QWORD PTR ext_s$[rbp]
	mov	QWORD PTR epol_args$[rbp+80], rax
	mov	QWORD PTR epol_args$[rbp+48], 4
	call	QWORD PTR kvz_get_extended_block

; 1058 : 
; 1059 :   kvz_pixel *tmp_pic = pic->y + orig.y * pic->stride + orig.x;

	mov	r9d, DWORD PTR [rsi+72]
	mov	eax, r9d
	imul	eax, ebx
	mov	DWORD PTR tmp_stride$1$[rbp], r9d
	movsxd	r10, eax
	add	r10, QWORD PTR [rsi+16]
	movsxd	rax, edi
	add	r10, rax

; 1060 :   int tmp_stride = pic->stride;
; 1061 :                   
; 1062 :   // Search integer position
; 1063 :   costs[0] = kvz_satd_any_size(width, height,

	movsxd	r8, DWORD PTR ext_s$[rbp]
	mov	rdx, QWORD PTR ext_origin$[rbp]
	mov	ecx, DWORD PTR width$1$[rbp]
	inc	rdx
	add	rdx, r8
	mov	DWORD PTR [rsp+40], r8d
	mov	QWORD PTR [rsp+32], rdx
	mov	r8, r10
	mov	edx, DWORD PTR height$1$[rbp]
	mov	QWORD PTR tmp_pic$1$[rbp], r10
	call	QWORD PTR kvz_satd_any_size
	mov	DWORD PTR costs$[rbp], eax

; 1064 :     tmp_pic, tmp_stride,
; 1065 :     ext_origin + ext_s + 1, ext_s);
; 1066 : 
; 1067 :   costs[0] += info->mvd_cost_func(state,

	lea	rdx, QWORD PTR [r12+44]
	lea	rax, QWORD PTR bitcosts$[rbp]
	mov	r9d, 2
	mov	QWORD PTR [rsp+64], rax
	lea	rcx, QWORD PTR [r12+52]
	mov	eax, DWORD PTR [r12+24]
	mov	r8d, r14d
	mov	DWORD PTR [rsp+56], eax
	movzx	eax, WORD PTR [r12+112]
	mov	WORD PTR [rsp+48], ax
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, r13
	mov	QWORD PTR [rsp+32], rdx
	mov	edx, r15d
	call	QWORD PTR [r12+120]
	mov	ecx, DWORD PTR costs$[rbp]

; 1068 :                                   mv.x, mv.y, 2,
; 1069 :                                   info->mv_cand,
; 1070 :                                   info->merge_cand,
; 1071 :                                   info->num_merge_cand,
; 1072 :                                   info->ref_idx,
; 1073 :                                   &bitcosts[0]);
; 1074 :   best_cost = costs[0];
; 1075 :   best_bitcost = bitcosts[0];

	lea	r13d, DWORD PTR [r15+r15]

; 1076 :   
; 1077 :   //Set mv to half-pixel precision
; 1078 :   mv.x *= 2;
; 1079 :   mv.y *= 2;
; 1080 : 
; 1081 :   ipol_blocks_func * filter_steps[4] = {
; 1082 :     kvz_filter_hpel_blocks_hor_ver_luma,
; 1083 :     kvz_filter_hpel_blocks_diag_luma,
; 1084 :     kvz_filter_qpel_blocks_hor_ver_luma,
; 1085 :     kvz_filter_qpel_blocks_diag_luma,
; 1086 :   };
; 1087 : 
; 1088 :   // Search halfpel positions around best integer mv
; 1089 :   int i = 1;
; 1090 :   for (int step = 0; step < fme_level; ++step){

	mov	edx, DWORD PTR fme_level$1$[rbp]
	lea	ebx, DWORD PTR [r14+r14]
	mov	r9d, DWORD PTR bitcosts$[rbp]
	add	ecx, eax
	mov	rax, QWORD PTR kvz_filter_hpel_blocks_hor_ver_luma
	xor	r8d, r8d
	mov	QWORD PTR filter_steps$[rbp], rax
	mov	rax, QWORD PTR kvz_filter_hpel_blocks_diag_luma
	mov	QWORD PTR filter_steps$[rbp+8], rax
	mov	rax, QWORD PTR kvz_filter_qpel_blocks_hor_ver_luma
	mov	QWORD PTR filter_steps$[rbp+16], rax
	mov	rax, QWORD PTR kvz_filter_qpel_blocks_diag_luma
	mov	QWORD PTR filter_steps$[rbp+24], rax
	mov	eax, 1
	mov	DWORD PTR i$1$[rbp], eax
	mov	esi, eax
	mov	DWORD PTR best_cost$1$[rbp], ecx
	mov	DWORD PTR costs$[rbp], ecx
	mov	DWORD PTR best_bitcost$1$[rbp], r9d
	mov	DWORD PTR mv$[rbp], r13d
	mov	DWORD PTR mv$[rbp+4], ebx
	mov	DWORD PTR step$1$[rbp], r8d
	test	edx, edx
	jle	$LN3@search_fra

; 145  :     const vector2d_t mv_lcu = {

	xor	r10d, r10d
	lea	eax, DWORD PTR [rdx-1]
	mov	QWORD PTR $T2[rbp], r10
	lea	r15, OFFSET FLAT:?square@?1??search_frac@@9@9
	mov	DWORD PTR tv2769[rbp], eax
	lea	r14d, QWORD PTR [r8+8]
$LL4@search_fra:

; 1093 : 
; 1094 :     filter_steps[step](state->encoder_control,

	movzx	eax, BYTE PTR sample_off_y$1$[rbp]
	xor	edi, edi
	mov	rcx, QWORD PTR state$1$[rbp]
	cmp	r8d, 2
	mov	r9d, DWORD PTR internal_width$1$[rbp]
	movzx	r8d, WORD PTR ext_s$[rbp]
	setb	dil
	mov	BYTE PTR [rsp+80], al
	movzx	eax, BYTE PTR sample_off_x$1$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rsp+72], al
	lea	rax, QWORD PTR hor_first_cols$[rbp]
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR intermediate$[rbp]
	mov	BYTE PTR [rsp+56], dl
	mov	rdx, QWORD PTR ext_origin$[rbp]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR filtered$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR internal_height$1$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	DWORD PTR mv_shift$1$[rbp], edi
	call	QWORD PTR filter_steps$[rbp+r10*8]

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r9, QWORD PTR [r12]
	mov	ecx, edi

; 1095 :       ext_origin,
; 1096 :       ext_s,
; 1097 :       internal_width,
; 1098 :       internal_height,
; 1099 :       filtered,
; 1100 :       intermediate,
; 1101 :       fme_level,
; 1102 :       hor_first_cols,
; 1103 :       sample_off_x,
; 1104 :       sample_off_y);
; 1105 :           
; 1106 :     const vector2d_t *pattern[4] = { &square[i], &square[i + 1], &square[i + 2], &square[i + 3] };

	movsxd	rax, esi

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	edx, 1
	rol	edx, cl

; 1091 : 
; 1092 :     const int mv_shift = (step < 2) ? 1 : 0;

	mov	ecx, 2

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	DWORD PTR tv2777[rbp], edx

; 1091 : 
; 1092 :     const int mv_shift = (step < 2) ? 1 : 0;

	mov	QWORD PTR tv2802[rbp], rcx

; 1095 :       ext_origin,
; 1096 :       ext_s,
; 1097 :       internal_width,
; 1098 :       internal_height,
; 1099 :       filtered,
; 1100 :       intermediate,
; 1101 :       fme_level,
; 1102 :       hor_first_cols,
; 1103 :       sample_off_x,
; 1104 :       sample_off_y);
; 1105 :           
; 1106 :     const vector2d_t *pattern[4] = { &square[i], &square[i + 1], &square[i + 2], &square[i + 3] };

	lea	rax, QWORD PTR [r15+rax*8]
	mov	QWORD PTR pattern$3[rbp], rax
	lea	eax, DWORD PTR [rsi+1]
	cdqe
	lea	rax, QWORD PTR [r15+rax*8]
	mov	QWORD PTR pattern$3[rbp+8], rax
	lea	eax, DWORD PTR [rsi+2]
	cdqe
	lea	rax, QWORD PTR [r15+rax*8]
	mov	QWORD PTR pattern$3[rbp+16], rax
	lea	eax, DWORD PTR [rsi+3]
	cdqe
	lea	rax, QWORD PTR [r15+rax*8]
	mov	QWORD PTR pattern$3[rbp+24], rax
	lea	rax, QWORD PTR within_tile$1[rbp+1]
	mov	QWORD PTR tv2751[rbp], rax
	lea	rax, QWORD PTR pattern$3[rbp+8]
	mov	QWORD PTR tv2750[rbp], rax

; 1107 : 
; 1108 :     int8_t within_tile[4];
; 1109 :     for (int j = 0; j < 4; j++) {

	jmp	SHORT $LN7@search_fra
	npad	3
$LL115@search_fra:
	mov	ebx, DWORD PTR mv$[rbp+4]
$LN7@search_fra:

; 1110 :       within_tile[j] =

	mov	rax, QWORD PTR [rax-8]

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r10, QWORD PTR [r9]

; 1110 :       within_tile[j] =

	mov	r11d, DWORD PTR [rax+4]
	add	r11d, ebx
	mov	ebx, DWORD PTR [rax]
	add	ebx, r13d
	imul	r11d, edx
	imul	ebx, edx

; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, ebx
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN110@search_fra
	dec	eax
	or	eax, -4
	inc	eax
$LN110@search_fra:
	test	eax, eax
	jne	SHORT $LN38@search_fra
	mov	eax, r11d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN109@search_fra
	dec	eax
	or	eax, -4
	inc	eax
$LN109@search_fra:
	test	eax, eax
	jne	SHORT $LN38@search_fra
	xor	r13b, r13b
	jmp	SHORT $LN39@search_fra
$LN38@search_fra:
	mov	r13b, 1
$LN39@search_fra:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, ebx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN108@search_fra
	dec	eax
	or	eax, -8
	inc	eax
$LN108@search_fra:
	test	eax, eax
	jne	SHORT $LN40@search_fra
	mov	eax, r11d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN107@search_fra
	dec	eax
	or	eax, -8
	inc	eax
$LN107@search_fra:
	test	eax, eax
	jne	SHORT $LN40@search_fra
	xor	r15b, r15b
	jmp	SHORT $LN41@search_fra
$LN40@search_fra:
	mov	r15b, 1
$LN41@search_fra:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r10+172], 0
	je	$LN31@search_fra
	cmp	DWORD PTR [r10+168], 0
	je	$LN31@search_fra

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	r13b, r13b
	je	SHORT $LN24@search_fra

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	r9d, 4
	jmp	SHORT $LN26@search_fra
$LN24@search_fra:

; 122  :     } else if (is_frac_chroma) {

	xor	r9d, r9d
	test	r15b, r15b
	cmovne	r9d, ecx
$LN26@search_fra:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r10+44], 0
	je	SHORT $LN27@search_fra

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r9d, 10
	jmp	SHORT $LN29@search_fra
$LN27@search_fra:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r10+40], 0
	je	SHORT $LN29@search_fra

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r9d, 8
$LN29@search_fra:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR [r12+40]
	add	edx, DWORD PTR [r12+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	esi, DWORD PTR [r10+6536]
	add	edx, r9d
	mov	r14d, DWORD PTR [r12+28]
	lea	eax, DWORD PTR [r11+rdx*4]
	cdq
	movzx	edi, dl
	add	edi, eax
	mov	eax, DWORD PTR [r12+32]
	cdq
	sar	edi, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	edi, eax
	cmp	edi, esi
	jg	$LN42@search_fra

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	ecx, DWORD PTR [r12+36]
	add	ecx, r14d
	add	ecx, r9d
	lea	eax, DWORD PTR [rbx+rcx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, r14d
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r10+6532]
	sar	eax, 6
	add	edx, esi
	sub	r8d, eax
	add	r8d, edi
	cmp	r8d, edx
	jg	$LN42@search_fra
	mov	r9, QWORD PTR [r12]
	mov	r14d, 8
$LN31@search_fra:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r10+2360]
	test	eax, eax
	jne	SHORT $LN32@search_fra

; 162  :     return true;

	mov	al, 1
	jmp	SHORT $LN22@search_fra
$LN32@search_fra:

; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	xor	edx, edx

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN36@search_fra

; 168  :     if (is_frac_luma) {

	test	r13b, r13b
	je	SHORT $LN34@search_fra

; 169  :       margin = 4 << 2;

	lea	edx, QWORD PTR [rax+12]
	jmp	SHORT $LN36@search_fra
$LN34@search_fra:

; 170  :     } else if (is_frac_chroma) {

	test	r15b, r15b
	cmovne	edx, r14d
$LN36@search_fra:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [r12+28]
	lea	r10d, DWORD PTR [rbx+rax*4]
	mov	eax, DWORD PTR [r12+32]
	lea	r8d, DWORD PTR [r11+rax*4]
	cmp	r10d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	SHORT $LN42@search_fra
	cmp	r8d, edx
	jl	SHORT $LN42@search_fra

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [r9+48]
	mov	r9, QWORD PTR [rax]
	mov	eax, DWORD PTR [r12+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r9+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r10d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN42@search_fra

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	ecx, DWORD PTR [r9+20]
	mov	eax, DWORD PTR [r12+40]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN42@search_fra
	mov	al, 1
	jmp	SHORT $LN22@search_fra
$LN42@search_fra:

; 1110 :       within_tile[j] =

	xor	al, al
$LN22@search_fra:
	mov	rcx, QWORD PTR tv2751[rbp]
	mov	BYTE PTR [rcx-1], al
	mov	rax, QWORD PTR tv2750[rbp]

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	rcx, QWORD PTR [r12]

; 1110 :       within_tile[j] =

	mov	rax, QWORD PTR [rax]

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r10, QWORD PTR [rcx]

; 1110 :       within_tile[j] =

	mov	ebx, DWORD PTR [rax]
	mov	r11d, DWORD PTR [rax+4]
	add	ebx, DWORD PTR mv$[rbp]
	imul	ebx, DWORD PTR tv2777[rbp]
	add	r11d, DWORD PTR mv$[rbp+4]
	imul	r11d, DWORD PTR tv2777[rbp]

; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, ebx
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN106@search_fra
	dec	eax
	or	eax, -4
	inc	eax
$LN106@search_fra:
	test	eax, eax
	jne	SHORT $LN66@search_fra
	mov	eax, r11d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN105@search_fra
	dec	eax
	or	eax, -4
	inc	eax
$LN105@search_fra:
	test	eax, eax
	jne	SHORT $LN66@search_fra
	xor	r13b, r13b
	jmp	SHORT $LN67@search_fra
$LN66@search_fra:
	mov	r13b, 1
$LN67@search_fra:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, ebx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN104@search_fra
	dec	eax
	or	eax, -8
	inc	eax
$LN104@search_fra:
	test	eax, eax
	jne	SHORT $LN68@search_fra
	mov	eax, r11d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN103@search_fra
	dec	eax
	or	eax, -8
	inc	eax
$LN103@search_fra:
	test	eax, eax
	jne	SHORT $LN68@search_fra
	xor	r15b, r15b
	jmp	SHORT $LN69@search_fra
$LN68@search_fra:
	mov	r15b, 1
$LN69@search_fra:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r10+172], 0
	je	$LN75@search_fra
	cmp	DWORD PTR [r10+168], 0
	je	$LN75@search_fra

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	r13b, r13b
	je	SHORT $LN70@search_fra

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	r9d, 4
	jmp	SHORT $LN71@search_fra
$LN70@search_fra:

; 122  :     } else if (is_frac_chroma) {

	xor	r9d, r9d
	mov	eax, 2
	test	r15b, r15b
	cmovne	r9d, eax
$LN71@search_fra:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r10+44], 0
	je	SHORT $LN72@search_fra

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r9d, 10
	jmp	SHORT $LN73@search_fra
$LN72@search_fra:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r10+40], 0
	je	SHORT $LN73@search_fra

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r9d, 8
$LN73@search_fra:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR [r12+40]
	add	edx, DWORD PTR [r12+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	esi, DWORD PTR [r10+6536]
	add	edx, r9d
	mov	r14d, DWORD PTR [r12+28]
	lea	eax, DWORD PTR [r11+rdx*4]
	cdq
	movzx	edi, dl
	add	edi, eax
	mov	eax, DWORD PTR [r12+32]
	cdq
	sar	edi, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	edi, eax
	cmp	edi, esi
	jg	$LN79@search_fra

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {
; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	ecx, DWORD PTR [r12+36]
	add	ecx, r14d
	add	ecx, r9d
	lea	eax, DWORD PTR [rbx+rcx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, r14d
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r10+6532]
	sar	eax, 6
	add	edx, esi
	sub	r8d, eax
	add	r8d, edi
	cmp	r8d, edx
	jg	$LN79@search_fra
	mov	rcx, QWORD PTR [r12]
$LN75@search_fra:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r10+2360]
	test	eax, eax
	jne	SHORT $LN76@search_fra

; 162  :     return true;

	mov	al, 1
	jmp	SHORT $LN81@search_fra
$LN76@search_fra:

; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	xor	edx, edx

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN78@search_fra

; 168  :     if (is_frac_luma) {

	test	r13b, r13b
	je	SHORT $LN77@search_fra

; 169  :       margin = 4 << 2;

	lea	edx, QWORD PTR [rax+12]
	jmp	SHORT $LN78@search_fra
$LN77@search_fra:

; 170  :     } else if (is_frac_chroma) {

	test	r15b, r15b
	mov	eax, 8
	cmovne	edx, eax
$LN78@search_fra:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [r12+28]
	lea	r10d, DWORD PTR [rbx+rax*4]
	mov	eax, DWORD PTR [r12+32]
	lea	r8d, DWORD PTR [r11+rax*4]
	cmp	r10d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	SHORT $LN79@search_fra
	cmp	r8d, edx
	jl	SHORT $LN79@search_fra

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [rcx+48]
	mov	r9, QWORD PTR [rax]
	mov	eax, DWORD PTR [r12+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r9+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r10d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN79@search_fra

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	ecx, DWORD PTR [r9+20]
	mov	eax, DWORD PTR [r12+40]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN79@search_fra
	mov	al, 1
	jmp	SHORT $LN81@search_fra
$LN79@search_fra:

; 1110 :       within_tile[j] =

	xor	al, al
$LN81@search_fra:
	mov	rcx, QWORD PTR tv2751[rbp]
	mov	r9, QWORD PTR [r12]
	mov	edx, DWORD PTR tv2777[rbp]
	mov	r13d, DWORD PTR mv$[rbp]
	mov	BYTE PTR [rcx], al
	add	rcx, 2
	mov	rax, QWORD PTR tv2750[rbp]
	add	rax, 16
	mov	QWORD PTR tv2751[rbp], rcx
	sub	QWORD PTR tv2802[rbp], 1
	mov	ecx, 2
	mov	QWORD PTR tv2750[rbp], rax
	lea	r14d, QWORD PTR [rcx+6]
	jne	$LL115@search_fra

; 1111 :         fracmv_within_tile(info, (mv.x + pattern[j]->x) * (1 << mv_shift), (mv.y + pattern[j]->y) * (1 << mv_shift));
; 1112 :     };
; 1113 : 
; 1114 :     kvz_pixel *filtered_pos[4] = { 0 };
; 1115 :     filtered_pos[0] = &filtered[0][0];
; 1116 :     filtered_pos[1] = &filtered[1][0];
; 1117 :     filtered_pos[2] = &filtered[2][0];
; 1118 :     filtered_pos[3] = &filtered[3][0];
; 1119 : 
; 1120 :     kvz_satd_any_size_quad(width, height, (const kvz_pixel **)filtered_pos, LCU_WIDTH, tmp_pic, tmp_stride, 4, costs, within_tile);

	mov	edx, DWORD PTR height$1$[rbp]
	lea	rax, QWORD PTR filtered$[rbp]
	mov	QWORD PTR filtered_pos$4[rbp], rax
	lea	r9d, QWORD PTR [rcx+62]
	mov	ecx, DWORD PTR width$1$[rbp]
	lea	rax, QWORD PTR filtered$[rbp+4096]
	mov	QWORD PTR filtered_pos$4[rbp+8], rax
	lea	r8, QWORD PTR filtered_pos$4[rbp]
	lea	rax, QWORD PTR filtered$[rbp+8192]
	mov	QWORD PTR filtered_pos$4[rbp+16], rax
	lea	rax, QWORD PTR filtered$[rbp+12288]
	mov	QWORD PTR filtered_pos$4[rbp+24], rax
	lea	rax, QWORD PTR within_tile$1[rbp]
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR costs$[rbp]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR tmp_stride$1$[rbp]
	mov	DWORD PTR [rsp+48], 4
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR tmp_pic$1$[rbp]
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR kvz_satd_any_size_quad
	lea	rdi, QWORD PTR within_tile$1[rbp]
	mov	r15d, 4
	lea	rbx, QWORD PTR costs$[rbp]
	lea	rsi, QWORD PTR pattern$3[rbp]
	lea	r14, QWORD PTR bitcosts$[rbp]
$LL10@search_fra:

; 1123 :       if (within_tile[j]) {

	cmp	BYTE PTR [rdi], 0
	mov	r13d, DWORD PTR mv$[rbp]
	je	SHORT $LN8@search_fra

; 1124 :         costs[j] += info->mvd_cost_func(

	mov	eax, DWORD PTR [r12+24]
	mov	rcx, QWORD PTR [rsi]
	mov	r8d, DWORD PTR mv$[rbp+4]
	mov	r9d, DWORD PTR mv_shift$1$[rbp]
	mov	QWORD PTR [rsp+64], r14
	mov	edx, DWORD PTR [rcx]
	add	r8d, DWORD PTR [rcx+4]
	add	edx, r13d
	mov	rcx, QWORD PTR state$1$[rbp]
	mov	DWORD PTR [rsp+56], eax
	movzx	eax, WORD PTR [r12+112]
	mov	WORD PTR [rsp+48], ax
	lea	rax, QWORD PTR [r12+52]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR [r12+44]
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR [r12+120]
	add	DWORD PTR [rbx], eax
$LN8@search_fra:

; 1121 : 
; 1122 :     for (int j = 0; j < 4; j++) {

	add	r14, 4
	inc	rdi
	add	rsi, 8
	add	rbx, 4
	sub	r15, 1
	jne	SHORT $LL10@search_fra

; 1125 :             state,
; 1126 :             mv.x + pattern[j]->x,
; 1127 :             mv.y + pattern[j]->y,
; 1128 :             mv_shift,
; 1129 :             info->mv_cand,
; 1130 :             info->merge_cand,
; 1131 :             info->num_merge_cand,
; 1132 :             info->ref_idx,
; 1133 :             &bitcosts[j]
; 1134 :         );
; 1135 :       }
; 1136 :     }
; 1137 : 
; 1138 :     for (int j = 0; j < 4; ++j) {
; 1139 :       if (within_tile[j] && costs[j] < best_cost) {

	mov	ecx, DWORD PTR best_cost$1$[rbp]
	mov	esi, DWORD PTR i$1$[rbp]
	cmp	BYTE PTR within_tile$1[rbp], r15b
	je	SHORT $LN118@search_fra
	mov	eax, DWORD PTR costs$[rbp]
	cmp	eax, ecx
	jae	SHORT $LN118@search_fra

; 1140 :         best_cost = costs[j];
; 1141 :         best_bitcost = bitcosts[j];

	mov	r9d, DWORD PTR bitcosts$[rbp]

; 1142 :         best_index = i + j;

	mov	edx, esi
	mov	DWORD PTR best_index$1$[rbp], edx
	mov	ecx, eax
	mov	DWORD PTR best_cost$1$[rbp], eax
	mov	DWORD PTR best_bitcost$1$[rbp], r9d
	jmp	SHORT $LN62@search_fra
$LN118@search_fra:

; 1125 :             state,
; 1126 :             mv.x + pattern[j]->x,
; 1127 :             mv.y + pattern[j]->y,
; 1128 :             mv_shift,
; 1129 :             info->mv_cand,
; 1130 :             info->merge_cand,
; 1131 :             info->num_merge_cand,
; 1132 :             info->ref_idx,
; 1133 :             &bitcosts[j]
; 1134 :         );
; 1135 :       }
; 1136 :     }
; 1137 : 
; 1138 :     for (int j = 0; j < 4; ++j) {
; 1139 :       if (within_tile[j] && costs[j] < best_cost) {

	mov	r9d, DWORD PTR best_bitcost$1$[rbp]
	mov	edx, DWORD PTR best_index$1$[rbp]
$LN62@search_fra:
	cmp	BYTE PTR within_tile$1[rbp+1], 0
	je	SHORT $LN94@search_fra
	mov	eax, DWORD PTR costs$[rbp+4]
	cmp	eax, ecx
	jae	SHORT $LN94@search_fra

; 1140 :         best_cost = costs[j];
; 1141 :         best_bitcost = bitcosts[j];

	mov	r9d, DWORD PTR bitcosts$[rbp+4]

; 1142 :         best_index = i + j;

	lea	edx, DWORD PTR [rsi+1]
	mov	DWORD PTR best_index$1$[rbp], edx
	mov	ecx, eax
	mov	DWORD PTR best_cost$1$[rbp], eax
	mov	DWORD PTR best_bitcost$1$[rbp], r9d
$LN94@search_fra:

; 1125 :             state,
; 1126 :             mv.x + pattern[j]->x,
; 1127 :             mv.y + pattern[j]->y,
; 1128 :             mv_shift,
; 1129 :             info->mv_cand,
; 1130 :             info->merge_cand,
; 1131 :             info->num_merge_cand,
; 1132 :             info->ref_idx,
; 1133 :             &bitcosts[j]
; 1134 :         );
; 1135 :       }
; 1136 :     }
; 1137 : 
; 1138 :     for (int j = 0; j < 4; ++j) {
; 1139 :       if (within_tile[j] && costs[j] < best_cost) {

	cmp	BYTE PTR within_tile$1[rbp+2], 0
	je	SHORT $LN96@search_fra
	mov	eax, DWORD PTR costs$[rbp+8]
	cmp	eax, ecx
	jae	SHORT $LN96@search_fra

; 1140 :         best_cost = costs[j];
; 1141 :         best_bitcost = bitcosts[j];

	mov	r9d, DWORD PTR bitcosts$[rbp+8]

; 1142 :         best_index = i + j;

	lea	edx, DWORD PTR [rsi+2]
	mov	DWORD PTR best_index$1$[rbp], edx
	mov	ecx, eax
	mov	DWORD PTR best_cost$1$[rbp], eax
	mov	DWORD PTR best_bitcost$1$[rbp], r9d
$LN96@search_fra:

; 1125 :             state,
; 1126 :             mv.x + pattern[j]->x,
; 1127 :             mv.y + pattern[j]->y,
; 1128 :             mv_shift,
; 1129 :             info->mv_cand,
; 1130 :             info->merge_cand,
; 1131 :             info->num_merge_cand,
; 1132 :             info->ref_idx,
; 1133 :             &bitcosts[j]
; 1134 :         );
; 1135 :       }
; 1136 :     }
; 1137 : 
; 1138 :     for (int j = 0; j < 4; ++j) {
; 1139 :       if (within_tile[j] && costs[j] < best_cost) {

	cmp	BYTE PTR within_tile$1[rbp+3], 0
	je	SHORT $LN98@search_fra
	mov	eax, DWORD PTR costs$[rbp+12]
	cmp	eax, ecx
	jae	SHORT $LN98@search_fra

; 1140 :         best_cost = costs[j];
; 1141 :         best_bitcost = bitcosts[j];

	mov	r9d, DWORD PTR bitcosts$[rbp+12]

; 1142 :         best_index = i + j;

	lea	edx, DWORD PTR [rsi+3]
	mov	DWORD PTR best_index$1$[rbp], edx
	mov	ecx, eax
	mov	DWORD PTR best_cost$1$[rbp], eax
	mov	DWORD PTR best_bitcost$1$[rbp], r9d
$LN98@search_fra:

; 1143 :       }
; 1144 :     }
; 1145 : 
; 1146 :     i += 4;
; 1147 : 
; 1148 :     // Update mv for the best position on current precision
; 1149 :     if (step == 1 || step == fme_level - 1) {

	mov	r10, QWORD PTR $T2[rbp]
	add	esi, 4
	mov	r8d, DWORD PTR step$1$[rbp]
	mov	r14d, DWORD PTR tv2769[rbp]
	mov	DWORD PTR i$1$[rbp], esi
	cmp	r10, 1
	je	SHORT $LN99@search_fra
	cmp	r8d, r14d
	jne	$LN114@search_fra
$LN99@search_fra:

; 1150 :       // Move search to best_index
; 1151 :       mv.x += square[best_index].x;
; 1152 :       mv.y += square[best_index].y;

	mov	ebx, DWORD PTR mv$[rbp+4]
	lea	r15, OFFSET FLAT:?square@?1??search_frac@@9@9
	mov	eax, edx

; 1153 : 
; 1154 :       // On last hpel step...
; 1155 :       if (step == MIN(fme_level - 1, 1)) {

	mov	r11d, 1
	mov	ecx, DWORD PTR [r15+rax*8]
	add	r13d, ecx
	mov	edx, DWORD PTR [r15+rax*8+4]
	add	ebx, edx
	cmp	r14d, 1
	mov	DWORD PTR mv$[rbp], r13d
	mov	eax, r14d
	mov	DWORD PTR mv$[rbp+4], ebx
	cmovge	eax, r11d
	cmp	r8d, eax
	jne	SHORT $LN116@search_fra

; 1156 :         //Set mv to quarterpel precision
; 1157 :         mv.x *= 2;

	add	r13d, r13d

; 1158 :         mv.y *= 2;
; 1159 :         sample_off_x = square[best_index].x;

	mov	BYTE PTR sample_off_x$1$[rbp], cl
	add	ebx, ebx
	mov	DWORD PTR mv$[rbp], r13d

; 1160 :         sample_off_y = square[best_index].y;
; 1161 :         best_index = 0;

	xor	eax, eax
	mov	DWORD PTR mv$[rbp+4], ebx
	mov	DWORD PTR best_index$1$[rbp], eax

; 1162 :         i = 1;

	mov	esi, r11d
	mov	BYTE PTR sample_off_y$1$[rbp], dl
	mov	DWORD PTR i$1$[rbp], r11d
$LN116@search_fra:

; 1076 :   
; 1077 :   //Set mv to half-pixel precision
; 1078 :   mv.x *= 2;
; 1079 :   mv.y *= 2;
; 1080 : 
; 1081 :   ipol_blocks_func * filter_steps[4] = {
; 1082 :     kvz_filter_hpel_blocks_hor_ver_luma,
; 1083 :     kvz_filter_hpel_blocks_diag_luma,
; 1084 :     kvz_filter_qpel_blocks_hor_ver_luma,
; 1085 :     kvz_filter_qpel_blocks_diag_luma,
; 1086 :   };
; 1087 : 
; 1088 :   // Search halfpel positions around best integer mv
; 1089 :   int i = 1;
; 1090 :   for (int step = 0; step < fme_level; ++step){

	mov	ecx, DWORD PTR best_cost$1$[rbp]
$LN2@search_fra:
	mov	edx, DWORD PTR fme_level$1$[rbp]
	inc	r8d
	inc	r10
	mov	DWORD PTR step$1$[rbp], r8d
	mov	QWORD PTR $T2[rbp], r10
	mov	r14d, 8
	cmp	r8d, edx
	jl	$LL4@search_fra
$LN3@search_fra:

; 1163 :       }
; 1164 :     }
; 1165 :   }
; 1166 : 
; 1167 :   info->best_mv = mv;

	mov	rax, QWORD PTR mv$[rbp]
	mov	QWORD PTR [r12+128], rax

; 1168 :   info->best_cost = best_cost;

	mov	DWORD PTR [r12+136], ecx

; 1169 :   info->best_bitcost = best_bitcost;

	mov	DWORD PTR [r12+140], r9d

; 1170 : }

	lea	r11, QWORD PTR [rsp+68896]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN114@search_fra:

; 1143 :       }
; 1144 :     }
; 1145 : 
; 1146 :     i += 4;
; 1147 : 
; 1148 :     // Update mv for the best position on current precision
; 1149 :     if (step == 1 || step == fme_level - 1) {

	mov	ebx, DWORD PTR mv$[rbp+4]
	lea	r15, OFFSET FLAT:?square@?1??search_frac@@9@9
	jmp	SHORT $LN2@search_fra
search_frac ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
mv$ = 8
scale$ = 16
get_scaled_mv PROC

; 1177 :   int32_t scaled = scale * mv;

	movsx	r8d, cx
	imul	r8d, edx

; 1178 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	eax, r8d
	shr	eax, 31
	lea	ecx, DWORD PTR [r8+127]
	add	ecx, eax
	mov	eax, 32767				; 00007fffH
	sar	ecx, 8
	cmp	ecx, eax
	jg	SHORT $LN9@get_scaled
	mov	eax, -32768				; ffffffffffff8000H
	cmp	ecx, eax
	jl	SHORT $LN9@get_scaled
	movzx	eax, cx
$LN9@get_scaled:

; 1179 : }

	ret	0
get_scaled_mv ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
current_poc$ = 8
current_ref_poc$ = 16
neighbor_poc$ = 24
neighbor_ref_poc$ = 32
mv_cand$ = 40
apply_mv_scaling PROC

; 1195 :   int32_t diff_current = current_poc - current_ref_poc;

	sub	ecx, edx

; 1196 :   int32_t diff_neighbor = neighbor_poc - neighbor_ref_poc;

	sub	r8d, r9d

; 1197 : 
; 1198 :   if (diff_current == diff_neighbor) return;

	cmp	ecx, r8d
	je	$LN1@apply_mv_s

; 1199 :   if (diff_neighbor == 0) return;

	test	r8d, r8d
	je	$LN1@apply_mv_s

; 1200 : 
; 1201 :   diff_current = CLIP(-128, 127, diff_current);

	mov	edx, 127				; 0000007fH
	mov	eax, -128				; ffffffffffffff80H
	cmp	ecx, edx

; 1202 :   diff_neighbor = CLIP(-128, 127, diff_neighbor);
; 1203 : 
; 1204 :   int scale = CLIP(-4096, 4095,

	mov	r9d, 4095				; 00000fffH
	cmovg	ecx, edx
	cmp	ecx, eax
	cmovl	ecx, eax
	cmp	r8d, edx
	cmovg	r8d, edx
	cmp	r8d, eax
	cmovl	r8d, eax
	mov	eax, r8d
	cdq
	xor	eax, edx
	sub	eax, edx
	sar	eax, 1
	add	eax, 16384				; 00004000H
	cdq
	idiv	r8d
	imul	eax, ecx
	add	eax, 32					; 00000020H
	sar	eax, 6
	cmp	eax, r9d
	jg	SHORT $LN12@apply_mv_s
	mov	r9d, -4096				; fffffffffffff000H
	cmp	eax, r9d
	jl	SHORT $LN12@apply_mv_s
	mov	r9d, eax
$LN12@apply_mv_s:

; 1177 :   int32_t scaled = scale * mv;

	mov	r10, QWORD PTR mv_cand$[rsp]

; 1178 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	r8d, -32768				; ffffffffffff8000H
	movsx	ecx, WORD PTR [r10]
	imul	ecx, r9d
	mov	eax, ecx
	shr	eax, 31
	lea	edx, DWORD PTR [rcx+127]
	add	edx, eax
	sar	edx, 8
	cmp	edx, 32767				; 00007fffH
	jg	SHORT $LN32@apply_mv_s
	cmp	edx, r8d
	jge	SHORT $LN20@apply_mv_s
	mov	edx, r8d
	jmp	SHORT $LN20@apply_mv_s
$LN32@apply_mv_s:
	mov	edx, 32767				; 00007fffH
$LN20@apply_mv_s:

; 1177 :   int32_t scaled = scale * mv;

	movsx	ecx, WORD PTR [r10+4]

; 1205 :     (diff_current * ((0x4000 + (abs(diff_neighbor) >> 1)) / diff_neighbor) + 32) >> 6);
; 1206 : 
; 1207 :   mv_cand->x = get_scaled_mv(mv_cand->x, scale);

	movsx	eax, dx

; 1177 :   int32_t scaled = scale * mv;

	imul	ecx, r9d

; 1205 :     (diff_current * ((0x4000 + (abs(diff_neighbor) >> 1)) / diff_neighbor) + 32) >> 6);
; 1206 : 
; 1207 :   mv_cand->x = get_scaled_mv(mv_cand->x, scale);

	mov	DWORD PTR [r10], eax

; 1178 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	eax, ecx
	shr	eax, 31
	lea	edx, DWORD PTR [rcx+127]
	add	edx, eax
	sar	edx, 8
	cmp	edx, 32767				; 00007fffH
	jg	SHORT $LN33@apply_mv_s
	cmp	edx, r8d
	jl	SHORT $LN28@apply_mv_s
	mov	r8d, edx

; 1208 :   mv_cand->y = get_scaled_mv(mv_cand->y, scale);

	movsx	eax, r8w
	mov	DWORD PTR [r10+4], eax

; 1209 : }

	ret	0
$LN33@apply_mv_s:

; 1178 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	r8d, 32767				; 00007fffH
$LN28@apply_mv_s:

; 1208 :   mv_cand->y = get_scaled_mv(mv_cand->y, scale);

	movsx	eax, r8w
	mov	DWORD PTR [r10+4], eax
$LN1@apply_mv_s:

; 1209 : }

	ret	0
apply_mv_scaling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
block_width$1$ = 80
steps$1$ = 80
best_dist$4 = 80
steps$1$ = 88
tv4924 = 88
ext_s$5 = 88
start$6 = 88
mv$ = 88
better_found$1$ = 96
pic_x$1$ = 104
mv_previous$7 = 104
margin$2$ = 112
tv4970 = 120
ext_origin$8 = 128
cfg$1$ = 128
state$1$ = 136
ext$9 = 136
epol_args$10 = 144
merge_cand$11 = 144
ext_buffer$12 = 240
LX_idx$1$ = 4416
info$ = 4416
ref_list$1$ = 4424
depth$dead$ = 4424
lcu$ = 4432
cur_cu$ = 4440
inter_cost$ = 4448
inter_bitcost$ = 4456
best_LX_cost$ = 4464
unipred_LX$ = 4472
search_pu_inter_ref PROC

; 1222 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-4088]
	mov	eax, 4344				; 000010f8H
	call	__chkstk
	sub	rsp, rax

; 1223 :   const kvz_config *cfg = &info->state->encoder_control->cfg;

	mov	rax, QWORD PTR [rcx]

; 1224 : 
; 1225 :   // which list, L0 or L1, ref_idx is in and in what index
; 1226 :   int8_t ref_list = -1;

	mov	sil, -1
	mov	rdi, r9
	mov	BYTE PTR ref_list$1$[rbp-256], sil
	mov	r13, rcx

; 1227 :   // the index of the ref_idx in L0 or L1 list
; 1228 :   int8_t LX_idx;
; 1229 :   // max value of LX_idx plus one
; 1230 :   const int8_t LX_IDX_MAX_PLUS_1 = MAX(info->state->frame->ref_LX_size[0],

	mov	r10, QWORD PTR [rax+40]
	mov	rdx, QWORD PTR [rax]
	mov	QWORD PTR cfg$1$[rbp-256], rdx
	movzx	eax, BYTE PTR [r10+81]
	movzx	r11d, BYTE PTR [r10+82]
	cmp	al, r11b
	cmova	r11d, eax

; 1231 :     info->state->frame->ref_LX_size[1]);
; 1232 : 
; 1233 :   for (LX_idx = 0; LX_idx < LX_IDX_MAX_PLUS_1; LX_idx++)

	xor	bl, bl
	mov	BYTE PTR LX_idx$1$[rbp-256], bl
	test	r11b, r11b
	jle	SHORT $LN367@search_pu_

; 1243 :     if (LX_idx < info->state->frame->ref_LX_size[1] &&

	mov	ecx, DWORD PTR [rcx+24]
	mov	r8d, eax
$LL4@search_pu_:

; 1234 :   {
; 1235 :     // check if ref_idx is in L0
; 1236 :     if (LX_idx < info->state->frame->ref_LX_size[0] &&

	movzx	edx, bl
	cmp	edx, r8d
	jae	SHORT $LN324@search_pu_
	movzx	eax, BYTE PTR [r10+rdx+49]
	mov	ecx, DWORD PTR [r13+24]
	cmp	eax, ecx
	je	$LN286@search_pu_
$LN324@search_pu_:

; 1243 :     if (LX_idx < info->state->frame->ref_LX_size[1] &&

	movzx	eax, BYTE PTR [r10+82]
	cmp	edx, eax
	jae	SHORT $LN359@search_pu_
	movzx	eax, BYTE PTR [r10+rdx+65]
	cmp	eax, ecx
	jne	SHORT $LN2@search_pu_

; 1244 :       info->state->frame->ref_LX[1][LX_idx] == info->ref_idx) {
; 1245 :       ref_list = 1;

	mov	sil, 1
	mov	BYTE PTR ref_list$1$[rbp-256], sil
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 453  :   assert(pic_x >= 0 && pic_x <= pic->width - block_width);

	jmp	SHORT $LN54@search_pu_
$LN359@search_pu_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1243 :     if (LX_idx < info->state->frame->ref_LX_size[1] &&

	mov	ecx, DWORD PTR [r13+24]
$LN2@search_pu_:

; 1231 :     info->state->frame->ref_LX_size[1]);
; 1232 : 
; 1233 :   for (LX_idx = 0; LX_idx < LX_IDX_MAX_PLUS_1; LX_idx++)

	inc	bl
	mov	BYTE PTR LX_idx$1$[rbp-256], bl
	cmp	bl, r11b
	jl	SHORT $LL4@search_pu_
$LN367@search_pu_:

; 1246 :       break;
; 1247 :     }
; 1248 :   }
; 1249 :   // ref_idx has to be found in either L0 or L1
; 1250 :   assert(LX_idx < LX_IDX_MAX_PLUS_1);

	mov	r8d, 1250				; 000004e2H
	lea	rdx, OFFSET FLAT:$SG4294942471
	lea	rcx, OFFSET FLAT:$SG4294942470
	call	QWORD PTR __imp__wassert
$LN54@search_pu_:

; 1253 :   int8_t temp_ref_idx = cur_cu->inter.mv_ref[ref_list];

	movsx	rax, sil
	xorps	xmm0, xmm0
	mov	QWORD PTR tv4970[rsp], rax
	xorps	xmm1, xmm1
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1342 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };

	movdqu	XMMWORD PTR merge_cand$11[rbp-256], xmm0
	mov	QWORD PTR merge_cand$11[rbp-208], 0
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1253 :   int8_t temp_ref_idx = cur_cu->inter.mv_ref[ref_list];

	movzx	r12d, BYTE PTR [rax+rdi+16]

; 1254 : 
; 1255 :   // Get MV candidates
; 1256 :   cur_cu->inter.mv_ref[ref_list] = LX_idx;

	mov	BYTE PTR [rax+rdi+16], bl

; 1258 :   kvz_inter_get_mv_cand(info->state,

	mov	rdi, QWORD PTR [r13]
	mov	r15d, DWORD PTR [r13+40]
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	r9d, r15d
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1258 :   kvz_inter_get_mv_cand(info->state,

	mov	r14d, DWORD PTR [r13+36]
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	r8d, r14d
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1258 :   kvz_inter_get_mv_cand(info->state,

	mov	esi, DWORD PTR [r13+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	edx, esi
	mov	rax, QWORD PTR [rdi+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1258 :   kvz_inter_get_mv_cand(info->state,

	mov	ebx, DWORD PTR [r13+28]
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1342 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };

	movdqu	XMMWORD PTR merge_cand$11[rbp-240], xmm1
	movdqu	XMMWORD PTR merge_cand$11[rbp-224], xmm0

; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	rcx, QWORD PTR [rax]
	lea	rax, QWORD PTR merge_cand$11[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR lcu$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rcx+16]
	mov	ecx, ebx
	mov	DWORD PTR [rsp+32], eax
	call	get_spatial_merge_candidates

; 1345 :                                state->tile->frame->width,
; 1346 :                                state->tile->frame->height,
; 1347 :                                lcu,
; 1348 :                                &merge_cand);
; 1349 :   get_temporal_merge_candidates(state, x, y, width, height, 1, 0, &merge_cand);

	lea	rax, QWORD PTR merge_cand$11[rbp-256]
	mov	r9d, r14d
	mov	QWORD PTR [rsp+56], rax
	mov	r8d, esi
	mov	edx, ebx
	mov	DWORD PTR [rsp+32], r15d
	mov	rcx, rdi
	call	get_temporal_merge_candidates
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1258 :   kvz_inter_get_mv_cand(info->state,

	lea	rax, QWORD PTR [r13+44]
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1350 :   get_mv_cand_from_candidates(state, x, y, width, height, &merge_cand, cur_cu, reflist, mv_cand);

	mov	r9d, r14d
	mov	QWORD PTR [rsp+64], rax
	mov	r8d, esi
	movzx	eax, BYTE PTR ref_list$1$[rbp-256]
	mov	edx, ebx
	mov	BYTE PTR [rsp+56], al
	mov	rcx, rdi
	mov	rax, QWORD PTR cur_cu$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR merge_cand$11[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], r15d
	call	get_mv_cand_from_candidates
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1269 :   cur_cu->inter.mv_ref[ref_list] = temp_ref_idx;

	mov	rcx, QWORD PTR tv4970[rsp]
	mov	rax, QWORD PTR cur_cu$[rbp-256]
	mov	BYTE PTR [rcx+rax+16], r12b

; 1270 : 
; 1271 :   vector2d_t mv = { 0, 0 };

	xor	r12d, r12d

; 1272 : 
; 1273 :   // Take starting point for MV search from previous frame.
; 1274 :   // When temporal motion vector candidates are added, there is probably
; 1275 :   // no point to this anymore, but for now it helps.
; 1276 :   const int mid_x = info->state->tile->offset_x + info->origin.x + (info->width >> 1);

	mov	rcx, QWORD PTR [r13]
	mov	edi, DWORD PTR [r13+36]

; 1277 :   const int mid_y = info->state->tile->offset_y + info->origin.y + (info->height >> 1);

	mov	ebx, DWORD PTR [r13+40]
	sar	edi, 1
	mov	rax, QWORD PTR [rcx+48]
	sar	ebx, 1
	mov	QWORD PTR mv$[rsp], r12
	add	edi, DWORD PTR [rax+20]
	add	ebx, DWORD PTR [rax+24]

; 1278 :   const cu_array_t* ref_array = info->state->frame->ref->cu_arrays[info->ref_idx];

	mov	rax, QWORD PTR [rcx+40]
	movsxd	rcx, DWORD PTR [r13+24]
	add	edi, DWORD PTR [r13+28]
	add	ebx, DWORD PTR [r13+32]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+8]
	mov	rsi, QWORD PTR [rax+rcx*8]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	edi, DWORD PTR [rsi+16]
	jb	SHORT $LN59@search_pu_
	lea	r8d, QWORD PTR [r12+101]
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN59@search_pu_:

; 102  :   assert(y_px < cua->height);

	cmp	ebx, DWORD PTR [rsi+20]
	jb	SHORT $LN60@search_pu_
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN60@search_pu_:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rsi+24]
	sar	eax, 2
	shr	edi, 2
	shr	ebx, 2
	imul	eax, ebx
	add	eax, edi
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1280 :   if (ref_cu->type == CU_INTER) {

	mov	edi, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rsi+8]
	lea	rdx, QWORD PTR [rax+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1280 :   if (ref_cu->type == CU_INTER) {

	mov	ecx, 4
	movzx	eax, BYTE PTR [rdx]
	and	al, 3
	mov	DWORD PTR margin$2$[rsp], ecx
	cmp	al, dil
	jne	$LN402@search_pu_

; 1281 :     vector2d_t mv_previous = { 0, 0 };
; 1282 :     if (ref_cu->inter.mv_dir & 1) {

	movzx	r14d, BYTE PTR [rdx+18]
	test	r14b, 64				; 00000040H
	je	SHORT $LN24@search_pu_

; 1283 :       mv_previous.x = ref_cu->inter.mv[0][0];

	movsx	ebx, WORD PTR [rdx+8]

; 1284 :       mv_previous.y = ref_cu->inter.mv[0][1];

	movsx	r11d, WORD PTR [rdx+10]

; 1285 :     }

	jmp	SHORT $LN408@search_pu_
$LN286@search_pu_:

; 1237 :       info->state->frame->ref_LX[0][LX_idx] == info->ref_idx) {
; 1238 :       ref_list = 0;

	xor	sil, sil
	mov	BYTE PTR ref_list$1$[rbp-256], sil

; 1239 :       break;

	jmp	$LN54@search_pu_
$LN24@search_pu_:

; 1286 :     else {
; 1287 :       mv_previous.x = ref_cu->inter.mv[1][0];

	movsx	ebx, WORD PTR [rdx+12]

; 1288 :       mv_previous.y = ref_cu->inter.mv[1][1];

	movsx	r11d, WORD PTR [rdx+14]
$LN408@search_pu_:

; 1289 :     }
; 1290 :     // Apply mv scaling if neighbor poc is available
; 1291 :     if (info->state->frame->ref_LX_size[ref_list] > 0) {

	mov	r15, QWORD PTR [r13]
	mov	rax, QWORD PTR tv4970[rsp]
	mov	DWORD PTR mv_previous$7[rsp+4], r11d
	mov	DWORD PTR mv_previous$7[rsp], ebx
	mov	r10, QWORD PTR [r15+40]
	cmp	BYTE PTR [rax+r10+81], r12b
	jbe	$LN61@search_pu_

; 1292 :       // When there are reference pictures from the future (POC > current POC)
; 1293 :       // in L0 or L1, the primary list for the colocated PU is the inverse of
; 1294 :       // collocated_from_l0_flag. Otherwise it is equal to reflist.
; 1295 :       //
; 1296 :       // Kvazaar always sets collocated_from_l0_flag so the list is L1 when
; 1297 :       // there are future references.
; 1298 :       int col_list = ref_list;
; 1299 :       for (int i = 0; i < info->state->frame->ref->used_size; i++) {

	mov	rdi, QWORD PTR [r10+40]
	mov	ecx, r12d
	movsx	esi, BYTE PTR ref_list$1$[rbp-256]
	mov	r8d, DWORD PTR [rdi+36]
	test	r8d, r8d
	je	SHORT $LN6@search_pu_

; 1300 :         if (info->state->frame->ref->pocs[i] > info->state->frame->poc) {

	mov	r9d, DWORD PTR [r10+12]
	mov	rax, QWORD PTR [rdi+16]
$LL7@search_pu_:
	cmp	DWORD PTR [rax], r9d
	jg	SHORT $LN288@search_pu_

; 1292 :       // When there are reference pictures from the future (POC > current POC)
; 1293 :       // in L0 or L1, the primary list for the colocated PU is the inverse of
; 1294 :       // collocated_from_l0_flag. Otherwise it is equal to reflist.
; 1295 :       //
; 1296 :       // Kvazaar always sets collocated_from_l0_flag so the list is L1 when
; 1297 :       // there are future references.
; 1298 :       int col_list = ref_list;
; 1299 :       for (int i = 0; i < info->state->frame->ref->used_size; i++) {

	inc	ecx
	add	rax, 4
	cmp	ecx, r8d
	jb	SHORT $LL7@search_pu_

; 1388 :     if (info->merge_cand[merge_idx].dir != 3 &&
; 1389 :         info->merge_cand[merge_idx].mv[info->merge_cand[merge_idx].dir - 1][0] == mv.x &&
; 1390 :         info->merge_cand[merge_idx].mv[info->merge_cand[merge_idx].dir - 1][1] == mv.y &&

	jmp	SHORT $LN6@search_pu_
$LN288@search_pu_:

; 1301 :           col_list = 1;

	mov	esi, 1
$LN6@search_pu_:

; 1306 :         // Use the other list if the colocated PU does not have a MV for the
; 1307 :         // primary list.
; 1308 :         col_list = 1 - col_list;
; 1309 :       }
; 1310 : 
; 1311 :       uint8_t neighbor_poc_index = info->state->frame->ref_LX[ref_list][LX_idx];

	movsx	rax, BYTE PTR LX_idx$1$[rbp-256]
	mov	rcx, QWORD PTR tv4970[rsp]
	shl	rcx, 4
	add	rcx, rax

; 1195 :   int32_t diff_current = current_poc - current_ref_poc;

	mov	rax, QWORD PTR [rdi+16]

; 1312 :       // Scaling takes current POC, reference POC, neighbor POC and neighbor reference POC as argument
; 1313 :       apply_mv_scaling(

	movzx	r8d, BYTE PTR [rcx+r10+49]
	mov	ecx, r14d

; 1195 :   int32_t diff_current = current_poc - current_ref_poc;

	mov	r10d, DWORD PTR [r10+12]

; 1302 :           break;
; 1303 :         }
; 1304 :       }
; 1305 :       if ((ref_cu->inter.mv_dir & (col_list + 1)) == 0) {

	shr	ecx, 6

; 1195 :   int32_t diff_current = current_poc - current_ref_poc;

	mov	r9d, DWORD PTR [rax+r8*4]

; 1302 :           break;
; 1303 :         }
; 1304 :       }
; 1305 :       if ((ref_cu->inter.mv_dir & (col_list + 1)) == 0) {

	lea	eax, DWORD PTR [rsi+1]
	and	cl, al

; 1195 :   int32_t diff_current = current_poc - current_ref_poc;

	sub	r10d, r9d

; 1306 :         // Use the other list if the colocated PU does not have a MV for the
; 1307 :         // primary list.
; 1308 :         col_list = 1 - col_list;
; 1309 :       }
; 1310 : 
; 1311 :       uint8_t neighbor_poc_index = info->state->frame->ref_LX[ref_list][LX_idx];

	mov	eax, 1
	sub	eax, esi
	test	cl, cl
	cmovne	eax, esi

; 1312 :       // Scaling takes current POC, reference POC, neighbor POC and neighbor reference POC as argument
; 1313 :       apply_mv_scaling(

	cdqe
	lea	rcx, QWORD PTR [rax+r8*2]
	movzx	eax, BYTE PTR [rax+rdx+16]
	shl	rcx, 4
	add	rcx, rax
	mov	rax, QWORD PTR [rdi+24]
	movzx	edx, BYTE PTR [rcx+rax]

; 1196 :   int32_t diff_neighbor = neighbor_poc - neighbor_ref_poc;

	mov	rax, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rax+r8*8]
	sub	r9d, DWORD PTR [rcx+rdx*4+120]

; 1197 : 
; 1198 :   if (diff_current == diff_neighbor) return;

	cmp	r10d, r9d
	je	$LN400@search_pu_

; 1199 :   if (diff_neighbor == 0) return;

	test	r9d, r9d
	je	$LN400@search_pu_

; 1200 : 
; 1201 :   diff_current = CLIP(-128, 127, diff_current);

	mov	eax, -128				; ffffffffffffff80H
	mov	ecx, 127				; 0000007fH
	cmp	r10d, ecx
	cmovg	r10d, ecx
	cmp	r10d, eax
	cmovl	r10d, eax

; 1202 :   diff_neighbor = CLIP(-128, 127, diff_neighbor);

	cmp	r9d, ecx
	cmovg	r9d, ecx
	cmp	r9d, eax
	cmovl	r9d, eax

; 1203 : 
; 1204 :   int scale = CLIP(-4096, 4095,

	mov	eax, r9d
	cdq
	xor	eax, edx
	sub	eax, edx
	sar	eax, 1
	add	eax, 16384				; 00004000H
	cdq
	idiv	r9d
	mov	r8d, eax
	imul	r8d, r10d
	add	r8d, 32					; 00000020H
	sar	r8d, 6
	cmp	r8d, 4095				; 00000fffH
	jg	SHORT $LN352@search_pu_
	mov	eax, -4096				; fffffffffffff000H
	cmp	r8d, eax
	cmovl	r8d, eax
	jmp	SHORT $LN72@search_pu_
$LN352@search_pu_:
	mov	r8d, 4095				; 00000fffH
$LN72@search_pu_:

; 1177 :   int32_t scaled = scale * mv;

	movsx	ecx, WORD PTR mv_previous$7[rsp]

; 1178 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	r9d, -32768				; ffffffffffff8000H
	imul	ecx, r8d
	mov	eax, ecx
	shr	eax, 31
	lea	edx, DWORD PTR [rcx+127]
	add	edx, eax
	sar	edx, 8
	cmp	edx, 32767				; 00007fffH
	jg	SHORT $LN353@search_pu_
	cmp	edx, r9d
	cmovl	edx, r9d
	jmp	SHORT $LN80@search_pu_
$LN353@search_pu_:
	mov	edx, 32767				; 00007fffH
$LN80@search_pu_:

; 1177 :   int32_t scaled = scale * mv;

	movsx	ecx, WORD PTR mv_previous$7[rsp+4]

; 1207 :   mv_cand->x = get_scaled_mv(mv_cand->x, scale);

	movsx	ebx, dx

; 1177 :   int32_t scaled = scale * mv;

	imul	ecx, r8d

; 1207 :   mv_cand->x = get_scaled_mv(mv_cand->x, scale);

	mov	DWORD PTR mv_previous$7[rsp], ebx

; 1178 :   return CLIP(-32768, 32767, (scaled + 127 + (scaled < 0)) >> 8);

	mov	eax, ecx
	shr	eax, 31
	lea	edx, DWORD PTR [rcx+127]
	add	edx, eax
	sar	edx, 8
	cmp	edx, 32767				; 00007fffH
	jg	SHORT $LN354@search_pu_
	cmp	edx, r9d
	cmovl	edx, r9d
	jmp	SHORT $LN88@search_pu_
$LN354@search_pu_:
	mov	edx, 32767				; 00007fffH
$LN88@search_pu_:

; 1208 :   mv_cand->y = get_scaled_mv(mv_cand->y, scale);

	movsx	r11d, dx
	mov	DWORD PTR mv_previous$7[rsp+4], r11d
$LN400@search_pu_:

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	ecx, 4
	lea	edi, QWORD PTR [rcx-2]
$LN61@search_pu_:
	mov	r10, QWORD PTR [r15]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, ebx
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN379@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN379@search_pu_:
	test	eax, eax
	jne	SHORT $LN107@search_pu_
	mov	eax, r11d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN378@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN378@search_pu_:
	test	eax, eax
	jne	SHORT $LN107@search_pu_
	xor	r14b, r14b
	jmp	SHORT $LN108@search_pu_
$LN107@search_pu_:
	mov	r14b, 1
$LN108@search_pu_:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, ebx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN377@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN377@search_pu_:
	test	eax, eax
	jne	SHORT $LN109@search_pu_
	mov	eax, r11d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN376@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN376@search_pu_:
	test	eax, eax
	jne	SHORT $LN109@search_pu_
	xor	sil, sil
	jmp	SHORT $LN110@search_pu_
$LN109@search_pu_:
	mov	sil, 1
$LN110@search_pu_:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r10+172], r12d
	je	$LN100@search_pu_
	cmp	DWORD PTR [r10+168], r12d
	je	$LN100@search_pu_

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	r14b, r14b
	je	SHORT $LN93@search_pu_

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	r9d, ecx
	jmp	SHORT $LN95@search_pu_
$LN93@search_pu_:

; 122  :     } else if (is_frac_chroma) {

	test	sil, sil
	mov	r9d, r12d
	cmovne	r9d, edi
$LN95@search_pu_:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r10+44], r12d
	je	SHORT $LN96@search_pu_

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r9d, 10
	jmp	SHORT $LN98@search_pu_
$LN96@search_pu_:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r10+40], r12d
	je	SHORT $LN98@search_pu_

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r9d, 8
$LN98@search_pu_:

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR [r13+40]
	add	edx, DWORD PTR [r13+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	r15d, DWORD PTR [r10+6536]
	add	edx, r9d
	mov	r12d, DWORD PTR [r13+28]
	lea	eax, DWORD PTR [r11+rdx*4]
	cdq
	movzx	edi, dl
	add	edi, eax
	mov	eax, DWORD PTR [r13+32]
	cdq
	sar	edi, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	edi, eax
	cmp	edi, r15d
	jg	$LN397@search_pu_

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR [r13+36]
	add	edx, r12d
	add	edx, r9d
	lea	eax, DWORD PTR [rbx+rdx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, r12d
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	xor	r12d, r12d
	add	eax, edx
	mov	edx, DWORD PTR [r10+6532]
	sar	eax, 6
	add	edx, r15d
	sub	r8d, eax
	add	r8d, edi
	cmp	r8d, edx
	jg	$LN402@search_pu_
	mov	r15, QWORD PTR [r13]
$LN100@search_pu_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r10+2360]
	mov	edi, 8
	test	eax, eax
	je	SHORT $LN345@search_pu_

; 162  :     return true;
; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	mov	edx, r12d

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN105@search_pu_

; 168  :     if (is_frac_luma) {

	test	r14b, r14b
	je	SHORT $LN103@search_pu_

; 169  :       margin = 4 << 2;

	lea	edx, QWORD PTR [rax+12]
	jmp	SHORT $LN105@search_pu_
$LN103@search_pu_:

; 170  :     } else if (is_frac_chroma) {

	test	sil, sil
	cmovne	edx, edi
$LN105@search_pu_:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [r13+28]
	lea	r10d, DWORD PTR [rbx+rax*4]
	mov	eax, DWORD PTR [r13+32]
	lea	r8d, DWORD PTR [r11+rax*4]
	cmp	r10d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	SHORT $LN386@search_pu_
	cmp	r8d, edx
	jl	SHORT $LN386@search_pu_

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [r15+48]
	mov	r9, QWORD PTR [rax]
	mov	eax, DWORD PTR [r13+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r9+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r10d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN386@search_pu_

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	ecx, DWORD PTR [r9+20]
	mov	eax, DWORD PTR [r13+40]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN386@search_pu_
$LN345@search_pu_:

; 1314 :         info->state->frame->poc,
; 1315 :         info->state->frame->ref->pocs[info->state->frame->ref_LX[ref_list][LX_idx]],
; 1316 :         info->state->frame->ref->pocs[neighbor_poc_index],
; 1317 :         info->state->frame->ref->images[neighbor_poc_index]->ref_pocs[
; 1318 :           info->state->frame->ref->ref_LXs[neighbor_poc_index]
; 1319 :           [col_list]
; 1320 :           [ref_cu->inter.mv_ref[col_list]]
; 1321 :         ],
; 1322 :         &mv_previous
; 1323 :       );
; 1324 :     }
; 1325 : 
; 1326 :     // Check if the mv is valid after scaling
; 1327 :     if (fracmv_within_tile(info, mv_previous.x, mv_previous.y)) {
; 1328 :       mv = mv_previous;

	mov	rdx, QWORD PTR mv_previous$7[rsp]
	jmp	SHORT $LN29@search_pu_
$LN397@search_pu_:

; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	xor	r12d, r12d
$LN402@search_pu_:

; 1280 :   if (ref_cu->type == CU_INTER) {

	mov	edi, 8
$LN386@search_pu_:
	mov	rdx, QWORD PTR mv$[rsp]
$LN29@search_pu_:

; 1329 :     }
; 1330 :   }
; 1331 : 
; 1332 :   int search_range = 32;
; 1333 :   switch (cfg->ime_algorithm) {

	mov	r8, QWORD PTR cfg$1$[rbp-256]
	mov	r9d, 32					; 00000020H
	mov	ecx, DWORD PTR [r8+80]
	sub	ecx, 3
	je	SHORT $LN33@search_pu_
	sub	ecx, 1
	je	SHORT $LN32@search_pu_
	sub	ecx, 1
	je	SHORT $LN34@search_pu_
	cmp	ecx, 1
	jne	SHORT $LN34@search_pu_

; 1334 :     case KVZ_IME_FULL64: search_range = 64; break;

	lea	r9d, QWORD PTR [rcx+63]
	jmp	SHORT $LN34@search_pu_
$LN32@search_pu_:

; 1335 :     case KVZ_IME_FULL32: search_range = 32; break;
; 1336 :     case KVZ_IME_FULL16: search_range = 16; break;

	mov	r9d, 16
	jmp	SHORT $LN34@search_pu_
$LN33@search_pu_:

; 1337 :     case KVZ_IME_FULL8: search_range = 8; break;

	mov	r9d, edi
$LN34@search_pu_:

; 1338 :     default: break;
; 1339 :   }
; 1340 : 
; 1341 :   info->best_cost = UINT32_MAX;

	mov	DWORD PTR [r13+136], -1			; ffffffffH

; 1342 : 
; 1343 :   switch (cfg->ime_algorithm) {

	mov	eax, DWORD PTR [r8+80]
	cmp	eax, 1
	je	$LN35@search_pu_
	jle	$LN38@search_pu_
	cmp	eax, 6
	jle	$LN36@search_pu_
	cmp	eax, 7
	jne	$LN38@search_pu_

; 1355 : 
; 1356 :     case KVZ_IME_DIA:
; 1357 :       diamond_search(info, mv, info->state->encoder_control->cfg.me_max_steps);

	mov	rax, QWORD PTR [r13]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+2456]

; 839  :   select_starting_point(info, extra_mv);

	mov	rcx, r13

; 1355 : 
; 1356 :     case KVZ_IME_DIA:
; 1357 :       diamond_search(info, mv, info->state->encoder_control->cfg.me_max_steps);

	mov	DWORD PTR steps$1$[rsp], eax

; 839  :   select_starting_point(info, extra_mv);

	call	select_starting_point

; 840  : 
; 841  :   // Check if we should stop search
; 842  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	rax, QWORD PTR [r13]
	mov	rcx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+2384], 0
	je	SHORT $LN156@search_pu_
	mov	rcx, r13
	call	early_terminate
	test	al, al
	jne	$LN392@search_pu_
$LN156@search_pu_:

; 843  :     early_terminate(info))
; 844  :   {
; 845  :     return;
; 846  :   }
; 847  :   
; 848  :   // current motion vector
; 849  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	r15d, DWORD PTR [r13+128]
	lea	rdi, OFFSET FLAT:?diamond@?1??diamond_search@@9@9
	mov	r12d, DWORD PTR [r13+132]

; 850  : 
; 851  :   // current best index
; 852  :   enum diapos best_index = DIA_CENTER;

	mov	esi, 4
	sar	r15d, 2
	sar	r12d, 2
	xor	ebx, ebx
	npad	1
$LL149@search_pu_:

; 853  : 
; 854  :   // initial search of the points of the diamond
; 855  :   for (int i = 0; i < 5; ++i) {
; 856  :     if (check_mv_cost(info, mv.x + diamond[i].x, mv.y + diamond[i].y)) {

	mov	r8d, DWORD PTR [rdi+4]
	mov	rcx, r13
	mov	edx, DWORD PTR [rdi]
	add	r8d, r12d
	add	edx, r15d
	call	check_mv_cost
	test	al, al
	lea	rdi, QWORD PTR [rdi+8]
	cmovne	esi, ebx
	inc	ebx
	cmp	ebx, 5
	jl	SHORT $LL149@search_pu_

; 857  :       best_index = i;
; 858  :     }
; 859  :   }
; 860  : 
; 861  :   if (best_index == DIA_CENTER) {

	cmp	esi, 4
	je	$LN392@search_pu_
	mov	r8d, DWORD PTR steps$1$[rsp]

; 862  :     // the center point was the best in initial check
; 863  :     return;
; 864  :   }
; 865  : 
; 866  :   // Move the center to the best match.
; 867  :   mv.x += diamond[best_index].x;

	lea	r9, OFFSET FLAT:?diamond@?1??diamond_search@@9@9
	movsxd	r14, esi

; 868  :   mv.y += diamond[best_index].y;
; 869  : 
; 870  :   // the arrival direction, the index of the diamond member that will be excluded
; 871  :   enum diapos from_dir = DIA_CENTER;

	mov	ecx, 4
	add	r15d, DWORD PTR [r9+r14*8]
	add	r12d, DWORD PTR [r9+r14*8+4]
	npad	6
$LL152@search_pu_:

; 872  : 
; 873  :   // whether we found a better candidate this iteration
; 874  :   uint8_t better_found;
; 875  : 
; 876  :   do {
; 877  :     better_found = 0;

	xor	dl, dl

; 878  :     // decrement count if enabled
; 879  :     if (steps > 0) steps -= 1;
; 880  : 
; 881  :     // search the points of the diamond
; 882  :     for (int i = 0; i < 4; ++i) {

	lea	eax, DWORD PTR [r8-1]
	test	r8d, r8d
	mov	BYTE PTR better_found$1$[rsp], dl
	cmove	eax, r8d
	mov	DWORD PTR steps$1$[rsp], eax
	xor	eax, eax
	mov	edi, eax
	mov	ebx, eax

; 883  :       // this is where we came from so it's checked already
; 884  :       if (i == from_dir) continue;

	movsxd	rax, ecx
	mov	QWORD PTR tv4924[rsp], rax
$LL155@search_pu_:
	cmp	rbx, rax
	je	SHORT $LN153@search_pu_

; 885  : 
; 886  :       if (check_mv_cost(info, mv.x + diamond[i].x, mv.y + diamond[i].y)) {

	mov	r8d, DWORD PTR [r9+rbx*8+4]
	mov	rcx, r13
	mov	edx, DWORD PTR [r9+rbx*8]
	add	r8d, r12d
	add	edx, r15d
	call	check_mv_cost
	test	al, al
	lea	r9, OFFSET FLAT:?diamond@?1??diamond_search@@9@9
	mov	rax, QWORD PTR tv4924[rsp]
	je	SHORT $LN393@search_pu_

; 887  :         best_index = i;
; 888  :         better_found = 1;

	mov	dl, 1
	mov	esi, edi
	mov	BYTE PTR better_found$1$[rsp], dl
	mov	r14, rbx
	jmp	SHORT $LN153@search_pu_
$LN393@search_pu_:

; 885  : 
; 886  :       if (check_mv_cost(info, mv.x + diamond[i].x, mv.y + diamond[i].y)) {

	movzx	edx, BYTE PTR better_found$1$[rsp]
$LN153@search_pu_:

; 878  :     // decrement count if enabled
; 879  :     if (steps > 0) steps -= 1;
; 880  : 
; 881  :     // search the points of the diamond
; 882  :     for (int i = 0; i < 4; ++i) {

	inc	edi
	inc	rbx
	cmp	edi, 4
	jl	SHORT $LL155@search_pu_

; 889  :       }
; 890  :     }
; 891  : 
; 892  :     if (better_found) {

	test	dl, dl
	je	SHORT $LN392@search_pu_

; 893  :       // Move the center to the best match.
; 894  :       mv.x += diamond[best_index].x;

	add	r15d, DWORD PTR [r9+r14*8]

; 895  :       mv.y += diamond[best_index].y;
; 896  : 
; 897  :       // record where we came from to the next iteration
; 898  :       // the xor operation flips the orientation
; 899  :       from_dir = best_index ^ 0x3;

	mov	ecx, esi
	add	r12d, DWORD PTR [r9+r14*8+4]
	xor	ecx, 3

; 900  :     }
; 901  :   } while (better_found && steps != 0);

	mov	r8d, DWORD PTR steps$1$[rsp]
	test	r8d, r8d
	jne	$LL152@search_pu_
$LN392@search_pu_:

; 1362 :       break;
; 1363 :   }
; 1364 : 
; 1365 :   if (cfg->fme_level > 0 && info->best_cost < *inter_cost) {

	mov	rdx, QWORD PTR cfg$1$[rbp-256]
	mov	ecx, DWORD PTR [r13+136]
	cmp	DWORD PTR [rdx+84], 0
	jle	$LN325@search_pu_
	mov	rax, QWORD PTR inter_cost$[rbp-256]
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rcx
	comisd	xmm0, QWORD PTR [rax]
	jae	$LN325@search_pu_

; 1366 :     search_frac(info);

	mov	rcx, r13
	call	search_frac
	jmp	$LN41@search_pu_
$LN36@search_pu_:

; 1344 :     case KVZ_IME_TZ:
; 1345 :       tz_search(info, mv);
; 1346 :       break;
; 1347 : 
; 1348 :     case KVZ_IME_FULL64:
; 1349 :     case KVZ_IME_FULL32:
; 1350 :     case KVZ_IME_FULL16:
; 1351 :     case KVZ_IME_FULL8:
; 1352 :     case KVZ_IME_FULL:
; 1353 :       search_mv_full(info, search_range, mv);

	mov	r8, rdx
	mov	rcx, r13
	mov	edx, r9d
	call	search_mv_full

; 1354 :       break;

	jmp	SHORT $LN392@search_pu_
$LN38@search_pu_:

; 1358 :       break;
; 1359 : 
; 1360 :     default:
; 1361 :       hexagon_search(info, mv, info->state->encoder_control->cfg.me_max_steps);

	mov	rax, QWORD PTR [r13]
	mov	rcx, QWORD PTR [rax]
	mov	r12d, DWORD PTR [rcx+2456]

; 739  :   select_starting_point(info, extra_mv);

	mov	rcx, r13
	call	select_starting_point

; 740  : 
; 741  :   // Check if we should stop search
; 742  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	rax, QWORD PTR [r13]
	mov	rcx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+2384], 0
	je	SHORT $LN177@search_pu_
	mov	rcx, r13
	call	early_terminate
	test	al, al
	jne	SHORT $LN392@search_pu_
$LN177@search_pu_:

; 743  :       early_terminate(info))
; 744  :   {
; 745  :     return;
; 746  :   }
; 747  : 
; 748  :   vector2d_t mv = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	r14d, DWORD PTR [r13+128]
	lea	rsi, OFFSET FLAT:?large_hexbs@?1??hexagon_search@@9@9+8
	mov	r15d, DWORD PTR [r13+132]
	sar	r14d, 2
	sar	r15d, 2

; 749  : 
; 750  :   // Current best index, either to merge_cands, large_hexbs or small_hexbs.
; 751  :   int best_index = 0;

	xor	ebx, ebx
	lea	edi, QWORD PTR [rbx+1]
	npad	6
$LL168@search_pu_:

; 752  : 
; 753  :   // Search the initial 7 points of the hexagon.
; 754  :   for (int i = 1; i < 7; ++i) {
; 755  :     if (check_mv_cost(info, mv.x + large_hexbs[i].x, mv.y + large_hexbs[i].y)) {

	mov	r8d, DWORD PTR [rsi+4]
	mov	rcx, r13
	mov	edx, DWORD PTR [rsi]
	add	r8d, r15d
	add	edx, r14d
	call	check_mv_cost
	test	al, al
	lea	rsi, QWORD PTR [rsi+8]
	cmovne	ebx, edi
	inc	edi
	cmp	edi, 7
	jl	SHORT $LL168@search_pu_

; 756  :       best_index = i;
; 757  :     }
; 758  :   }
; 759  : 
; 760  :   // Iteratively search the 3 new points around the best match, until the best
; 761  :   // match is in the center.
; 762  :   while (best_index != 0 && steps != 0) {

	test	ebx, ebx
	je	SHORT $LN390@search_pu_
$LL169@search_pu_:
	test	r12d, r12d
	je	SHORT $LN390@search_pu_

; 763  :     // decrement count if enabled
; 764  :     if (steps > 0) steps -= 1;
; 765  : 
; 766  :     // Starting point of the 3 offsets to be searched.
; 767  :     unsigned start;
; 768  :     if (best_index == 1) {

	dec	r12d
	mov	DWORD PTR steps$1$[rsp], r12d
	cmp	ebx, 1
	jne	SHORT $LN180@search_pu_

; 769  :       start = 6;

	lea	edi, QWORD PTR [rbx+5]
	jmp	SHORT $LN183@search_pu_
$LN180@search_pu_:

; 770  :     } else if (best_index == 8) {
; 771  :       start = 1;

	mov	edi, 1
	cmp	ebx, 8
	je	SHORT $LN183@search_pu_

; 772  :     } else {
; 773  :       start = best_index - 1;

	lea	edi, DWORD PTR [rbx-1]
$LN183@search_pu_:

; 774  :     }
; 775  : 
; 776  :     // Move the center to the best match.
; 777  :     mv.x += large_hexbs[best_index].x;

	movsxd	rax, ebx
	lea	r12, OFFSET FLAT:?large_hexbs@?1??hexagon_search@@9@9
	add	r14d, DWORD PTR [r12+rax*8]

; 778  :     mv.y += large_hexbs[best_index].y;

	add	r15d, DWORD PTR [r12+rax*8+4]

; 779  :     best_index = 0;

	xor	ebx, ebx
	lea	esi, QWORD PTR [rbx+3]
	npad	12
$LL173@search_pu_:

; 780  : 
; 781  :     // Iterate through the next 3 points.
; 782  :     for (int i = 0; i < 3; ++i) {
; 783  :       vector2d_t offset = large_hexbs[start + i];

	mov	eax, edi
	mov	rcx, QWORD PTR [r12+rax*8]
	mov	r8, rcx
	shr	r8, 32					; 00000020H
	add	r8d, r15d

; 784  :       if (check_mv_cost(info, mv.x + offset.x, mv.y + offset.y)) {

	lea	edx, DWORD PTR [rcx+r14]
	mov	rcx, r13
	call	check_mv_cost
	test	al, al
	cmovne	ebx, edi
	inc	edi
	sub	rsi, 1
	jne	SHORT $LL173@search_pu_

; 756  :       best_index = i;
; 757  :     }
; 758  :   }
; 759  : 
; 760  :   // Iteratively search the 3 new points around the best match, until the best
; 761  :   // match is in the center.
; 762  :   while (best_index != 0 && steps != 0) {

	mov	r12d, DWORD PTR steps$1$[rsp]
	test	ebx, ebx
	jne	SHORT $LL169@search_pu_
$LN390@search_pu_:

; 1234 :   {
; 1235 :     // check if ref_idx is in L0
; 1236 :     if (LX_idx < info->state->frame->ref_LX_size[0] &&

	lea	rbx, OFFSET FLAT:?small_hexbs@?1??hexagon_search@@9@9+8
	lea	rdi, OFFSET FLAT:?small_hexbs@?1??hexagon_search@@9@9+72
$LL176@search_pu_:

; 796  :     check_mv_cost(info, mv.x + small_hexbs[i].x, mv.y + small_hexbs[i].y);

	mov	r8d, DWORD PTR [rbx+4]
	mov	rcx, r13
	mov	edx, DWORD PTR [rbx]
	add	r8d, r15d
	add	edx, r14d
	call	check_mv_cost
	add	rbx, 8
	cmp	rbx, rdi
	jl	SHORT $LL176@search_pu_

; 1388 :     if (info->merge_cand[merge_idx].dir != 3 &&
; 1389 :         info->merge_cand[merge_idx].mv[info->merge_cand[merge_idx].dir - 1][0] == mv.x &&
; 1390 :         info->merge_cand[merge_idx].mv[info->merge_cand[merge_idx].dir - 1][1] == mv.y &&

	jmp	$LN392@search_pu_
$LN35@search_pu_:

; 631  :   select_starting_point(info, extra_mv);

	mov	rcx, r13
	mov	DWORD PTR best_dist$4[rsp], r12d
	call	select_starting_point

; 632  : 
; 633  :   // Check if we should stop search
; 634  :   if (info->state->encoder_control->cfg.me_early_termination &&

	mov	rax, QWORD PTR [r13]
	mov	rcx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+2384], 0
	je	SHORT $LN128@search_pu_
	mov	rcx, r13
	call	early_terminate
	test	al, al
	jne	$LN392@search_pu_
$LN128@search_pu_:

; 635  :       early_terminate(info))
; 636  :   {
; 637  :     return;
; 638  :   }
; 639  : 
; 640  :   vector2d_t start = { info->best_mv.x >> 2, info->best_mv.y >> 2 };

	mov	r14d, DWORD PTR [r13+128]

; 641  : 
; 642  :   // step 2, grid search
; 643  :   int rounds_without_improvement = 0;

	mov	esi, r12d
	mov	r15d, DWORD PTR [r13+132]

; 644  :   for (int iDist = 1; iDist <= iSearchRange; iDist *= 2) {

	mov	edi, 1
	sar	r14d, 2
	sar	r15d, 2
	mov	DWORD PTR start$6[rsp+4], r15d
	mov	DWORD PTR start$6[rsp], r14d
	mov	rbx, QWORD PTR start$6[rsp]
	npad	4
$LL116@search_pu_:

; 645  :     kvz_tz_pattern_search(info, step2_type, iDist, start, &best_dist);

	lea	rax, QWORD PTR best_dist$4[rsp]
	mov	r9, rbx
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, r13
	call	kvz_tz_pattern_search

; 646  : 
; 647  :     // Break the loop if the last three rounds didn't produce a better MV.
; 648  :     if (best_dist != iDist) rounds_without_improvement++;

	mov	ecx, DWORD PTR best_dist$4[rsp]
	cmp	ecx, edi
	je	SHORT $LN363@search_pu_
	lea	eax, DWORD PTR [rsi+1]
	mov	esi, eax

; 649  :     if (rounds_without_improvement >= 3) break;

	cmp	eax, 3
	jge	SHORT $LN289@search_pu_
$LN363@search_pu_:

; 644  :   for (int iDist = 1; iDist <= iSearchRange; iDist *= 2) {

	add	edi, edi
	cmp	edi, 96					; 00000060H
	jle	SHORT $LL116@search_pu_
$LN289@search_pu_:

; 650  :   }
; 651  : 
; 652  :   if (start.x != 0 || start.y != 0) {

	test	r14d, r14d
	jne	SHORT $LN132@search_pu_
	test	r15d, r15d
	je	SHORT $LN398@search_pu_
$LN132@search_pu_:

; 653  :     // repeat step 2 starting from the zero MV
; 654  :     start.x = 0;
; 655  :     start.y = 0;
; 656  :     rounds_without_improvement = 0;
; 657  :     for (int iDist = 1; iDist <= iSearchRange/2; iDist *= 2) {

	mov	r14d, 1
	mov	QWORD PTR start$6[rsp], 0
	mov	rbx, QWORD PTR start$6[rsp]
	mov	edi, r14d
	mov	esi, r12d
	npad	11
$LL119@search_pu_:

; 658  :       kvz_tz_pattern_search(info, step2_type, iDist, start, &best_dist);

	lea	rax, QWORD PTR best_dist$4[rsp]
	mov	r9, rbx
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, r13
	call	kvz_tz_pattern_search

; 659  : 
; 660  :       if (best_dist != iDist) rounds_without_improvement++;

	mov	ecx, DWORD PTR best_dist$4[rsp]
	cmp	ecx, edi
	je	SHORT $LN362@search_pu_
	lea	eax, DWORD PTR [rsi+1]
	mov	esi, eax

; 661  :       if (rounds_without_improvement >= 3) break;

	cmp	eax, 3
	jge	SHORT $LL123@search_pu_
$LN362@search_pu_:

; 653  :     // repeat step 2 starting from the zero MV
; 654  :     start.x = 0;
; 655  :     start.y = 0;
; 656  :     rounds_without_improvement = 0;
; 657  :     for (int iDist = 1; iDist <= iSearchRange/2; iDist *= 2) {

	add	edi, edi
	cmp	edi, 48					; 00000030H
	jle	SHORT $LL119@search_pu_

; 650  :   }
; 651  : 
; 652  :   if (start.x != 0 || start.y != 0) {

	jmp	SHORT $LL123@search_pu_
$LN398@search_pu_:
	mov	r14d, 1
	npad	7
$LL123@search_pu_:

; 662  :     }
; 663  :   }
; 664  : 
; 665  :   //step 3, raster scan
; 666  :   if (use_raster_scan && best_dist > iRaster) {
; 667  :     best_dist = iRaster;
; 668  :     kvz_tz_raster_search(info, iSearchRange, iRaster);
; 669  :   }
; 670  : 
; 671  :   //step 4
; 672  : 
; 673  :   //raster refinement
; 674  :   if (use_raster_refinement && best_dist > 0) {
; 675  :     for (int iDist = best_dist >> 1; iDist > 0; iDist >>= 1) {
; 676  :       start.x = info->best_mv.x >> 2;
; 677  :       start.y = info->best_mv.y >> 2;
; 678  :       kvz_tz_pattern_search(info, step4_type, iDist, start, &best_dist);
; 679  :     }
; 680  :   }
; 681  : 
; 682  :   //star refinement (repeat step 2 for the current starting point)
; 683  :   while (use_star_refinement && best_dist > 0) {

	test	ecx, ecx
	jle	$LN392@search_pu_

; 684  :     best_dist = 0;
; 685  :     start.x = info->best_mv.x >> 2;

	mov	eax, DWORD PTR [r13+128]

; 686  :     start.y = info->best_mv.y >> 2;
; 687  :     for (int iDist = 1; iDist <= iSearchRange; iDist *= 2) {

	mov	edi, r14d
	sar	eax, 2
	mov	DWORD PTR start$6[rsp], eax
	mov	eax, DWORD PTR [r13+132]
	sar	eax, 2
	mov	DWORD PTR start$6[rsp+4], eax
	mov	rbx, QWORD PTR start$6[rsp]
	mov	DWORD PTR best_dist$4[rsp], r12d
	npad	15
$LL127@search_pu_:

; 688  :       kvz_tz_pattern_search(info, step4_type, iDist, start, &best_dist);

	lea	rax, QWORD PTR best_dist$4[rsp]
	mov	r9, rbx
	mov	r8d, edi
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, r13
	call	kvz_tz_pattern_search
	add	edi, edi
	cmp	edi, 96					; 00000060H
	jle	SHORT $LL127@search_pu_
	mov	ecx, DWORD PTR best_dist$4[rsp]
	jmp	SHORT $LL123@search_pu_
$LN325@search_pu_:

; 1367 : 
; 1368 :   } else if (info->best_cost < UINT32_MAX) {

	cmp	ecx, -1					; ffffffffH
	jae	$LN41@search_pu_

; 1370 :     info->best_cost = kvz_image_calc_satd(

	mov	edx, DWORD PTR [r13+28]
	mov	rax, QWORD PTR [r13]
	mov	ebx, DWORD PTR [r13+132]
	mov	esi, DWORD PTR [r13+128]
	mov	edi, DWORD PTR [r13+32]
	mov	rax, QWORD PTR [rax+48]
	mov	ecx, DWORD PTR [r13+36]
	mov	r12d, DWORD PTR [r13+40]
	mov	r14, QWORD PTR [r13+16]
	sar	ebx, 2
	add	ebx, DWORD PTR [rax+24]
	sar	esi, 2
	add	ebx, edi
	add	esi, DWORD PTR [rax+20]
	mov	rax, QWORD PTR [rax]
	add	esi, edx
	mov	DWORD PTR block_width$1$[rsp], ecx
	mov	DWORD PTR pic_x$1$[rsp], edx
	mov	r15, QWORD PTR [rax]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 453  :   assert(pic_x >= 0 && pic_x <= pic->width - block_width);

	test	edx, edx
	js	SHORT $LN233@search_pu_
	mov	eax, DWORD PTR [r15+64]
	sub	eax, ecx
	cmp	edx, eax
	jle	SHORT $LN234@search_pu_
$LN233@search_pu_:
	mov	r8d, 453				; 000001c5H
	lea	rdx, OFFSET FLAT:$SG4294955944
	lea	rcx, OFFSET FLAT:$SG4294955943
	call	QWORD PTR __imp__wassert
$LN234@search_pu_:

; 454  :   assert(pic_y >= 0 && pic_y <= pic->height - block_height);

	test	edi, edi
	js	SHORT $LN235@search_pu_
	mov	eax, DWORD PTR [r15+68]
	sub	eax, r12d
	cmp	edi, eax
	jle	SHORT $LN236@search_pu_
$LN235@search_pu_:
	mov	r8d, 454				; 000001c6H
	lea	rdx, OFFSET FLAT:$SG4294955942
	lea	rcx, OFFSET FLAT:$SG4294955941
	call	QWORD PTR __imp__wassert
$LN236@search_pu_:

; 455  : 
; 456  :   if (ref_x >= 0 && ref_x <= ref->width  - block_width &&
; 457  :       ref_y >= 0 && ref_y <= ref->height - block_height)

	mov	ecx, DWORD PTR block_width$1$[rsp]
	test	esi, esi
	js	SHORT $LN230@search_pu_
	mov	eax, DWORD PTR [r14+64]
	sub	eax, ecx
	cmp	esi, eax
	jg	SHORT $LN230@search_pu_
	test	ebx, ebx
	js	SHORT $LN230@search_pu_
	mov	eax, DWORD PTR [r14+68]
	sub	eax, r12d
	cmp	ebx, eax
	jg	SHORT $LN230@search_pu_

; 458  :   {
; 459  :     // Reference block is completely inside the frame, so just calculate the
; 460  :     // SAD directly. This is the most common case, which is why it's first.
; 461  :     const kvz_pixel *pic_data = &pic->y[pic_y * pic->stride + pic_x];
; 462  :     const kvz_pixel *ref_data = &ref->y[ref_y * ref->stride + ref_x];

	mov	r10d, DWORD PTR [r14+72]
	imul	ebx, r10d

; 463  :     return kvz_satd_any_size(block_width,

	mov	DWORD PTR [rsp+40], r10d
	lea	eax, DWORD PTR [rsi+rbx]
	cdqe
	add	rax, QWORD PTR [r14+16]
	jmp	SHORT $LN409@search_pu_
$LN230@search_pu_:

; 464  :                              block_height,
; 465  :                              pic_data,
; 466  :                              pic->stride,
; 467  :                              ref_data,
; 468  :                              ref->stride) >> (KVZ_BIT_DEPTH - 8);
; 469  :   } else {
; 470  :     // Extrapolate pixels from outside the frame.
; 471  : 
; 472  :     // Space for extrapolated pixels and the part from the picture
; 473  :     // The extrapolation function will set the pointers and stride.
; 474  :     kvz_pixel ext_buffer[LCU_LUMA_SIZE];
; 475  :     kvz_pixel *ext = NULL;
; 476  :     kvz_pixel *ext_origin = NULL;
; 477  :     int ext_s = 0;
; 478  :     kvz_epol_args epol_args = {

	mov	rax, QWORD PTR [r14+16]
	xor	edx, edx
	mov	QWORD PTR epol_args$10[rbp-256], rax
	mov	eax, DWORD PTR [r14+64]
	mov	DWORD PTR epol_args$10[rbp-248], eax
	mov	eax, DWORD PTR [r14+68]
	mov	DWORD PTR epol_args$10[rbp-244], eax
	mov	eax, DWORD PTR [r14+72]
	mov	DWORD PTR epol_args$10[rbp-240], eax

; 479  :       .src = ref->y,
; 480  :       .src_w = ref->width,
; 481  :       .src_h = ref->height,
; 482  :       .src_s = ref->stride,
; 483  :       .blk_x = ref_x,
; 484  :       .blk_y = ref_y,
; 485  :       .blk_w = block_width,
; 486  :       .blk_h = block_height,
; 487  :       .pad_l = 0,
; 488  :       .pad_r = 0,
; 489  :       .pad_t = 0,
; 490  :       .pad_b = 0,
; 491  :       .pad_b_simd = 0,
; 492  :     };
; 493  : 
; 494  :     // Initialize separately. Gets rid of warning
; 495  :     // about using nonstandard extension.
; 496  :     epol_args.buf = ext_buffer;

	lea	rax, QWORD PTR ext_buffer$12[rbp-256]
	mov	QWORD PTR epol_args$10[rbp-200], rax

; 497  :     epol_args.ext = &ext;

	lea	rax, QWORD PTR ext$9[rbp-256]
	mov	QWORD PTR epol_args$10[rbp-192], rax

; 498  :     epol_args.ext_origin = &ext_origin;

	lea	rax, QWORD PTR ext_origin$8[rbp-256]
	mov	QWORD PTR epol_args$10[rbp-184], rax

; 499  :     epol_args.ext_s = &ext_s;

	lea	rax, QWORD PTR ext_s$5[rsp]
	mov	DWORD PTR epol_args$10[rbp-228], ecx

; 500  : 
; 501  :     kvz_get_extended_block(&epol_args);

	lea	rcx, QWORD PTR epol_args$10[rbp-256]
	mov	QWORD PTR epol_args$10[rbp-176], rax
	mov	QWORD PTR ext$9[rbp-256], rdx
	mov	QWORD PTR ext_origin$8[rbp-256], rdx
	mov	DWORD PTR ext_s$5[rsp], edx
	mov	DWORD PTR epol_args$10[rbp-236], esi
	mov	DWORD PTR epol_args$10[rbp-232], ebx
	mov	DWORD PTR epol_args$10[rbp-224], r12d
	mov	QWORD PTR epol_args$10[rbp-220], rdx
	mov	QWORD PTR epol_args$10[rbp-212], rdx
	mov	DWORD PTR epol_args$10[rbp-204], edx
	call	QWORD PTR kvz_get_extended_block

; 502  : 
; 503  :     const kvz_pixel *pic_data = &pic->y[pic_y * pic->stride + pic_x];
; 504  : 
; 505  :     unsigned satd = kvz_satd_any_size(block_width,

	mov	eax, DWORD PTR ext_s$5[rsp]
	mov	ecx, DWORD PTR block_width$1$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR ext_origin$8[rbp-256]
$LN409@search_pu_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1370 :     info->best_cost = kvz_image_calc_satd(

	mov	r9d, DWORD PTR [r15+72]
	mov	edx, r12d
	imul	edi, r9d
	mov	QWORD PTR [rsp+32], rax
	add	edi, DWORD PTR pic_x$1$[rsp]
	movsxd	r8, edi
	add	r8, QWORD PTR [r15+16]
	call	QWORD PTR kvz_satd_any_size
	mov	DWORD PTR [r13+136], eax
	mov	ecx, eax

; 1371 :         info->state->tile->frame->source,
; 1372 :         info->ref,
; 1373 :         info->origin.x,
; 1374 :         info->origin.y,
; 1375 :         info->state->tile->offset_x + info->origin.x + (info->best_mv.x >> 2),
; 1376 :         info->state->tile->offset_y + info->origin.y + (info->best_mv.y >> 2),
; 1377 :         info->width,
; 1378 :         info->height);
; 1379 :     info->best_cost += info->best_bitcost * (int)(info->state->lambda_sqrt + 0.5);

	mov	rax, QWORD PTR [r13]
	movsd	xmm0, QWORD PTR [rax+376]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si eax, xmm0
	imul	eax, DWORD PTR [r13+140]
	add	eax, ecx
	mov	DWORD PTR [r13+136], eax
$LN41@search_pu_:

; 1380 :   }
; 1381 : 
; 1382 :   mv = info->best_mv;

	mov	rax, QWORD PTR [r13+128]

; 1383 : 
; 1384 :   int merged = 0;
; 1385 :   int merge_idx = 0;
; 1386 :   // Check every candidate to find a match
; 1387 :   for (merge_idx = 0; merge_idx < info->num_merge_cand; merge_idx++) {

	xor	esi, esi
	mov	r10d, DWORD PTR [r13+112]
	mov	r14d, esi
	mov	QWORD PTR mv$[rsp], rax
	mov	r12d, eax
	mov	r15d, DWORD PTR mv$[rsp+4]
	test	r10d, r10d
	jle	SHORT $LN361@search_pu_
	npad	13
$LL14@search_pu_:

; 1388 :     if (info->merge_cand[merge_idx].dir != 3 &&
; 1389 :         info->merge_cand[merge_idx].mv[info->merge_cand[merge_idx].dir - 1][0] == mv.x &&
; 1390 :         info->merge_cand[merge_idx].mv[info->merge_cand[merge_idx].dir - 1][1] == mv.y &&

	movsxd	rdx, r14d
	lea	r9, QWORD PTR [rdx+rdx*2]
	movzx	eax, BYTE PTR [r13+r9*4+52]
	cmp	al, 3
	je	SHORT $LN12@search_pu_
	lea	rcx, QWORD PTR [rax-1]
	lea	r8, QWORD PTR [rcx+rdx*2]
	add	r8, rdx
	movsx	eax, WORD PTR [r13+r8*4+56]
	cmp	eax, r12d
	jne	SHORT $LN12@search_pu_
	movsx	eax, WORD PTR [r13+r8*4+58]
	cmp	eax, r15d
	jne	SHORT $LN12@search_pu_
	lea	rax, QWORD PTR [rcx+r9*4]
	shl	rcx, 4
	movzx	edx, BYTE PTR [rax+r13+53]
	mov	rax, QWORD PTR [r13]
	add	rdx, rcx
	mov	rcx, QWORD PTR [rax+40]
	movzx	eax, BYTE PTR [rdx+rcx+49]
	cmp	eax, DWORD PTR [r13+24]
	je	SHORT $LN291@search_pu_
$LN12@search_pu_:

; 1383 : 
; 1384 :   int merged = 0;
; 1385 :   int merge_idx = 0;
; 1386 :   // Check every candidate to find a match
; 1387 :   for (merge_idx = 0; merge_idx < info->num_merge_cand; merge_idx++) {

	inc	r14d
	cmp	r14d, r10d
	jl	SHORT $LL14@search_pu_
$LN361@search_pu_:

; 352  :   const bool same_cand =

	movsx	ecx, WORD PTR [r13+44]

; 1395 :       break;
; 1396 :     }
; 1397 :   }
; 1398 : 
; 1399 :   // Only check when candidates are different
; 1400 :   int cu_mv_cand = 0;
; 1401 :   if (!merged) {
; 1402 :     cu_mv_cand =

	mov	r10, QWORD PTR [r13]
	mov	QWORD PTR state$1$[rbp-256], r10

; 352  :   const bool same_cand =

	cmp	cx, WORD PTR [r13+48]
	jne	SHORT $LN238@search_pu_
	movzx	eax, WORD PTR [r13+50]
	cmp	WORD PTR [r13+46], ax
	jne	SHORT $LN238@search_pu_

; 353  :     (mv_cand[0][0] == mv_cand[1][0] && mv_cand[0][1] == mv_cand[1][1]);
; 354  : 
; 355  :   if (same_cand && !cost_out) {
; 356  :     // Pick the first one if both candidates are the same.
; 357  :     return 0;

	mov	r9d, esi
	jmp	SHORT $LN410@search_pu_
$LN291@search_pu_:

; 1391 :         (uint32_t)info->state->frame->ref_LX[info->merge_cand[merge_idx].dir - 1][
; 1392 :         info->merge_cand[merge_idx].ref[info->merge_cand[merge_idx].dir - 1]] == info->ref_idx)
; 1393 :     {
; 1394 :       merged = 1;

	mov	r9d, esi
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 453  :   assert(pic_x >= 0 && pic_x <= pic->width - block_width);

	mov	ecx, 1
	jmp	SHORT $LN237@search_pu_
$LN238@search_pu_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 369  :   uint32_t cand1_cost = mvd_coding_cost(

	mov	rax, QWORD PTR [r10]
	lea	r8, OFFSET FLAT:get_mvd_coding_cost
	lea	rdi, QWORD PTR [r10+128]
	mov	r9d, r15d
	lea	rsi, OFFSET FLAT:kvz_get_mvd_coding_cost_cabac
	mov	rdx, rdi
	cmp	BYTE PTR [rax+2356], 0
	movsx	eax, WORD PTR [r13+46]
	cmove	rsi, r8
	mov	r8d, r12d
	sub	r8d, ecx
	sub	r9d, eax
	mov	rcx, r10
	call	rsi

; 370  :       state, &state->cabac,
; 371  :       mv_x - mv_cand[0][0],
; 372  :       mv_y - mv_cand[0][1]);
; 373  : 
; 374  :   uint32_t cand2_cost;
; 375  :   if (same_cand) {
; 376  :     cand2_cost = cand1_cost;
; 377  :   } else {
; 378  :     cand2_cost = mvd_coding_cost(

	movsx	r8d, WORD PTR [r13+50]
	mov	r9d, r15d
	movsx	r10d, WORD PTR [r13+48]
	sub	r9d, r8d
	mov	rcx, QWORD PTR state$1$[rbp-256]
	mov	r8d, r12d
	sub	r8d, r10d
	mov	rdx, rdi
	mov	ebx, eax
	call	rsi

; 379  :       state, &state->cabac,
; 380  :       mv_x - mv_cand[1][0],
; 381  :       mv_y - mv_cand[1][1]);
; 382  :   }
; 383  : 
; 384  :   if (cost_out) {
; 385  :     *cost_out = MIN(cand1_cost, cand2_cost);
; 386  :   }
; 387  : 
; 388  :   // Pick the second candidate if it has lower cost.
; 389  :   return cand2_cost < cand1_cost ? 1 : 0;

	xor	esi, esi
	cmp	eax, ebx
	setb	r9b
$LN410@search_pu_:

; 1403 :       select_mv_cand(info->state, info->mv_cand, mv.x, mv.y, NULL);
; 1404 :   }
; 1405 : 
; 1406 :   if (info->best_cost < *inter_cost) {

	mov	ecx, esi
$LN237@search_pu_:
	mov	edx, DWORD PTR [r13+136]
	xorps	xmm1, xmm1
	mov	r10, QWORD PTR inter_cost$[rbp-256]
	cvtsi2sd xmm1, rdx
	comisd	xmm1, QWORD PTR [r10]
	jae	$LN401@search_pu_

; 1407 :     // Map reference index to L0/L1 pictures
; 1408 :     cur_cu->inter.mv_dir = ref_list+1;

	mov	rdx, QWORD PTR cur_cu$[rbp-256]
	movzx	ebx, BYTE PTR ref_list$1$[rbp-256]

; 1409 :     uint8_t mv_ref_coded = LX_idx;
; 1410 : 
; 1411 :     cur_cu->merged                  = merged;
; 1412 :     cur_cu->merge_idx               = merge_idx;
; 1413 :     cur_cu->inter.mv_ref[ref_list]  = LX_idx;

	movzx	r11d, BYTE PTR LX_idx$1$[rbp-256]
	movzx	eax, bl
	shl	cl, 4
	and	BYTE PTR [rdx+1], 15
	or	cl, BYTE PTR [rdx+1]
	and	BYTE PTR [rdx+18], 63			; 0000003fH
	and	cl, 31
	shl	al, 6
	add	al, 64					; 00000040H
	shl	r14b, 5
	or	BYTE PTR [rdx+18], al
	or	cl, r14b
	mov	r14, QWORD PTR tv4970[rsp]

; 1414 :     cur_cu->inter.mv[ref_list][0]   = (int16_t)mv.x;

	movzx	eax, WORD PTR mv$[rsp]
	mov	BYTE PTR [rdx+1], cl
	mov	BYTE PTR [r14+rdx+16], r11b
	mov	WORD PTR [rdx+r14*4+8], ax

; 1415 :     cur_cu->inter.mv[ref_list][1]   = (int16_t)mv.y;

	movzx	eax, WORD PTR mv$[rsp+4]
	mov	WORD PTR [rdx+r14*4+10], ax
	movzx	r8d, BYTE PTR [rdx+18]

; 1416 : 
; 1417 :     CU_SET_MV_CAND(cur_cu, ref_list, cu_mv_cand);

	test	bl, bl
	jne	SHORT $LN45@search_pu_
	and	r8b, 248				; 000000f8H
	or	r8b, r9b
	jmp	SHORT $LN15@search_pu_
$LN45@search_pu_:
	movzx	eax, r8b
	movzx	ecx, r9b
	shl	cl, 3
	and	al, 199					; 000000c7H
	movzx	r8d, cl
	or	r8b, al
$LN15@search_pu_:

; 1418 : 
; 1419 :     *inter_cost = info->best_cost;

	mov	BYTE PTR [rdx+18], r8b

; 1420 :     *inter_bitcost = info->best_bitcost + cur_cu->inter.mv_dir - 1 + mv_ref_coded;

	lea	eax, DWORD PTR [r11-1]
	mov	edx, DWORD PTR [r13+136]
	xorps	xmm1, xmm1
	movzx	ecx, r8b
	shr	ecx, 6
	add	ecx, DWORD PTR [r13+140]
	add	ecx, eax
	mov	rax, QWORD PTR inter_bitcost$[rbp-256]
	cvtsi2sd xmm1, rdx
	mov	DWORD PTR [rax], ecx
	movsd	QWORD PTR [r10], xmm1
	jmp	SHORT $LN327@search_pu_
$LN401@search_pu_:

; 1403 :       select_mv_cand(info->state, info->mv_cand, mv.x, mv.y, NULL);
; 1404 :   }
; 1405 : 
; 1406 :   if (info->best_cost < *inter_cost) {

	mov	r14, QWORD PTR tv4970[rsp]
$LN327@search_pu_:

; 1421 :   }
; 1422 : 
; 1423 : 
; 1424 :   // Update best unipreds for biprediction
; 1425 :   if (info->best_cost < best_LX_cost[ref_list]) {

	mov	r11, QWORD PTR best_LX_cost$[rbp-256]
	xorps	xmm0, xmm0
	mov	eax, edx
	cvtsi2sd xmm0, rax
	comisd	xmm0, QWORD PTR [r11+r14*8]
	jae	$LN48@search_pu_

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	rcx, QWORD PTR [r13]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, r12d
	mov	r10, QWORD PTR [rcx]
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN375@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN375@search_pu_:
	test	eax, eax
	jne	SHORT $LN263@search_pu_
	mov	eax, r15d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN374@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN374@search_pu_:
	test	eax, eax
	jne	SHORT $LN263@search_pu_
	xor	dil, dil
	jmp	SHORT $LN264@search_pu_
$LN263@search_pu_:
	mov	dil, 1
$LN264@search_pu_:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, r12d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN373@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN373@search_pu_:
	test	eax, eax
	jne	SHORT $LN265@search_pu_
	mov	eax, r15d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN372@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN372@search_pu_:
	test	eax, eax
	jne	SHORT $LN265@search_pu_
	xor	bl, bl
	jmp	SHORT $LN266@search_pu_
$LN265@search_pu_:
	mov	bl, 1
$LN266@search_pu_:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r10+172], 0
	je	$LN256@search_pu_
	cmp	DWORD PTR [r10+168], 0
	je	$LN256@search_pu_

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	dil, dil
	je	SHORT $LN249@search_pu_

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	eax, 4
	jmp	SHORT $LN251@search_pu_
$LN249@search_pu_:

; 122  :     } else if (is_frac_chroma) {

	test	bl, bl
	mov	eax, esi
	mov	ecx, 2
	cmovne	eax, ecx
	mov	DWORD PTR margin$2$[rsp], eax
$LN251@search_pu_:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r10+44], 0
	je	SHORT $LN252@search_pu_

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	eax, 10
	jmp	SHORT $LN411@search_pu_
$LN252@search_pu_:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r10+40], 0
	je	SHORT $LN254@search_pu_

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	eax, 8
$LN411@search_pu_:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {

	mov	DWORD PTR margin$2$[rsp], eax
$LN254@search_pu_:

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR [r13+40]
	add	edx, DWORD PTR [r13+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	esi, DWORD PTR [r10+6536]
	add	edx, eax
	mov	r14d, DWORD PTR [r13+28]
	lea	eax, DWORD PTR [r15+rdx*4]
	cdq
	movzx	r11d, dl
	add	r11d, eax
	mov	eax, DWORD PTR [r13+32]
	cdq
	sar	r11d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	r11d, eax
	cmp	r11d, esi
	jg	$LN48@search_pu_

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	ecx, DWORD PTR margin$2$[rsp]
	add	ecx, r14d
	add	ecx, DWORD PTR [r13+36]
	lea	eax, DWORD PTR [r12+rcx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, r14d
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r10+6532]
	sar	eax, 6
	add	edx, esi
	sub	r8d, eax
	add	r8d, r11d
	cmp	r8d, edx
	jg	$LN48@search_pu_
	mov	rcx, QWORD PTR [r13]
	mov	r11, QWORD PTR best_LX_cost$[rbp-256]
	mov	r14, QWORD PTR tv4970[rsp]
$LN256@search_pu_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r10+2360]
	test	eax, eax
	je	SHORT $LN347@search_pu_

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN395@search_pu_

; 168  :     if (is_frac_luma) {

	test	dil, dil
	je	SHORT $LN259@search_pu_

; 169  :       margin = 4 << 2;

	lea	ebx, QWORD PTR [rax+12]
	jmp	SHORT $LN261@search_pu_
$LN259@search_pu_:

; 170  :     } else if (is_frac_chroma) {

	test	bl, bl
	mov	eax, 8
	mov	ebx, 0
	cmovne	ebx, eax
	jmp	SHORT $LN261@search_pu_
$LN395@search_pu_:

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	xor	ebx, ebx
$LN261@search_pu_:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [r13+28]
	lea	r10d, DWORD PTR [r12+rax*4]
	mov	eax, DWORD PTR [r13+32]
	lea	edx, DWORD PTR [r15+rax*4]
	cmp	r10d, ebx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	$LN48@search_pu_
	cmp	edx, ebx
	jl	$LN48@search_pu_

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [rcx+48]
	mov	r8, QWORD PTR [rax]
	mov	eax, DWORD PTR [r13+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r8+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r10d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, ebx
	jl	$LN48@search_pu_

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	ecx, DWORD PTR [r8+20]
	mov	eax, DWORD PTR [r13+40]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, ebx
	jl	SHORT $LN48@search_pu_
$LN347@search_pu_:

; 1426 :     bool valid_mv = fracmv_within_tile(info, mv.x, mv.y);
; 1427 :     if (valid_mv) {
; 1428 :       // Map reference index to L0/L1 pictures
; 1429 :       unipred_LX[ref_list].inter.mv_dir = ref_list + 1;

	mov	rdx, QWORD PTR unipred_LX$[rbp-256]
	lea	r8, QWORD PTR [r14+r14*4]
	movzx	r10d, BYTE PTR ref_list$1$[rbp-256]

; 1430 :       unipred_LX[ref_list].inter.mv_ref[ref_list] = LX_idx;

	movzx	ecx, BYTE PTR LX_idx$1$[rbp-256]
	movzx	eax, r10b
	shl	al, 6
	and	BYTE PTR [rdx+r8*4+18], 63		; 0000003fH
	add	al, 64					; 00000040H
	or	BYTE PTR [rdx+r8*4+18], al
	imul	rax, r14, 21
	mov	BYTE PTR [rax+rdx+16], cl

; 1431 :       unipred_LX[ref_list].inter.mv[ref_list][0] = (int16_t)mv.x;

	lea	rax, QWORD PTR [r14+r14*2]
	movzx	ecx, WORD PTR mv$[rsp]
	mov	WORD PTR [rdx+rax*8+8], cx

; 1432 :       unipred_LX[ref_list].inter.mv[ref_list][1] = (int16_t)mv.y;

	movzx	ecx, WORD PTR mv$[rsp+4]
	mov	WORD PTR [rdx+rax*8+10], cx
	movzx	ecx, BYTE PTR [rdx+r8*4+18]

; 1433 : 
; 1434 :       CU_SET_MV_CAND(&unipred_LX[ref_list], ref_list, cu_mv_cand);

	test	r10b, r10b
	jne	SHORT $LN49@search_pu_
	and	cl, 248					; 000000f8H
	or	cl, r9b
	jmp	SHORT $LN18@search_pu_
$LN49@search_pu_:
	movzx	eax, cl
	shl	r9b, 3
	and	al, 199					; 000000c7H
	movzx	ecx, r9b
	or	cl, al
$LN18@search_pu_:

; 1435 : 
; 1436 :       best_LX_cost[ref_list] = info->best_cost;

	movsd	QWORD PTR [r11+r14*8], xmm1
	mov	BYTE PTR [rdx+r8*4+18], cl
$LN48@search_pu_:

; 1437 :     }
; 1438 :   }
; 1439 : }

	add	rsp, 4344				; 000010f8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
search_pu_inter_ref ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
x$1$ = 96
extra_bits$1$ = 96
x$1$ = 96
tv3180 = 104
x$1$ = 112
y$1$ = 116
idx$1$ = 120
num_cand_pairs$1$ = 124
bitcost$1 = 128
mv$2 = 136
$T3 = 144
tv3432 = 152
ref$1$ = 160
frame$1$ = 168
merge_cand$4 = 176
width$1$ = 336
info$ = 336
depth$dead$ = 344
height$1$ = 344
lcu$ = 352
cur_cu$ = 360
inter_cost$ = 368
inter_bitcost$ = 376
search_pu_inter_bipred PROC

; 1450 : {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rsi
	sub	rsp, 312				; 00000138H

; 1451 :   const image_list_t *const ref = info->state->frame->ref;

	mov	rax, QWORD PTR [rcx]
	mov	rsi, rcx
	mov	rbp, r9
	mov	r9, QWORD PTR [rax+40]

; 1452 :   uint8_t (*ref_LX)[16] = info->state->frame->ref_LX;
; 1453 :   const videoframe_t * const frame = info->state->tile->frame;

	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR tv3180[rsp], r9
	mov	rcx, QWORD PTR [r9+40]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR frame$1$[rsp], rax

; 1454 :   const int x         = info->origin.x;

	mov	eax, DWORD PTR [rsi+28]
	mov	DWORD PTR x$1$[rsp], eax

; 1455 :   const int y         = info->origin.y;

	mov	eax, DWORD PTR [rsi+32]
	mov	DWORD PTR y$1$[rsp], eax

; 1456 :   const int width     = info->width;

	mov	eax, DWORD PTR [rsi+36]
	mov	DWORD PTR width$1$[rsp], eax

; 1457 :   const int height    = info->height;

	mov	eax, DWORD PTR [rsi+40]
	mov	DWORD PTR height$1$[rsp], eax
	mov	QWORD PTR ref$1$[rsp], rcx

; 1458 : 
; 1459 :   static const uint8_t priorityList0[] = { 0, 1, 0, 2, 1, 2, 0, 3, 1, 3, 2, 3 };
; 1460 :   static const uint8_t priorityList1[] = { 1, 0, 2, 0, 2, 1, 3, 0, 3, 1, 3, 2 };
; 1461 :   const unsigned num_cand_pairs =

	mov	ecx, DWORD PTR [rsi+112]
	lea	eax, DWORD PTR [rcx-1]
	imul	eax, ecx
	cmp	eax, 12
	jge	SHORT $LN26@search_pu_
	lea	edx, DWORD PTR [rcx-1]
	imul	edx, ecx
	mov	DWORD PTR num_cand_pairs$1$[rsp], edx

; 1462 :     MIN(info->num_merge_cand * (info->num_merge_cand - 1), 12);
; 1463 : 
; 1464 :   inter_merge_cand_t *merge_cand = info->merge_cand;
; 1465 : 
; 1466 :   for (int32_t idx = 0; idx < num_cand_pairs; idx++) {

	test	edx, edx
	je	$LN313@search_pu_
	jmp	SHORT $LN303@search_pu_
$LN26@search_pu_:

; 1458 : 
; 1459 :   static const uint8_t priorityList0[] = { 0, 1, 0, 2, 1, 2, 0, 3, 1, 3, 2, 3 };
; 1460 :   static const uint8_t priorityList1[] = { 1, 0, 2, 0, 2, 1, 3, 0, 3, 1, 3, 2 };
; 1461 :   const unsigned num_cand_pairs =

	mov	DWORD PTR num_cand_pairs$1$[rsp], 12
$LN303@search_pu_:
	mov	QWORD PTR [rsp+360], rbx

; 1548 :         if (merge_cand[merge_idx].mv[0][0] == cur_cu->inter.mv[0][0] &&
; 1549 :             merge_cand[merge_idx].mv[0][1] == cur_cu->inter.mv[0][1] &&
; 1550 :             merge_cand[merge_idx].mv[1][0] == cur_cu->inter.mv[1][0] &&
; 1551 :             merge_cand[merge_idx].mv[1][1] == cur_cu->inter.mv[1][1] &&
; 1552 :             merge_cand[merge_idx].ref[0] == cur_cu->inter.mv_ref[0] &&

	lea	rcx, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+304], rdi
	xor	r11d, r11d
	mov	QWORD PTR [rsp+296], r12
	mov	eax, r11d
	mov	QWORD PTR [rsp+288], r13
	mov	QWORD PTR [rsp+280], r14
	mov	QWORD PTR [rsp+272], r15
	movaps	XMMWORD PTR [rsp+240], xmm7
	movsd	xmm7, QWORD PTR __real@3fe0000000000000
	movaps	XMMWORD PTR [rsp+256], xmm6
	mov	QWORD PTR $T3[rsp], rax
	mov	DWORD PTR idx$1$[rsp], r11d
	npad	3
$LL4@search_pu_:

; 1467 :     uint8_t i = priorityList0[idx];
; 1468 :     uint8_t j = priorityList1[idx];

	movzx	r8d, BYTE PTR ?priorityList0@?1??search_pu_inter_bipred@@9@9[rax+rcx]
	movzx	edx, BYTE PTR ?priorityList1@?1??search_pu_inter_bipred@@9@9[rax+rcx]

; 1469 :     if (i >= info->num_merge_cand || j >= info->num_merge_cand) break;

	mov	ecx, DWORD PTR [rsi+112]
	cmp	r8d, ecx
	jge	$LN335@search_pu_
	cmp	edx, ecx
	jge	$LN335@search_pu_

; 1470 : 
; 1471 :     // Find one L0 and L1 candidate according to the priority list
; 1472 :     if (!(merge_cand[i].dir & 0x1) || !(merge_cand[j].dir & 0x2)) continue;

	lea	r12, QWORD PTR [r8+r8*2]
	test	BYTE PTR [rsi+r12*4+52], 1
	je	$LN2@search_pu_
	lea	r14, QWORD PTR [rdx+rdx*2]
	test	BYTE PTR [rsi+r14*4+52], 2
	mov	QWORD PTR tv3432[rsp], r14
	je	$LN2@search_pu_

; 1473 : 
; 1474 :     if (ref_LX[0][merge_cand[i].ref[0]] == ref_LX[1][merge_cand[j].ref[1]] &&
; 1475 :         merge_cand[i].mv[0][0] == merge_cand[j].mv[1][0] &&

	movzx	eax, BYTE PTR [rsi+r14*4+54]
	movzx	ecx, BYTE PTR [rsi+r12*4+53]
	movzx	eax, BYTE PTR [rax+r9+65]
	cmp	BYTE PTR [rcx+r9+49], al
	jne	SHORT $LN18@search_pu_
	movzx	eax, WORD PTR [rsi+r14*4+60]
	cmp	WORD PTR [rsi+r12*4+56], ax
	jne	SHORT $LN18@search_pu_
	movzx	eax, WORD PTR [rsi+r14*4+62]
	cmp	WORD PTR [rsi+r12*4+58], ax
	je	$LN2@search_pu_
$LN18@search_pu_:

; 1483 :     mv[0][1] = merge_cand[i].mv[0][1];

	movsx	eax, WORD PTR [rsi+r12*4+58]
	movsx	ecx, WORD PTR [rsi+r12*4+56]

; 1485 :     mv[1][1] = merge_cand[j].mv[1][1];

	mov	r13d, eax

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r9, QWORD PTR [rsi]

; 1484 :     mv[1][0] = merge_cand[j].mv[1][0];

	movzx	ebx, WORD PTR [rsi+r14*4+60]

; 1485 :     mv[1][1] = merge_cand[j].mv[1][1];

	movzx	edx, WORD PTR [rsi+r14*4+62]
	mov	WORD PTR mv$2[rsp+2], ax

; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, ecx

; 1476 :         merge_cand[i].mv[0][1] == merge_cand[j].mv[1][1])
; 1477 :     {
; 1478 :       continue;
; 1479 :     }
; 1480 : 
; 1481 :     int16_t mv[2][2];
; 1482 :     mv[0][0] = merge_cand[i].mv[0][0];

	mov	WORD PTR mv$2[rsp], cx

; 1484 :     mv[1][0] = merge_cand[j].mv[1][0];

	mov	WORD PTR mv$2[rsp+4], bx

; 1485 :     mv[1][1] = merge_cand[j].mv[1][1];

	mov	WORD PTR mv$2[rsp+6], dx

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r10, QWORD PTR [r9]

; 1486 : 
; 1487 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1488 :     if (!fracmv_within_tile(info, mv[0][0], mv[0][1]) ||

	mov	DWORD PTR x$1$[rsp], ecx

; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN312@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN312@search_pu_:
	test	eax, eax
	jne	SHORT $LN44@search_pu_
	mov	eax, r13d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN311@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN311@search_pu_:
	test	eax, eax
	jne	SHORT $LN44@search_pu_
	xor	r15b, r15b
	jmp	SHORT $LN45@search_pu_
$LN44@search_pu_:
	mov	r15b, 1
$LN45@search_pu_:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, ecx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN310@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN310@search_pu_:
	test	eax, eax
	jne	SHORT $LN46@search_pu_
	mov	eax, r13d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN309@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN309@search_pu_:
	test	eax, eax
	jne	SHORT $LN46@search_pu_
	xor	dil, dil
	jmp	SHORT $LN47@search_pu_
$LN46@search_pu_:
	mov	dil, 1
$LN47@search_pu_:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r10+172], 0
	je	$LN37@search_pu_
	cmp	DWORD PTR [r10+168], 0
	je	$LN37@search_pu_

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	r15b, r15b
	je	SHORT $LN30@search_pu_

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	r8d, 4
	jmp	SHORT $LN32@search_pu_
$LN30@search_pu_:

; 122  :     } else if (is_frac_chroma) {

	test	dil, dil
	mov	r8d, r11d
	mov	eax, 2
	cmovne	r8d, eax
$LN32@search_pu_:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r10+44], 0
	je	SHORT $LN33@search_pu_

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r8d, 10
	jmp	SHORT $LN35@search_pu_
$LN33@search_pu_:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r10+40], 0
	je	SHORT $LN35@search_pu_

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r8d, 8
$LN35@search_pu_:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {

	mov	ecx, DWORD PTR [rsi+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	r11d, DWORD PTR [r10+6536]
	mov	ebx, DWORD PTR [rsi+28]
	lea	eax, DWORD PTR [r8+rcx]
	add	eax, DWORD PTR [rsi+40]
	lea	eax, DWORD PTR [rax*4]
	add	eax, r13d
	cdq
	movzx	r9d, dl
	add	r9d, eax
	mov	eax, ecx
	cdq
	sar	r9d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	r9d, eax
	cmp	r9d, r11d
	jg	$LN327@search_pu_

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR [rsi+36]
	mov	eax, DWORD PTR x$1$[rsp]
	add	edx, r8d
	add	edx, ebx
	lea	eax, DWORD PTR [rax+rdx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, ebx
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r10+6532]
	sar	eax, 6
	add	edx, r11d
	sub	r8d, eax
	xor	r11d, r11d
	add	r8d, r9d
	cmp	r8d, edx
	jg	$LN317@search_pu_
	mov	ecx, DWORD PTR x$1$[rsp]
	movzx	ebx, WORD PTR [rsi+r14*4+60]
	mov	r9, QWORD PTR [rsi]
$LN37@search_pu_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r10+2360]
	test	eax, eax
	je	SHORT $LN301@search_pu_

; 162  :     return true;
; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	mov	edx, r11d

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN42@search_pu_

; 168  :     if (is_frac_luma) {

	test	r15b, r15b
	je	SHORT $LN40@search_pu_

; 169  :       margin = 4 << 2;

	lea	edx, QWORD PTR [rax+12]
	jmp	SHORT $LN42@search_pu_
$LN40@search_pu_:

; 170  :     } else if (is_frac_chroma) {

	test	dil, dil
	mov	eax, 8
	cmovne	edx, eax
$LN42@search_pu_:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [rsi+28]
	lea	r11d, DWORD PTR [rcx+rax*4]
	mov	eax, DWORD PTR [rsi+32]
	lea	r8d, DWORD PTR [rax*4]
	add	r8d, r13d
	cmp	r11d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	$LN327@search_pu_
	cmp	r8d, edx
	jl	$LN327@search_pu_

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [r9+48]
	mov	r9, QWORD PTR [rax]
	mov	eax, DWORD PTR [rsi+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r9+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r11d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN327@search_pu_

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	ecx, DWORD PTR [r9+20]
	mov	eax, DWORD PTR [rsi+40]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN327@search_pu_
$LN301@search_pu_:

; 1486 : 
; 1487 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1488 :     if (!fracmv_within_tile(info, mv[0][0], mv[0][1]) ||

	movsx	r13d, WORD PTR [rsi+r14*4+62]
	movsx	ecx, bx

; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, ecx

; 1486 : 
; 1487 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1488 :     if (!fracmv_within_tile(info, mv[0][0], mv[0][1]) ||

	mov	DWORD PTR x$1$[rsp], ecx

; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN308@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN308@search_pu_:
	test	eax, eax
	jne	SHORT $LN66@search_pu_
	mov	eax, r13d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN307@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN307@search_pu_:
	test	eax, eax
	jne	SHORT $LN66@search_pu_
	xor	r15b, r15b
	jmp	SHORT $LN67@search_pu_
$LN66@search_pu_:
	mov	r15b, 1
$LN67@search_pu_:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, ecx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN306@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN306@search_pu_:
	test	eax, eax
	jne	SHORT $LN68@search_pu_
	mov	eax, r13d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN305@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN305@search_pu_:
	test	eax, eax
	jne	SHORT $LN68@search_pu_
	xor	bl, bl
	jmp	SHORT $LN69@search_pu_
$LN68@search_pu_:
	mov	bl, 1
$LN69@search_pu_:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r10+172], 0
	je	$LN59@search_pu_
	cmp	DWORD PTR [r10+168], 0
	je	$LN59@search_pu_

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	r15b, r15b
	je	SHORT $LN52@search_pu_

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	r9d, 4
	jmp	SHORT $LN54@search_pu_
$LN52@search_pu_:

; 122  :     } else if (is_frac_chroma) {

	xor	eax, eax
	mov	r9d, eax
	test	bl, bl
	mov	eax, 2
	cmovne	r9d, eax
$LN54@search_pu_:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r10+44], 0
	je	SHORT $LN55@search_pu_

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r9d, 10
	jmp	SHORT $LN57@search_pu_
$LN55@search_pu_:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r10+40], 0
	je	SHORT $LN57@search_pu_

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r9d, 8
$LN57@search_pu_:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {

	mov	r8d, DWORD PTR [rsi+32]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	edi, DWORD PTR [r10+6536]
	mov	r14d, DWORD PTR [rsi+28]
	lea	ecx, DWORD PTR [r9+r8]
	add	ecx, DWORD PTR [rsi+40]
	lea	eax, DWORD PTR [rcx*4]
	add	eax, r13d
	cdq
	movzx	r11d, dl
	add	r11d, eax
	mov	eax, r8d
	cdq
	sar	r11d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	r11d, eax
	cmp	r11d, edi
	jg	$LN327@search_pu_

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR [rsi+36]
	mov	eax, DWORD PTR x$1$[rsp]
	add	edx, r9d
	add	edx, r14d
	lea	eax, DWORD PTR [rax+rdx*4]
	cdq
	movzx	r8d, dl
	add	r8d, eax
	mov	eax, r14d
	cdq
	sar	r8d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r10+6532]
	sar	eax, 6
	add	edx, edi
	sub	r8d, eax
	add	r8d, r11d
	cmp	r8d, edx
	jg	$LN327@search_pu_
	mov	r14, QWORD PTR tv3432[rsp]
	mov	ecx, DWORD PTR x$1$[rsp]
$LN59@search_pu_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r10+2360]
	test	eax, eax
	je	$LN314@search_pu_

; 162  :     return true;
; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	xor	r11d, r11d
	mov	edx, r11d

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN64@search_pu_

; 168  :     if (is_frac_luma) {

	test	r15b, r15b
	je	SHORT $LN62@search_pu_

; 169  :       margin = 4 << 2;

	lea	edx, QWORD PTR [rax+12]
	jmp	SHORT $LN64@search_pu_
$LN62@search_pu_:

; 170  :     } else if (is_frac_chroma) {

	test	bl, bl
	mov	eax, 8
	cmovne	edx, eax
$LN64@search_pu_:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	eax, DWORD PTR [rsi+28]
	lea	r10d, DWORD PTR [rcx+rax*4]
	mov	eax, DWORD PTR [rsi+32]
	lea	r8d, DWORD PTR [rax*4]
	add	r8d, r13d
	cmp	r10d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	$LN317@search_pu_
	cmp	r8d, edx
	jl	$LN317@search_pu_

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	r11, QWORD PTR [rsi]
	mov	rax, QWORD PTR [r11+48]
	mov	r9, QWORD PTR [rax]
	mov	eax, DWORD PTR [rsi+36]
	shl	eax, 2
	mov	ecx, DWORD PTR [r9+16]
	shl	ecx, 2
	sub	ecx, eax
	sub	ecx, r10d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN327@search_pu_

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	ecx, DWORD PTR [r9+20]
	mov	eax, DWORD PTR [rsi+40]
	shl	ecx, 2
	shl	eax, 2
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN327@search_pu_

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	jmp	SHORT $LN302@search_pu_
$LN314@search_pu_:
	mov	r11, QWORD PTR [rsi]
$LN302@search_pu_:

; 1489 :         !fracmv_within_tile(info, mv[1][0], mv[1][1]))
; 1490 :     {
; 1491 :       continue;
; 1492 :     }
; 1493 : 
; 1494 :     kvz_inter_recon_bipred(info->state,

	movzx	ecx, BYTE PTR [rsi+r14*4+54]
	mov	rdx, QWORD PTR tv3180[rsp]
	mov	rax, QWORD PTR ref$1$[rsp]
	mov	r13d, DWORD PTR height$1$[rsp]
	mov	r15d, DWORD PTR width$1$[rsp]
	movzx	r8d, BYTE PTR [rcx+rdx+65]
	movzx	ecx, BYTE PTR [rsi+r12*4+53]
	mov	rax, QWORD PTR [rax]
	mov	edi, DWORD PTR x$1$[rsp]
	mov	r9d, edi
	mov	ebx, DWORD PTR y$1$[rsp]
	movzx	edx, BYTE PTR [rcx+rdx+49]
	mov	rcx, QWORD PTR lcu$[rsp]
	mov	r8, QWORD PTR [rax+r8*8]
	mov	BYTE PTR [rsp+80], 0
	mov	rdx, QWORD PTR [rax+rdx*8]
	mov	BYTE PTR [rsp+72], 1
	mov	QWORD PTR [rsp+64], rcx
	lea	rcx, QWORD PTR mv$2[rsp]
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, r11
	mov	DWORD PTR [rsp+48], r13d
	mov	DWORD PTR [rsp+40], r15d
	mov	DWORD PTR [rsp+32], ebx
	call	kvz_inter_recon_bipred

; 1495 :                            ref->images[ref_LX[0][merge_cand[i].ref[0]]],
; 1496 :                            ref->images[ref_LX[1][merge_cand[j].ref[1]]],
; 1497 :                            x, y,
; 1498 :                            width,
; 1499 :                            height,
; 1500 :                            mv,
; 1501 :                            lcu,
; 1502 :                            true,
; 1503 :                            false);
; 1504 : 
; 1505 :     const kvz_pixel *rec = &lcu->rec.y[SUB_SCU(y) * LCU_WIDTH + SUB_SCU(x)];
; 1506 :     const kvz_pixel *src = &frame->source->y[x + y * frame->source->width];

	mov	rax, QWORD PTR frame$1$[rsp]
	mov	r8, QWORD PTR lcu$[rsp]
	add	r8, 6540				; 0000198cH
	mov	rcx, QWORD PTR [rax]
	mov	r9d, DWORD PTR [rcx+64]
	mov	eax, r9d
	imul	eax, ebx

; 1507 :     uint32_t cost =

	mov	DWORD PTR [rsp+40], r9d
	mov	r9d, 64					; 00000040H
	add	eax, edi
	movsxd	rdx, eax
	mov	eax, edi
	add	rdx, QWORD PTR [rcx+16]
	and	eax, 63					; 0000003fH
	mov	ecx, ebx
	mov	QWORD PTR [rsp+32], rdx
	and	ecx, 63					; 0000003fH
	mov	edx, r13d
	shl	ecx, 6
	add	eax, ecx
	mov	ecx, r15d
	add	r8, rax
	call	QWORD PTR kvz_satd_any_size

; 1508 :       kvz_satd_any_size(width, height, rec, LCU_WIDTH, src, frame->source->width);
; 1509 : 
; 1510 :     uint32_t bitcost[2] = { 0, 0 };
; 1511 : 
; 1512 :     cost += info->mvd_cost_func(info->state,

	movsx	r8d, WORD PTR [rsi+r12*4+58]
	lea	r15, QWORD PTR [rsi+44]
	movsx	edx, WORD PTR [rsi+r12*4+56]
	xor	edi, edi
	mov	rcx, QWORD PTR [rsi]
	mov	ebx, eax
	lea	rax, QWORD PTR bitcost$1[rsp]
	mov	QWORD PTR bitcost$1[rsp], rdi
	mov	QWORD PTR [rsp+64], rax
	xor	r9d, r9d
	mov	DWORD PTR [rsp+56], edi
	mov	WORD PTR [rsp+48], di
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR [rsi+120]

; 1513 :                                merge_cand[i].mv[0][0],
; 1514 :                                merge_cand[i].mv[0][1],
; 1515 :                                0,
; 1516 :                                info->mv_cand,
; 1517 :                                NULL, 0, 0,
; 1518 :                                &bitcost[0]);
; 1519 :     cost += info->mvd_cost_func(info->state,

	movsx	r8d, WORD PTR [rsi+r12*4+62]
	xor	r9d, r9d
	movsx	edx, WORD PTR [rsi+r12*4+60]
	add	ebx, eax
	mov	rcx, QWORD PTR [rsi]
	lea	rax, QWORD PTR bitcost$1[rsp+4]
	mov	QWORD PTR [rsp+64], rax
	mov	DWORD PTR [rsp+56], edi
	mov	WORD PTR [rsp+48], di
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR [rsi+120]

; 1520 :                                merge_cand[i].mv[1][0],
; 1521 :                                merge_cand[i].mv[1][1],
; 1522 :                                0,
; 1523 :                                info->mv_cand,
; 1524 :                                NULL, 0, 0,
; 1525 :                                &bitcost[1]);
; 1526 : 
; 1527 :     const uint8_t mv_ref_coded[2] = {

	movzx	ecx, BYTE PTR [rsi+r14*4+54]
	add	ebx, eax

; 1528 :       merge_cand[i].ref[0],
; 1529 :       merge_cand[j].ref[1]
; 1530 :     };
; 1531 :     const int extra_bits = mv_ref_coded[0] + mv_ref_coded[1] + 2 /* mv dir cost */;

	movzx	r13d, BYTE PTR [rsi+r12*4+53]
	add	ecx, 2
	add	r13d, ecx
	mov	DWORD PTR extra_bits$1$[rsp], r13d

; 1532 :     cost += info->state->lambda_sqrt * extra_bits + 0.5;

	mov	rax, QWORD PTR [rsi]
	xorps	xmm0, xmm0
	movd	xmm1, r13d
	xorps	xmm6, xmm6
	cvtdq2pd xmm1, xmm1
	mulsd	xmm1, QWORD PTR [rax+376]
	mov	eax, ebx
	cvtsi2sd xmm0, rax

; 1533 : 
; 1534 :     if (cost < *inter_cost) {

	mov	rax, QWORD PTR inter_cost$[rsp]
	addsd	xmm1, xmm7
	addsd	xmm1, xmm0
	cvttsd2si rcx, xmm1
	mov	ecx, ecx
	cvtsi2sd xmm6, rcx
	comisd	xmm6, QWORD PTR [rax]
	jae	$LN327@search_pu_

; 1535 :       cur_cu->inter.mv_dir = 3;

	or	BYTE PTR [rbp+18], 192			; 000000c0H

; 1536 : 
; 1537 :       cur_cu->inter.mv_ref[0] = merge_cand[i].ref[0];
; 1538 :       cur_cu->inter.mv_ref[1] = merge_cand[j].ref[1];
; 1539 : 
; 1540 :       cur_cu->inter.mv[0][0] = merge_cand[i].mv[0][0];
; 1541 :       cur_cu->inter.mv[0][1] = merge_cand[i].mv[0][1];
; 1542 :       cur_cu->inter.mv[1][0] = merge_cand[j].mv[1][0];
; 1543 :       cur_cu->inter.mv[1][1] = merge_cand[j].mv[1][1];
; 1544 :       cur_cu->merged = 0;
; 1545 : 
; 1546 :       // Check every candidate to find a match
; 1547 :       for (int merge_idx = 0; merge_idx < info->num_merge_cand; merge_idx++) {

	mov	edx, edi
	movzx	eax, BYTE PTR [rsi+r12*4+53]
	mov	BYTE PTR [rbp+16], al
	movzx	eax, BYTE PTR [rsi+r14*4+54]
	mov	BYTE PTR [rbp+17], al
	movzx	r9d, WORD PTR [rsi+r12*4+56]
	mov	WORD PTR [rbp+8], r9w
	movzx	eax, WORD PTR [rsi+r12*4+58]
	mov	WORD PTR [rbp+10], ax
	movzx	eax, WORD PTR [rsi+r14*4+60]
	mov	WORD PTR [rbp+12], ax
	movzx	eax, WORD PTR [rsi+r14*4+62]
	mov	WORD PTR [rbp+14], ax
	and	BYTE PTR [rbp+1], 239			; 000000efH
	mov	r8d, DWORD PTR [rsi+112]
	movzx	r10d, BYTE PTR [rbp+1]
	test	r8d, r8d
	jle	SHORT $LN304@search_pu_
	npad	5
$LL7@search_pu_:

; 1548 :         if (merge_cand[merge_idx].mv[0][0] == cur_cu->inter.mv[0][0] &&
; 1549 :             merge_cand[merge_idx].mv[0][1] == cur_cu->inter.mv[0][1] &&
; 1550 :             merge_cand[merge_idx].mv[1][0] == cur_cu->inter.mv[1][0] &&
; 1551 :             merge_cand[merge_idx].mv[1][1] == cur_cu->inter.mv[1][1] &&
; 1552 :             merge_cand[merge_idx].ref[0] == cur_cu->inter.mv_ref[0] &&

	mov	eax, edx
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	WORD PTR [rsi+rcx*4+56], r9w
	jne	SHORT $LN5@search_pu_
	movzx	eax, WORD PTR [rbp+10]
	cmp	WORD PTR [rsi+rcx*4+58], ax
	jne	SHORT $LN5@search_pu_
	movzx	eax, WORD PTR [rbp+12]
	cmp	WORD PTR [rsi+rcx*4+60], ax
	jne	SHORT $LN5@search_pu_
	movzx	eax, WORD PTR [rbp+14]
	cmp	WORD PTR [rsi+rcx*4+62], ax
	jne	SHORT $LN5@search_pu_
	movzx	eax, BYTE PTR [rbp+16]
	cmp	BYTE PTR [rsi+rcx*4+53], al
	jne	SHORT $LN5@search_pu_
	movzx	eax, BYTE PTR [rbp+17]
	cmp	BYTE PTR [rsi+rcx*4+54], al
	je	SHORT $LN290@search_pu_
$LN5@search_pu_:

; 1536 : 
; 1537 :       cur_cu->inter.mv_ref[0] = merge_cand[i].ref[0];
; 1538 :       cur_cu->inter.mv_ref[1] = merge_cand[j].ref[1];
; 1539 : 
; 1540 :       cur_cu->inter.mv[0][0] = merge_cand[i].mv[0][0];
; 1541 :       cur_cu->inter.mv[0][1] = merge_cand[i].mv[0][1];
; 1542 :       cur_cu->inter.mv[1][0] = merge_cand[j].mv[1][0];
; 1543 :       cur_cu->inter.mv[1][1] = merge_cand[j].mv[1][1];
; 1544 :       cur_cu->merged = 0;
; 1545 : 
; 1546 :       // Check every candidate to find a match
; 1547 :       for (int merge_idx = 0; merge_idx < info->num_merge_cand; merge_idx++) {

	inc	edx
	cmp	edx, r8d
	jl	SHORT $LL7@search_pu_
	jmp	SHORT $LN304@search_pu_
$LN290@search_pu_:

; 1553 :             merge_cand[merge_idx].ref[1] == cur_cu->inter.mv_ref[1])
; 1554 :         {
; 1555 :           cur_cu->merged = 1;
; 1556 :           cur_cu->merge_idx = merge_idx;

	shl	dl, 5
	and	r10b, 15
	or	dl, r10b
	or	dl, 16
	mov	BYTE PTR [rbp+1], dl
$LN304@search_pu_:

; 1557 :           break;
; 1558 :         }
; 1559 :       }
; 1560 : 
; 1561 :       // Each motion vector has its own candidate
; 1562 :       for (int reflist = 0; reflist < 2; reflist++) {

	mov	r12d, DWORD PTR x$1$[rsp]
	mov	r14d, edi
	mov	r13d, DWORD PTR y$1$[rsp]
	npad	7
$LL10@search_pu_:

; 1563 :         kvz_inter_get_mv_cand(info->state, x, y, width, height, info->mv_cand, cur_cu, lcu, reflist);

	mov	rbx, QWORD PTR [rsi]
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1342 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };

	xor	eax, eax

; 1343 : 
; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	r9d, DWORD PTR height$1$[rsp]
	xorps	xmm0, xmm0
	mov	r8d, DWORD PTR width$1$[rsp]
	xorps	xmm1, xmm1

; 1342 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };

	mov	QWORD PTR merge_cand$4[rsp+48], rax

; 1343 : 
; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	edx, r13d
	mov	rax, QWORD PTR [rbx+48]
	movdqu	XMMWORD PTR merge_cand$4[rsp], xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1563 :         kvz_inter_get_mv_cand(info->state, x, y, width, height, info->mv_cand, cur_cu, lcu, reflist);

	mov	edi, r14d
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1342 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };

	movdqu	XMMWORD PTR merge_cand$4[rsp+16], xmm1
	movdqu	XMMWORD PTR merge_cand$4[rsp+32], xmm0

; 1343 : 
; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	rcx, QWORD PTR [rax]
	lea	rax, QWORD PTR merge_cand$4[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR lcu$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rcx+16]
	mov	ecx, r12d
	mov	DWORD PTR [rsp+32], eax
	call	get_spatial_merge_candidates

; 1345 :                                state->tile->frame->width,
; 1346 :                                state->tile->frame->height,
; 1347 :                                lcu,
; 1348 :                                &merge_cand);
; 1349 :   get_temporal_merge_candidates(state, x, y, width, height, 1, 0, &merge_cand);

	mov	r9d, DWORD PTR width$1$[rsp]
	lea	rax, QWORD PTR merge_cand$4[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	r8d, r13d
	mov	eax, DWORD PTR height$1$[rsp]
	mov	edx, r12d
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], eax
	call	get_temporal_merge_candidates

; 1350 :   get_mv_cand_from_candidates(state, x, y, width, height, &merge_cand, cur_cu, reflist, mv_cand);

	mov	r9d, DWORD PTR width$1$[rsp]
	lea	rax, QWORD PTR merge_cand$4[rsp]
	mov	QWORD PTR [rsp+64], r15
	mov	r8d, r13d
	mov	BYTE PTR [rsp+56], r14b
	mov	edx, r12d
	mov	QWORD PTR [rsp+48], rbp
	mov	rcx, rbx
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR height$1$[rsp]
	mov	DWORD PTR [rsp+32], eax
	call	get_mv_cand_from_candidates
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1564 :         int cu_mv_cand = select_mv_cand(

	movsx	r9d, WORD PTR [rbp+rdi*4+10]
	xor	eax, eax
	movsx	r8d, WORD PTR [rbp+rdi*4+8]
	mov	rdx, r15
	mov	rcx, QWORD PTR [rsi]
	mov	QWORD PTR [rsp+32], rax
	call	select_mv_cand

; 1565 :             info->state,
; 1566 :             info->mv_cand,
; 1567 :             cur_cu->inter.mv[reflist][0],
; 1568 :             cur_cu->inter.mv[reflist][1],
; 1569 :             NULL);
; 1570 :         CU_SET_MV_CAND(cur_cu, reflist, cu_mv_cand);

	movzx	ecx, BYTE PTR [rbp+18]
	and	al, 7
	test	r14d, r14d
	jne	SHORT $LN23@search_pu_
	and	cl, 248					; 000000f8H
	jmp	SHORT $LN336@search_pu_
$LN23@search_pu_:
	and	cl, 199					; 000000c7H
	shl	al, 3
$LN336@search_pu_:

; 1557 :           break;
; 1558 :         }
; 1559 :       }
; 1560 : 
; 1561 :       // Each motion vector has its own candidate
; 1562 :       for (int reflist = 0; reflist < 2; reflist++) {

	or	cl, al
	inc	r14d
	mov	BYTE PTR [rbp+18], cl
	cmp	r14d, 2
	jl	$LL10@search_pu_

; 1571 :       }
; 1572 : 
; 1573 :       *inter_cost = cost;

	mov	rax, QWORD PTR inter_cost$[rsp]

; 1574 :       *inter_bitcost = bitcost[0] + bitcost[1] + extra_bits;

	mov	ecx, DWORD PTR extra_bits$1$[rsp]
	add	ecx, DWORD PTR bitcost$1[rsp+4]
	add	ecx, DWORD PTR bitcost$1[rsp]
	movsd	QWORD PTR [rax], xmm6
	mov	rax, QWORD PTR inter_bitcost$[rsp]
	mov	DWORD PTR [rax], ecx
$LN327@search_pu_:

; 1462 :     MIN(info->num_merge_cand * (info->num_merge_cand - 1), 12);
; 1463 : 
; 1464 :   inter_merge_cand_t *merge_cand = info->merge_cand;
; 1465 : 
; 1466 :   for (int32_t idx = 0; idx < num_cand_pairs; idx++) {

	xor	r11d, r11d
$LN317@search_pu_:
	mov	r9, QWORD PTR tv3180[rsp]
$LN2@search_pu_:
	mov	r12d, DWORD PTR idx$1$[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	rax, QWORD PTR $T3[rsp]
	inc	r12d
	inc	rax
	mov	DWORD PTR idx$1$[rsp], r12d
	mov	QWORD PTR $T3[rsp], rax
	cmp	r12d, DWORD PTR num_cand_pairs$1$[rsp]
	jb	$LL4@search_pu_
$LN335@search_pu_:
	movaps	xmm6, XMMWORD PTR [rsp+256]
	mov	r15, QWORD PTR [rsp+272]
	mov	r14, QWORD PTR [rsp+280]
	mov	r13, QWORD PTR [rsp+288]
	mov	r12, QWORD PTR [rsp+296]
	mov	rdi, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [rsp+360]
	movaps	xmm7, XMMWORD PTR [rsp+240]
$LN313@search_pu_:

; 1575 :     }
; 1576 :   }
; 1577 : }

	add	rsp, 312				; 00000138H
	pop	rsi
	pop	rbp
	ret	0
search_pu_inter_bipred ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
all_cands$ = 8
cand_to_add$ = 16
added_idx_list$ = 24
list_size$ = 32
merge_candidate_in_list PROC

; 1593 : {

	mov	QWORD PTR [rsp+8], rbx

; 1594 :   bool found = false;

	xor	al, al
	mov	r11, r8
	mov	rbx, rcx

; 1595 :   for (int i = 0; i < list_size && !found; ++i) {

	test	r9d, r9d
	jle	SHORT $LN12@merge_cand
	movsxd	r10, r9d
	xor	r8d, r8d
$LL4@merge_cand:
	test	al, al
	jne	SHORT $LN12@merge_cand

; 1596 :     inter_merge_cand_t * list_cand = &all_cands[added_idx_list[i]];

	movsx	rax, BYTE PTR [r8+r11]
	lea	rcx, QWORD PTR [rax+rax*2]

; 1597 : 
; 1598 :     found = cand_to_add->dir == list_cand->dir &&

	movzx	eax, BYTE PTR [rbx+rcx*4]
	cmp	BYTE PTR [rdx], al
	jne	SHORT $LN6@merge_cand
	movzx	eax, BYTE PTR [rbx+rcx*4+1]
	cmp	BYTE PTR [rdx+1], al
	jne	SHORT $LN6@merge_cand
	movzx	eax, WORD PTR [rbx+rcx*4+4]
	cmp	WORD PTR [rdx+4], ax
	jne	SHORT $LN6@merge_cand
	movzx	eax, WORD PTR [rbx+rcx*4+6]
	cmp	WORD PTR [rdx+6], ax
	jne	SHORT $LN6@merge_cand
	movzx	eax, BYTE PTR [rbx+rcx*4+2]
	cmp	BYTE PTR [rdx+2], al
	jne	SHORT $LN6@merge_cand
	movzx	eax, WORD PTR [rbx+rcx*4+8]
	cmp	WORD PTR [rdx+8], ax
	jne	SHORT $LN6@merge_cand
	movzx	eax, WORD PTR [rbx+rcx*4+10]
	cmp	WORD PTR [rdx+10], ax
	jne	SHORT $LN6@merge_cand
	mov	al, 1
	jmp	SHORT $LN7@merge_cand
$LN6@merge_cand:
	xor	al, al
$LN7@merge_cand:

; 1595 :   for (int i = 0; i < list_size && !found; ++i) {

	inc	r8
	cmp	r8, r10
	jl	SHORT $LL4@merge_cand
$LN12@merge_cand:

; 1599 :         cand_to_add->ref[0] == list_cand->ref[0] &&
; 1600 :         cand_to_add->mv[0][0] == list_cand->mv[0][0] &&
; 1601 :         cand_to_add->mv[0][1] == list_cand->mv[0][1] &&
; 1602 :         cand_to_add->ref[1] == list_cand->ref[1] &&
; 1603 :         cand_to_add->mv[1][0] == list_cand->mv[1][0] &&
; 1604 :         cand_to_add->mv[1][1] == list_cand->mv[1][1];
; 1605 :   }
; 1606 : 
; 1607 :   return found;
; 1608 : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
merge_candidate_in_list ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
height$1$ = 96
y$1$ = 100
mrg_cands$ = 104
x$1$ = 112
width$1$ = 116
margin$2$ = 120
y_local$1$ = 124
x_local$1$ = 128
info$ = 144
merge_idx$1$ = 304
tv2220 = 304
width$1$ = 312
cfg$1$ = 320
state$1$ = 328
cur_cu$1$ = 328
unipreds$ = 336
merge_cand$2 = 376
mrg_costs$ = 376
best_cost_LX$ = 432
bitcost$3 = 560
state$ = 560
x_cu$ = 568
extra_bits$1$ = 576
tv5009 = 576
y_cu$ = 576
depth$ = 584
y$1$ = 592
tv5591 = 592
part_mode$ = 592
has_chroma$1$ = 600
mv_x$1$ = 600
i_pu$ = 600
num_rdo_cands$2$ = 608
mv$4 = 608
lcu$ = 608
inter_cost$ = 616
inter_bitcost$ = 624
search_pu_inter PROC

; 1632 : {

	mov	rax, rsp
	mov	DWORD PTR [rax+32], r9d
	mov	DWORD PTR [rax+24], r8d
	mov	DWORD PTR [rax+16], edx
	mov	QWORD PTR [rax+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-296]
	sub	rsp, 488				; 000001e8H

; 1633 :   *inter_cost = MAX_INT;
; 1634 :   *inter_bitcost = MAX_INT;
; 1635 : 
; 1636 :   const kvz_config *cfg = &state->encoder_control->cfg;
; 1637 :   const videoframe_t * const frame = state->tile->frame;
; 1638 :   const int width_cu  = LCU_WIDTH >> depth;
; 1639 :   const int x         = PU_GET_X(part_mode, width_cu, x_cu, i_pu);

	movsxd	r11, DWORD PTR i_pu$[rbp-256]
	lea	r14, OFFSET FLAT:__ImageBase
	movaps	XMMWORD PTR [rax-88], xmm6
	mov	edi, edx
	movaps	XMMWORD PTR [rax-104], xmm7
	mov	r13, rcx
	mov	rax, QWORD PTR inter_cost$[rbp-256]
	mov	esi, r8d
	mov	rcx, 4746794007244308480		; 41dfffffffc00000H
	mov	QWORD PTR [rax], rcx
	mov	ecx, r9d
	mov	rax, QWORD PTR inter_bitcost$[rbp-256]
	mov	r9d, 64					; 00000040H
	sar	r9d, cl
	movsxd	rcx, DWORD PTR part_mode$[rbp-256]
	mov	DWORD PTR width$1$[rbp-256], r9d
	mov	DWORD PTR [rax], 2147483647		; 7fffffffH
	mov	rax, QWORD PTR [r13]
	mov	QWORD PTR cfg$1$[rbp-256], rax
	lea	r8, QWORD PTR [r11+rcx*4]
	mov	rax, QWORD PTR [r13+48]
	mov	r10, QWORD PTR [rax]
	movzx	eax, BYTE PTR kvz_part_mode_offsets[r14+r8*2]
	imul	eax, r9d
	cdq
	and	edx, 3
	lea	ecx, DWORD PTR [rdx+rax]

; 1640 :   const int y         = PU_GET_Y(part_mode, width_cu, y_cu, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_offsets[r14+r8*2+1]
	imul	eax, r9d
	sar	ecx, 2
	add	ecx, edi
	mov	DWORD PTR x$1$[rsp], ecx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	esi, eax

; 1641 :   const int width     = PU_GET_W(part_mode, width_cu, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[r14+r8*2]
	imul	eax, r9d
	mov	DWORD PTR y$1$[rsp], esi
	cdq
	and	edx, 3
	lea	r12d, DWORD PTR [rdx+rax]

; 1642 :   const int height    = PU_GET_H(part_mode, width_cu, i_pu);

	movzx	eax, BYTE PTR kvz_part_mode_sizes[r14+r8*2+1]
	imul	eax, r9d
	sar	r12d, 2
	mov	DWORD PTR width$1$[rsp], r12d
	cdq
	and	edx, 3
	lea	r8d, DWORD PTR [rdx+rax]
	sar	r8d, 2
	mov	DWORD PTR height$1$[rsp], r8d

; 1643 : 
; 1644 :   // Merge candidate A1 may not be used for the second PU of Nx2N, nLx2N and
; 1645 :   // nRx2N partitions.
; 1646 :   const bool merge_a1 = i_pu == 0 || width >= height;

	test	r11d, r11d
	je	$LN448@search_pu_
	cmp	r12d, r8d
	jge	$LN448@search_pu_
	xor	bl, bl
$LN450@search_pu_:

; 1647 :   // Merge candidate B1 may not be used for the second PU of 2NxN, 2NxnU and
; 1648 :   // 2NxnD partitions.
; 1649 :   const bool merge_b1 = i_pu == 0 || width <= height;

	mov	dil, 1
$LN55@search_pu_:

; 1650 : 
; 1651 :   const int x_local   = SUB_SCU(x);
; 1652 :   const int y_local   = SUB_SCU(y);
; 1653 :   cu_info_t *cur_cu   = LCU_GET_CU_AT_PX(lcu, x_local, y_local);

	mov	r14, QWORD PTR lcu$[rbp-256]
	mov	edx, ecx
	and	edx, 63					; 0000003fH

; 1654 : 
; 1655 :   inter_search_info_t info = {

	mov	QWORD PTR info$[rbp-256], r13
	xorps	xmm0, xmm0
	mov	DWORD PTR x_local$1$[rbp-256], edx
	mov	eax, esi
	xor	esi, esi
	and	eax, 63					; 0000003fH
	mov	DWORD PTR y_local$1$[rsp], eax
	shr	eax, 2
	imul	ecx, eax, 17
	mov	eax, edx
	shr	eax, 2
	lea	rdx, OFFSET FLAT:kvz_calc_mvd_cost_cabac
	add	ecx, eax
	mov	eax, ecx
	lea	rcx, QWORD PTR [rcx*4+6334]
	add	rcx, rax
	mov	rax, QWORD PTR [r10]
	mov	QWORD PTR info$[rbp-248], rax
	mov	eax, DWORD PTR x$1$[rsp]
	mov	DWORD PTR info$[rbp-228], eax
	mov	eax, DWORD PTR y$1$[rsp]
	lea	r15, QWORD PTR [r14+rcx*4]
	mov	rcx, QWORD PTR cfg$1$[rbp-256]
	mov	DWORD PTR info$[rbp-224], eax
	xor	eax, eax
	mov	QWORD PTR info$[rbp-148], rax
	lea	rax, OFFSET FLAT:calc_mvd_cost
	mov	QWORD PTR info$[rbp-240], rsi
	mov	DWORD PTR info$[rbp-232], esi
	mov	DWORD PTR info$[rbp-220], r12d
	mov	DWORD PTR info$[rbp-216], r8d
	movups	XMMWORD PTR info$[rbp-212], xmm0
	mov	QWORD PTR cur_cu$1$[rbp-256], r15
	movups	XMMWORD PTR info$[rbp-196], xmm0
	movups	XMMWORD PTR info$[rbp-180], xmm0
	movups	XMMWORD PTR info$[rbp-164], xmm0
	cmp	BYTE PTR [rcx+2356], sil
	mov	ecx, r12d
	mov	QWORD PTR info$[rbp-128], rsi
	cmovne	rax, rdx
	mov	QWORD PTR info$[rbp-120], rsi
	mov	QWORD PTR info$[rbp-136], rax
	call	QWORD PTR kvz_get_optimized_sad

; 1656 :     .state          = state,
; 1657 :     .pic            = frame->source,
; 1658 :     .origin         = { x, y },
; 1659 :     .width          = width,
; 1660 :     .height         = height,
; 1661 :     .mvd_cost_func  = cfg->mv_rdo ? kvz_calc_mvd_cost_cabac : calc_mvd_cost,
; 1662 :     .optimized_sad  = kvz_get_optimized_sad(width),
; 1663 :   };
; 1664 : 
; 1665 :   // Search for merge mode candidates
; 1666 :   info.num_merge_cand = kvz_inter_get_merge_cand(

	mov	r8d, DWORD PTR y$1$[rsp]
	mov	r9d, r12d
	mov	edx, DWORD PTR x$1$[rsp]
	mov	rcx, r13
	mov	QWORD PTR [rsp+64], r14
	mov	QWORD PTR info$[rbp-112], rax
	lea	rax, QWORD PTR info$[rbp-204]
	mov	QWORD PTR [rsp+56], rax
	mov	BYTE PTR [rsp+48], dil
	mov	BYTE PTR [rsp+40], bl
	mov	ebx, DWORD PTR height$1$[rsp]
	mov	DWORD PTR [rsp+32], ebx
	call	kvz_inter_get_merge_cand

; 1667 :       state,
; 1668 :       x, y,
; 1669 :       width, height,
; 1670 :       merge_a1, merge_b1,
; 1671 :       info.merge_cand,
; 1672 :       lcu
; 1673 :   );
; 1674 : 
; 1675 :   // Default to candidate 0
; 1676 :   CU_SET_MV_CAND(cur_cu, 0, 0);
; 1677 :   CU_SET_MV_CAND(cur_cu, 1, 0);
; 1678 : 
; 1679 :   // Merge Analysis starts here
; 1680 :   int8_t mrg_cands[MRG_MAX_NUM_CANDS];
; 1681 :   double mrg_costs[MRG_MAX_NUM_CANDS];
; 1682 :   for (int i = 0; i < MRG_MAX_NUM_CANDS; ++i) {
; 1683 :     mrg_cands[i] = -1;
; 1684 :     mrg_costs[i] = MAX_DOUBLE;

	movaps	xmm6, XMMWORD PTR __xmm@7fee42d130773b767fee42d130773b76

; 1685 :   }
; 1686 : 
; 1687 :   int num_rdo_cands = 0;
; 1688 : 
; 1689 :   // Check motion vector constraints and perform rough search
; 1690 :   for (int merge_idx = 0; merge_idx < info.num_merge_cand; ++merge_idx) {

	lea	r10d, QWORD PTR [rsi+2]
	movzx	eax, al
	mov	r8d, 4
	mov	DWORD PTR info$[rbp-144], eax
	movaps	xmm7, xmm6
	and	BYTE PTR [r15+18], 192			; 000000c0H
	mov	eax, esi
	mov	edi, esi
	movsd	QWORD PTR mrg_costs$[rbp-224], xmm6
	mov	DWORD PTR mrg_cands$[rsp], -1		; ffffffffH
	movups	XMMWORD PTR mrg_costs$[rbp-256], xmm6
	mov	BYTE PTR mrg_cands$[rsp+4], -1
	movups	XMMWORD PTR mrg_costs$[rbp-240], xmm6
	mov	DWORD PTR num_rdo_cands$2$[rbp-256], esi
	mov	DWORD PTR merge_idx$1$[rbp-256], eax
	mov	DWORD PTR margin$2$[rsp], r8d
	cmp	DWORD PTR info$[rbp-144], esi
	jg	$LN13@search_pu_
	mov	r12d, DWORD PTR info$[rbp-228]
$LN12@search_pu_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 427  :   for (uint8_t i = 1; i < length; ++i) {

	mov	r8b, 1
	cmp	dil, r8b
	jbe	SHORT $LN153@search_pu_
	lea	r9, QWORD PTR mrg_cands$[rsp+1]
	lea	r10, QWORD PTR mrg_costs$[rbp-248]
	npad	7
$LL154@search_pu_:

; 428  :     const double cur_cost = costs[i];

	movsd	xmm1, QWORD PTR [r10]

; 429  :     const int8_t cur_mode = modes[i];
; 430  :     uint8_t j = i;

	movzx	edx, r8b
	movzx	r11d, BYTE PTR [r9]
	npad	3
$LL155@search_pu_:

; 431  :     while (j > 0 && cur_cost < costs[j - 1]) {

	movzx	ecx, dl
	movsd	xmm0, QWORD PTR mrg_costs$[rbp+rcx*8-264]
	comisd	xmm1, xmm0
	jae	SHORT $LN156@search_pu_

; 432  :       costs[j] = costs[j - 1];
; 433  :       modes[j] = modes[j - 1];

	movzx	eax, BYTE PTR mrg_cands$[rsp+rcx-1]
	mov	BYTE PTR mrg_cands$[rsp+rcx], al
	movsd	QWORD PTR mrg_costs$[rbp+rcx*8-256], xmm0

; 434  :       --j;

	add	dl, 255					; 000000ffH
	jne	SHORT $LL155@search_pu_
$LN156@search_pu_:

; 435  :     }
; 436  :     costs[j] = cur_cost;

	movzx	eax, dl
	inc	r8b
	add	r10, 8
	inc	r9
	movsd	QWORD PTR mrg_costs$[rbp+rax*8-256], xmm1

; 437  :     modes[j] = cur_mode;

	mov	BYTE PTR mrg_cands$[rsp+rax], r11b
	cmp	r8b, dil
	jb	SHORT $LL154@search_pu_
	movsd	xmm7, QWORD PTR mrg_costs$[rbp-256]
$LN153@search_pu_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1736 :   num_rdo_cands = MIN(1, num_rdo_cands);

	mov	eax, 1
	cmp	edi, eax
	cmovg	edi, eax

; 1737 :     
; 1738 :   // Early Skip Mode Decision
; 1739 :   bool has_chroma = state->encoder_control->chroma_format != KVZ_CSP_400;

	mov	rax, QWORD PTR [r13]
	mov	DWORD PTR num_rdo_cands$2$[rbp-256], edi
	mov	eax, DWORD PTR [rax+2596]
	test	eax, eax
	mov	DWORD PTR tv5009[rbp-256], eax

; 1740 :   if (cfg->early_skip && cur_cu->part_size == SIZE_2Nx2N) {

	mov	rax, QWORD PTR cfg$1$[rbp-256]
	setne	BYTE PTR has_chroma$1$[rbp-256]
	cmp	BYTE PTR [rax+2474], 0
	je	$LN15@search_pu_
	cmp	BYTE PTR [r15], 32			; 00000020H
	jae	$LN15@search_pu_

; 1741 :     for (int merge_rdo_idx = 0; merge_rdo_idx < num_rdo_cands; ++merge_rdo_idx) {

	mov	ebx, esi
	test	edi, edi
	jle	$LN15@search_pu_

; 1694 :     cur_cu->inter.mv_ref[0] = cur_cand->ref[0];
; 1695 :     cur_cu->inter.mv_ref[1] = cur_cand->ref[1];
; 1696 :     cur_cu->inter.mv[0][0] = cur_cand->mv[0][0];
; 1697 :     cur_cu->inter.mv[0][1] = cur_cand->mv[0][1];
; 1698 :     cur_cu->inter.mv[1][0] = cur_cand->mv[1][0];
; 1699 :     cur_cu->inter.mv[1][1] = cur_cand->mv[1][1];
; 1700 : 
; 1701 :     // If bipred is not enabled, do not try candidates with mv_dir == 3.
; 1702 :     // Bipred is also forbidden for 4x8 and 8x4 blocks by the standard. 
; 1703 :     if (cur_cu->inter.mv_dir == 3 && !state->encoder_control->cfg.bipred) continue;

	movsxd	r8, DWORD PTR depth$[rbp-256]
	lea	rdi, QWORD PTR mrg_cands$[rsp]
	mov	r13, r8
	mov	QWORD PTR tv2220[rbp-256], r8
	npad	10
$LL16@search_pu_:

; 1748 :       cur_cu->inter.mv_dir = info.merge_cand[merge_idx].dir;

	movzx	eax, BYTE PTR [r15+18]
	xor	r10d, r10d
	movsx	rsi, BYTE PTR [rdi]
	and	al, 63					; 0000003fH
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 137  :   for (unsigned y = 0; y < width; y += SCU_WIDTH) {

	mov	r11d, DWORD PTR width$1$[rbp-256]
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1747 :       int merge_idx = mrg_cands[merge_rdo_idx];

	mov	r12, rsi

; 1748 :       cur_cu->inter.mv_dir = info.merge_cand[merge_idx].dir;

	lea	rdx, QWORD PTR [rsi+rsi*2]
	movzx	ecx, BYTE PTR info$[rbp+rdx*4-204]
	shl	cl, 6
	or	cl, al
	mov	BYTE PTR [r15+18], cl

; 1749 :       cur_cu->inter.mv_ref[0] = info.merge_cand[merge_idx].ref[0];

	movzx	eax, BYTE PTR info$[rbp+rdx*4-203]
	mov	BYTE PTR [r15+16], al

; 1750 :       cur_cu->inter.mv_ref[1] = info.merge_cand[merge_idx].ref[1];

	movzx	eax, BYTE PTR info$[rbp+rdx*4-202]
	mov	BYTE PTR [r15+17], al

; 1751 :       cur_cu->inter.mv[0][0] = info.merge_cand[merge_idx].mv[0][0];

	movzx	eax, WORD PTR info$[rbp+rdx*4-200]
	mov	WORD PTR [r15+8], ax

; 1752 :       cur_cu->inter.mv[0][1] = info.merge_cand[merge_idx].mv[0][1];

	movzx	eax, WORD PTR info$[rbp+rdx*4-198]
	mov	WORD PTR [r15+10], ax

; 1753 :       cur_cu->inter.mv[1][0] = info.merge_cand[merge_idx].mv[1][0];

	movzx	eax, WORD PTR info$[rbp+rdx*4-196]
	mov	WORD PTR [r15+12], ax

; 1754 :       cur_cu->inter.mv[1][1] = info.merge_cand[merge_idx].mv[1][1];

	movzx	eax, WORD PTR info$[rbp+rdx*4-194]
	mov	WORD PTR [r15+14], ax
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 137  :   for (unsigned y = 0; y < width; y += SCU_WIDTH) {

	test	r11d, r11d
	je	SHORT $LN160@search_pu_
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1755 :       kvz_lcu_fill_trdepth(lcu, x, y, depth, MAX(1, depth));

	mov	r15d, DWORD PTR x_local$1$[rbp-256]
	cmp	r8d, 1
	mov	esi, DWORD PTR y_local$1$[rsp]
	mov	eax, 1
	movzx	r9d, r8b
	cmovl	r9d, eax
	and	r9b, 7
	xor	r13d, r13d
	npad	10
$LL161@search_pu_:
	lea	eax, DWORD PTR [r10+rsi]
; File F:\open_codec_learn_2021\kvazaar-master\src\search.c

; 138  :     for (unsigned x = 0; x < width; x += SCU_WIDTH) {

	mov	edx, r13d
	shr	eax, 2
	imul	r8d, eax, 17
	npad	2
$LL164@search_pu_:

; 139  :       LCU_GET_CU_AT_PX(lcu, x_local + x, y_local + y)->tr_depth = tr_depth;

	lea	eax, DWORD PTR [rdx+r15]
	add	edx, 4
	shr	eax, 2
	add	eax, 18
	add	eax, r8d
	lea	rax, QWORD PTR [rax+rax*4]
	and	BYTE PTR [r14+rax*4+24977], 248		; 000000f8H
	or	BYTE PTR [r14+rax*4+24977], r9b
	cmp	edx, r11d
	jb	SHORT $LL164@search_pu_

; 137  :   for (unsigned y = 0; y < width; y += SCU_WIDTH) {

	add	r10d, 4
	cmp	r10d, r11d
	jb	SHORT $LL161@search_pu_
	mov	r15, QWORD PTR cur_cu$1$[rbp-256]
	movzx	esi, BYTE PTR [rdi]
	mov	r13, QWORD PTR tv2220[rbp-256]
$LN160@search_pu_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1756 :       kvz_inter_recon_cu(state, lcu, x, y, width, true, false);

	mov	eax, DWORD PTR width$1$[rsp]
	mov	rdx, r14
	mov	r9d, DWORD PTR y$1$[rsp]
	mov	r8d, DWORD PTR x$1$[rsp]
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	BYTE PTR [rsp+48], 0
	mov	BYTE PTR [rsp+40], 1
	mov	DWORD PTR [rsp+32], eax
	call	kvz_inter_recon_cu

; 1757 :       kvz_quantize_lcu_residual(state, true, false, x, y, depth, cur_cu, lcu, true);

	mov	eax, DWORD PTR depth$[rbp-256]
	xor	r8d, r8d
	mov	r9d, DWORD PTR x$1$[rsp]
	mov	dl, 1
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	BYTE PTR [rsp+64], 1
	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r15
	mov	BYTE PTR [rsp+40], al
	mov	eax, DWORD PTR y$1$[rsp]
	mov	DWORD PTR [rsp+32], eax
	call	kvz_quantize_lcu_residual
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR cbf_masks[rcx+r13*2]
	test	ax, WORD PTR [r15+4]
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1759 :       if (cbf_is_set(cur_cu->cbf, depth, COLOR_Y)) {

	jne	$LN14@search_pu_

; 1760 :         continue;
; 1761 :       }
; 1762 :       else if (has_chroma) {

	cmp	DWORD PTR tv5009[rbp-256], 0
	je	$LN14@search_pu_

; 1763 :         kvz_inter_recon_cu(state, lcu, x, y, width, false, has_chroma);

	movzx	eax, BYTE PTR has_chroma$1$[rbp-256]
	mov	rdx, r14
	mov	r9d, DWORD PTR y$1$[rsp]
	mov	r8d, DWORD PTR x$1$[rsp]
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	BYTE PTR [rsp+48], al
	mov	eax, DWORD PTR width$1$[rsp]
	mov	BYTE PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], eax
	call	kvz_inter_recon_cu

; 1764 :         kvz_quantize_lcu_residual(state, false, has_chroma, x, y, depth, cur_cu, lcu, true);

	mov	eax, DWORD PTR depth$[rbp-256]
	xor	edx, edx
	mov	r9d, DWORD PTR x$1$[rsp]
	movzx	r8d, BYTE PTR has_chroma$1$[rbp-256]
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	BYTE PTR [rsp+64], 1
	mov	QWORD PTR [rsp+56], r14
	mov	QWORD PTR [rsp+48], r15
	mov	BYTE PTR [rsp+40], al
	mov	eax, DWORD PTR y$1$[rsp]
	mov	DWORD PTR [rsp+32], eax
	call	kvz_quantize_lcu_residual

; 1765 :         if (!cbf_is_set_any(cur_cu->cbf, depth)) {

	movzx	edx, WORD PTR [r15+4]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	rax, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR cbf_masks[rax+r13*2]
	test	ax, dx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	jne	SHORT $LN14@search_pu_

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	ecx, eax
	shl	ecx, 5
	or	ecx, eax
	shl	ecx, 5
	test	ecx, edx

; 526  :   return cbf_is_set(cbf, depth, COLOR_Y) ||

	je	$LN420@search_pu_
$LN14@search_pu_:
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1741 :     for (int merge_rdo_idx = 0; merge_rdo_idx < num_rdo_cands; ++merge_rdo_idx) {

	inc	ebx
	inc	rdi
	cmp	ebx, DWORD PTR num_rdo_cands$2$[rbp-256]
	jge	$LN488@search_pu_
	mov	r8d, DWORD PTR depth$[rbp-256]
	jmp	$LL16@search_pu_
$LN448@search_pu_:

; 1643 : 
; 1644 :   // Merge candidate A1 may not be used for the second PU of Nx2N, nLx2N and
; 1645 :   // nRx2N partitions.
; 1646 :   const bool merge_a1 = i_pu == 0 || width >= height;

	mov	bl, 1

; 1647 :   // Merge candidate B1 may not be used for the second PU of 2NxN, 2NxnU and
; 1648 :   // 2NxnD partitions.
; 1649 :   const bool merge_b1 = i_pu == 0 || width <= height;

	test	r11d, r11d
	je	$LN450@search_pu_
	cmp	r12d, r8d
	jle	$LN450@search_pu_
	xor	dil, dil
	jmp	$LN55@search_pu_
	npad	6
$LL508@search_pu_:

; 1685 :   }
; 1686 : 
; 1687 :   int num_rdo_cands = 0;
; 1688 : 
; 1689 :   // Check motion vector constraints and perform rough search
; 1690 :   for (int merge_idx = 0; merge_idx < info.num_merge_cand; ++merge_idx) {

	mov	r12d, DWORD PTR width$1$[rsp]
$LN13@search_pu_:

; 1691 : 
; 1692 :     inter_merge_cand_t *cur_cand = &info.merge_cand[merge_idx];
; 1693 :     cur_cu->inter.mv_dir = cur_cand->dir;

	movzx	ecx, BYTE PTR [r15+18]
	cdqe
	and	cl, 63					; 0000003fH
	lea	rdx, QWORD PTR [rax+rax*2]
	movzx	eax, BYTE PTR info$[rbp+rdx*4-204]
	shl	al, 6
	or	cl, al
	mov	BYTE PTR [r15+18], cl

; 1694 :     cur_cu->inter.mv_ref[0] = cur_cand->ref[0];
; 1695 :     cur_cu->inter.mv_ref[1] = cur_cand->ref[1];
; 1696 :     cur_cu->inter.mv[0][0] = cur_cand->mv[0][0];
; 1697 :     cur_cu->inter.mv[0][1] = cur_cand->mv[0][1];
; 1698 :     cur_cu->inter.mv[1][0] = cur_cand->mv[1][0];
; 1699 :     cur_cu->inter.mv[1][1] = cur_cand->mv[1][1];
; 1700 : 
; 1701 :     // If bipred is not enabled, do not try candidates with mv_dir == 3.
; 1702 :     // Bipred is also forbidden for 4x8 and 8x4 blocks by the standard. 
; 1703 :     if (cur_cu->inter.mv_dir == 3 && !state->encoder_control->cfg.bipred) continue;

	and	cl, 192					; 000000c0H
	movzx	eax, BYTE PTR info$[rbp+rdx*4-203]
	mov	BYTE PTR [r15+16], al
	movzx	eax, BYTE PTR info$[rbp+rdx*4-202]
	mov	BYTE PTR [r15+17], al
	movzx	eax, WORD PTR info$[rbp+rdx*4-200]
	mov	WORD PTR [r15+8], ax
	movzx	eax, WORD PTR info$[rbp+rdx*4-198]
	mov	WORD PTR [r15+10], ax
	movzx	eax, WORD PTR info$[rbp+rdx*4-196]
	mov	WORD PTR [r15+12], ax
	movzx	eax, WORD PTR info$[rbp+rdx*4-194]
	mov	WORD PTR tv5591[rbp-256], ax
	mov	WORD PTR [r15+14], ax
	cmp	cl, 192					; 000000c0H
	jne	SHORT $LN34@search_pu_
	mov	rax, QWORD PTR [r13]
	cmp	DWORD PTR [rax+92], 0
	je	SHORT $LN486@search_pu_

; 1704 :     if (cur_cu->inter.mv_dir == 3 && !(width + height > 12)) continue;

	lea	eax, DWORD PTR [rbx+r12]
	cmp	eax, 12
	jg	SHORT $LN34@search_pu_
$LN486@search_pu_:

; 1694 :     cur_cu->inter.mv_ref[0] = cur_cand->ref[0];
; 1695 :     cur_cu->inter.mv_ref[1] = cur_cand->ref[1];
; 1696 :     cur_cu->inter.mv[0][0] = cur_cand->mv[0][0];
; 1697 :     cur_cu->inter.mv[0][1] = cur_cand->mv[0][1];
; 1698 :     cur_cu->inter.mv[1][0] = cur_cand->mv[1][0];
; 1699 :     cur_cu->inter.mv[1][1] = cur_cand->mv[1][1];
; 1700 : 
; 1701 :     // If bipred is not enabled, do not try candidates with mv_dir == 3.
; 1702 :     // Bipred is also forbidden for 4x8 and 8x4 blocks by the standard. 
; 1703 :     if (cur_cu->inter.mv_dir == 3 && !state->encoder_control->cfg.bipred) continue;

	mov	r12d, DWORD PTR info$[rbp-228]
	jmp	$LN11@search_pu_
$LN34@search_pu_:

; 1594 :   bool found = false;

	xor	r13b, r13b

; 1595 :   for (int i = 0; i < list_size && !found; ++i) {

	mov	r9d, esi
	test	edi, edi
	jle	SHORT $LN102@search_pu_

; 1597 : 
; 1598 :     found = cand_to_add->dir == list_cand->dir &&

	lea	r8, QWORD PTR mrg_cands$[rsp]
$LL103@search_pu_:

; 1595 :   for (int i = 0; i < list_size && !found; ++i) {

	test	r13b, r13b
	jne	SHORT $LN490@search_pu_

; 1596 :     inter_merge_cand_t * list_cand = &all_cands[added_idx_list[i]];

	movsx	rax, BYTE PTR [r8]
	lea	rcx, QWORD PTR [rax+rax*2]

; 1597 : 
; 1598 :     found = cand_to_add->dir == list_cand->dir &&

	movzx	eax, BYTE PTR info$[rbp+rcx*4-204]
	cmp	BYTE PTR info$[rbp+rdx*4-204], al
	jne	SHORT $LN105@search_pu_
	movzx	eax, BYTE PTR info$[rbp+rcx*4-203]
	cmp	BYTE PTR info$[rbp+rdx*4-203], al
	jne	SHORT $LN105@search_pu_
	movzx	eax, WORD PTR info$[rbp+rcx*4-200]
	cmp	WORD PTR info$[rbp+rdx*4-200], ax
	jne	SHORT $LN105@search_pu_
	movzx	eax, WORD PTR info$[rbp+rcx*4-198]
	cmp	WORD PTR info$[rbp+rdx*4-198], ax
	jne	SHORT $LN105@search_pu_
	movzx	eax, BYTE PTR info$[rbp+rcx*4-202]
	cmp	BYTE PTR info$[rbp+rdx*4-202], al
	jne	SHORT $LN105@search_pu_
	movzx	eax, WORD PTR info$[rbp+rcx*4-196]
	cmp	WORD PTR info$[rbp+rdx*4-196], ax
	jne	SHORT $LN105@search_pu_
	movzx	eax, WORD PTR info$[rbp+rcx*4-194]
	cmp	WORD PTR info$[rbp+rdx*4-194], ax
	jne	SHORT $LN105@search_pu_
	mov	r13b, 1
	jmp	SHORT $LN106@search_pu_
$LN105@search_pu_:
	xor	r13b, r13b
$LN106@search_pu_:

; 1595 :   for (int i = 0; i < list_size && !found; ++i) {

	inc	r9d
	inc	r8
	cmp	r9d, edi
	jl	SHORT $LL103@search_pu_
$LN490@search_pu_:
	mov	r8d, 4
$LN102@search_pu_:

; 1705 : 
; 1706 :     bool is_duplicate = merge_candidate_in_list(info.merge_cand, cur_cand,
; 1707 :       mrg_cands, 
; 1708 :       num_rdo_cands);
; 1709 : 
; 1710 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1711 :     // Don't add duplicates to list
; 1712 :     if (!fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]) ||
; 1713 :         !fracmv_within_tile(&info, cur_cu->inter.mv[1][0], cur_cu->inter.mv[1][1]) ||

	movsx	ecx, WORD PTR [r15+8]

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	rdx, QWORD PTR info$[rbp-256]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, ecx

; 1705 : 
; 1706 :     bool is_duplicate = merge_candidate_in_list(info.merge_cand, cur_cand,
; 1707 :       mrg_cands, 
; 1708 :       num_rdo_cands);
; 1709 : 
; 1710 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1711 :     // Don't add duplicates to list
; 1712 :     if (!fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]) ||
; 1713 :         !fracmv_within_tile(&info, cur_cu->inter.mv[1][0], cur_cu->inter.mv[1][1]) ||

	movsx	r11d, WORD PTR [r15+10]

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r9, QWORD PTR [rdx]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN485@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN485@search_pu_:
	test	eax, eax
	jne	SHORT $LN123@search_pu_
	mov	eax, r11d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN484@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN484@search_pu_:
	test	eax, eax
	jne	SHORT $LN123@search_pu_
	xor	sil, sil
	jmp	SHORT $LN124@search_pu_
$LN123@search_pu_:
	mov	sil, 1
$LN124@search_pu_:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, ecx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN483@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN483@search_pu_:
	test	eax, eax
	jne	SHORT $LN125@search_pu_
	mov	eax, r11d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN482@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN482@search_pu_:
	test	eax, eax
	jne	SHORT $LN125@search_pu_
	xor	bl, bl
	jmp	SHORT $LN126@search_pu_
$LN125@search_pu_:
	mov	bl, 1
$LN126@search_pu_:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r9+172], 0
	mov	r12d, DWORD PTR info$[rbp-228]
	je	$LN116@search_pu_
	cmp	DWORD PTR [r9+168], 0
	je	$LN116@search_pu_

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	sil, sil
	jne	SHORT $LN111@search_pu_

; 122  :     } else if (is_frac_chroma) {

	xor	r8d, r8d
	test	bl, bl
	cmovne	r8d, r10d
$LN111@search_pu_:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r9+44], 0
	je	SHORT $LN112@search_pu_

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r8d, 10
	jmp	SHORT $LN114@search_pu_
$LN112@search_pu_:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r9+40], 0
	je	SHORT $LN114@search_pu_

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r8d, 8
$LN114@search_pu_:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {

	mov	eax, r12d
	cdq
	and	edx, 63					; 0000003fH
	lea	edi, DWORD PTR [rdx+rax]

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR info$[rbp-216]
	add	edx, r8d
	sar	edi, 6
	add	edx, DWORD PTR info$[rbp-224]
	lea	eax, DWORD PTR [r11+rdx*4]

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	r11d, DWORD PTR [r9+6536]
	cdq
	movzx	r10d, dl
	add	r10d, eax
	mov	eax, DWORD PTR info$[rbp-224]
	cdq
	sar	r10d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	r10d, eax
	cmp	r10d, r11d
	jg	$LN506@search_pu_

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR info$[rbp-220]
	movsx	eax, WORD PTR [r15+8]
	add	edx, r8d
	add	edx, r12d
	lea	eax, DWORD PTR [rax+rdx*4]
	cdq
	movzx	edx, dl
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r9+6532]
	sar	eax, 8
	add	edx, r11d
	sub	eax, edi
	add	eax, r10d
	cmp	eax, edx
	jg	$LN506@search_pu_
	movsx	r11d, WORD PTR [r15+10]
	movsx	ecx, WORD PTR [r15+8]
$LN116@search_pu_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r9+2360]
	test	eax, eax
	je	$LN491@search_pu_

; 162  :     return true;
; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	xor	edx, edx

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN121@search_pu_

; 168  :     if (is_frac_luma) {

	test	sil, sil
	je	SHORT $LN119@search_pu_

; 169  :       margin = 4 << 2;

	lea	edx, QWORD PTR [rax+12]
	jmp	SHORT $LN121@search_pu_
$LN119@search_pu_:

; 170  :     } else if (is_frac_chroma) {

	test	bl, bl
	mov	eax, 8
	cmovne	edx, eax
$LN121@search_pu_:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	mov	edi, DWORD PTR info$[rbp-224]
	lea	r10d, DWORD PTR [rcx+r12*4]
	lea	r8d, DWORD PTR [r11+rdi*4]
	cmp	r10d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	SHORT $LN506@search_pu_
	cmp	r8d, edx
	jl	SHORT $LN506@search_pu_

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR info$[rbp-256]
	mov	rax, QWORD PTR [rax+48]
	mov	r11, QWORD PTR [rax]
	mov	eax, DWORD PTR info$[rbp-220]
	mov	ecx, DWORD PTR [r11+16]
	shl	ecx, 2
	lea	eax, DWORD PTR [rax*4]
	sub	ecx, eax
	sub	ecx, r10d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	SHORT $LN506@search_pu_

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	eax, DWORD PTR info$[rbp-216]
	mov	ecx, DWORD PTR [r11+20]
	shl	ecx, 2
	lea	eax, DWORD PTR [rax*4]
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jge	SHORT $LN464@search_pu_
$LN506@search_pu_:

; 1685 :   }
; 1686 : 
; 1687 :   int num_rdo_cands = 0;
; 1688 : 
; 1689 :   // Check motion vector constraints and perform rough search
; 1690 :   for (int merge_idx = 0; merge_idx < info.num_merge_cand; ++merge_idx) {

	mov	r13, QWORD PTR state$[rbp-256]
$LN507@search_pu_:
	mov	edi, DWORD PTR num_rdo_cands$2$[rbp-256]
	mov	ebx, DWORD PTR height$1$[rsp]
$LN511@search_pu_:
	mov	r10d, 2
	xor	esi, esi
	lea	r8d, QWORD PTR [r10+2]
$LN11@search_pu_:
	mov	eax, DWORD PTR merge_idx$1$[rbp-256]
	inc	eax
	mov	DWORD PTR merge_idx$1$[rbp-256], eax
	cmp	eax, DWORD PTR info$[rbp-144]
	jl	$LL508@search_pu_
	movsd	xmm7, QWORD PTR mrg_costs$[rbp-256]
	jmp	$LN12@search_pu_
$LN491@search_pu_:

; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	edi, DWORD PTR info$[rbp-224]
$LN464@search_pu_:

; 1705 : 
; 1706 :     bool is_duplicate = merge_candidate_in_list(info.merge_cand, cur_cand,
; 1707 :       mrg_cands, 
; 1708 :       num_rdo_cands);
; 1709 : 
; 1710 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1711 :     // Don't add duplicates to list
; 1712 :     if (!fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]) ||
; 1713 :         !fracmv_within_tile(&info, cur_cu->inter.mv[1][0], cur_cu->inter.mv[1][1]) ||

	movsx	ecx, WORD PTR [r15+12]
	movsx	r10d, WORD PTR tv5591[rbp-256]

; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, ecx

; 1705 : 
; 1706 :     bool is_duplicate = merge_candidate_in_list(info.merge_cand, cur_cand,
; 1707 :       mrg_cands, 
; 1708 :       num_rdo_cands);
; 1709 : 
; 1710 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1711 :     // Don't add duplicates to list
; 1712 :     if (!fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]) ||
; 1713 :         !fracmv_within_tile(&info, cur_cu->inter.mv[1][0], cur_cu->inter.mv[1][1]) ||

	mov	DWORD PTR y$1$[rbp-256], r10d

; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN481@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN481@search_pu_:
	test	eax, eax
	jne	SHORT $LN145@search_pu_
	mov	eax, r10d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN480@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN480@search_pu_:
	test	eax, eax
	jne	SHORT $LN145@search_pu_
	xor	sil, sil
	jmp	SHORT $LN146@search_pu_
$LN145@search_pu_:
	mov	sil, 1
$LN146@search_pu_:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, ecx
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN479@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN479@search_pu_:
	test	eax, eax
	jne	SHORT $LN147@search_pu_
	mov	eax, r10d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN478@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN478@search_pu_:
	test	eax, eax
	jne	SHORT $LN147@search_pu_
	xor	bl, bl
	jmp	SHORT $LN148@search_pu_
$LN147@search_pu_:
	mov	bl, 1
$LN148@search_pu_:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r9+172], 0
	je	$LN138@search_pu_
	cmp	DWORD PTR [r9+168], 0
	je	$LN138@search_pu_

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	sil, sil
	je	SHORT $LN131@search_pu_

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	r8d, 4
	jmp	SHORT $LN133@search_pu_
$LN131@search_pu_:

; 122  :     } else if (is_frac_chroma) {

	xor	r8d, r8d
	mov	eax, 2
	test	bl, bl
	cmovne	r8d, eax
$LN133@search_pu_:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r9+44], 0
	je	SHORT $LN134@search_pu_

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r8d, 10
	jmp	SHORT $LN136@search_pu_
$LN134@search_pu_:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r9+40], 0
	je	SHORT $LN136@search_pu_

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r8d, 8
$LN136@search_pu_:

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	r11d, DWORD PTR [r9+6536]
	mov	eax, r12d
	cdq
	and	edx, 63					; 0000003fH
	lea	edi, DWORD PTR [rdx+rax]
	mov	edx, DWORD PTR info$[rbp-216]
	add	edx, r8d
	sar	edi, 6
	add	edx, DWORD PTR info$[rbp-224]
	lea	eax, DWORD PTR [r10+rdx*4]
	cdq
	movzx	r10d, dl
	add	r10d, eax
	mov	eax, DWORD PTR info$[rbp-224]
	cdq
	sar	r10d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	r10d, eax
	cmp	r10d, r11d
	jg	$LN506@search_pu_

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR info$[rbp-220]
	movsx	eax, WORD PTR [r15+12]
	add	edx, r8d
	add	edx, r12d
	lea	eax, DWORD PTR [rax+rdx*4]
	cdq
	movzx	edx, dl
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r9+6532]
	sar	eax, 8
	add	edx, r11d
	sub	eax, edi
	add	eax, r10d
	cmp	eax, edx
	jg	$LN506@search_pu_
	mov	r10d, DWORD PTR y$1$[rbp-256]
	movsx	ecx, WORD PTR [r15+12]
	mov	edi, DWORD PTR info$[rbp-224]
$LN138@search_pu_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r9+2360]
	test	eax, eax
	je	SHORT $LN465@search_pu_

; 162  :     return true;
; 163  :   }
; 164  : 
; 165  :   // Margin as luma quater pixels.
; 166  :   int margin = 0;

	xor	edx, edx

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN143@search_pu_

; 168  :     if (is_frac_luma) {

	test	sil, sil
	je	SHORT $LN141@search_pu_

; 169  :       margin = 4 << 2;

	lea	edx, QWORD PTR [rax+12]
	jmp	SHORT $LN143@search_pu_
$LN141@search_pu_:

; 170  :     } else if (is_frac_chroma) {

	test	bl, bl
	mov	eax, 8
	cmovne	edx, eax
$LN143@search_pu_:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	lea	r9d, DWORD PTR [rcx+r12*4]
	lea	r8d, DWORD PTR [r10+rdi*4]
	cmp	r9d, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	$LN506@search_pu_
	cmp	r8d, edx
	jl	$LN506@search_pu_

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR info$[rbp-256]
	mov	rax, QWORD PTR [rax+48]
	mov	r10, QWORD PTR [rax]
	mov	eax, DWORD PTR info$[rbp-220]
	mov	ecx, DWORD PTR [r10+16]
	shl	ecx, 2
	lea	eax, DWORD PTR [rax*4]
	sub	ecx, eax
	sub	ecx, r9d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN506@search_pu_

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	eax, DWORD PTR info$[rbp-216]
	mov	ecx, DWORD PTR [r10+20]
	shl	ecx, 2
	lea	eax, DWORD PTR [rax*4]
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, edx
	jl	$LN506@search_pu_
$LN465@search_pu_:

; 1705 : 
; 1706 :     bool is_duplicate = merge_candidate_in_list(info.merge_cand, cur_cand,
; 1707 :       mrg_cands, 
; 1708 :       num_rdo_cands);
; 1709 : 
; 1710 :     // Don't try merge candidates that don't satisfy mv constraints.
; 1711 :     // Don't add duplicates to list
; 1712 :     if (!fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]) ||
; 1713 :         !fracmv_within_tile(&info, cur_cu->inter.mv[1][0], cur_cu->inter.mv[1][1]) ||

	test	r13b, r13b
	mov	r13, QWORD PTR state$[rbp-256]
	jne	$LN507@search_pu_

; 1714 :         is_duplicate)
; 1715 :     {
; 1716 :       continue;
; 1717 :     }
; 1718 : 
; 1719 :     kvz_inter_pred_pu(state, lcu, x_cu, y_cu, width_cu, true, false, i_pu);

	mov	eax, DWORD PTR i_pu$[rbp-256]
	mov	rdx, r14
	mov	r9d, DWORD PTR y_cu$[rbp-256]
	mov	rcx, r13
	mov	r8d, DWORD PTR x_cu$[rbp-256]
	mov	DWORD PTR [rsp+56], eax
	mov	eax, DWORD PTR width$1$[rbp-256]
	mov	BYTE PTR [rsp+48], 0
	mov	BYTE PTR [rsp+40], 1
	mov	DWORD PTR [rsp+32], eax
	call	kvz_inter_pred_pu

; 1720 :     mrg_costs[num_rdo_cands] = kvz_satd_any_size(width, height,

	mov	edx, DWORD PTR x_local$1$[rbp-256]
	mov	r9d, 64					; 00000040H
	mov	eax, DWORD PTR y_local$1$[rsp]
	mov	ebx, DWORD PTR height$1$[rsp]
	shl	eax, 6
	lea	rcx, QWORD PTR [rdx+392]
	mov	DWORD PTR [rsp+40], 64			; 00000040H
	add	rax, r14
	lea	r8, QWORD PTR [rdx+6540]
	add	rcx, rax
	add	r8, rax
	mov	QWORD PTR [rsp+32], rcx
	mov	edx, ebx
	mov	ecx, DWORD PTR width$1$[rsp]
	call	QWORD PTR kvz_satd_any_size
	movsxd	rdi, DWORD PTR num_rdo_cands$2$[rbp-256]
	xorps	xmm1, xmm1

; 1721 :       lcu->rec.y + y_local * LCU_WIDTH + x_local, LCU_WIDTH,
; 1722 :       lcu->ref.y + y_local * LCU_WIDTH + x_local, LCU_WIDTH);
; 1723 :     
; 1724 :     // Add cost of coding the merge index
; 1725 :     mrg_costs[num_rdo_cands] += merge_idx * info.state->lambda_sqrt;

	mov	ecx, DWORD PTR merge_idx$1$[rbp-256]
	mov	rdx, QWORD PTR info$[rbp-256]
	mov	r12d, DWORD PTR info$[rbp-228]
	mov	eax, eax
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0

; 1726 : 
; 1727 :     mrg_cands[num_rdo_cands] = merge_idx;

	mov	BYTE PTR mrg_cands$[rsp+rdi], cl
	cvtsi2sd xmm1, rax
	mulsd	xmm0, QWORD PTR [rdx+376]
	addsd	xmm0, xmm1
	movsd	QWORD PTR mrg_costs$[rbp+rdi*8-256], xmm0

; 1728 :     num_rdo_cands++;

	inc	edi
	mov	DWORD PTR num_rdo_cands$2$[rbp-256], edi

; 154  :     if (mv_lcu.x + mv_lcu.y >

	jmp	$LN511@search_pu_
$LN420@search_pu_:

; 1766 :           cur_cu->type = CU_INTER;
; 1767 :           cur_cu->merge_idx = merge_idx;

	movzx	eax, BYTE PTR [r15+1]
	and	BYTE PTR [r15], 254			; 000000feH
	and	al, 31
	or	BYTE PTR [r15], 2
	shl	sil, 5
	or	al, sil

; 1768 :           cur_cu->skipped = true;

	or	al, 8
	mov	BYTE PTR [r15+1], al

; 1769 :           *inter_cost = 0.0;  // TODO: Check this

	mov	rax, QWORD PTR inter_cost$[rbp-256]
	mov	QWORD PTR [rax], 0

; 1770 :           *inter_bitcost = merge_idx; // TODO: Check this

	mov	rax, QWORD PTR inter_bitcost$[rbp-256]
	mov	DWORD PTR [rax], r12d

; 1771 :           return;

	jmp	$LN58@search_pu_
$LN488@search_pu_:

; 1741 :     for (int merge_rdo_idx = 0; merge_rdo_idx < num_rdo_cands; ++merge_rdo_idx) {

	mov	r12d, DWORD PTR info$[rbp-228]
$LN15@search_pu_:

; 1772 :         }
; 1773 :       }
; 1774 :     }
; 1775 :   }
; 1776 : 
; 1777 :   // AMVP search starts here
; 1778 : 
; 1779 :   // Store unipred information of L0 and L1 for biprediction
; 1780 :   // Best cost will be left at MAX_DOUBLE if no valid CU is found
; 1781 :   double best_cost_LX[2] = { MAX_DOUBLE, MAX_DOUBLE };
; 1782 :   cu_info_t unipreds[2];
; 1783 : 
; 1784 :   for (int ref_idx = 0; ref_idx < state->frame->ref->used_size; ref_idx++) {

	mov	rsi, QWORD PTR state$[rbp-256]
	xor	r13d, r13d
	movaps	xmm0, XMMWORD PTR __xmm@7fee42d130773b767fee42d130773b76
	mov	ebx, r13d
	movups	XMMWORD PTR best_cost_LX$[rbp-256], xmm0
	mov	rcx, QWORD PTR [rsi+40]
	mov	rax, QWORD PTR [rcx+40]
	cmp	DWORD PTR [rax+36], r13d
	jbe	$LN18@search_pu_
	mov	edi, r13d
	npad	9
$LL19@search_pu_:

; 1785 :     info.ref_idx = ref_idx;
; 1786 :     info.ref = state->frame->ref->images[ref_idx];
; 1787 : 
; 1788 :     search_pu_inter_ref(&info, depth, lcu, cur_cu, inter_cost, inter_bitcost, best_cost_LX, unipreds);

	mov	edx, DWORD PTR depth$[rbp-256]
	mov	r9, r15
	mov	DWORD PTR info$[rbp-232], ebx
	mov	r8, r14
	mov	rax, QWORD PTR [rcx+40]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR [rdi+rcx]
	lea	rcx, QWORD PTR info$[rbp-256]
	mov	QWORD PTR info$[rbp-240], rax
	lea	rax, QWORD PTR unipreds$[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR best_cost_LX$[rbp-256]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR inter_bitcost$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR inter_cost$[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	call	search_pu_inter_ref
	mov	rcx, QWORD PTR [rsi+40]
	lea	rdi, QWORD PTR [rdi+8]
	inc	ebx
	mov	rax, QWORD PTR [rcx+40]
	cmp	ebx, DWORD PTR [rax+36]
	jb	SHORT $LL19@search_pu_
	mov	r12d, DWORD PTR info$[rbp-228]
	movups	xmm0, XMMWORD PTR best_cost_LX$[rbp-256]
$LN18@search_pu_:

; 1789 :   }
; 1790 : 
; 1791 :   // Search bi-pred positions
; 1792 :   bool can_use_bipred = state->frame->slicetype == KVZ_SLICE_B

	cmp	DWORD PTR [rcx+88], r13d
	jne	$LN48@search_pu_
	mov	rax, QWORD PTR cfg$1$[rbp-256]
	cmp	DWORD PTR [rax+92], r13d
	je	$LN48@search_pu_
	mov	esi, DWORD PTR width$1$[rsp]
	mov	ebx, DWORD PTR height$1$[rsp]
	lea	eax, DWORD PTR [rbx+rsi]
	cmp	eax, 16
	jl	$LN48@search_pu_

; 1793 :     && cfg->bipred
; 1794 :     && width + height >= 16; // 4x8 and 8x4 PBs are restricted to unipred
; 1795 : 
; 1796 :   if (can_use_bipred) {
; 1797 : 
; 1798 :     // Try biprediction from valid acquired unipreds.
; 1799 :     if (best_cost_LX[0] != MAX_DOUBLE && best_cost_LX[1] != MAX_DOUBLE) {

	ucomisd	xmm0, xmm6
	je	$LN510@search_pu_
	movsd	xmm0, QWORD PTR best_cost_LX$[rbp-248]
	ucomisd	xmm0, xmm6
	je	$LN510@search_pu_

; 1800 : 
; 1801 :       // TODO: logic is copy paste from search_pu_inter_bipred.
; 1802 :       // Get rid of duplicate code asap.
; 1803 :       const image_list_t *const ref = info.state->frame->ref;
; 1804 :       uint8_t(*ref_LX)[16] = info.state->frame->ref_LX;
; 1805 : 
; 1806 :       inter_merge_cand_t *merge_cand = info.merge_cand;
; 1807 : 
; 1808 :       int16_t mv[2][2];
; 1809 :       mv[0][0] = unipreds[0].inter.mv[0][0];

	movzx	eax, WORD PTR unipreds$[rbp-248]
	mov	r11, QWORD PTR info$[rbp-256]

; 1810 :       mv[0][1] = unipreds[0].inter.mv[0][1];
; 1811 :       mv[1][0] = unipreds[1].inter.mv[1][0];
; 1812 :       mv[1][1] = unipreds[1].inter.mv[1][1];
; 1813 : 
; 1814 :       kvz_inter_recon_bipred(info.state,

	mov	BYTE PTR [rsp+80], r13b
	mov	BYTE PTR [rsp+72], 1
	mov	QWORD PTR [rsp+64], r14
	mov	r9, QWORD PTR [r11+40]
	mov	rcx, QWORD PTR [r9+40]
	mov	WORD PTR mv$4[rbp-256], ax
	movzx	eax, WORD PTR unipreds$[rbp-246]
	mov	WORD PTR mv$4[rbp-254], ax
	movzx	eax, WORD PTR unipreds$[rbp-224]
	mov	WORD PTR mv$4[rbp-252], ax
	movzx	eax, WORD PTR unipreds$[rbp-222]
	mov	WORD PTR mv$4[rbp-250], ax
	mov	r10, QWORD PTR [rcx]
	mov	rcx, r11
	movzx	eax, BYTE PTR unipreds$[rbp-219]
	movzx	r8d, BYTE PTR [rax+r9+65]
	movzx	eax, BYTE PTR unipreds$[rbp-240]
	mov	r8, QWORD PTR [r10+r8*8]
	movzx	edx, BYTE PTR [rax+r9+49]
	lea	rax, QWORD PTR mv$4[rbp-256]
	mov	r9d, DWORD PTR x$1$[rsp]
	mov	QWORD PTR [rsp+56], rax
	mov	eax, DWORD PTR y$1$[rsp]
	mov	rdx, QWORD PTR [r10+rdx*8]
	mov	DWORD PTR [rsp+48], ebx
	mov	DWORD PTR [rsp+40], esi
	mov	DWORD PTR [rsp+32], eax
	call	kvz_inter_recon_bipred

; 1815 :         ref->images[ref_LX[0][unipreds[0].inter.mv_ref[0]]],
; 1816 :         ref->images[ref_LX[1][unipreds[1].inter.mv_ref[1]]],
; 1817 :         x, y,
; 1818 :         width,
; 1819 :         height,
; 1820 :         mv,
; 1821 :         lcu,
; 1822 :         true,
; 1823 :         false);
; 1824 : 
; 1825 :       const kvz_pixel *rec = &lcu->rec.y[SUB_SCU(y) * LCU_WIDTH + SUB_SCU(x)];
; 1826 :       const kvz_pixel *src = &lcu->ref.y[SUB_SCU(y) * LCU_WIDTH + SUB_SCU(x)];

	mov	eax, DWORD PTR y_local$1$[rsp]
	lea	rcx, QWORD PTR [r14+392]
	shl	eax, 6
	lea	r8, QWORD PTR [r14+6540]
	add	eax, DWORD PTR x_local$1$[rbp-256]

; 1827 :       uint32_t cost =

	mov	r9d, 64					; 00000040H
	add	rcx, rax
	mov	DWORD PTR [rsp+40], 64			; 00000040H
	mov	QWORD PTR [rsp+32], rcx
	add	r8, rax
	mov	ecx, esi
	mov	edx, ebx
	call	QWORD PTR kvz_satd_any_size

; 1828 :         kvz_satd_any_size(width, height, rec, LCU_WIDTH, src, LCU_WIDTH);
; 1829 : 
; 1830 :       uint32_t bitcost[2] = { 0, 0 };
; 1831 : 
; 1832 :       cost += info.mvd_cost_func(info.state,

	movsx	r8d, WORD PTR unipreds$[rbp-246]
	xor	r9d, r9d
	movsx	edx, WORD PTR unipreds$[rbp-248]
	mov	ebx, eax
	mov	rcx, QWORD PTR info$[rbp-256]
	lea	rax, QWORD PTR bitcost$3[rbp-256]
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR info$[rbp-212]
	mov	DWORD PTR [rsp+56], r13d
	mov	WORD PTR [rsp+48], r13w
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], rax
	mov	QWORD PTR bitcost$3[rbp-256], r13
	call	QWORD PTR info$[rbp-136]

; 1833 :         unipreds[0].inter.mv[0][0],
; 1834 :         unipreds[0].inter.mv[0][1],
; 1835 :         0,
; 1836 :         info.mv_cand,
; 1837 :         NULL, 0, 0,
; 1838 :         &bitcost[0]);
; 1839 :       cost += info.mvd_cost_func(info.state,

	movsx	r8d, WORD PTR unipreds$[rbp-222]
	xor	r9d, r9d
	movsx	edx, WORD PTR unipreds$[rbp-224]
	add	ebx, eax
	mov	rcx, QWORD PTR info$[rbp-256]
	lea	rax, QWORD PTR bitcost$3[rbp-252]
	mov	QWORD PTR [rsp+64], rax
	lea	rax, QWORD PTR info$[rbp-212]
	mov	DWORD PTR [rsp+56], r13d
	mov	WORD PTR [rsp+48], r13w
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR info$[rbp-136]

; 1840 :         unipreds[1].inter.mv[1][0],
; 1841 :         unipreds[1].inter.mv[1][1],
; 1842 :         0,
; 1843 :         info.mv_cand,
; 1844 :         NULL, 0, 0,
; 1845 :         &bitcost[1]);
; 1846 : 
; 1847 :       const uint8_t mv_ref_coded[2] = {
; 1848 :         unipreds[0].inter.mv_ref[0],
; 1849 :         unipreds[1].inter.mv_ref[1]
; 1850 :       };
; 1851 :       const int extra_bits = mv_ref_coded[0] + mv_ref_coded[1] + 2 /* mv dir cost */;

	movzx	ecx, BYTE PTR unipreds$[rbp-219]
	add	ebx, eax
	movzx	eax, BYTE PTR unipreds$[rbp-240]
	add	ecx, 2
	add	eax, ecx
	mov	DWORD PTR extra_bits$1$[rbp-256], eax
	movd	xmm1, eax

; 1852 :       cost += info.state->lambda_sqrt * extra_bits + 0.5;

	mov	rax, QWORD PTR info$[rbp-256]
	cvtdq2pd xmm1, xmm1
	mulsd	xmm1, QWORD PTR [rax+376]
	addsd	xmm1, QWORD PTR __real@3fe0000000000000
	mov	eax, ebx
	xorps	xmm0, xmm0
	xorps	xmm6, xmm6
	cvtsi2sd xmm0, rax

; 1853 : 
; 1854 :       if (cost < *inter_cost) {

	mov	rax, QWORD PTR inter_cost$[rbp-256]
	addsd	xmm1, xmm0
	cvttsd2si rcx, xmm1
	mov	ecx, ecx
	cvtsi2sd xmm6, rcx
	comisd	xmm6, QWORD PTR [rax]
	jae	$LN489@search_pu_

; 1855 :         cur_cu->inter.mv_dir = 3;

	or	BYTE PTR [r15+18], 192			; 000000c0H

; 1856 : 
; 1857 :         cur_cu->inter.mv_ref[0] = unipreds[0].inter.mv_ref[0];
; 1858 :         cur_cu->inter.mv_ref[1] = unipreds[1].inter.mv_ref[1];
; 1859 : 
; 1860 :         cur_cu->inter.mv[0][0] = unipreds[0].inter.mv[0][0];
; 1861 :         cur_cu->inter.mv[0][1] = unipreds[0].inter.mv[0][1];
; 1862 :         cur_cu->inter.mv[1][0] = unipreds[1].inter.mv[1][0];
; 1863 :         cur_cu->inter.mv[1][1] = unipreds[1].inter.mv[1][1];
; 1864 :         cur_cu->merged = 0;
; 1865 : 
; 1866 :         // Check every candidate to find a match
; 1867 :         for (int merge_idx = 0; merge_idx < info.num_merge_cand; merge_idx++) {

	mov	edx, r13d
	movzx	eax, BYTE PTR unipreds$[rbp-240]
	mov	BYTE PTR [r15+16], al
	movzx	eax, BYTE PTR unipreds$[rbp-219]
	mov	BYTE PTR [r15+17], al
	movzx	eax, WORD PTR unipreds$[rbp-248]
	mov	WORD PTR [r15+8], ax
	movzx	eax, WORD PTR unipreds$[rbp-246]
	mov	WORD PTR [r15+10], ax
	movzx	eax, WORD PTR unipreds$[rbp-224]
	mov	WORD PTR [r15+12], ax
	movzx	eax, WORD PTR unipreds$[rbp-222]
	and	BYTE PTR [r15+1], 239			; 000000efH
	movzx	r9d, BYTE PTR [r15+1]
	mov	WORD PTR [r15+14], ax
	mov	r8d, DWORD PTR info$[rbp-144]
	test	r8d, r8d
	jle	SHORT $LN473@search_pu_

; 1868 :           if (merge_cand[merge_idx].mv[0][0] == cur_cu->inter.mv[0][0] &&
; 1869 :             merge_cand[merge_idx].mv[0][1] == cur_cu->inter.mv[0][1] &&
; 1870 :             merge_cand[merge_idx].mv[1][0] == cur_cu->inter.mv[1][0] &&
; 1871 :             merge_cand[merge_idx].mv[1][1] == cur_cu->inter.mv[1][1] &&
; 1872 :             merge_cand[merge_idx].ref[0] == cur_cu->inter.mv_ref[0] &&

	movzx	r10d, WORD PTR [r15+8]
	npad	14
$LL22@search_pu_:
	movsxd	rax, edx
	lea	rcx, QWORD PTR [rax+rax*2]
	cmp	WORD PTR info$[rbp+rcx*4-200], r10w
	jne	SHORT $LN20@search_pu_
	movzx	eax, WORD PTR [r15+10]
	cmp	WORD PTR info$[rbp+rcx*4-198], ax
	jne	SHORT $LN20@search_pu_
	movzx	eax, WORD PTR [r15+12]
	cmp	WORD PTR info$[rbp+rcx*4-196], ax
	jne	SHORT $LN20@search_pu_
	movzx	eax, WORD PTR [r15+14]
	cmp	WORD PTR info$[rbp+rcx*4-194], ax
	jne	SHORT $LN20@search_pu_
	movzx	eax, BYTE PTR [r15+16]
	cmp	BYTE PTR info$[rbp+rcx*4-203], al
	jne	SHORT $LN20@search_pu_
	movzx	eax, BYTE PTR [r15+17]
	cmp	BYTE PTR info$[rbp+rcx*4-202], al
	je	SHORT $LN421@search_pu_
$LN20@search_pu_:

; 1856 : 
; 1857 :         cur_cu->inter.mv_ref[0] = unipreds[0].inter.mv_ref[0];
; 1858 :         cur_cu->inter.mv_ref[1] = unipreds[1].inter.mv_ref[1];
; 1859 : 
; 1860 :         cur_cu->inter.mv[0][0] = unipreds[0].inter.mv[0][0];
; 1861 :         cur_cu->inter.mv[0][1] = unipreds[0].inter.mv[0][1];
; 1862 :         cur_cu->inter.mv[1][0] = unipreds[1].inter.mv[1][0];
; 1863 :         cur_cu->inter.mv[1][1] = unipreds[1].inter.mv[1][1];
; 1864 :         cur_cu->merged = 0;
; 1865 : 
; 1866 :         // Check every candidate to find a match
; 1867 :         for (int merge_idx = 0; merge_idx < info.num_merge_cand; merge_idx++) {

	inc	edx
	cmp	edx, r8d
	jl	SHORT $LL22@search_pu_
	jmp	SHORT $LN473@search_pu_
$LN421@search_pu_:

; 1873 :             merge_cand[merge_idx].ref[1] == cur_cu->inter.mv_ref[1])
; 1874 :           {
; 1875 :             cur_cu->merged = 1;

	or	r9b, 16

; 1876 :             cur_cu->merge_idx = merge_idx;

	shl	dl, 5
	and	r9b, 31
	or	dl, r9b
	mov	BYTE PTR [r15+1], dl
$LN473@search_pu_:

; 1877 :             break;
; 1878 :           }
; 1879 :         }
; 1880 : 
; 1881 :         // Each motion vector has its own candidate
; 1882 :         for (int reflist = 0; reflist < 2; reflist++) {

	mov	r12d, r13d
	npad	9
$LL25@search_pu_:

; 1883 :           kvz_inter_get_mv_cand(info.state, x, y, width, height, info.mv_cand, cur_cu, lcu, reflist);

	mov	rbx, QWORD PTR info$[rbp-256]
	xorps	xmm0, xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	r9d, DWORD PTR height$1$[rsp]
	xorps	xmm1, xmm1
	mov	edx, DWORD PTR y$1$[rsp]
	mov	r8d, esi
	mov	QWORD PTR merge_cand$2[rbp-208], r13
	mov	rax, QWORD PTR [rbx+48]
	mov	r13d, DWORD PTR x$1$[rsp]
	movdqu	XMMWORD PTR merge_cand$2[rbp-256], xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 1883 :           kvz_inter_get_mv_cand(info.state, x, y, width, height, info.mv_cand, cur_cu, lcu, reflist);

	mov	edi, r12d
; File F:\open_codec_learn_2021\kvazaar-master\src\inter.c

; 1342 :   merge_candidates_t merge_cand = { {0, 0}, {0, 0, 0}, 0, 0 };

	movdqu	XMMWORD PTR merge_cand$2[rbp-240], xmm1
	movdqu	XMMWORD PTR merge_cand$2[rbp-224], xmm0

; 1344 :   get_spatial_merge_candidates(x, y, width, height,

	mov	rcx, QWORD PTR [rax]
	lea	rax, QWORD PTR merge_cand$2[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], r14
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [rcx+16]
	mov	ecx, r13d
	mov	DWORD PTR [rsp+32], eax
	call	get_spatial_merge_candidates

; 1345 :                                state->tile->frame->width,
; 1346 :                                state->tile->frame->height,
; 1347 :                                lcu,
; 1348 :                                &merge_cand);
; 1349 :   get_temporal_merge_candidates(state, x, y, width, height, 1, 0, &merge_cand);

	mov	r8d, DWORD PTR y$1$[rsp]
	lea	rax, QWORD PTR merge_cand$2[rbp-256]
	mov	QWORD PTR [rsp+56], rax
	mov	r9d, esi
	mov	eax, DWORD PTR height$1$[rsp]
	mov	edx, r13d
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], eax
	call	get_temporal_merge_candidates

; 1350 :   get_mv_cand_from_candidates(state, x, y, width, height, &merge_cand, cur_cu, reflist, mv_cand);

	mov	r8d, DWORD PTR y$1$[rsp]
	lea	rax, QWORD PTR info$[rbp-212]
	mov	QWORD PTR [rsp+64], rax
	mov	r9d, esi
	mov	BYTE PTR [rsp+56], r12b
	lea	rax, QWORD PTR merge_cand$2[rbp-256]
	mov	QWORD PTR [rsp+48], r15
	mov	edx, r13d
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rbx
	mov	eax, DWORD PTR height$1$[rsp]
	mov	DWORD PTR [rsp+32], eax
	call	get_mv_cand_from_candidates
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c

; 352  :   const bool same_cand =

	movsx	r10d, WORD PTR info$[rbp-212]

; 1884 :           int cu_mv_cand = select_mv_cand(

	movsx	r8d, WORD PTR [r15+rdi*4+8]
	mov	rcx, QWORD PTR info$[rbp-256]
	movsx	r13d, WORD PTR [r15+rdi*4+10]

; 352  :   const bool same_cand =

	movsx	edx, WORD PTR info$[rbp-210]

; 1884 :           int cu_mv_cand = select_mv_cand(

	mov	DWORD PTR mv_x$1$[rbp-256], r8d
	mov	QWORD PTR state$1$[rbp-256], rcx

; 352  :   const bool same_cand =

	cmp	r10w, WORD PTR info$[rbp-208]
	jne	SHORT $LN295@search_pu_
	cmp	dx, WORD PTR info$[rbp-206]
	jne	SHORT $LN295@search_pu_

; 353  :     (mv_cand[0][0] == mv_cand[1][0] && mv_cand[0][1] == mv_cand[1][1]);
; 354  : 
; 355  :   if (same_cand && !cost_out) {
; 356  :     // Pick the first one if both candidates are the same.
; 357  :     return 0;

	xor	r13d, r13d
	mov	edx, r13d
	jmp	SHORT $LN28@search_pu_
$LN295@search_pu_:

; 358  :   }
; 359  : 
; 360  :   uint32_t (*mvd_coding_cost)(const encoder_state_t * const state,
; 361  :                               const cabac_data_t*,
; 362  :                               int32_t, int32_t);
; 363  :   if (state->encoder_control->cfg.mv_rdo) {
; 364  :     mvd_coding_cost = kvz_get_mvd_coding_cost_cabac;
; 365  :   } else {
; 366  :     mvd_coding_cost = get_mvd_coding_cost;
; 367  :   }
; 368  : 
; 369  :   uint32_t cand1_cost = mvd_coding_cost(

	mov	rax, QWORD PTR [rcx]
	lea	rdi, QWORD PTR [rcx+128]
	mov	r9d, r13d
	lea	rsi, OFFSET FLAT:kvz_get_mvd_coding_cost_cabac
	cmp	BYTE PTR [rax+2356], 0
	lea	rax, OFFSET FLAT:get_mvd_coding_cost
	cmove	rsi, rax
	sub	r9d, edx
	mov	rdx, rdi
	sub	r8d, r10d
	call	rsi

; 370  :       state, &state->cabac,
; 371  :       mv_x - mv_cand[0][0],
; 372  :       mv_y - mv_cand[0][1]);
; 373  : 
; 374  :   uint32_t cand2_cost;
; 375  :   if (same_cand) {
; 376  :     cand2_cost = cand1_cost;
; 377  :   } else {
; 378  :     cand2_cost = mvd_coding_cost(

	movsx	r10d, WORD PTR info$[rbp-206]
	mov	rdx, rdi
	mov	r8d, DWORD PTR mv_x$1$[rbp-256]
	sub	r13d, r10d
	movsx	r10d, WORD PTR info$[rbp-208]
	mov	r9d, r13d
	mov	rcx, QWORD PTR state$1$[rbp-256]
	sub	r8d, r10d
	mov	ebx, eax
	call	rsi
	mov	esi, DWORD PTR width$1$[rsp]

; 379  :       state, &state->cabac,
; 380  :       mv_x - mv_cand[1][0],
; 381  :       mv_y - mv_cand[1][1]);
; 382  :   }
; 383  : 
; 384  :   if (cost_out) {
; 385  :     *cost_out = MIN(cand1_cost, cand2_cost);
; 386  :   }
; 387  : 
; 388  :   // Pick the second candidate if it has lower cost.
; 389  :   return cand2_cost < cand1_cost ? 1 : 0;

	xor	r13d, r13d
	cmp	eax, ebx
	mov	edi, r12d
	setb	dl
$LN28@search_pu_:

; 1885 :             info.state,
; 1886 :             info.mv_cand,
; 1887 :             cur_cu->inter.mv[reflist][0],
; 1888 :             cur_cu->inter.mv[reflist][1],
; 1889 :             NULL);
; 1890 :           CU_SET_MV_CAND(cur_cu, reflist, cu_mv_cand);

	movzx	ecx, BYTE PTR [r15+18]
	test	edi, edi
	jne	SHORT $LN46@search_pu_
	and	cl, 248					; 000000f8H
	or	cl, dl
	jmp	SHORT $LN26@search_pu_
$LN46@search_pu_:
	movzx	eax, cl
	shl	dl, 3
	and	al, 199					; 000000c7H
	movzx	ecx, dl
	or	cl, al
$LN26@search_pu_:

; 1877 :             break;
; 1878 :           }
; 1879 :         }
; 1880 : 
; 1881 :         // Each motion vector has its own candidate
; 1882 :         for (int reflist = 0; reflist < 2; reflist++) {

	inc	r12d
	mov	BYTE PTR [r15+18], cl
	cmp	r12d, 2
	jl	$LL25@search_pu_

; 1891 :         }
; 1892 : 
; 1893 :         *inter_cost = cost;
; 1894 :         *inter_bitcost = bitcost[0] + bitcost[1] + extra_bits;

	mov	ecx, DWORD PTR extra_bits$1$[rbp-256]
	mov	rax, QWORD PTR inter_cost$[rbp-256]
	mov	rdx, QWORD PTR inter_bitcost$[rbp-256]
	add	ecx, DWORD PTR bitcost$3[rbp-252]
	add	ecx, DWORD PTR bitcost$3[rbp-256]
	mov	r12d, DWORD PTR info$[rbp-228]
	mov	DWORD PTR [rdx], ecx
	movsd	QWORD PTR [rax], xmm6
	jmp	SHORT $LN44@search_pu_
$LN489@search_pu_:

; 1853 : 
; 1854 :       if (cost < *inter_cost) {

	mov	r12d, DWORD PTR info$[rbp-228]
	jmp	SHORT $LN512@search_pu_
$LN510@search_pu_:

; 1895 :       }
; 1896 :     }
; 1897 : 
; 1898 :     // TODO: this probably should have a separate command line option
; 1899 :     if (cfg->rdo == 3) {

	mov	rax, QWORD PTR inter_cost$[rbp-256]
$LN512@search_pu_:
	mov	rdx, QWORD PTR inter_bitcost$[rbp-256]
$LN44@search_pu_:
	mov	rcx, QWORD PTR cfg$1$[rbp-256]
	cmp	DWORD PTR [rcx+64], 3
	jne	SHORT $LN48@search_pu_

; 1900 :       search_pu_inter_bipred(&info, depth, lcu, cur_cu, inter_cost, inter_bitcost);

	mov	QWORD PTR [rsp+40], rdx
	lea	rcx, QWORD PTR info$[rbp-256]
	mov	edx, DWORD PTR depth$[rbp-256]
	mov	r9, r15
	mov	r8, r14
	mov	QWORD PTR [rsp+32], rax
	call	search_pu_inter_bipred
	mov	r12d, DWORD PTR info$[rbp-228]
$LN48@search_pu_:

; 1901 :     }
; 1902 :   }
; 1903 : 
; 1904 :   // Compare best merge cost to amvp cost
; 1905 :   if (mrg_costs[0] < *inter_cost) {

	mov	rax, QWORD PTR inter_cost$[rbp-256]
	movsd	xmm0, QWORD PTR [rax]
	comisd	xmm7, xmm0
	jae	$LN471@search_pu_

; 1906 :     *inter_cost = mrg_costs[0];
; 1907 :     *inter_bitcost = 0; // TODO: Check this
; 1908 :     int merge_idx = mrg_cands[0];
; 1909 :     cur_cu->type = CU_INTER;

	and	BYTE PTR [r15], 254			; 000000feH

; 1910 :     cur_cu->merge_idx = merge_idx;
; 1911 :     cur_cu->inter.mv_dir = info.merge_cand[merge_idx].dir;
; 1912 :     cur_cu->inter.mv_ref[0] = info.merge_cand[merge_idx].ref[0];
; 1913 :     cur_cu->inter.mv_ref[1] = info.merge_cand[merge_idx].ref[1];
; 1914 :     cur_cu->inter.mv[0][0] = info.merge_cand[merge_idx].mv[0][0];
; 1915 :     cur_cu->inter.mv[0][1] = info.merge_cand[merge_idx].mv[0][1];
; 1916 :     cur_cu->inter.mv[1][0] = info.merge_cand[merge_idx].mv[1][0];
; 1917 :     cur_cu->inter.mv[1][1] = info.merge_cand[merge_idx].mv[1][1];
; 1918 :     cur_cu->merged = true;
; 1919 :     cur_cu->skipped = false;

	movaps	xmm0, xmm7
	or	BYTE PTR [r15], 2
	movzx	r8d, BYTE PTR [r15+1]
	movsx	rcx, BYTE PTR mrg_cands$[rsp]
	and	r8b, 31
	movsd	QWORD PTR [rax], xmm7
	mov	rax, QWORD PTR inter_bitcost$[rbp-256]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	mov	DWORD PTR [rax], r13d
	movzx	eax, cl
	shl	al, 5
	or	r8b, al
	movzx	eax, BYTE PTR [r15+18]
	mov	BYTE PTR [r15+1], r8b
	and	al, 63					; 0000003fH
	movzx	ecx, BYTE PTR info$[rbp+rdx*4-204]
	or	r8b, 16
	shl	cl, 6
	or	cl, al
	mov	BYTE PTR [r15+18], cl
	and	r8b, 247				; 000000f7H
	movzx	eax, BYTE PTR info$[rbp+rdx*4-203]
	mov	BYTE PTR [r15+16], al
	movzx	eax, BYTE PTR info$[rbp+rdx*4-202]
	mov	BYTE PTR [r15+17], al
	movzx	eax, WORD PTR info$[rbp+rdx*4-200]
	mov	WORD PTR [r15+8], ax
	movzx	eax, WORD PTR info$[rbp+rdx*4-198]
	mov	WORD PTR [r15+10], ax
	movzx	eax, WORD PTR info$[rbp+rdx*4-196]
	mov	WORD PTR [r15+12], ax
	movzx	eax, WORD PTR info$[rbp+rdx*4-194]
	mov	WORD PTR [r15+14], ax
	mov	BYTE PTR [r15+1], r8b
	mov	r12d, DWORD PTR info$[rbp-228]
$LN471@search_pu_:

; 1920 :   }
; 1921 : 
; 1922 :   if (*inter_cost < INT_MAX && cur_cu->inter.mv_dir == 1) {

	comisd	xmm0, QWORD PTR __real@41dfffffffc00000
	jae	$LN58@search_pu_
	movzx	eax, BYTE PTR [r15+18]
	and	al, 192					; 000000c0H
	cmp	al, 64					; 00000040H
	jne	$LN58@search_pu_

; 1923 :     assert(fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]));

	movsx	r9d, WORD PTR [r15+8]

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	rcx, QWORD PTR info$[rbp-256]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	mov	eax, r9d

; 1923 :     assert(fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]));

	movsx	r10d, WORD PTR [r15+10]

; 108  :   const encoder_control_t *ctrl = info->state->encoder_control;

	mov	r8, QWORD PTR [rcx]

; 109  : 
; 110  :   const bool is_frac_luma   = x % 4 != 0 || y % 4 != 0;

	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN477@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN477@search_pu_:
	test	eax, eax
	jne	SHORT $LN403@search_pu_
	mov	eax, r10d
	and	eax, -2147483645			; ffffffff80000003H
	jge	SHORT $LN476@search_pu_
	dec	eax
	or	eax, -4
	inc	eax
$LN476@search_pu_:
	test	eax, eax
	jne	SHORT $LN403@search_pu_
	xor	dil, dil
	jmp	SHORT $LN404@search_pu_
$LN403@search_pu_:
	mov	dil, 1
$LN404@search_pu_:

; 111  :   const bool is_frac_chroma = x % 8 != 0 || y % 8 != 0;

	mov	eax, r9d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN475@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN475@search_pu_:
	test	eax, eax
	jne	SHORT $LN405@search_pu_
	mov	eax, r10d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN474@search_pu_
	dec	eax
	or	eax, -8
	inc	eax
$LN474@search_pu_:
	test	eax, eax
	jne	SHORT $LN405@search_pu_
	xor	bl, bl
	jmp	SHORT $LN406@search_pu_
$LN405@search_pu_:
	mov	bl, 1
$LN406@search_pu_:

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	cmp	DWORD PTR [r8+172], 0
	je	$LN492@search_pu_
	cmp	DWORD PTR [r8+168], 0
	je	$LN492@search_pu_

; 114  :     // Check that the block does not reference pixels that are not final.
; 115  : 
; 116  :     // Margin as luma pixels.
; 117  :     int margin = 0;
; 118  :     if (is_frac_luma) {

	test	dil, dil
	je	SHORT $LN389@search_pu_

; 119  :       // Fractional motion estimation needs up to 4 pixels outside the
; 120  :       // block.
; 121  :       margin = 4;

	mov	r11d, 4
	jmp	SHORT $LN391@search_pu_
$LN389@search_pu_:

; 122  :     } else if (is_frac_chroma) {

	test	bl, bl
	mov	r11d, r13d
	mov	eax, 2
	cmovne	r11d, eax
	mov	DWORD PTR margin$2$[rsp], r11d
$LN391@search_pu_:

; 123  :       // Odd chroma interpolation needs up to 2 luma pixels outside the
; 124  :       // block.
; 125  :       margin = 2;
; 126  :     }
; 127  : 
; 128  :     if (ctrl->cfg.sao_type) {

	cmp	DWORD PTR [r8+44], 0
	je	SHORT $LN392@search_pu_

; 129  :       // Make sure we don't refer to pixels for which SAO reconstruction
; 130  :       // has not been done.
; 131  :       margin += SAO_DELAY_PX;

	add	r11d, 10
	jmp	SHORT $LN513@search_pu_
$LN392@search_pu_:

; 132  :     } else if (ctrl->cfg.deblock_enable) {

	cmp	DWORD PTR [r8+40], 0
	je	SHORT $LN394@search_pu_

; 133  :       // Make sure we don't refer to pixels that have not been deblocked.
; 134  :       margin += DEBLOCK_DELAY_PX;

	add	r11d, 8
$LN513@search_pu_:

; 135  :     }
; 136  : 
; 137  :     // Coordinates of the top-left corner of the containing LCU.
; 138  :     const vector2d_t orig_lcu = {

	mov	DWORD PTR margin$2$[rsp], r11d
$LN394@search_pu_:

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	r15d, DWORD PTR info$[rbp-224]
	mov	eax, r12d

; 146  :       ((info->origin.x + info->width  + margin) * 4 + x) / (LCU_WIDTH << 2) - orig_lcu.x,
; 147  :       ((info->origin.y + info->height + margin) * 4 + y) / (LCU_WIDTH << 2) - orig_lcu.y,
; 148  :     };
; 149  : 
; 150  :     if (mv_lcu.y > ctrl->max_inter_ref_lcu.down) {

	mov	esi, DWORD PTR [r8+6536]
	cdq
	and	edx, 63					; 0000003fH
	lea	r14d, DWORD PTR [rdx+rax]
	mov	edx, DWORD PTR info$[rbp-216]
	add	edx, r11d
	sar	r14d, 6
	add	edx, r15d
	lea	eax, DWORD PTR [r10+rdx*4]
	cdq
	movzx	r11d, dl
	add	r11d, eax
	mov	eax, r15d
	cdq
	sar	r11d, 8
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	sub	r11d, eax
	cmp	r11d, esi
	jg	$LN407@search_pu_

; 139  :       .x = info->origin.x / LCU_WIDTH,
; 140  :       .y = info->origin.y / LCU_WIDTH,
; 141  :     };
; 142  :     // Difference between the coordinates of the LCU containing the
; 143  :     // bottom-left corner of the referenced block and the LCU containing
; 144  :     // this block.
; 145  :     const vector2d_t mv_lcu = {

	mov	edx, DWORD PTR margin$2$[rsp]
	add	edx, DWORD PTR info$[rbp-220]
	add	edx, r12d
	lea	eax, DWORD PTR [r9+rdx*4]
	cdq
	movzx	edx, dl
	add	eax, edx

; 151  :       return false;
; 152  :     }
; 153  : 
; 154  :     if (mv_lcu.x + mv_lcu.y >

	mov	edx, DWORD PTR [r8+6532]
	sar	eax, 8
	add	edx, esi
	sub	eax, r14d
	add	eax, r11d
	cmp	eax, edx
	jg	$LN407@search_pu_

; 112  : 
; 113  :   if (ctrl->cfg.owf && ctrl->cfg.wpp) {

	mov	rcx, QWORD PTR info$[rbp-256]
$LN396@search_pu_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	eax, DWORD PTR [r8+2360]
	test	eax, eax
	je	$LN58@search_pu_

; 167  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_FRAME_AND_TILE_MARGIN) {

	cmp	eax, 4
	jne	SHORT $LN401@search_pu_

; 168  :     if (is_frac_luma) {

	test	dil, dil
	je	SHORT $LN399@search_pu_

; 169  :       margin = 4 << 2;

	lea	r13d, QWORD PTR [rax+12]
	jmp	SHORT $LN401@search_pu_
$LN492@search_pu_:

; 155  :         ctrl->max_inter_ref_lcu.down + ctrl->max_inter_ref_lcu.right)
; 156  :     {
; 157  :       return false;
; 158  :     }
; 159  :   }
; 160  : 
; 161  :   if (ctrl->cfg.mv_constraint == KVZ_MV_CONSTRAIN_NONE) {

	mov	r15d, DWORD PTR info$[rbp-224]
	jmp	SHORT $LN396@search_pu_
$LN399@search_pu_:

; 170  :     } else if (is_frac_chroma) {

	test	bl, bl
	mov	eax, 8
	cmovne	r13d, eax
$LN401@search_pu_:

; 171  :       margin = 2 << 2;
; 172  :     }
; 173  :   }
; 174  : 
; 175  :   // TODO implement KVZ_MV_CONSTRAIN_FRAM and KVZ_MV_CONSTRAIN_TILE.
; 176  :   const vector2d_t abs_mv = {

	lea	r8d, DWORD PTR [r9+r12*4]
	lea	edx, DWORD PTR [r10+r15*4]
	cmp	r8d, r13d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	jl	SHORT $LN407@search_pu_
	cmp	edx, r13d
	jl	SHORT $LN407@search_pu_

; 177  :     info->origin.x * 4 + x,
; 178  :     info->origin.y * 4 + y,
; 179  :   };
; 180  : 
; 181  :   // Check that both margin constraints are satisfied.
; 182  :   const int from_right  =

	mov	rax, QWORD PTR [rcx+48]
	mov	r9, QWORD PTR [rax]
	mov	eax, DWORD PTR info$[rbp-220]
	mov	ecx, DWORD PTR [r9+16]
	shl	ecx, 2
	lea	eax, DWORD PTR [rax*4]
	sub	ecx, eax
	sub	ecx, r8d

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, r13d
	jl	SHORT $LN407@search_pu_

; 183  :     (info->state->tile->frame->width  << 2) - (abs_mv.x + (info->width  << 2));
; 184  :   const int from_bottom =

	mov	eax, DWORD PTR info$[rbp-216]
	mov	ecx, DWORD PTR [r9+20]
	shl	ecx, 2
	lea	eax, DWORD PTR [rax*4]
	sub	ecx, eax
	sub	ecx, edx

; 185  :     (info->state->tile->frame->height << 2) - (abs_mv.y + (info->height << 2));
; 186  : 
; 187  :   return abs_mv.x >= margin &&

	cmp	ecx, r13d
	jge	SHORT $LN58@search_pu_
$LN407@search_pu_:

; 1923 :     assert(fracmv_within_tile(&info, cur_cu->inter.mv[0][0], cur_cu->inter.mv[0][1]));

	mov	r8d, 1923				; 00000783H
	lea	rdx, OFFSET FLAT:$SG4294942469
	lea	rcx, OFFSET FLAT:$SG4294942468
	call	QWORD PTR __imp__wassert
$LN58@search_pu_:

; 1924 :   }
; 1925 : }

	movaps	xmm6, XMMWORD PTR [rsp+464]
	movaps	xmm7, XMMWORD PTR [rsp+448]
	add	rsp, 488				; 000001e8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
search_pu_inter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\search_inter.c
_TEXT	SEGMENT
state$ = 128
x$ = 136
y$ = 144
depth$ = 152
lcu$ = 160
inter_cost$ = 168
inter_bitcost$ = 176
kvz_cu_cost_inter_rd2 PROC

; 1950 :   uint32_t *inter_bitcost){

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H

; 1951 : 
; 1952 :   cu_info_t *cur_cu = LCU_GET_CU_AT_PX(lcu, SUB_SCU(x), SUB_SCU(y));

	mov	r12, QWORD PTR lcu$[rsp]
	mov	rsi, rcx
	mov	eax, r8d

; 1953 :   int tr_depth = MAX(1, depth);

	mov	ecx, r9d
	sar	eax, 2
	mov	ebp, r9d
	and	eax, 15
	mov	r14d, r8d
	imul	r10d, eax, 17
	mov	r15d, edx
	mov	eax, edx
	sar	eax, 2
	and	eax, 15
	add	r10d, eax
	mov	eax, r10d
	lea	r13, QWORD PTR [r10*4+6334]
	add	r13, rax
	mov	eax, 1
	cmp	r9d, eax
	cmovl	ecx, eax

; 1954 :   if (cur_cu->part_size != SIZE_2Nx2N) {
; 1955 :     tr_depth = depth + 1;
; 1956 :   }
; 1957 :   kvz_lcu_fill_trdepth(lcu, x, y, depth, tr_depth);

	lea	eax, DWORD PTR [r9+1]
	cmp	BYTE PTR [r12+r13*4], 32		; 00000020H
	lea	r13, QWORD PTR [r12+r13*4]
	cmovb	eax, ecx
	mov	rcx, r12
	mov	DWORD PTR [rsp+32], eax
	call	kvz_lcu_fill_trdepth

; 1958 : 
; 1959 :   const bool reconstruct_chroma = state->encoder_control->chroma_format != KVZ_CSP_400;

	mov	rdx, QWORD PTR [rsi]

; 1960 :   kvz_inter_recon_cu(state, lcu, x, y, CU_WIDTH_FROM_DEPTH(depth), true, reconstruct_chroma);

	mov	eax, 64					; 00000040H
	mov	ecx, ebp
	mov	r9d, r14d
	mov	r8d, r15d
	mov	edi, DWORD PTR [rdx+2596]
	test	edi, edi
	mov	rdx, r12
	setne	bl
	sar	eax, cl
	mov	BYTE PTR [rsp+48], bl
	mov	rcx, rsi
	mov	BYTE PTR [rsp+40], 1
	mov	DWORD PTR [rsp+32], eax
	call	kvz_inter_recon_cu

; 1961 :   kvz_quantize_lcu_residual(state, true, reconstruct_chroma,

	mov	BYTE PTR [rsp+64], 0
	mov	r9d, r15d
	mov	QWORD PTR [rsp+56], r12
	movzx	r8d, bl
	mov	QWORD PTR [rsp+48], 0
	mov	dl, 1
	mov	BYTE PTR [rsp+40], bpl
	mov	rcx, rsi
	mov	DWORD PTR [rsp+32], r14d
	call	kvz_quantize_lcu_residual

; 1962 :     x, y, depth,
; 1963 :     NULL,
; 1964 :     lcu,
; 1965 :     false);
; 1966 : 
; 1967 :   *inter_cost = kvz_cu_rd_cost_luma(state, SUB_SCU(x), SUB_SCU(y), depth, cur_cu, lcu);

	and	r14d, 63				; 0000003fH
	mov	QWORD PTR [rsp+40], r12
	and	r15d, 63				; 0000003fH
	mov	QWORD PTR [rsp+32], r13
	mov	r8d, r14d
	mov	edx, r15d
	mov	r9d, ebp
	mov	rcx, rsi
	call	kvz_cu_rd_cost_luma
	mov	rbx, QWORD PTR inter_cost$[rsp]
	movaps	xmm1, xmm0
	movsd	QWORD PTR [rbx], xmm0

; 1968 :   if (reconstruct_chroma) {

	test	edi, edi
	je	SHORT $LN5@kvz_cu_cos

; 1969 :     *inter_cost += kvz_cu_rd_cost_chroma(state, SUB_SCU(x), SUB_SCU(y), depth, cur_cu, lcu);

	mov	QWORD PTR [rsp+40], r12
	mov	r9d, ebp
	mov	r8d, r14d
	mov	QWORD PTR [rsp+32], r13
	mov	edx, r15d
	mov	rcx, rsi
	call	kvz_cu_rd_cost_chroma
	movaps	xmm1, xmm0
	addsd	xmm1, QWORD PTR [rbx]
$LN5@kvz_cu_cos:

; 1970 :   }
; 1971 : 
; 1972 :   *inter_cost += *inter_bitcost * state->lambda;

	mov	rax, QWORD PTR inter_bitcost$[rsp]

; 1973 : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [r11+56]
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR [rax]
	cvtsi2sd xmm0, rcx
	mulsd	xmm0, QWORD PTR [rsi+368]
	mov	rsi, QWORD PTR [r11+64]
	addsd	xmm0, xmm1
	movsd	QWORD PTR [rbx], xmm0
	mov	rbx, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
kvz_cu_cost_inter_rd2 ENDP
_TEXT	ENDS
END
