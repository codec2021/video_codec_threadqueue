; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
PUBLIC	printf
PUBLIC	kvz_encoder_state_finalize
PUBLIC	kvz_encoder_state_init
pdata	SEGMENT
$pdata$encoder_state_config_slice_init DD imagerel encoder_state_config_slice_init
	DD	imagerel encoder_state_config_slice_init+202
	DD	imagerel $unwind$encoder_state_config_slice_init
$pdata$encoder_state_config_tile_finalize DD imagerel encoder_state_config_tile_finalize
	DD	imagerel encoder_state_config_tile_finalize+30
	DD	imagerel $unwind$encoder_state_config_tile_finalize
$pdata$2$encoder_state_config_tile_finalize DD imagerel encoder_state_config_tile_finalize+30
	DD	imagerel encoder_state_config_tile_finalize+648
	DD	imagerel $chain$2$encoder_state_config_tile_finalize
$pdata$3$encoder_state_config_tile_finalize DD imagerel encoder_state_config_tile_finalize+648
	DD	imagerel encoder_state_config_tile_finalize+659
	DD	imagerel $chain$3$encoder_state_config_tile_finalize
$pdata$encoder_state_config_tile_init DD imagerel encoder_state_config_tile_init
	DD	imagerel encoder_state_config_tile_init+745
	DD	imagerel $unwind$encoder_state_config_tile_init
$pdata$encoder_state_config_frame_finalize DD imagerel encoder_state_config_frame_finalize
	DD	imagerel encoder_state_config_frame_finalize+26
	DD	imagerel $unwind$encoder_state_config_frame_finalize
$pdata$0$encoder_state_config_frame_finalize DD imagerel encoder_state_config_frame_finalize+26
	DD	imagerel encoder_state_config_frame_finalize+220
	DD	imagerel $chain$0$encoder_state_config_frame_finalize
$pdata$1$encoder_state_config_frame_finalize DD imagerel encoder_state_config_frame_finalize+220
	DD	imagerel encoder_state_config_frame_finalize+231
	DD	imagerel $chain$1$encoder_state_config_frame_finalize
$pdata$encoder_state_config_frame_init DD imagerel encoder_state_config_frame_init
	DD	imagerel encoder_state_config_frame_init+655
	DD	imagerel $unwind$encoder_state_config_frame_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$kvz_encoder_state_finalize DD imagerel $LN116
	DD	imagerel $LN116+10
	DD	imagerel $unwind$kvz_encoder_state_finalize
$pdata$1$kvz_encoder_state_finalize DD imagerel $LN116+10
	DD	imagerel $LN116+544
	DD	imagerel $chain$1$kvz_encoder_state_finalize
$pdata$2$kvz_encoder_state_finalize DD imagerel $LN116+544
	DD	imagerel $LN116+610
	DD	imagerel $chain$2$kvz_encoder_state_finalize
$pdata$kvz_encoder_state_init DD imagerel $LN504
	DD	imagerel $LN504+526
	DD	imagerel $unwind$kvz_encoder_state_init
$pdata$3$kvz_encoder_state_init DD imagerel $LN504+526
	DD	imagerel $LN504+4918
	DD	imagerel $chain$3$kvz_encoder_state_init
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
xdata	SEGMENT
$unwind$encoder_state_config_slice_init DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$encoder_state_config_tile_finalize DD 040a01H
	DD	09340aH
	DD	07006320aH
$chain$2$encoder_state_config_tile_finalize DD 060f21H
	DD	08e40fH
	DD	07640aH
	DD	065405H
	DD	imagerel encoder_state_config_tile_finalize
	DD	imagerel encoder_state_config_tile_finalize+30
	DD	imagerel $unwind$encoder_state_config_tile_finalize
$chain$3$encoder_state_config_tile_finalize DD 021H
	DD	imagerel encoder_state_config_tile_finalize
	DD	imagerel encoder_state_config_tile_finalize+30
	DD	imagerel $unwind$encoder_state_config_tile_finalize
$unwind$encoder_state_config_tile_init DD 0c1c01H
	DD	010641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
$unwind$encoder_state_config_frame_finalize DD 040a01H
	DD	07340aH
	DD	07006320aH
$chain$0$encoder_state_config_frame_finalize DD 020521H
	DD	066405H
	DD	imagerel encoder_state_config_frame_finalize
	DD	imagerel encoder_state_config_frame_finalize+26
	DD	imagerel $unwind$encoder_state_config_frame_finalize
$chain$1$encoder_state_config_frame_finalize DD 021H
	DD	imagerel encoder_state_config_frame_finalize
	DD	imagerel encoder_state_config_frame_finalize+26
	DD	imagerel $unwind$encoder_state_config_frame_finalize
$unwind$encoder_state_config_frame_init DD 0ac901H
	DD	0774c9H
	DD	0654c4H
	DD	096410H
	DD	083410H
	DD	0e00c3210H
$unwind$kvz_encoder_state_finalize DD 040a01H
	DD	08340aH
	DD	07006320aH
$chain$1$kvz_encoder_state_finalize DD 041321H
	DD	076413H
	DD	065405H
	DD	imagerel $LN116
	DD	imagerel $LN116+10
	DD	imagerel $unwind$kvz_encoder_state_finalize
$chain$2$kvz_encoder_state_finalize DD 021H
	DD	imagerel $LN116
	DD	imagerel $LN116+10
	DD	imagerel $unwind$kvz_encoder_state_finalize
$unwind$kvz_encoder_state_init DD 060c01H
	DD	013010cH
	DD	060047005H
	DD	030025003H
$chain$3$kvz_encoder_state_init DD 082221H
	DD	0ff422H
	DD	010e41dH
	DD	011d415H
	DD	012c408H
	DD	imagerel $LN504
	DD	imagerel $LN504+526
	DD	imagerel $unwind$kvz_encoder_state_init
	ORG $+1
$SG4294953162 DB '0', 00H, 00H, 00H
	ORG $+2
$SG4294953139 DB 'Slice %d ends after tile %d, in which it should be incl'
	DB	'uded!', 0aH, 00H
	ORG $+2
$SG4294953140 DB 'Slice %d starts before tile %d, in which it should be i'
	DB	'ncluded!', 0aH, 00H
	ORG $+7
$SG4294953141 DB 'Tile %d ends after slice %d, in which it should be incl'
	DB	'uded!', 0aH, 00H
	ORG $+2
$SG4294953164 DB 'Invalid encoder_state->type %d!', 0aH, 00H
	ORG $+7
$SG4294953142 DB 'Tile %d starts before slice %d, in which it should be i'
	DB	'ncluded!', 0aH, 00H
	ORG $+7
$SG4294953149 DB 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '_', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'l', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'o', 00H, 'r', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294953165 DB 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '_', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'p', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	00H, 00H
$SG4294953143 DB 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '_', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'l', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'o', 00H, 'r', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, '[', 00H, 'i', 00H, ']', 00H, '.'
	DB	00H, 'l', 00H, 'e', 00H, 'f', 00H, 't', 00H, '-', 00H, '>', 00H
	DB	'p', 00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, '.', 00H, 'x', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'l', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'o', 00H, 'r'
	DB	00H, 'd', 00H, 'e', 00H, 'r', 00H, '[', 00H, 'i', 00H, ']', 00H
	DB	'.', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, '.', 00H, 'x', 00H, ' ', 00H, '-', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H
	ORG $+2
$SG4294953144 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953145 DB 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '_', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'l', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'o', 00H, 'r', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, '[', 00H, 'i', 00H, ']', 00H, '.'
	DB	00H, 'a', 00H, 'b', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG4294953146 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953147 DB 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '_', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'p', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	'-', 00H, '>', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, '[', 00H, 'j', 00H, ']', 00H
	DB	'.', 00H, 'l', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'o', 00H, 'r'
	DB	00H, 'd', 00H, 'e', 00H, 'r', 00H, '[', 00H, 'k', 00H, ']', 00H
	DB	'.', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, '.', 00H, 'y', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd'
	DB	00H, '_', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 'l', 00H, 'c', 00H, 'u', 00H, '_', 00H, 'o'
	DB	00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '[', 00H, 'i', 00H
	DB	']', 00H, '.', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'i', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'y', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, '1', 00H, 00H, 00H
	ORG $+6
$SG4294953148 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953150 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953151 DB 'Unable to init child...', 0aH, 00H
	ORG $+7
$SG4294953152 DB 'Could not initialize encoder_state->wfrow!', 0aH, 00H
	ORG $+4
$SG4294953153 DB 'Invalid: first CTB in slice %d is not at the tile %d ed'
	DB	'ge, and the slice spans on more than one row.', 0aH, 00H
	ORG $+2
$SG4294953167 DB 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '_', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'p', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	00H, 00H
$SG4294953156 DB '!', 00H, '(', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H
	DB	'd', 00H, 'r', 00H, 'e', 00H, 'n', 00H, '_', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'w', 00H, '_', 00H, 's', 00H, 'l', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '|', 00H, '|', 00H, ' '
	DB	00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, 'r', 00H
	DB	'e', 00H, 'n', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'w', 00H, '_', 00H, 't', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	')', 00H, 00H, 00H
	ORG $+2
$SG4294953157 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953158 DB 'Unable to init child...', 0aH, 00H
	ORG $+7
$SG4294953159 DB 'Failed to allocate memory for children...', 0aH, 00H
	ORG $+5
$SG4294953160 DB 'Could not initialize encoder_state->tile!', 0aH, 00H
	ORG $+5
$SG4294953161 DB 'Could not initialize encoder_state->slice!', 0aH, 00H
	ORG $+4
$SG4294953163 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953166 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953168 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953169 DB 'Could not initialize encoder_state->wfrow!', 0aH, 00H
	ORG $+4
$SG4294953170 DB 'Could not initialize encoder_state->slice!', 0aH, 00H
	ORG $+4
$SG4294953171 DB 'Could not initialize encoder_state->tile!', 0aH, 00H
	ORG $+5
$SG4294953172 DB 'Could not initialize encoder_state->frame!', 0aH, 00H
	ORG $+4
$SG4294953173 DB 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '_', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H, '>'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r'
	DB	00H, 'o', 00H, 'l', 00H, 00H, 00H
	ORG $+6
$SG4294953174 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953175 DB 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 's', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'e', 00H, '-'
	DB	00H, '>', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, '-', 00H, '1', 00H, 00H, 00H
	ORG $+2
$SG4294953176 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '_', 00H, 'd'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H
$SG4294953177 DB 'Error allocating wf_jobs array!', 0aH, 00H
	ORG $+7
$SG4294953178 DB 'Error allocating videoframe!', 0dH, 0aH, 00H
	ORG $+1
$SG4294953179 DB 'Failed to allocate the picture list!', 0aH, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\constraint.c
; File F:\open_codec_learn_2021\kvazaar-master\src\ml_intra_cu_depth_pred.c
; File F:\open_codec_learn_2021\kvazaar-master\src\constraint.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
_TEXT	SEGMENT
start_in_ts$1$ = 64
children_allow_tile$1$ = 68
end_in_ts$1$ = 72
tv5806 = 80
encoder$1$ = 88
$T1 = 96
new_child$1$ = 104
tv5785 = 192
range_end_tile$1$ = 192
child_state$ = 192
tv5926 = 200
children_allow_wavefront_row$1$ = 200
parent_state$ = 200
children_allow_slice$1$ = 208
child_count$1$ = 216
kvz_encoder_state_init PROC

; 342  : int kvz_encoder_state_init(encoder_state_t * const child_state, encoder_state_t * const parent_state) {

$LN504:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H
	mov	rbx, rcx

; 343  :   //We require that, if parent_state is NULL:
; 344  :   //child_state->encoder_control is set
; 345  :   //
; 346  :   //If parent_state is not NULL, the following variable should either be set to NULL,
; 347  :   //in order to inherit from parent, or should point to a valid structure:
; 348  :   //child_state->frame
; 349  :   //child_state->tile
; 350  :   //child_state->slice
; 351  :   //child_state->wfrow
; 352  :   
; 353  :   child_state->parent = parent_state;

	mov	QWORD PTR [rcx+24], rdx

; 354  :   child_state->children = MALLOC(encoder_state_t, 1);

	mov	ecx, 424				; 000001a8H
	mov	rdi, rdx
	call	QWORD PTR __imp_malloc

; 355  :   child_state->children[0].encoder_control = NULL;

	xor	ebp, ebp
	mov	QWORD PTR [rbx+16], rax
	mov	QWORD PTR [rax], rbp

; 356  :   child_state->crypto_hdl = NULL;

	mov	QWORD PTR [rbx+352], rbp

; 357  :   child_state->must_code_qp_delta = false;

	mov	BYTE PTR [rbx+385], bpl

; 358  :   child_state->tqj_bitstream_written = NULL;

	mov	QWORD PTR [rbx+408], rbp

; 359  :   child_state->tqj_recon_done = NULL;

	mov	QWORD PTR [rbx+400], rbp

; 360  :   
; 361  :   if (!parent_state) {

	test	rdi, rdi
	jne	$LN34@kvz_encode

; 362  :     const encoder_control_t * const encoder = child_state->encoder_control;

	mov	rdi, QWORD PTR [rbx]

; 363  :     child_state->type = ENCODER_STATE_TYPE_MAIN;

	mov	DWORD PTR [rbx+8], 77			; 0000004dH

; 364  :     assert(child_state->encoder_control);

	test	rdi, rdi
	jne	SHORT $LN93@kvz_encode
	mov	r8d, 364				; 0000016cH
	lea	rdx, OFFSET FLAT:$SG4294953174
	lea	rcx, OFFSET FLAT:$SG4294953173
	call	QWORD PTR __imp__wassert
$LN93@kvz_encode:

; 365  :     child_state->frame = MALLOC(encoder_state_config_frame_t, 1);

	mov	ecx, 248				; 000000f8H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+40], rax

; 366  :     if (!child_state->frame || !encoder_state_config_frame_init(child_state)) {

	test	rax, rax
	je	$LN37@kvz_encode
	mov	rcx, rbx
	call	encoder_state_config_frame_init
	test	eax, eax
	je	$LN37@kvz_encode

; 369  :     }
; 370  :     child_state->tile = MALLOC(encoder_state_config_tile_t, 1);

	mov	ecx, 72					; 00000048H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+48], rax

; 371  :     if (!child_state->tile || !encoder_state_config_tile_init(child_state, 0, 0, encoder->in.width, encoder->in.height, encoder->in.width_in_lcu, encoder->in.height_in_lcu)) {

	test	rax, rax
	je	$LN39@kvz_encode
	mov	eax, DWORD PTR [rdi+2532]
	xor	r8d, r8d
	mov	r9d, DWORD PTR [rdi+2528]
	xor	edx, edx
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], eax
	call	encoder_state_config_tile_init
	test	eax, eax
	je	$LN39@kvz_encode

; 374  :     }
; 375  : 
; 376  :     child_state->slice = MALLOC(encoder_state_config_slice_t, 1);

	mov	ecx, 20
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+56], rax

; 377  :     if (!child_state->slice || !encoder_state_config_slice_init(child_state, 0, encoder->in.width_in_lcu * encoder->in.height_in_lcu - 1)) {

	test	rax, rax
	je	SHORT $LN41@kvz_encode
	mov	r8d, DWORD PTR [rdi+2540]
	xor	edx, edx
	imul	r8d, DWORD PTR [rdi+2536]
	mov	rcx, rbx
	dec	r8d
	call	encoder_state_config_slice_init
	test	eax, eax
	je	SHORT $LN41@kvz_encode

; 380  :     }
; 381  :     child_state->wfrow = MALLOC(encoder_state_config_wfrow_t, 1);

	mov	ecx, 4
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+64], rax

; 382  :     if (!child_state->wfrow || !encoder_state_config_wfrow_init(child_state, 0)) {

	test	rax, rax
	je	SHORT $LN43@kvz_encode

; 215  :   state->wfrow->lcu_offset_y = lcu_offset_y;

	mov	DWORD PTR [rax], ebp
	mov	rsi, QWORD PTR [rbx]

; 385  :     }
; 386  :   } else {

	jmp	$LN47@kvz_encode
$LN43@kvz_encode:

; 383  :       fprintf(stderr, "Could not initialize encoder_state->wfrow!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953169
	call	fprintf

; 384  :       return 0;

	xor	eax, eax

; 720  : }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN41@kvz_encode:

; 378  :       fprintf(stderr, "Could not initialize encoder_state->slice!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953170
	call	fprintf

; 379  :       return 0;

	xor	eax, eax

; 720  : }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN39@kvz_encode:

; 372  :       fprintf(stderr, "Could not initialize encoder_state->tile!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953171
	call	fprintf

; 373  :       return 0;

	xor	eax, eax

; 720  : }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN37@kvz_encode:

; 367  :       fprintf(stderr, "Could not initialize encoder_state->frame!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953172
	call	fprintf

; 368  :       return 0;

	xor	eax, eax

; 720  : }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
$LN34@kvz_encode:

; 387  :     child_state->encoder_control = parent_state->encoder_control;

	mov	rsi, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rsi

; 388  :     if (!child_state->frame) child_state->frame = parent_state->frame;

	cmp	QWORD PTR [rbx+40], rbp
	jne	SHORT $LN44@kvz_encode
	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rbx+40], rax
$LN44@kvz_encode:

; 389  :     if (!child_state->tile) child_state->tile = parent_state->tile;

	cmp	QWORD PTR [rbx+48], rbp
	jne	SHORT $LN45@kvz_encode
	mov	rax, QWORD PTR [rdi+48]
	mov	QWORD PTR [rbx+48], rax
$LN45@kvz_encode:

; 390  :     if (!child_state->slice) child_state->slice = parent_state->slice;

	cmp	QWORD PTR [rbx+56], rbp
	jne	SHORT $LN46@kvz_encode
	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rbx+56], rax
$LN46@kvz_encode:

; 391  :     if (!child_state->wfrow) child_state->wfrow = parent_state->wfrow;

	cmp	QWORD PTR [rbx+64], rbp
	jne	SHORT $LN47@kvz_encode
	mov	rax, QWORD PTR [rdi+64]
	mov	QWORD PTR [rbx+64], rax
$LN47@kvz_encode:
	mov	QWORD PTR [rsp+144], r12
; File F:\open_codec_learn_2021\kvazaar-master\src\constraint.c

; 44   :   constr = MALLOC(constraint_t, 1);

	mov	ecx, 8
	mov	QWORD PTR [rsp+136], r13
	mov	QWORD PTR [rsp+128], r14
	mov	QWORD PTR [rsp+120], r15
	call	QWORD PTR __imp_malloc
	mov	r14, rax

; 45   :   if (!constr) {

	test	rax, rax
	jne	SHORT $LN134@kvz_encode

; 46   :     fprintf(stderr, "Memory allocation failed!\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294945910
	call	fprintf

; 47   :     assert(0);

	lea	r8d, QWORD PTR [r14+47]
	lea	rdx, OFFSET FLAT:$SG4294945909
	lea	rcx, OFFSET FLAT:$SG4294945908
	call	QWORD PTR __imp__wassert
$LN134@kvz_encode:

; 48   :   }
; 49   : 
; 50   :   // Allocate the ml_intra_ctu_pred_t structure
; 51   :   constr->ml_intra_depth_ctu = NULL;

	mov	QWORD PTR [r14], rbp

; 52   :   if (encoder->cfg.ml_pu_depth_intra) // TODO: Change this by a new param !!

	cmp	BYTE PTR [rsi+2475], bpl
	je	$LN132@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\ml_intra_cu_depth_pred.c

; 830  : 	ml_intra_depth_ctu = MALLOC(ml_intra_ctu_pred_t, 1);

	mov	ecx, 24
	call	QWORD PTR __imp_malloc
	mov	rdi, rax

; 831  : 	if (!ml_intra_depth_ctu) {

	test	rax, rax
	jne	SHORT $LN140@kvz_encode

; 832  : 		fprintf(stderr, "Memory allocation failed!\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294943335
	call	fprintf

; 833  : 		assert(0);

	mov	r8d, 833				; 00000341H
	lea	rdx, OFFSET FLAT:$SG4294943334
	lea	rcx, OFFSET FLAT:$SG4294943333
	call	QWORD PTR __imp__wassert
$LN140@kvz_encode:

; 834  : 	}
; 835  : 	// Set the number of number of deth add to 1 by default
; 836  : 	ml_intra_depth_ctu->i_nb_addDepth = 1;
; 837  : 	// Set the extra Upper Expansion in the upper_depth enabled by default 
; 838  : 	ml_intra_depth_ctu->b_extra_up_exp = true;
; 839  : 
; 840  : 	// Allocate the depth matrices 
; 841  : 	ml_intra_depth_ctu->_mat_lower_depth = MALLOC(uint8_t, LCU_DEPTH_MAT_SIZE);

	mov	ecx, 64					; 00000040H
	mov	WORD PTR [rdi], 257			; 00000101H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+16], rax

; 842  : 	if (!ml_intra_depth_ctu->_mat_lower_depth) {

	test	rax, rax
	jne	SHORT $LN141@kvz_encode

; 843  : 		fprintf(stderr, "Memory allocation failed!\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294943332
	call	fprintf

; 844  : 		assert(0);

	mov	r8d, 844				; 0000034cH
	lea	rdx, OFFSET FLAT:$SG4294943331
	lea	rcx, OFFSET FLAT:$SG4294943330
	call	QWORD PTR __imp__wassert
$LN141@kvz_encode:

; 845  : 	}
; 846  : 	ml_intra_depth_ctu->_mat_upper_depth = MALLOC(uint8_t, LCU_DEPTH_MAT_SIZE);

	mov	ecx, 64					; 00000040H
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+8], rax

; 847  : 	if (!ml_intra_depth_ctu->_mat_upper_depth) {

	test	rax, rax
	jne	SHORT $LN142@kvz_encode

; 848  : 		fprintf(stderr, "Memory allocation failed!\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294943329
	call	fprintf

; 849  : 		assert(0);

	mov	r8d, 849				; 00000351H
	lea	rdx, OFFSET FLAT:$SG4294943328
	lea	rcx, OFFSET FLAT:$SG4294943327
	call	QWORD PTR __imp__wassert
$LN142@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\constraint.c

; 54   :     constr->ml_intra_depth_ctu = kvz_init_ml_intra_depth_const();

	mov	QWORD PTR [r14], rdi
$LN132@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 396  :   kvz_bitstream_init(&child_state->stream);

	lea	rax, QWORD PTR [rbx+96]
	mov	QWORD PTR [rbx+416], r14
	xorps	xmm0, xmm0

; 404  :     int child_count = 0;

	mov	DWORD PTR child_count$1$[rsp], ebp
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 74   :   memset(stream, 0, sizeof(bitstream_t));

	movups	XMMWORD PTR [rax], xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 404  :     int child_count = 0;

	mov	r12d, ebp

; 405  :     //We first check the type of this element.
; 406  :     //If it's a MAIN, it can allow both slices or tiles as child
; 407  :     //If it's a TILE, it can allow slices as child, if its parent is not a slice, or wavefront rows if there is no other children
; 408  :     //If it's a SLICE, it can allow tiles as child, if its parent is not a tile, or wavefront rows if there is no other children
; 409  :     //If it's a WAVEFRONT_ROW, it doesn't allow any children
; 410  :     int children_allow_wavefront_row = 0;

	mov	DWORD PTR children_allow_wavefront_row$1$[rsp], ebp
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 74   :   memset(stream, 0, sizeof(bitstream_t));

	movups	XMMWORD PTR [rax+16], xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 420  :     switch(child_state->type) {

	mov	edi, DWORD PTR [rbx+8]
	mov	esi, ebp
	mov	r15, QWORD PTR [rbx]
	mov	ecx, edi
	mov	QWORD PTR [rbx+160], rax
	mov	r13d, ebp
	mov	QWORD PTR encoder$1$[rsp], r15
	mov	DWORD PTR children_allow_slice$1$[rsp], ebp
	mov	DWORD PTR children_allow_tile$1$[rsp], ebp
	sub	ecx, 77					; 0000004dH
	je	$LN48@kvz_encode
	sub	ecx, 6
	je	$LN49@kvz_encode
	sub	ecx, 1
	je	SHORT $LN51@kvz_encode
	cmp	ecx, 3
	je	SHORT $LN53@kvz_encode

; 448  :       default:
; 449  :         fprintf(stderr, "Invalid encoder_state->type %d!\n", child_state->type);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, edi
	lea	rdx, OFFSET FLAT:$SG4294953164
	mov	rcx, rax
	call	fprintf

; 450  :         assert(0);

	mov	r8d, 450				; 000001c2H
	lea	rdx, OFFSET FLAT:$SG4294953163
	lea	rcx, OFFSET FLAT:$SG4294953162
	call	QWORD PTR __imp__wassert

; 451  :         return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN53@kvz_encode:

; 443  :       case ENCODER_STATE_TYPE_WAVEFRONT_ROW:
; 444  :         //GCC tries to be too clever...
; 445  :         start_in_ts = -1;
; 446  :         end_in_ts = -1;
; 447  :         break;

	mov	DWORD PTR [rbx+72], 1
	jmp	$LN476@kvz_encode
$LN51@kvz_encode:

; 435  :       case ENCODER_STATE_TYPE_TILE:
; 436  :         assert(child_state->parent);

	mov	rax, QWORD PTR [rbx+24]
	test	rax, rax
	jne	SHORT $LN97@kvz_encode
	mov	r8d, 436				; 000001b4H
	lea	rdx, OFFSET FLAT:$SG4294953166
	lea	rcx, OFFSET FLAT:$SG4294953165
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rbx+24]
$LN97@kvz_encode:

; 437  :         if (child_state->parent->type != ENCODER_STATE_TYPE_SLICE) children_allow_slice = 1;
; 438  :         children_allow_wavefront_row =

	cmp	DWORD PTR [rax+8], 83			; 00000053H
	setne	sil
	mov	DWORD PTR children_allow_slice$1$[rsp], esi
	cmp	DWORD PTR [r15+168], ebp
	je	SHORT $LN468@kvz_encode
	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx+24], 1
	jle	SHORT $LN468@kvz_encode
	mov	DWORD PTR children_allow_wavefront_row$1$[rsp], 1
	jmp	SHORT $LN99@kvz_encode
$LN468@kvz_encode:
	mov	rax, QWORD PTR [rbx+48]
	mov	DWORD PTR children_allow_wavefront_row$1$[rsp], ebp
	mov	rcx, QWORD PTR [rax]
$LN99@kvz_encode:

; 439  :           encoder->cfg.wpp && child_state->tile->frame->height_in_lcu > 1;
; 440  :         start_in_ts = child_state->tile->lcu_offset_in_ts;
; 441  :         end_in_ts = child_state->tile->lcu_offset_in_ts + child_state->tile->frame->width_in_lcu * child_state->tile->frame->height_in_lcu;

	mov	r14d, DWORD PTR [rcx+28]
	imul	r14d, DWORD PTR [rcx+24]
	mov	r8d, DWORD PTR [rax+28]
	add	r14d, r8d

; 442  :         break;

	jmp	$LN502@kvz_encode
$LN49@kvz_encode:

; 426  :         break;
; 427  :       case ENCODER_STATE_TYPE_SLICE:
; 428  :         assert(child_state->parent);

	mov	rax, QWORD PTR [rbx+24]
	test	rax, rax
	jne	SHORT $LN94@kvz_encode
	mov	r8d, 428				; 000001acH
	lea	rdx, OFFSET FLAT:$SG4294953168
	lea	rcx, OFFSET FLAT:$SG4294953167
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rbx+24]
$LN94@kvz_encode:

; 429  :         if (child_state->parent->type != ENCODER_STATE_TYPE_TILE) children_allow_tile = 1;
; 430  :         start_in_ts = child_state->slice->start_in_ts;

	cmp	DWORD PTR [rax+8], 84			; 00000054H
	mov	rax, QWORD PTR [rbx+56]
	setne	r13b
	mov	DWORD PTR children_allow_tile$1$[rsp], r13d

; 431  :         end_in_ts = child_state->slice->end_in_ts + 1;

	mov	r14d, DWORD PTR [rax+8]
	mov	r8d, DWORD PTR [rax+4]
	inc	r14d
	mov	DWORD PTR start_in_ts$1$[rsp], r8d
	mov	DWORD PTR end_in_ts$1$[rsp], r14d

; 433  :         children_allow_wavefront_row = encoder->cfg.wpp && num_wpp_rows > 1;

	cmp	DWORD PTR [r15+168], ebp
	je	SHORT $LN473@kvz_encode

; 432  :         int num_wpp_rows = (end_in_ts - start_in_ts) / child_state->tile->frame->width_in_lcu;

	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, r14d
	sub	eax, r8d
	cdq
	idiv	DWORD PTR [rcx+28]

; 433  :         children_allow_wavefront_row = encoder->cfg.wpp && num_wpp_rows > 1;

	cmp	eax, 1
	jle	SHORT $LN473@kvz_encode
	mov	DWORD PTR children_allow_wavefront_row$1$[rsp], 1
	jmp	SHORT $LN2@kvz_encode
$LN473@kvz_encode:
	mov	DWORD PTR children_allow_wavefront_row$1$[rsp], ebp

; 434  :         break;

	jmp	SHORT $LN2@kvz_encode
$LN48@kvz_encode:

; 421  :       case ENCODER_STATE_TYPE_MAIN:
; 422  :         children_allow_slice = 1;
; 423  :         children_allow_tile = 1;
; 424  :         start_in_ts = 0;
; 425  :         end_in_ts = child_state->tile->frame->width_in_lcu * child_state->tile->frame->height_in_lcu;

	mov	rax, QWORD PTR [rbx+48]
	mov	esi, 1
	mov	DWORD PTR children_allow_slice$1$[rsp], esi
	mov	r13d, esi
	mov	DWORD PTR children_allow_tile$1$[rsp], esi
	mov	r8d, ebp
	mov	rcx, QWORD PTR [rax]
	mov	r14d, DWORD PTR [rcx+28]
	imul	r14d, DWORD PTR [rcx+24]
$LN502@kvz_encode:

; 452  :     }
; 453  :     
; 454  :     range_start = start_in_ts;

	mov	DWORD PTR end_in_ts$1$[rsp], r14d
	mov	DWORD PTR start_in_ts$1$[rsp], r8d
$LN2@kvz_encode:
	mov	ebp, r8d

; 456  :     while (range_start < end_in_ts && (children_allow_slice || children_allow_tile)) {

	cmp	r8d, r14d
	jge	$LN488@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 45   :     if (encoder->slice_addresses_in_ts[i] == lcu_addr_in_ts) return 1;

	xor	edi, edi
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 456  :     while (range_start < end_in_ts && (children_allow_slice || children_allow_tile)) {

	mov	QWORD PTR $T1[rsp], r12
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 45   :     if (encoder->slice_addresses_in_ts[i] == lcu_addr_in_ts) return 1;

	mov	QWORD PTR tv5806[rsp], rdi
	npad	3
$LL4@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 456  :     while (range_start < end_in_ts && (children_allow_slice || children_allow_tile)) {

	test	esi, esi
	jne	SHORT $LN55@kvz_encode
	test	r13d, r13d
	je	$LN497@kvz_encode
$LN55@kvz_encode:

; 457  :       encoder_state_t *new_child = NULL;

	xor	r14d, r14d

; 458  :       int range_end_slice = range_start; //Will be incremented to get the range of the "thing"
; 459  :       int range_end_tile = range_start; //Will be incremented to get the range of the "thing"

	mov	DWORD PTR range_end_tile$1$[rsp], ebp
	mov	esi, ebp
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 61   :   assert(lcu_addr_in_ts >= 0 && lcu_addr_in_ts < encoder->in.height_in_lcu * encoder->in.width_in_lcu);

	test	ebp, ebp
	js	SHORT $LN469@kvz_encode
	mov	eax, DWORD PTR [r15+2540]
	imul	eax, DWORD PTR [r15+2536]
	cmp	ebp, eax
	jl	SHORT $LN150@kvz_encode
$LN469@kvz_encode:
	mov	r8d, 61					; 0000003dH
	lea	rdx, OFFSET FLAT:$SG4294946299
	lea	rcx, OFFSET FLAT:$SG4294946298
	call	QWORD PTR __imp__wassert
$LN150@kvz_encode:

; 62   :   if (lcu_addr_in_ts == 0) return 1;

	test	ebp, ebp
	je	SHORT $LN460@kvz_encode

; 63   :   if (encoder->tiles_tile_id[lcu_addr_in_ts - 1] != encoder->tiles_tile_id[lcu_addr_in_ts]) {

	mov	rcx, QWORD PTR [r15+6424]
	movsxd	rdx, ebp
	mov	eax, DWORD PTR [rcx+rdx*4]
	cmp	DWORD PTR [rcx+rdx*4-4], eax
	je	SHORT $LN101@kvz_encode
$LN460@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 461  :       int tile_allowed = kvz_lcu_at_tile_start(encoder, range_start) && children_allow_tile;

	test	r13d, r13d
	je	SHORT $LN101@kvz_encode
	mov	r13d, 1
	jmp	SHORT $LN102@kvz_encode
$LN101@kvz_encode:
	xor	r13d, r13d
$LN102@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 42   :   assert(lcu_addr_in_ts >= 0 && lcu_addr_in_ts < encoder->in.height_in_lcu * encoder->in.width_in_lcu);

	test	ebp, ebp
	js	SHORT $LN470@kvz_encode
	mov	eax, DWORD PTR [r15+2540]
	imul	eax, DWORD PTR [r15+2536]
	cmp	ebp, eax
	jl	SHORT $LN159@kvz_encode
$LN470@kvz_encode:
	mov	r8d, 42					; 0000002aH
	lea	rdx, OFFSET FLAT:$SG4294946303
	lea	rcx, OFFSET FLAT:$SG4294946302
	call	QWORD PTR __imp__wassert
$LN159@kvz_encode:

; 43   :   if (lcu_addr_in_ts == 0) return 1;

	test	ebp, ebp
	je	$LN461@kvz_encode

; 44   :   for (i = 0; i < encoder->slice_count; ++i) {

	movsxd	rax, DWORD PTR [r15+6432]
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN103@kvz_encode
	mov	rdx, rax
	mov	rax, QWORD PTR [r15+6440]
$LL154@kvz_encode:

; 45   :     if (encoder->slice_addresses_in_ts[i] == lcu_addr_in_ts) return 1;

	cmp	DWORD PTR [rax], ebp
	je	$LN461@kvz_encode

; 44   :   for (i = 0; i < encoder->slice_count; ++i) {

	inc	rcx
	add	rax, 4
	cmp	rcx, rdx
	jl	SHORT $LL154@kvz_encode
$LN103@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 462  :       int slice_allowed = kvz_lcu_at_slice_start(encoder, range_start) && children_allow_slice;

	xor	r12d, r12d
$LN403@kvz_encode:

; 469  :       }
; 470  :       
; 471  :       if (tile_allowed) {

	test	r13d, r13d
	je	$LN458@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 52   :   assert(lcu_addr_in_ts >= 0 && lcu_addr_in_ts < encoder->in.height_in_lcu * encoder->in.width_in_lcu);

	mov	edx, DWORD PTR [r15+2540]
	mov	r9d, ebp
	mov	r8d, DWORD PTR [r15+2536]
	movsxd	rdi, ebp
$LL8@kvz_encode:

; 70   :   assert(lcu_addr_in_ts >= 0 && lcu_addr_in_ts < encoder->in.height_in_lcu * encoder->in.width_in_lcu);

	test	rdi, rdi
	js	SHORT $LN173@kvz_encode
	mov	eax, edx
	imul	eax, r8d
	cmp	r9d, eax
	jl	SHORT $LN174@kvz_encode
$LN173@kvz_encode:
	mov	r8d, 70					; 00000046H
	lea	rdx, OFFSET FLAT:$SG4294946297
	lea	rcx, OFFSET FLAT:$SG4294946296
	call	QWORD PTR __imp__wassert
	mov	edx, DWORD PTR [r15+2540]
	mov	r8d, DWORD PTR [r15+2536]
	mov	r9d, DWORD PTR range_end_tile$1$[rsp]
$LN174@kvz_encode:

; 71   :   if (lcu_addr_in_ts == encoder->in.height_in_lcu * encoder->in.width_in_lcu - 1) return 1;

	mov	eax, edx
	imul	eax, r8d
	dec	eax
	cmp	r9d, eax
	je	$LN467@kvz_encode

; 72   :   if (encoder->tiles_tile_id[lcu_addr_in_ts + 1] != encoder->tiles_tile_id[lcu_addr_in_ts]) {

	mov	rax, QWORD PTR [r15+6424]
	lea	rcx, QWORD PTR [rax+rdi*4]
	mov	eax, DWORD PTR [rax+rdi*4]
	cmp	DWORD PTR [rcx+4], eax
	jne	$LN467@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 473  :           ++range_end_tile;

	inc	r9d
	mov	DWORD PTR range_end_tile$1$[rsp], r9d
	inc	rdi

; 474  :         }

	jmp	SHORT $LL8@kvz_encode
$LN461@kvz_encode:

; 462  :       int slice_allowed = kvz_lcu_at_slice_start(encoder, range_start) && children_allow_slice;

	cmp	DWORD PTR children_allow_slice$1$[rsp], r14d
	je	$LN103@kvz_encode
	mov	r12d, 1
$LL6@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 52   :   assert(lcu_addr_in_ts >= 0 && lcu_addr_in_ts < encoder->in.height_in_lcu * encoder->in.width_in_lcu);

	test	esi, esi
	js	SHORT $LN472@kvz_encode
	mov	edx, DWORD PTR [r15+2536]
	mov	eax, edx
	mov	ecx, DWORD PTR [r15+2540]
	imul	eax, ecx
	cmp	esi, eax
	jl	SHORT $LN471@kvz_encode
$LN472@kvz_encode:
	mov	r8d, 52					; 00000034H
	lea	rdx, OFFSET FLAT:$SG4294946301
	lea	rcx, OFFSET FLAT:$SG4294946300
	call	QWORD PTR __imp__wassert
	mov	ecx, DWORD PTR [r15+2540]
	mov	edx, DWORD PTR [r15+2536]
$LN471@kvz_encode:

; 53   :   if (lcu_addr_in_ts == encoder->in.height_in_lcu * encoder->in.width_in_lcu - 1) return 1;

	imul	ecx, edx
	dec	ecx
	cmp	esi, ecx
	je	$LN403@kvz_encode

; 54   :   for (i = 0; i < encoder->slice_count; ++i) {

	movsxd	rax, DWORD PTR [r15+6432]
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN162@kvz_encode
	mov	rcx, QWORD PTR [r15+6440]
	mov	r8, rax
	npad	8
$LL163@kvz_encode:

; 55   :     if (encoder->slice_addresses_in_ts[i] == lcu_addr_in_ts + 1) return 1;

	lea	eax, DWORD PTR [rsi+1]
	cmp	DWORD PTR [rcx], eax
	je	$LN403@kvz_encode

; 54   :   for (i = 0; i < encoder->slice_count; ++i) {

	inc	rdx
	add	rcx, 4
	cmp	rdx, r8
	jl	SHORT $LL163@kvz_encode
$LN162@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 467  :           ++range_end_slice;

	inc	esi

; 468  :         }

	jmp	$LL6@kvz_encode
$LN467@kvz_encode:

; 475  :       }
; 476  :       
; 477  :       //printf("range_start=%d, range_end_slice=%d, range_end_tile=%d, tile_allowed=%d, slice_allowed=%d end_in_ts=%d\n",range_start,range_end_slice,range_end_tile,tile_allowed,slice_allowed,end_in_ts);
; 478  :       
; 479  :       if ((!tile_allowed || (range_end_slice >= range_end_tile)) && !new_child && slice_allowed) {

	mov	rdi, QWORD PTR tv5806[rsp]
	cmp	esi, r9d
	jl	SHORT $LN60@kvz_encode
$LN458@kvz_encode:
	test	r12d, r12d
	je	SHORT $LN459@kvz_encode

; 480  :         //Create a slice
; 481  :         new_child = &child_state->children[child_count];

	mov	r14, QWORD PTR [rbx+16]

; 482  :         new_child->encoder_control = encoder;
; 483  :         new_child->type  = ENCODER_STATE_TYPE_SLICE;
; 484  :         new_child->frame = child_state->frame;
; 485  :         new_child->tile  = child_state->tile;
; 486  :         new_child->wfrow = child_state->wfrow;
; 487  :         new_child->slice = MALLOC(encoder_state_config_slice_t, 1);

	mov	ecx, 20
	add	r14, rdi
	mov	QWORD PTR [r14], r15
	mov	DWORD PTR [r14+8], 83			; 00000053H
	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [r14+40], rax
	mov	rax, QWORD PTR [rbx+48]
	mov	QWORD PTR [r14+48], rax
	mov	rax, QWORD PTR [rbx+64]
	mov	QWORD PTR [r14+64], rax
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14+56], rax

; 488  :         if (!new_child->slice || !encoder_state_config_slice_init(new_child, range_start, range_end_slice)) {

	test	rax, rax
	je	$LN61@kvz_encode
	mov	r8d, esi
	mov	edx, ebp
	mov	rcx, r14
	call	encoder_state_config_slice_init
	test	eax, eax
	je	$LN61@kvz_encode
	mov	r9d, DWORD PTR range_end_tile$1$[rsp]
$LN60@kvz_encode:

; 491  :         }
; 492  :       }
; 493  :       
; 494  :       if ((!slice_allowed || (range_end_slice < range_end_tile)) && !new_child && tile_allowed) {

	test	r12d, r12d
	je	SHORT $LN63@kvz_encode
	cmp	esi, r9d
	jge	$LN64@kvz_encode
$LN63@kvz_encode:
	test	r14, r14
	jne	$LN457@kvz_encode
$LN459@kvz_encode:
	test	r13d, r13d
	je	$LN493@kvz_encode

; 495  :         //Create a tile
; 496  :         int tile_id = encoder->tiles_tile_id[range_start];

	mov	rax, QWORD PTR [r15+6424]
	movsxd	rcx, ebp

; 497  :         int tile_x = tile_id % encoder->cfg.tiles_width_count;

	mov	eax, DWORD PTR [rax+rcx*4]

; 498  :         int tile_y = tile_id / encoder->cfg.tiles_width_count;
; 499  :         
; 500  :         int lcu_offset_x = encoder->tiles_col_bd[tile_x];

	mov	rcx, QWORD PTR [r15+6392]
	cdq
	idiv	DWORD PTR [r15+144]
	movsxd	r8, edx
	mov	r12d, DWORD PTR [rcx+r8*4]
	lea	rdx, QWORD PTR [rcx+r8*4]

; 501  :         int lcu_offset_y = encoder->tiles_row_bd[tile_y];
; 502  :         int width_in_lcu = encoder->tiles_col_bd[tile_x+1]-encoder->tiles_col_bd[tile_x];
; 503  :         int height_in_lcu = encoder->tiles_row_bd[tile_y+1]-encoder->tiles_row_bd[tile_y];
; 504  :         int width = MIN(width_in_lcu * LCU_WIDTH, encoder->in.width - lcu_offset_x * LCU_WIDTH);

	mov	ebp, DWORD PTR [rdx+4]

; 505  :         int height = MIN(height_in_lcu * LCU_WIDTH, encoder->in.height - lcu_offset_y * LCU_WIDTH);
; 506  :         
; 507  :         new_child = &child_state->children[child_count];

	mov	rdx, QWORD PTR tv5806[rsp]
	sub	ebp, r12d
	add	rdx, QWORD PTR [rbx+16]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [r15+6400]
	mov	r13d, DWORD PTR [rax+rcx*4]
	lea	r8, QWORD PTR [rax+rcx*4]
	mov	r15d, DWORD PTR [r15+2528]
	mov	eax, r12d
	mov	edi, DWORD PTR [r8+4]
	mov	rcx, QWORD PTR encoder$1$[rsp]
	sub	edi, r13d
	shl	eax, 6
	sub	r15d, eax
	shl	ebp, 6
	mov	eax, r13d
	shl	edi, 6
	mov	r14d, DWORD PTR [rcx+2532]
	shl	eax, 6

; 508  :         new_child->encoder_control = encoder;

	mov	QWORD PTR [rdx], rcx
	sub	r14d, eax

; 509  :         new_child->type  = ENCODER_STATE_TYPE_TILE;

	mov	DWORD PTR [rdx+8], 84			; 00000054H

; 510  :         new_child->frame = child_state->frame;
; 511  :         new_child->tile  = MALLOC(encoder_state_config_tile_t, 1);

	mov	ecx, 72					; 00000048H
	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rdx+40], rax
	mov	QWORD PTR new_child$1$[rsp], rdx
	call	QWORD PTR __imp_malloc
	mov	rdx, QWORD PTR new_child$1$[rsp]
	mov	QWORD PTR [rdx+48], rax

; 512  :         new_child->slice = child_state->slice;

	mov	rcx, QWORD PTR [rbx+56]
	mov	QWORD PTR [rdx+56], rcx

; 513  :         new_child->wfrow = child_state->wfrow;

	mov	rcx, QWORD PTR [rbx+64]
	mov	QWORD PTR [rdx+64], rcx

; 514  :         
; 515  :         if (!new_child->tile || !encoder_state_config_tile_init(new_child, lcu_offset_x, lcu_offset_y, width, height, width_in_lcu, height_in_lcu)) {

	test	rax, rax
	je	$LN65@kvz_encode
	cmp	edi, r14d
	mov	r8d, r13d
	mov	edx, r12d
	cmovge	edi, r14d
	mov	r14, QWORD PTR new_child$1$[rsp]
	cmp	ebp, r15d
	mov	DWORD PTR [rsp+32], edi
	mov	rcx, r14
	cmovge	ebp, r15d
	mov	r9d, ebp
	call	encoder_state_config_tile_init
	test	eax, eax
	je	$LN65@kvz_encode
	mov	r15, QWORD PTR encoder$1$[rsp]
$LN64@kvz_encode:

; 518  :         }
; 519  :       }
; 520  :       
; 521  :       if (new_child) {

	test	r14, r14
	je	$LN494@kvz_encode
$LN457@kvz_encode:

; 522  :         child_state->children = realloc(child_state->children, sizeof(encoder_state_t) * (2+child_count));

	movsxd	r12, DWORD PTR child_count$1$[rsp]
	mov	rcx, QWORD PTR [rbx+16]
	lea	rax, QWORD PTR [r12+2]
	imul	rdx, rax, 424				; 000001a8H
	call	QWORD PTR __imp_realloc
	mov	QWORD PTR [rbx+16], rax

; 523  :         if (!child_state->children) {

	test	rax, rax
	je	$LN404@kvz_encode

; 526  :         }
; 527  : 
; 528  :         child_state->children[1 + child_count].encoder_control = NULL;

	mov	rcx, QWORD PTR tv5806[rsp]

; 533  :           for (i = 0; child_state->children[i].encoder_control && i < child_count; ++i) {

	xor	ebp, ebp
	mov	r14, QWORD PTR $T1[rsp]
	xor	edi, edi
	mov	QWORD PTR [rcx+rax+424], 0
	mov	r8, QWORD PTR [rbx+16]
	cmp	QWORD PTR [r8], rdi
	je	$LN11@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 52   :   assert(lcu_addr_in_ts >= 0 && lcu_addr_in_ts < encoder->in.height_in_lcu * encoder->in.width_in_lcu);

	mov	rcx, r8
	xor	edx, edx
	npad	1
$LL12@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 533  :           for (i = 0; child_state->children[i].encoder_control && i < child_count; ++i) {

	mov	r8, rcx
	cmp	rdi, r14
	jge	$LN11@kvz_encode

; 534  :             for (j = 0; child_state->children[i].children[j].encoder_control; ++j) {

	mov	rax, QWORD PTR [rcx+rdx+16]
	xor	r8d, r8d
	movsxd	r11, ebp
	cmp	QWORD PTR [rax], r8
	je	SHORT $LN439@kvz_encode
	imul	r10, r11, 424				; 000001a8H
	xor	r9d, r9d
	npad	10
$LL15@kvz_encode:

; 535  :               child_state->children[i].children[j].parent = &child_state->children[i];

	mov	rax, QWORD PTR [rbx+16]
	inc	r8
	lea	rcx, QWORD PTR [rax+r10]
	mov	rax, QWORD PTR [rax+rdx+16]
	mov	QWORD PTR [rax+r9+24], rcx
	mov	rcx, QWORD PTR [rbx+16]
	imul	r9, r8, 424				; 000001a8H
	mov	rax, QWORD PTR [rdx+rcx+16]
	cmp	QWORD PTR [r9+rax], 0
	jne	SHORT $LL15@kvz_encode
$LN439@kvz_encode:

; 536  :             }
; 537  :             for (j = 0; j < child_state->children[i].lcu_order_count; ++j) {

	xor	r9d, r9d
	imul	r10, r11, 424				; 000001a8H
	cmp	DWORD PTR [rcx+rdx+88], r9d
	jbe	SHORT $LN440@kvz_encode
	xor	r8d, r8d
$LL18@kvz_encode:

; 538  :               child_state->children[i].lcu_order[j].encoder_state = &child_state->children[i];

	mov	rax, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [r8+88]
	inc	r9d
	lea	rcx, QWORD PTR [rax+r10]
	mov	rax, QWORD PTR [rax+rdx+80]
	mov	QWORD PTR [rax+r8-80], rcx
	mov	rcx, QWORD PTR [rbx+16]
	cmp	r9d, DWORD PTR [rdx+rcx+88]
	jb	SHORT $LL18@kvz_encode
$LN440@kvz_encode:

; 539  :             }
; 540  :             child_state->children[i].cabac.stream = &child_state->children[i].stream;

	lea	rax, QWORD PTR [r10+96]
	inc	ebp
	add	rax, rcx
	inc	rdi
	mov	QWORD PTR [rcx+rdx+160], rax
	add	rdx, 424				; 000001a8H
	mov	r8, QWORD PTR [rbx+16]
	mov	rcx, r8
	cmp	QWORD PTR [rdx+r8], 0
	jne	$LL12@kvz_encode
$LN11@kvz_encode:

; 541  :           }
; 542  :         }
; 543  :         
; 544  :         if (!kvz_encoder_state_init(&child_state->children[child_count], child_state)) {

	imul	rcx, r12, 424				; 000001a8H
	mov	rdx, rbx
	add	rcx, r8
	call	kvz_encoder_state_init
	test	eax, eax
	je	$LN405@kvz_encode

; 547  :         }
; 548  :         child_count += 1;

	mov	rdi, QWORD PTR tv5806[rsp]
	inc	r12d
	inc	r14
	mov	DWORD PTR child_count$1$[rsp], r12d
	add	rdi, 424				; 000001a8H
	mov	QWORD PTR $T1[rsp], r14
	mov	QWORD PTR tv5806[rsp], rdi
	jmp	SHORT $LN66@kvz_encode
$LN494@kvz_encode:

; 518  :         }
; 519  :       }
; 520  :       
; 521  :       if (new_child) {

	mov	rdi, QWORD PTR tv5806[rsp]
$LN493@kvz_encode:

; 549  :       }
; 550  :       
; 551  :       range_start = MAX(range_end_slice, range_end_tile) + 1;

	mov	r12d, DWORD PTR child_count$1$[rsp]
$LN66@kvz_encode:
	mov	ebp, DWORD PTR range_end_tile$1$[rsp]
	cmp	esi, ebp
	mov	r14d, DWORD PTR end_in_ts$1$[rsp]
	cmovg	ebp, esi
	inc	ebp
	cmp	ebp, r14d
	jge	$LN497@kvz_encode

; 456  :     while (range_start < end_in_ts && (children_allow_slice || children_allow_tile)) {

	mov	esi, DWORD PTR children_allow_slice$1$[rsp]
	mov	r13d, DWORD PTR children_allow_tile$1$[rsp]
	jmp	$LL4@kvz_encode
$LN61@kvz_encode:

; 489  :           fprintf(stderr, "Could not initialize encoder_state->slice!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953161
	call	fprintf

; 490  :           return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN405@kvz_encode:

; 545  :           fprintf(stderr, "Unable to init child...\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953158
	call	fprintf

; 546  :           return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN404@kvz_encode:

; 524  :           fprintf(stderr, "Failed to allocate memory for children...\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953159
	call	fprintf

; 525  :           return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN65@kvz_encode:

; 516  :           fprintf(stderr, "Could not initialize encoder_state->tile!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953160
	call	fprintf

; 517  :           return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN497@kvz_encode:

; 552  :     }
; 553  :     
; 554  :     //We create wavefronts only if we have no children
; 555  :     if (children_allow_wavefront_row && child_count == 0) {

	mov	r8d, DWORD PTR start_in_ts$1$[rsp]
$LN488@kvz_encode:
	cmp	DWORD PTR children_allow_wavefront_row$1$[rsp], 0
	je	$LN23@kvz_encode
	test	r12d, r12d
	jne	$LN23@kvz_encode

; 556  :       int first_row = encoder->tiles_ctb_addr_ts_to_rs[start_in_ts] / encoder->in.width_in_lcu;

	mov	rcx, QWORD PTR [r15+6416]
	mov	r10d, DWORD PTR [r15+2536]
	movsxd	rbp, r8d
	mov	eax, DWORD PTR [rcx+rbp*4]
	cdq
	idiv	r10d
	mov	esi, eax

; 557  :       int last_row = encoder->tiles_ctb_addr_ts_to_rs[start_in_ts] / encoder->in.width_in_lcu;

	mov	edi, eax

; 558  :       int num_rows;
; 559  :       int i;
; 560  :       
; 561  :       assert(!(children_allow_slice || children_allow_tile));

	cmp	DWORD PTR children_allow_slice$1$[rsp], r12d
	jne	SHORT $LN109@kvz_encode
	cmp	DWORD PTR children_allow_tile$1$[rsp], r12d
	je	SHORT $LN111@kvz_encode
$LN109@kvz_encode:
	mov	r8d, 561				; 00000231H
	lea	rdx, OFFSET FLAT:$SG4294953157
	lea	rcx, OFFSET FLAT:$SG4294953156
	call	QWORD PTR __imp__wassert
	mov	rcx, QWORD PTR [r15+6416]
	mov	r10d, DWORD PTR [r15+2536]
$LN111@kvz_encode:

; 562  :       assert(child_count == 0);
; 563  :       
; 564  :       for (i=start_in_ts; i<end_in_ts; ++i) {

	movsxd	r9, r14d
	cmp	rbp, r9
	jge	SHORT $LN20@kvz_encode

; 565  :         const int row = encoder->tiles_ctb_addr_ts_to_rs[i] / encoder->in.width_in_lcu;

	lea	r8, QWORD PTR [rcx+rbp*4]
	sub	r9, rbp
	npad	1
$LL418@kvz_encode:
	mov	eax, DWORD PTR [r8]
	lea	r8, QWORD PTR [r8+4]
	cdq
	idiv	r10d

; 566  :         if (row < first_row) first_row = row;
; 567  :         if (row > last_row) last_row = row;

	cmp	eax, esi
	mov	ecx, eax
	cmovge	ecx, esi
	cmp	eax, edi
	mov	esi, ecx
	cmovle	eax, edi
	mov	edi, eax
	sub	r9, 1
	jne	SHORT $LL418@kvz_encode

; 679  :           child_state->lcu_order[i].above->below = &child_state->lcu_order[i];

	mov	rcx, QWORD PTR [r15+6416]
	mov	r10d, DWORD PTR [r15+2536]
$LN20@kvz_encode:

; 568  :       }
; 569  :       
; 570  :       num_rows = last_row - first_row + 1;

	mov	eax, DWORD PTR [rcx+rbp*4]
	sub	edi, esi

; 571  :       
; 572  :       //When entropy_coding_sync_enabled_flag is equal to 1 and the first coding tree block in a slice is not the first coding
; 573  :       //tree block of a row of coding tree blocks in a tile, it is a requirement of bitstream conformance that the last coding tree
; 574  :       //block in the slice shall belong to the same row of coding tree blocks as the first coding tree block in the slice.
; 575  :       
; 576  :       if (encoder->tiles_ctb_addr_ts_to_rs[start_in_ts] % encoder->in.width_in_lcu != child_state->tile->lcu_offset_x) {

	mov	rsi, QWORD PTR [rbx+48]
	cdq
	idiv	r10d
	lea	r12d, DWORD PTR [rdi+1]
	cmp	edx, DWORD PTR [rsi+12]
	je	SHORT $LN73@kvz_encode

; 577  :         if (num_rows > 1) {

	cmp	r12d, 1
	jle	SHORT $LN73@kvz_encode

; 578  :           fprintf(stderr, "Invalid: first CTB in slice %d is not at the tile %d edge, and the slice spans on more than one row.\n", child_state->slice->id, child_state->tile->id);

	mov	rbx, QWORD PTR [rbx+56]
	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [rsi+8]
	lea	rdx, OFFSET FLAT:$SG4294953153
	mov	r8d, DWORD PTR [rbx]
	mov	rcx, rax
	call	fprintf

; 579  :           return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN73@kvz_encode:

; 580  :         }
; 581  :       }
; 582  :       
; 583  :       //FIXME Do the same kind of check if we implement slice segments
; 584  :     
; 585  :       child_count = num_rows;
; 586  :       child_state->children = realloc(child_state->children, sizeof(encoder_state_t) * (num_rows + 1));

	mov	rcx, QWORD PTR [rbx+16]
	movsxd	rax, edi
	add	rax, 2
	imul	rdx, rax, 424				; 000001a8H
	call	QWORD PTR __imp_realloc

; 587  :       child_state->children[num_rows].encoder_control = NULL;

	movsxd	r15, edi

; 588  :       
; 589  :       for (i=0; i < num_rows; ++i) {

	xor	ebp, ebp
	inc	r15
	mov	QWORD PTR [rbx+16], rax
	imul	rcx, r15, 424				; 000001a8H
	mov	QWORD PTR [rcx+rax], 0
	test	r15, r15
	jle	SHORT $LN23@kvz_encode
	mov	r13, QWORD PTR encoder$1$[rsp]
	xor	esi, esi
	xor	r14d, r14d
	npad	7
$LL24@kvz_encode:

; 590  :         encoder_state_t *new_child = &child_state->children[i];

	mov	rdi, QWORD PTR [rbx+16]

; 591  :         
; 592  :         new_child->encoder_control = encoder;
; 593  :         new_child->type  = ENCODER_STATE_TYPE_WAVEFRONT_ROW;
; 594  :         new_child->frame = child_state->frame;
; 595  :         new_child->tile  = child_state->tile;
; 596  :         new_child->slice = child_state->slice;
; 597  :         new_child->wfrow = MALLOC(encoder_state_config_wfrow_t, 1);

	mov	ecx, 4
	add	rdi, r14
	mov	QWORD PTR [rdi], r13
	mov	DWORD PTR [rdi+8], 87			; 00000057H
	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rdi+40], rax
	mov	rax, QWORD PTR [rbx+48]
	mov	QWORD PTR [rdi+48], rax
	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rdi+56], rax
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+64], rax

; 598  :         
; 599  :         if (!new_child->wfrow || !encoder_state_config_wfrow_init(new_child, i)) {

	test	rax, rax
	je	$LN75@kvz_encode

; 602  :         }
; 603  :         
; 604  :         if (!kvz_encoder_state_init(new_child, child_state)) {

	mov	rdx, rbx

; 215  :   state->wfrow->lcu_offset_y = lcu_offset_y;

	mov	DWORD PTR [rax], ebp

; 602  :         }
; 603  :         
; 604  :         if (!kvz_encoder_state_init(new_child, child_state)) {

	mov	rcx, rdi
	call	kvz_encoder_state_init
	test	eax, eax
	je	$LN406@kvz_encode

; 588  :       
; 589  :       for (i=0; i < num_rows; ++i) {

	inc	ebp
	inc	rsi
	add	r14, 424				; 000001a8H
	cmp	rsi, r15
	jl	SHORT $LL24@kvz_encode
$LN23@kvz_encode:

; 607  :         }
; 608  :       }
; 609  :     }
; 610  :     
; 611  :     child_state->is_leaf = (child_count == 0);

	xor	ebp, ebp
	test	r12d, r12d
	mov	eax, ebp
	sete	al
	mov	DWORD PTR [rbx+72], eax

; 612  :     //This node is a leaf, compute LCU-order
; 613  :     if (child_state->is_leaf) {

	test	r12d, r12d
	jne	$LN77@kvz_encode
	mov	r15, QWORD PTR encoder$1$[rsp]
$LN476@kvz_encode:

; 614  :       //All LCU computations are relative to the tile
; 615  :       //Remark: this could be optimized, but since it's run only once, it's better to do it in a understandable way.
; 616  :       
; 617  :       //By default, the full tile
; 618  :       int i;
; 619  :       int lcu_id;
; 620  :       int lcu_start = 0;
; 621  :       //End is the element AFTER the end (iterate < lcu_end)
; 622  :       int lcu_end = child_state->tile->frame->width_in_lcu * child_state->tile->frame->height_in_lcu;

	mov	rcx, QWORD PTR [rbx+48]
	mov	rax, QWORD PTR [rcx]
	mov	r9d, DWORD PTR [rax+28]
	mov	r8d, DWORD PTR [rax+24]

; 623  :       
; 624  :       //Restrict to the current slice if needed
; 625  :       lcu_start = MAX(lcu_start, child_state->slice->start_in_ts - child_state->tile->lcu_offset_in_ts);

	mov	rax, QWORD PTR [rbx+56]
	imul	r8d, r9d
	mov	r12d, DWORD PTR [rax+4]
	sub	r12d, DWORD PTR [rcx+28]

; 626  :       lcu_end = MIN(lcu_end, child_state->slice->end_in_ts - child_state->tile->lcu_offset_in_ts + 1);

	mov	eax, DWORD PTR [rax+8]
	cmovs	r12d, ebp
	sub	eax, DWORD PTR [rcx+28]
	inc	eax
	cmp	r8d, eax
	cmovge	r8d, eax

; 627  :       
; 628  :       //Restrict to the current wavefront row if needed
; 629  :       if (child_state->type == ENCODER_STATE_TYPE_WAVEFRONT_ROW) {

	cmp	DWORD PTR [rbx+8], 87			; 00000057H
	jne	SHORT $LN119@kvz_encode

; 630  :         lcu_start = MAX(lcu_start, (child_state->wfrow->lcu_offset_y) * child_state->tile->frame->width_in_lcu);

	mov	rax, QWORD PTR [rbx+64]
	mov	ecx, DWORD PTR [rax]
	mov	eax, r9d
	imul	eax, ecx
	cmp	r12d, eax
	cmovle	r12d, eax

; 631  :         lcu_end = MIN(lcu_end, (child_state->wfrow->lcu_offset_y + 1) * child_state->tile->frame->width_in_lcu);

	lea	eax, DWORD PTR [rcx+1]
	imul	eax, r9d
	cmp	r8d, eax
	cmovge	r8d, eax
$LN119@kvz_encode:

; 632  :       }
; 633  :       
; 634  :       child_state->lcu_order_count = lcu_end - lcu_start;

	sub	r8d, r12d
	mov	eax, r8d

; 635  :       child_state->lcu_order = MALLOC(lcu_order_element_t, child_state->lcu_order_count);

	imul	rcx, rax, 88				; 00000058H
	mov	DWORD PTR [rbx+88], eax
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+80], rax

; 636  :       assert(child_state->lcu_order);

	test	rax, rax
	jne	SHORT $LN120@kvz_encode
	mov	r8d, 636				; 0000027cH
	lea	rdx, OFFSET FLAT:$SG4294953150
	lea	rcx, OFFSET FLAT:$SG4294953149
	call	QWORD PTR __imp__wassert
$LN120@kvz_encode:

; 637  :       
; 638  :       for (i = 0; i < child_state->lcu_order_count; ++i) {

	cmp	DWORD PTR [rbx+88], 0
	jbe	$LN78@kvz_encode

; 682  :           child_state->lcu_order[i].left = &child_state->lcu_order[i-1];

	mov	esi, r12d
	mov	edi, r12d
	not	esi
	neg	edi
	mov	DWORD PTR tv5926[rsp], esi
	mov	r14, rbp
	mov	DWORD PTR tv5785[rsp], edi
	npad	10
$LL27@kvz_encode:

; 639  :         lcu_id = lcu_start + i;
; 640  :         child_state->lcu_order[i].encoder_state = child_state;
; 641  :         child_state->lcu_order[i].id = lcu_id;
; 642  :         child_state->lcu_order[i].index = i;

	mov	rax, QWORD PTR [rbx+80]
	lea	r13d, DWORD PTR [r12+rdi]

; 643  :         child_state->lcu_order[i].position.x = lcu_id % child_state->tile->frame->width_in_lcu;
; 644  :         child_state->lcu_order[i].position.y = lcu_id / child_state->tile->frame->width_in_lcu;
; 645  :         child_state->lcu_order[i].position_px.x = child_state->lcu_order[i].position.x * LCU_WIDTH;
; 646  :         child_state->lcu_order[i].position_px.y = child_state->lcu_order[i].position.y * LCU_WIDTH;
; 647  :         child_state->lcu_order[i].size.x = MIN(LCU_WIDTH, encoder->in.width - (child_state->tile->lcu_offset_x * LCU_WIDTH + child_state->lcu_order[i].position_px.x));

	mov	r8d, 64					; 00000040H
	mov	QWORD PTR [r14+rax+8], rbx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [r14+rax], r12d
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [r14+rax+4], r13d
	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, r12d
	cdq
	idiv	DWORD PTR [rcx+28]
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [r14+rax+16], edx
	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, r12d
	cdq
	idiv	DWORD PTR [rcx+28]
	mov	rcx, QWORD PTR [rbx+80]
	mov	DWORD PTR [r14+rcx+20], eax
	mov	rcx, QWORD PTR [rbx+80]
	mov	eax, DWORD PTR [rcx+r14+16]
	shl	eax, 6
	mov	DWORD PTR [rcx+r14+24], eax
	mov	rcx, QWORD PTR [rbx+80]
	mov	eax, DWORD PTR [rcx+r14+20]
	shl	eax, 6
	mov	DWORD PTR [rcx+r14+28], eax
	mov	rax, QWORD PTR [rbx+48]
	mov	rdx, QWORD PTR [rbx+80]
	mov	ecx, DWORD PTR [rax+12]
	neg	ecx
	shl	ecx, 6
	sub	ecx, DWORD PTR [rdx+r14+24]
	add	ecx, DWORD PTR [r15+2528]
	cmp	ecx, 64					; 00000040H
	cmovg	ecx, r8d
	mov	DWORD PTR [rdx+r14+32], ecx

; 648  :         child_state->lcu_order[i].size.y = MIN(LCU_WIDTH, encoder->in.height - (child_state->tile->lcu_offset_y * LCU_WIDTH + child_state->lcu_order[i].position_px.y));

	mov	rax, QWORD PTR [rbx+48]
	mov	rdx, QWORD PTR [rbx+80]
	mov	ecx, DWORD PTR [rax+16]
	neg	ecx
	shl	ecx, 6
	sub	ecx, DWORD PTR [rdx+r14+28]
	add	ecx, DWORD PTR [r15+2532]
	cmp	ecx, r8d
	cmovg	ecx, r8d
	mov	DWORD PTR [rdx+r14+36], ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 80   :   const int lcu_addr_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[lcu_addr_in_ts];

	mov	rdx, QWORD PTR [rbx]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 649  :         child_state->lcu_order[i].first_row = kvz_lcu_in_first_row(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	r8, QWORD PTR [rbx+48]
	mov	eax, DWORD PTR [r8+28]
	add	eax, r12d
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 80   :   const int lcu_addr_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[lcu_addr_in_ts];

	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+6416]
	mov	r9d, DWORD PTR [rax+rcx*4]

; 81   : 
; 82   :   if (lcu_addr_in_rs / state->encoder_control->in.width_in_lcu == state->tile->lcu_offset_y) {

	mov	eax, r9d
	mov	ecx, DWORD PTR [rdx+2536]
	cdq
	idiv	ecx
	mov	r10d, eax
	cmp	eax, DWORD PTR [r8+16]
	jne	SHORT $LN372@kvz_encode

; 83   :     return 1;

	mov	ecx, 1
	jmp	SHORT $LN374@kvz_encode
$LN406@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 605  :           fprintf(stderr, "Unable to init child...\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953151
	call	fprintf

; 606  :           return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN75@kvz_encode:

; 600  :           fprintf(stderr, "Could not initialize encoder_state->wfrow!\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953152
	call	fprintf

; 601  :           return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN372@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 86   :   if (lcu_addr_in_rs / state->encoder_control->in.width_in_lcu == state->slice->start_in_rs / state->encoder_control->in.width_in_lcu) {

	mov	rax, QWORD PTR [rbx+56]
	mov	r8d, DWORD PTR [rax+12]
	mov	eax, r8d
	cdq
	idiv	ecx
	cmp	r10d, eax
	jne	SHORT $LN373@kvz_encode

; 87   :     return 1;

	mov	ecx, 1
	jmp	SHORT $LN374@kvz_encode
$LN373@kvz_encode:

; 88   :   }
; 89   : 
; 90   :   //One row above is before the start of the slice => it's also a boundary
; 91   :   if (lcu_addr_in_rs - state->encoder_control->in.width_in_lcu < state->slice->start_in_rs) {

	sub	r9d, ecx
	mov	ecx, ebp
	cmp	r9d, r8d
	setl	cl
$LN374@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 649  :         child_state->lcu_order[i].first_row = kvz_lcu_in_first_row(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [r14+rax+44], ecx

; 650  :         child_state->lcu_order[i].last_row = kvz_lcu_in_last_row(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	r8, QWORD PTR [rbx+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 100  :   const int lcu_addr_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[lcu_addr_in_ts];

	mov	rdx, QWORD PTR [rbx]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 650  :         child_state->lcu_order[i].last_row = kvz_lcu_in_last_row(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	eax, DWORD PTR [r8+28]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 102  :   if (lcu_addr_in_rs / state->encoder_control->in.width_in_lcu == state->tile->lcu_offset_y + state->tile->frame->height_in_lcu - 1) {

	mov	r9d, DWORD PTR [rdx+2536]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 650  :         child_state->lcu_order[i].last_row = kvz_lcu_in_last_row(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	add	eax, r12d
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 100  :   const int lcu_addr_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[lcu_addr_in_ts];

	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdx+6416]
	mov	r11d, DWORD PTR [rax+rcx*4]

; 102  :   if (lcu_addr_in_rs / state->encoder_control->in.width_in_lcu == state->tile->lcu_offset_y + state->tile->frame->height_in_lcu - 1) {

	mov	eax, r11d
	mov	rcx, QWORD PTR [r8]
	cdq
	idiv	r9d
	mov	edx, DWORD PTR [r8+16]
	mov	ecx, DWORD PTR [rcx+24]
	dec	edx
	add	edx, ecx
	mov	r10d, eax
	cmp	eax, edx
	jne	SHORT $LN377@kvz_encode

; 103  :     return 1;

	mov	ecx, 1
	jmp	SHORT $LN379@kvz_encode
$LN377@kvz_encode:

; 104  :   }
; 105  : 
; 106  :   if (lcu_addr_in_rs / state->encoder_control->in.width_in_lcu == state->slice->end_in_rs / state->encoder_control->in.width_in_lcu) {

	mov	rax, QWORD PTR [rbx+56]
	mov	r8d, DWORD PTR [rax+16]
	mov	eax, r8d
	cdq
	idiv	r9d
	cmp	r10d, eax
	jne	SHORT $LN378@kvz_encode

; 107  :     return 1;

	mov	ecx, 1
	jmp	SHORT $LN379@kvz_encode
$LN378@kvz_encode:

; 108  :   }
; 109  : 
; 110  :   //One row below is before the end of the slice => it's also a boundary
; 111  :   if (lcu_addr_in_rs + state->encoder_control->in.width_in_lcu > state->slice->end_in_rs) {

	lea	eax, DWORD PTR [r11+r9]
	mov	ecx, ebp
	cmp	eax, r8d
	setg	cl
$LN379@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 650  :         child_state->lcu_order[i].last_row = kvz_lcu_in_last_row(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [r14+rax+52], ecx

; 651  :         child_state->lcu_order[i].first_column = kvz_lcu_in_first_column(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	r9, QWORD PTR [rbx+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 121  :   const int lcu_addr_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[lcu_addr_in_ts];

	mov	r8, QWORD PTR [rbx]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 651  :         child_state->lcu_order[i].first_column = kvz_lcu_in_first_column(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	eax, DWORD PTR [r9+28]
	add	eax, r12d
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 121  :   const int lcu_addr_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[lcu_addr_in_ts];

	movsxd	rcx, eax
	mov	rax, QWORD PTR [r8+6416]
	mov	r10d, DWORD PTR [rax+rcx*4]

; 122  : 
; 123  :   //First column of tile?
; 124  :   if (lcu_addr_in_rs % state->encoder_control->in.width_in_lcu == state->tile->lcu_offset_x) {

	mov	eax, r10d
	cdq
	idiv	DWORD PTR [r8+2536]
	cmp	edx, DWORD PTR [r9+12]
	jne	SHORT $LN382@kvz_encode

; 125  :     return 1;

	mov	ecx, 1
	jmp	SHORT $LN383@kvz_encode
$LN382@kvz_encode:

; 126  :   }
; 127  : 
; 128  :   //Slice start may not be aligned with the tile, so we need to allow this
; 129  :   if (lcu_addr_in_rs == state->slice->start_in_rs) {

	mov	rax, QWORD PTR [rbx+56]
	mov	ecx, ebp
	cmp	r10d, DWORD PTR [rax+12]
	sete	cl
$LN383@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 651  :         child_state->lcu_order[i].first_column = kvz_lcu_in_first_column(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [r14+rax+40], ecx

; 652  :         child_state->lcu_order[i].last_column = kvz_lcu_in_last_column(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	rdx, QWORD PTR [rbx+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 138  :   const int lcu_addr_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[lcu_addr_in_ts];

	mov	r9, QWORD PTR [rbx]
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 652  :         child_state->lcu_order[i].last_column = kvz_lcu_in_last_column(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	eax, DWORD PTR [rdx+28]
	add	eax, r12d
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-geometry.c

; 138  :   const int lcu_addr_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[lcu_addr_in_ts];

	movsxd	rcx, eax
	mov	rax, QWORD PTR [r9+6416]
	mov	r10d, DWORD PTR [rax+rcx*4]

; 139  : 
; 140  :   //First column of tile?
; 141  :   if (lcu_addr_in_rs % state->encoder_control->in.width_in_lcu == state->tile->lcu_offset_x + state->tile->frame->width_in_lcu - 1) {

	mov	rax, QWORD PTR [rdx]
	mov	ecx, DWORD PTR [rdx+12]
	dec	ecx
	mov	r8d, DWORD PTR [rax+28]
	mov	eax, r10d
	cdq
	add	r8d, ecx
	idiv	DWORD PTR [r9+2536]
	cmp	edx, r8d
	jne	SHORT $LN386@kvz_encode

; 142  :     return 1;

	mov	ecx, 1
	jmp	SHORT $LN387@kvz_encode
$LN386@kvz_encode:

; 143  :   }
; 144  : 
; 145  :   //Slice start may not be aligned with the tile, so we need to allow this
; 146  :   if (lcu_addr_in_rs == state->slice->end_in_rs) {

	mov	rax, QWORD PTR [rbx+56]
	mov	ecx, ebp
	cmp	r10d, DWORD PTR [rax+16]
	sete	cl
$LN387@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 652  :         child_state->lcu_order[i].last_column = kvz_lcu_in_last_column(child_state, child_state->tile->lcu_offset_in_ts + lcu_id);

	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [r14+rax+48], ecx

; 653  :         
; 654  :         child_state->lcu_order[i].above = NULL;

	mov	rax, QWORD PTR [rbx+80]
	mov	QWORD PTR [r14+rax+56], rbp

; 655  :         child_state->lcu_order[i].below = NULL;

	mov	rax, QWORD PTR [rbx+80]
	mov	QWORD PTR [r14+rax+64], rbp

; 656  :         child_state->lcu_order[i].left = NULL;

	mov	rax, QWORD PTR [rbx+80]
	mov	QWORD PTR [r14+rax+72], rbp

; 657  :         child_state->lcu_order[i].right = NULL;

	mov	rax, QWORD PTR [rbx+80]
	mov	QWORD PTR [r14+rax+80], rbp

; 658  :         
; 659  :         if (!child_state->lcu_order[i].first_row) {

	mov	rdx, QWORD PTR [rbx+80]
	cmp	DWORD PTR [r14+rdx+44], 0
	jne	$LN475@kvz_encode

; 660  :           //Find LCU above
; 661  :           if (child_state->type == ENCODER_STATE_TYPE_WAVEFRONT_ROW) {

	cmp	DWORD PTR [rbx+8], 87			; 00000057H
	jne	$LN81@kvz_encode

; 662  :             int j;
; 663  :             //For all previous wavefront rows
; 664  :             for (j=0; &child_state->parent->children[j] != child_state && child_state->parent->children[j].encoder_control; ++j) {

	mov	r8, QWORD PTR [rbx+24]
	mov	r15d, ebp
	cmp	QWORD PTR [r8+16], rbx
	je	$LN491@kvz_encode
	mov	rsi, rbp
	npad	11
$LL30@kvz_encode:
	mov	r10, QWORD PTR [r8+16]
	cmp	QWORD PTR [r10+rsi], 0
	je	$LN490@kvz_encode

; 665  :               if (child_state->parent->children[j].wfrow->lcu_offset_y == child_state->wfrow->lcu_offset_y - 1) {

	mov	rax, QWORD PTR [rbx+64]
	mov	r9, r8
	mov	rdx, QWORD PTR [r10+rsi+64]
	mov	ecx, DWORD PTR [rax]
	dec	ecx
	cmp	DWORD PTR [rdx], ecx
	jne	$LN28@kvz_encode

; 666  :                 int k;
; 667  :                 for (k=0; k < child_state->parent->children[j].lcu_order_count; ++k) {

	cmp	DWORD PTR [r10+rsi+88], 0
	mov	edi, ebp
	jbe	SHORT $LN28@kvz_encode
$LL33@kvz_encode:

; 668  :                   if (child_state->parent->children[j].lcu_order[k].position.x == child_state->lcu_order[i].position.x) {

	mov	rax, QWORD PTR [r8+16]
	mov	r9, QWORD PTR [rbx+80]
	mov	rcx, QWORD PTR [rax+rsi+80]
	mov	eax, DWORD PTR [r14+r9+16]
	cmp	DWORD PTR [rcx+rbp+16], eax
	jne	SHORT $LN31@kvz_encode

; 669  :                     assert(child_state->parent->children[j].lcu_order[k].position.y == child_state->lcu_order[i].position.y - 1);

	mov	eax, DWORD PTR [r14+r9+20]
	dec	eax
	cmp	DWORD PTR [rcx+rbp+20], eax
	je	SHORT $LN474@kvz_encode
	mov	r8d, 669				; 0000029dH
	lea	rdx, OFFSET FLAT:$SG4294953148
	lea	rcx, OFFSET FLAT:$SG4294953147
	call	QWORD PTR __imp__wassert
	mov	r8, QWORD PTR [rbx+24]
	mov	r9, QWORD PTR [rbx+80]
$LN474@kvz_encode:

; 670  :                     child_state->lcu_order[i].above = &child_state->parent->children[j].lcu_order[k];

	mov	rdx, QWORD PTR [r8+16]
	movsxd	rax, edi
	imul	rcx, rax, 88				; 00000058H
	add	rcx, QWORD PTR [rdx+rsi+80]
	mov	QWORD PTR [r14+r9+56], rcx
$LN31@kvz_encode:

; 666  :                 int k;
; 667  :                 for (k=0; k < child_state->parent->children[j].lcu_order_count; ++k) {

	mov	r9, QWORD PTR [rbx+24]
	inc	edi
	add	rbp, 88					; 00000058H
	mov	r8, r9
	mov	rax, QWORD PTR [r9+16]
	cmp	edi, DWORD PTR [rax+rsi+88]
	jb	SHORT $LL33@kvz_encode
	xor	ebp, ebp
$LN28@kvz_encode:

; 662  :             int j;
; 663  :             //For all previous wavefront rows
; 664  :             for (j=0; &child_state->parent->children[j] != child_state && child_state->parent->children[j].encoder_control; ++j) {

	inc	r15d
	add	rsi, 424				; 000001a8H
	movsxd	rax, r15d
	mov	r8, r9
	imul	rcx, rax, 424				; 000001a8H
	add	rcx, QWORD PTR [r9+16]
	cmp	rcx, rbx
	jne	$LL30@kvz_encode
$LN490@kvz_encode:

; 677  :           }
; 678  :           assert(child_state->lcu_order[i].above);

	mov	esi, DWORD PTR tv5926[rsp]
	mov	edi, DWORD PTR tv5785[rsp]
$LN491@kvz_encode:
	mov	r15, QWORD PTR encoder$1$[rsp]
$LN82@kvz_encode:
	mov	rdx, QWORD PTR [rbx+80]
	cmp	QWORD PTR [r14+rdx+56], 0
	jne	SHORT $LN126@kvz_encode
	mov	r8d, 678				; 000002a6H
	lea	rdx, OFFSET FLAT:$SG4294953146
	lea	rcx, OFFSET FLAT:$SG4294953145
	call	QWORD PTR __imp__wassert
	mov	rdx, QWORD PTR [rbx+80]
$LN126@kvz_encode:

; 679  :           child_state->lcu_order[i].above->below = &child_state->lcu_order[i];

	movsxd	rax, r13d
	imul	rcx, rax, 88				; 00000058H
	mov	rax, QWORD PTR [r14+rdx+56]
	add	rcx, rdx
	mov	QWORD PTR [rax+64], rcx
	mov	rdx, QWORD PTR [rbx+80]
$LN475@kvz_encode:

; 680  :         }
; 681  :         if (!child_state->lcu_order[i].first_column) {

	cmp	DWORD PTR [r14+rdx+40], 0
	jne	SHORT $LN25@kvz_encode

; 682  :           child_state->lcu_order[i].left = &child_state->lcu_order[i-1];

	lea	eax, DWORD PTR [r12+rsi]
	movsxd	rcx, eax
	imul	rax, rcx, 88				; 00000058H
	add	rax, rdx
	mov	QWORD PTR [r14+rdx+72], rax

; 683  :           assert(child_state->lcu_order[i].left->position.x == child_state->lcu_order[i].position.x - 1);

	mov	rdx, QWORD PTR [rbx+80]
	mov	rcx, QWORD PTR [r14+rdx+72]
	mov	eax, DWORD PTR [r14+rdx+16]
	dec	eax
	cmp	DWORD PTR [rcx+16], eax
	je	SHORT $LN127@kvz_encode
	mov	r8d, 683				; 000002abH
	lea	rdx, OFFSET FLAT:$SG4294953144
	lea	rcx, OFFSET FLAT:$SG4294953143
	call	QWORD PTR __imp__wassert
	mov	rdx, QWORD PTR [rbx+80]
$LN127@kvz_encode:

; 684  :           child_state->lcu_order[i].left->right = &child_state->lcu_order[i];

	movsxd	rax, r13d
	imul	rcx, rax, 88				; 00000058H
	mov	rax, QWORD PTR [r14+rdx+72]
	add	rcx, rdx
	mov	QWORD PTR [rax+80], rcx
$LN25@kvz_encode:

; 637  :       
; 638  :       for (i = 0; i < child_state->lcu_order_count; ++i) {

	inc	r12d
	add	r14, 88					; 00000058H
	lea	eax, DWORD PTR [r12+rdi]
	cmp	eax, DWORD PTR [rbx+88]
	jb	$LL27@kvz_encode

; 685  :         }
; 686  :       }
; 687  :     } else {

	jmp	SHORT $LN78@kvz_encode
$LN81@kvz_encode:

; 671  :                   }
; 672  :                 }
; 673  :               }
; 674  :             }
; 675  :           } else {
; 676  :             child_state->lcu_order[i].above = &child_state->lcu_order[i-child_state->tile->frame->width_in_lcu];

	mov	rax, QWORD PTR [rbx+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, r13d
	sub	eax, DWORD PTR [rcx+28]
	cdqe
	imul	rcx, rax, 88				; 00000058H
	add	rcx, rdx
	mov	QWORD PTR [r14+rdx+56], rcx
	jmp	$LN82@kvz_encode
$LN77@kvz_encode:

; 688  :       child_state->lcu_order_count = 0;

	mov	DWORD PTR [rbx+88], ebp

; 689  :       child_state->lcu_order = NULL;

	mov	QWORD PTR [rbx+80], rbp
$LN78@kvz_encode:

; 690  :     }
; 691  :   }
; 692  :   
; 693  :   //Validate the structure
; 694  :   if (child_state->type == ENCODER_STATE_TYPE_TILE) {

	mov	eax, DWORD PTR [rbx+8]
	cmp	eax, 84					; 00000054H
	jne	SHORT $LN443@kvz_encode

; 695  :     if (child_state->tile->lcu_offset_in_ts < child_state->slice->start_in_ts) {

	mov	rdi, QWORD PTR [rbx+48]
	mov	rbx, QWORD PTR [rbx+56]
	mov	edx, DWORD PTR [rdi+28]
	cmp	edx, DWORD PTR [rbx+4]
	jge	SHORT $LN87@kvz_encode

; 696  :       fprintf(stderr, "Tile %d starts before slice %d, in which it should be included!\n", child_state->tile->id, child_state->slice->id);

	lea	ecx, QWORD PTR [rax-82]
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG4294953142
	mov	r8d, DWORD PTR [rdi+8]
	mov	rcx, rax
	call	fprintf

; 697  :       return 0;

	xor	eax, eax
	jmp	$LN501@kvz_encode
$LN87@kvz_encode:

; 698  :     }
; 699  :     if (child_state->tile->lcu_offset_in_ts + child_state->tile->frame->width_in_lcu * child_state->tile->frame->height_in_lcu - 1 > child_state->slice->end_in_ts) {

	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+28]
	imul	ecx, DWORD PTR [rax+24]
	lea	eax, DWORD PTR [rdx-1]
	add	eax, ecx
	cmp	eax, DWORD PTR [rbx+8]
	jle	$LN91@kvz_encode

; 700  :       fprintf(stderr, "Tile %d ends after slice %d, in which it should be included!\n", child_state->tile->id, child_state->slice->id);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [rbx]
	lea	rdx, OFFSET FLAT:$SG4294953141
	mov	r8d, DWORD PTR [rdi+8]
	mov	rcx, rax
	call	fprintf

; 701  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN501@kvz_encode
$LN443@kvz_encode:

; 702  :     }
; 703  :   }
; 704  :   
; 705  :   if (child_state->type == ENCODER_STATE_TYPE_SLICE) {

	cmp	eax, 83					; 00000053H
	jne	SHORT $LN91@kvz_encode

; 706  :     if (child_state->slice->start_in_ts < child_state->tile->lcu_offset_in_ts) {

	mov	rdi, QWORD PTR [rbx+48]
	mov	rbx, QWORD PTR [rbx+56]
	mov	edx, DWORD PTR [rdi+28]
	cmp	DWORD PTR [rbx+4], edx
	jge	SHORT $LN90@kvz_encode

; 707  :       fprintf(stderr, "Slice %d starts before tile %d, in which it should be included!\n", child_state->slice->id, child_state->tile->id);

	lea	ecx, QWORD PTR [rax-81]
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG4294953140
	mov	r8d, DWORD PTR [rbx]
	mov	rcx, rax
	call	fprintf

; 708  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN501@kvz_encode
$LN90@kvz_encode:

; 709  :     }
; 710  :     if (child_state->slice->end_in_ts > child_state->tile->lcu_offset_in_ts + child_state->tile->frame->width_in_lcu * child_state->tile->frame->height_in_lcu - 1) {

	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+28]
	imul	ecx, DWORD PTR [rax+24]
	lea	eax, DWORD PTR [rdx-1]
	add	eax, ecx
	cmp	DWORD PTR [rbx+8], eax
	jle	SHORT $LN91@kvz_encode

; 711  :       fprintf(stderr, "Slice %d ends after tile %d, in which it should be included!\n", child_state->slice->id, child_state->tile->id);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [rdi+8]
	lea	rdx, OFFSET FLAT:$SG4294953139
	mov	r8d, DWORD PTR [rbx]
	mov	rcx, rax
	call	fprintf

; 712  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN501@kvz_encode
$LN91@kvz_encode:

; 713  :     }
; 714  :   }
; 715  :   
; 716  : #ifdef KVZ_DEBUG_PRINT_THREADING_INFO
; 717  :   if (!parent_state) encoder_state_dump_graphviz(child_state);
; 718  : #endif //KVZ_DEBUG_PRINT_THREADING_INFO
; 719  :   return 1;

	mov	eax, 1
$LN501@kvz_encode:
	mov	r14, QWORD PTR [rsp+128]
	mov	r13, QWORD PTR [rsp+136]
	mov	r12, QWORD PTR [rsp+144]
	mov	r15, QWORD PTR [rsp+120]

; 720  : }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
kvz_encoder_state_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\constraint.c
; File F:\open_codec_learn_2021\kvazaar-master\src\ml_intra_cu_depth_pred.c
; File F:\open_codec_learn_2021\kvazaar-master\src\constraint.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
_TEXT	SEGMENT
state$ = 48
kvz_encoder_state_finalize PROC

; 722  : void kvz_encoder_state_finalize(encoder_state_t * const state) {

$LN116:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rsp+48], rbp
	mov	rdi, rcx

; 723  :   if (state->children) {

	mov	rcx, QWORD PTR [rcx+16]
	xor	ebp, ebp
	mov	QWORD PTR [rsp+56], rsi
	test	rcx, rcx
	je	SHORT $LN5@kvz_encode

; 724  :     int i=0;
; 725  :     for (i = 0; state->children[i].encoder_control; ++i) {

	mov	esi, ebp
	cmp	QWORD PTR [rcx], rsi
	je	SHORT $LN3@kvz_encode
	mov	ebx, ebp
	npad	5
$LL4@kvz_encode:

; 726  :       kvz_encoder_state_finalize(&state->children[i]);

	movsxd	rax, esi
	imul	rcx, rax, 424				; 000001a8H
	add	rcx, QWORD PTR [rdi+16]
	call	kvz_encoder_state_finalize
	mov	rcx, QWORD PTR [rdi+16]
	lea	rbx, QWORD PTR [rbx+424]
	inc	esi
	cmp	QWORD PTR [rbx+rcx], rbp
	jne	SHORT $LL4@kvz_encode
$LN3@kvz_encode:

; 727  :     }
; 728  : 
; 729  :     FREE_POINTER(state->children);

	call	QWORD PTR __imp_free
	mov	QWORD PTR [rdi+16], rbp
$LN5@kvz_encode:

; 730  :   }
; 731  :   
; 732  :   FREE_POINTER(state->lcu_order);

	mov	rcx, QWORD PTR [rdi+80]
	call	QWORD PTR __imp_free

; 733  :   state->lcu_order_count = 0;
; 734  :   
; 735  :   if (!state->parent || (state->parent->wfrow != state->wfrow)) {

	mov	rcx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rdi+80], rbp
	mov	DWORD PTR [rdi+88], ebp
	test	rcx, rcx
	je	SHORT $LN107@kvz_encode
	mov	rax, QWORD PTR [rdi+64]
	cmp	QWORD PTR [rcx+64], rax
	je	SHORT $LN113@kvz_encode
$LN107@kvz_encode:

; 736  :     FREE_POINTER(state->wfrow);

	mov	rcx, QWORD PTR [rdi+64]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rdi+64], rbp

; 737  :   }
; 738  :   
; 739  :   if (!state->parent || (state->parent->slice != state->slice)) {

	test	rcx, rcx
	je	SHORT $LN108@kvz_encode
$LN113@kvz_encode:
	mov	rax, QWORD PTR [rdi+56]
	cmp	QWORD PTR [rcx+56], rax
	je	SHORT $LN112@kvz_encode
$LN108@kvz_encode:

; 740  :     FREE_POINTER(state->slice);

	mov	rcx, QWORD PTR [rdi+56]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rdi+56], rbp

; 741  :   }
; 742  :   
; 743  :   if (!state->parent || (state->parent->tile != state->tile)) {

	test	rcx, rcx
	je	SHORT $LN109@kvz_encode
$LN112@kvz_encode:
	mov	rax, QWORD PTR [rdi+48]
	cmp	QWORD PTR [rcx+48], rax
	je	SHORT $LN111@kvz_encode
$LN109@kvz_encode:

; 744  :     encoder_state_config_tile_finalize(state);

	mov	rcx, rdi
	call	encoder_state_config_tile_finalize

; 745  :     FREE_POINTER(state->tile);

	mov	rcx, QWORD PTR [rdi+48]
	call	QWORD PTR __imp_free
	mov	rcx, QWORD PTR [rdi+24]
	mov	QWORD PTR [rdi+48], rbp

; 746  :   }
; 747  :   
; 748  :   if (!state->parent || (state->parent->frame != state->frame)) {

	test	rcx, rcx
	je	SHORT $LN110@kvz_encode
$LN111@kvz_encode:
	mov	rax, QWORD PTR [rdi+40]
	cmp	QWORD PTR [rcx+40], rax
	je	$LN12@kvz_encode
$LN110@kvz_encode:

; 100  :   if (state->frame == NULL) return;

	mov	rbx, QWORD PTR [rdi+40]
	test	rbx, rbx
	je	$LN63@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 75   :     delete static_cast<std::mutex*>(*mutex);

	mov	rsi, QWORD PTR [rbx+168]
	test	rsi, rsi
	je	SHORT $LN73@kvz_encode
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 44   :         _Mtx_destroy_in_situ(_Mymtx());

	mov	rcx, rsi
	call	QWORD PTR __imp__Mtx_destroy_in_situ
	mov	edx, 80					; 00000050H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN73@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 76   :     *mutex = nullptr;

	mov	QWORD PTR [rbx+168], rbp
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 103  :   if (state->frame->c_para) FREE_POINTER(state->frame->c_para);

	mov	rcx, QWORD PTR [rdi+40]
	mov	rax, QWORD PTR [rcx+232]
	test	rax, rax
	je	SHORT $LN65@kvz_encode
	mov	rcx, rax
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rax+232], rbp
	mov	rcx, QWORD PTR [rdi+40]
$LN65@kvz_encode:

; 104  :   if (state->frame->k_para) FREE_POINTER(state->frame->k_para);

	mov	rax, QWORD PTR [rcx+240]
	test	rax, rax
	je	SHORT $LN66@kvz_encode
	mov	rcx, rax
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rax+240], rbp
	mov	rcx, QWORD PTR [rdi+40]
$LN66@kvz_encode:

; 105  : 
; 106  :   kvz_image_list_destroy(state->frame->ref);

	mov	rcx, QWORD PTR [rcx+40]
	call	kvz_image_list_destroy

; 107  :   FREE_POINTER(state->frame->lcu_stats);

	mov	rcx, QWORD PTR [rdi+40]
	mov	rcx, QWORD PTR [rcx+160]
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rax+160], rbp

; 108  :   FREE_POINTER(state->frame->aq_offsets);

	mov	rcx, QWORD PTR [rdi+40]
	mov	rcx, QWORD PTR [rcx+192]
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rax+192], rbp
	mov	rbx, QWORD PTR [rdi+40]
$LN63@kvz_encode:

; 749  :     encoder_state_config_frame_finalize(state);
; 750  :     FREE_POINTER(state->frame);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
	mov	QWORD PTR [rdi+40], rbp
$LN12@kvz_encode:

; 751  :   }
; 752  :   
; 753  :   if (state->constraint) {

	mov	rsi, QWORD PTR [rdi+416]
	test	rsi, rsi
	je	SHORT $LN80@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\constraint.c

; 66   :   if (constr->ml_intra_depth_ctu) 

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	SHORT $LN83@kvz_encode
; File F:\open_codec_learn_2021\kvazaar-master\src\ml_intra_cu_depth_pred.c

; 859  : 	FREE_POINTER(ml_intra_depth_ctu->_mat_lower_depth);

	mov	rcx, QWORD PTR [rbx+16]
	call	QWORD PTR __imp_free

; 860  : 	FREE_POINTER(ml_intra_depth_ctu->_mat_upper_depth);

	mov	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rbx+16], rbp
	call	QWORD PTR __imp_free

; 861  : 
; 862  : 	FREE_POINTER(ml_intra_depth_ctu);

	mov	rcx, rbx
	mov	QWORD PTR [rbx+8], rbp
	call	QWORD PTR __imp_free
$LN83@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\constraint.c

; 70   :   FREE_POINTER(constr);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN80@kvz_encode:
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 202  :   kvz_bitstream_free_chunks(stream->first);

	mov	rcx, QWORD PTR [rdi+104]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+48]

; 113  :   while (chunk != NULL) {

	test	rcx, rcx
	je	SHORT $LN91@kvz_encode
	npad	4
$LL90@kvz_encode:

; 114  :     kvz_data_chunk *next = chunk->next;

	mov	rbx, QWORD PTR [rcx+4104]

; 115  :     free(chunk);

	call	QWORD PTR __imp_free

; 116  :     chunk = next;

	mov	rcx, rbx
	test	rbx, rbx
	jne	SHORT $LL90@kvz_encode
$LN91@kvz_encode:
	xorps	xmm0, xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 760  :   kvz_threadqueue_free_job(&state->tqj_recon_done);

	lea	rcx, QWORD PTR [rdi+400]
; File F:\open_codec_learn_2021\kvazaar-master\src\bitstream.c

; 74   :   memset(stream, 0, sizeof(bitstream_t));

	movups	XMMWORD PTR [rdi+96], xmm0
	movups	XMMWORD PTR [rdi+112], xmm0
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 760  :   kvz_threadqueue_free_job(&state->tqj_recon_done);

	call	kvz_threadqueue_free_job

; 761  :   kvz_threadqueue_free_job(&state->tqj_bitstream_written);

	lea	rcx, QWORD PTR [rdi+408]

; 762  : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 761  :   kvz_threadqueue_free_job(&state->tqj_bitstream_written);

	jmp	kvz_threadqueue_free_job
kvz_encoder_state_finalize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 954  :     {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rbx, rax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;
; 961  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
_TEXT	SEGMENT
state$ = 48
encoder_state_config_frame_init PROC

; 52   : static int encoder_state_config_frame_init(encoder_state_t * const state) {

	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
; File F:\open_codec_learn_2021\kvazaar-master\src\imagelist.c

; 49   :   image_list_t *list = (image_list_t *)malloc(sizeof(image_list_t));

	mov	ecx, 40					; 00000028H
	call	QWORD PTR __imp_malloc

; 50   :   list->size      = size;
; 51   :   list->images    = malloc(sizeof(kvz_picture*)  * size);

	mov	ecx, 128				; 00000080H
	mov	rbx, rax
	mov	DWORD PTR [rax+32], 16
	call	QWORD PTR __imp_malloc

; 52   :   list->cu_arrays = malloc(sizeof(cu_array_t*)   * size);

	mov	ecx, 128				; 00000080H
	mov	QWORD PTR [rbx], rax
	call	QWORD PTR __imp_malloc

; 53   :   list->pocs      = malloc(sizeof(int32_t)       * size);

	mov	ecx, 64					; 00000040H
	mov	QWORD PTR [rbx+8], rax
	call	QWORD PTR __imp_malloc

; 54   :   list->ref_LXs   = malloc(sizeof(*list->ref_LXs) * size);

	mov	ecx, 512				; 00000200H
	mov	QWORD PTR [rbx+16], rax
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx+24], rax

; 55   :   list->used_size = 0;

	xor	r14d, r14d
	mov	DWORD PTR [rbx+36], r14d
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 53   :   state->frame->ref = kvz_image_list_alloc(MAX_REF_PIC_COUNT);

	mov	rax, QWORD PTR [rsi+40]
	mov	QWORD PTR [rax+40], rbx

; 54   :   if(!state->frame->ref) {

	mov	rax, QWORD PTR [rsi+40]
	cmp	QWORD PTR [rax+40], r14
	jne	SHORT $LN8@encoder_st

; 55   :     fprintf(stderr, "Failed to allocate the picture list!\n");

	lea	ecx, QWORD PTR [r14+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294953179
	call	fprintf

; 56   :     return 0;

	xor	eax, eax

; 97   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN8@encoder_st:

; 57   :   }
; 58   :   state->frame->ref_list = REF_PIC_LIST_0;

	mov	BYTE PTR [rax+48], r14b

; 59   :   state->frame->num = 0;
; 60   :   state->frame->poc = 0;
; 61   :   state->frame->total_bits_coded = 0;
; 62   :   state->frame->cur_frame_bits_coded = 0;
; 63   :   state->frame->cur_gop_bits_coded = 0;
; 64   :   state->frame->prepared = 0;
; 65   :   state->frame->done = 1;
; 66   : 
; 67   :   state->frame->rc_alpha = 3.2003;

	mov	rcx, 4614388853743754307		; 40099a36e2eb1c43H
	mov	rax, QWORD PTR [rsi+40]

; 68   :   state->frame->rc_beta = -1.367;
; 69   :   state->frame->icost = 0;
; 70   : 
; 71   :   const encoder_control_t * const encoder = state->encoder_control;
; 72   :   const int num_lcus = encoder->in.width_in_lcu * encoder->in.height_in_lcu;
; 73   :   state->frame->lcu_stats = calloc(num_lcus, sizeof(lcu_stats_t));

	mov	edx, 72					; 00000048H
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], rdi
	mov	DWORD PTR [rax+8], r14d
	mov	rax, QWORD PTR [rsi+40]
	mov	DWORD PTR [rax+12], r14d
	mov	rax, QWORD PTR [rsi+40]
	mov	QWORD PTR [rax+96], r14
	mov	rax, QWORD PTR [rsi+40]
	mov	QWORD PTR [rax+112], r14
	mov	rax, QWORD PTR [rsi+40]
	mov	QWORD PTR [rax+104], r14
	mov	rax, QWORD PTR [rsi+40]
	mov	BYTE PTR [rax+152], r14b
	mov	rax, QWORD PTR [rsi+40]
	mov	BYTE PTR [rax+153], 1
	mov	rax, QWORD PTR [rsi+40]
	mov	QWORD PTR [rax+136], rcx
	mov	rcx, -4614536796991513428		; bff5df3b645a1cacH
	mov	rax, QWORD PTR [rsi+40]
	mov	QWORD PTR [rax+144], rcx
	mov	rax, QWORD PTR [rsi+40]
	mov	QWORD PTR [rax+208], r14
	mov	rdi, QWORD PTR [rsi]
	mov	eax, DWORD PTR [rdi+2536]
	imul	eax, DWORD PTR [rdi+2540]
	movsxd	rbx, eax
	mov	rcx, rbx
	call	QWORD PTR __imp_calloc
	mov	rcx, QWORD PTR [rsi+40]

; 74   :   state->frame->aq_offsets = MALLOC(double, num_lcus);

	lea	rbp, QWORD PTR [rbx*8]
	mov	QWORD PTR [rcx+160], rax
	mov	rcx, rbp
	call	QWORD PTR __imp_malloc
	mov	rcx, QWORD PTR [rsi+40]

; 75   : 
; 76   :   for (int y = 0; y < encoder->in.height_in_lcu; y++) {

	mov	r10d, r14d
	mov	QWORD PTR [rcx+192], rax
	cmp	DWORD PTR [rdi+2540], r14d
	jle	SHORT $LN3@encoder_st

; 59   :   state->frame->num = 0;
; 60   :   state->frame->poc = 0;
; 61   :   state->frame->total_bits_coded = 0;
; 62   :   state->frame->cur_frame_bits_coded = 0;
; 63   :   state->frame->cur_gop_bits_coded = 0;
; 64   :   state->frame->prepared = 0;
; 65   :   state->frame->done = 1;
; 66   : 
; 67   :   state->frame->rc_alpha = 3.2003;

	mov	edx, DWORD PTR [rdi+2536]
	mov	ebx, r14d
$LL4@encoder_st:

; 77   :     for (int x = 0; x < encoder->in.width_in_lcu; x++) {

	mov	r9d, r14d
	test	edx, edx
	jle	SHORT $LN2@encoder_st
	mov	r11d, r14d
$LL7@encoder_st:

; 78   :       int temp = MIN(encoder->cfg.width - x * 64, 64) * MIN(encoder->cfg.height - y * 64, 64);

	mov	eax, DWORD PTR [rdi+12]
	mov	ecx, 64					; 00000040H
	sub	eax, r11d
	mov	r8d, 64					; 00000040H
	cmp	eax, ecx
	cmovl	ecx, eax
	mov	eax, DWORD PTR [rdi+16]
	sub	eax, ebx
	cmp	eax, r8d
	cmovl	r8d, eax

; 79   :       state->frame->lcu_stats[x + y * encoder->in.width_in_lcu].pixels = temp;

	imul	edx, r10d
	imul	r8d, ecx
	add	r11d, 64				; 00000040H
	lea	eax, DWORD PTR [r9+rdx]
	inc	r9d
	cdqe
	lea	rdx, QWORD PTR [rax+rax*8]
	mov	rax, QWORD PTR [rsi+40]
	mov	rcx, QWORD PTR [rax+160]
	mov	DWORD PTR [rcx+rdx*8+4], r8d
	mov	edx, DWORD PTR [rdi+2536]
	cmp	r9d, edx
	jl	SHORT $LL7@encoder_st
$LN2@encoder_st:

; 75   : 
; 76   :   for (int y = 0; y < encoder->in.height_in_lcu; y++) {

	inc	r10d
	add	ebx, 64					; 00000040H
	cmp	r10d, DWORD PTR [rdi+2540]
	jl	SHORT $LL4@encoder_st
$LN3@encoder_st:

; 80   :     }
; 81   :   }
; 82   : 
; 83   :   state->frame->c_para = malloc(sizeof(double) * num_lcus);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc
	mov	rdx, QWORD PTR [rsi+40]
	mov	QWORD PTR [rdx+232], rax

; 84   :   if(state->frame->c_para == NULL) {

	mov	rax, QWORD PTR [rsi+40]
	cmp	QWORD PTR [rax+232], r14
	je	SHORT $LN81@encoder_st

; 85   :     return 0;
; 86   :   }
; 87   :   state->frame->k_para = malloc(sizeof(double) * num_lcus);

	mov	rcx, rbp
	call	QWORD PTR __imp_malloc
	mov	rcx, QWORD PTR [rsi+40]
	mov	QWORD PTR [rcx+240], rax

; 88   :   if (state->frame->k_para == NULL) {

	mov	rdi, QWORD PTR [rsi+40]
	cmp	QWORD PTR [rdi+240], r14
	je	SHORT $LN81@encoder_st
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	ecx, 80					; 00000050H
	call	??2@YAPEAX_K@Z				; operator new
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	mov	edx, 2
	mov	rcx, rax
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	rbx, rax
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	call	QWORD PTR __imp__Mtx_init_in_situ
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 94   :   state->frame->new_ratecontrol = kvz_get_rc_data(NULL);

	mov	rax, QWORD PTR data
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	QWORD PTR [rdi+168], rbx
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 94   :   state->frame->new_ratecontrol = kvz_get_rc_data(NULL);

	mov	rcx, QWORD PTR [rsi+40]
	mov	QWORD PTR [rcx+176], rax

; 95   : 
; 96   :   return 1;

	mov	eax, 1
	jmp	SHORT $LN83@encoder_st
$LN81@encoder_st:

; 89   :     return 0;

	xor	eax, eax
$LN83@encoder_st:
	mov	rbp, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+56]

; 97   : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
encoder_state_config_frame_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
_TEXT	SEGMENT
state$ = 48
encoder_state_config_frame_finalize PROC

; 99   : static void encoder_state_config_frame_finalize(encoder_state_t * const state) {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 100  :   if (state->frame == NULL) return;

	mov	rdi, QWORD PTR [rcx+40]
	mov	rbx, rcx
	test	rdi, rdi
	je	$LN1@encoder_st
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 75   :     delete static_cast<std::mutex*>(*mutex);

	mov	QWORD PTR [rsp+48], rsi
	mov	rsi, QWORD PTR [rdi+168]
	test	rsi, rsi
	je	SHORT $LN11@encoder_st
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 44   :         _Mtx_destroy_in_situ(_Mymtx());

	mov	rcx, rsi
	call	QWORD PTR __imp__Mtx_destroy_in_situ
	mov	edx, 80					; 00000050H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN11@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 76   :     *mutex = nullptr;

	xor	esi, esi
	mov	QWORD PTR [rdi+168], rsi
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 103  :   if (state->frame->c_para) FREE_POINTER(state->frame->c_para);

	mov	rcx, QWORD PTR [rbx+40]
	mov	rax, QWORD PTR [rcx+232]
	test	rax, rax
	je	SHORT $LN3@encoder_st
	mov	rcx, rax
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rax+232], rsi
	mov	rcx, QWORD PTR [rbx+40]
$LN3@encoder_st:

; 104  :   if (state->frame->k_para) FREE_POINTER(state->frame->k_para);

	mov	rax, QWORD PTR [rcx+240]
	test	rax, rax
	je	SHORT $LN4@encoder_st
	mov	rcx, rax
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rax+240], rsi
	mov	rcx, QWORD PTR [rbx+40]
$LN4@encoder_st:

; 105  : 
; 106  :   kvz_image_list_destroy(state->frame->ref);

	mov	rcx, QWORD PTR [rcx+40]
	call	kvz_image_list_destroy

; 107  :   FREE_POINTER(state->frame->lcu_stats);

	mov	rcx, QWORD PTR [rbx+40]
	mov	rcx, QWORD PTR [rcx+160]
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rax+160], rsi

; 108  :   FREE_POINTER(state->frame->aq_offsets);

	mov	rcx, QWORD PTR [rbx+40]
	mov	rcx, QWORD PTR [rcx+192]
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR [rax+192], rsi
	mov	rsi, QWORD PTR [rsp+48]
$LN1@encoder_st:

; 109  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
encoder_state_config_frame_finalize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
_TEXT	SEGMENT
chroma_sizes_hor$ = 32
chroma_sizes_ver$ = 48
state$ = 112
lcu_offset_x$ = 120
lcu_offset_y$ = 128
width$ = 136
height$ = 144
width_in_lcu$dead$ = 152
height_in_lcu$dead$ = 160
encoder_state_config_tile_init PROC

; 113  :                                           const int width, const int height, const int width_in_lcu, const int height_in_lcu) {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 114  :   
; 115  :   const encoder_control_t * const encoder = state->encoder_control;

	mov	r14, QWORD PTR [rcx]
	mov	r12d, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c

; 50   :   videoframe_t *frame = calloc(1, sizeof(videoframe_t));

	mov	edx, 64					; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 113  :                                           const int width, const int height, const int width_in_lcu, const int height_in_lcu) {

	mov	rsi, rcx
	mov	ebx, r9d
	mov	r15d, r8d

; 116  :   state->tile->frame = kvz_videoframe_alloc(width, height, state->encoder_control->chroma_format);

	mov	ebp, DWORD PTR [r14+2596]
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c

; 50   :   videoframe_t *frame = calloc(1, sizeof(videoframe_t));

	lea	ecx, QWORD PTR [rdx-63]
	call	QWORD PTR __imp_calloc

; 51   :   if (!frame) return 0;

	xor	r13d, r13d
	mov	rdi, rax
	test	rax, rax
	jne	SHORT $LN13@encoder_st
	mov	edi, r13d
	jmp	SHORT $LN14@encoder_st
$LN13@encoder_st:

; 52   : 
; 53   :   frame->width  = width;
; 54   :   frame->height = height;

	mov	ecx, DWORD PTR height$[rsp]
	mov	DWORD PTR [rax+20], ecx
	mov	DWORD PTR [rax+16], ebx

; 55   :   frame->width_in_lcu  = CEILDIV(frame->width,  LCU_WIDTH);

	lea	eax, DWORD PTR [rbx+63]
	cdq
	and	edx, 63					; 0000003fH
	lea	r8d, DWORD PTR [rdx+rax]

; 56   :   frame->height_in_lcu = CEILDIV(frame->height, LCU_WIDTH);

	lea	eax, DWORD PTR [rcx+63]
	sar	r8d, 6
	cdq
	mov	DWORD PTR [rdi+28], r8d
	and	edx, 63					; 0000003fH
	add	eax, edx
	sar	eax, 6
	mov	DWORD PTR [rdi+24], eax

; 57   : 
; 58   :   frame->sao_luma = MALLOC(sao_info_t, frame->width_in_lcu * frame->height_in_lcu);

	imul	eax, r8d
	cdqe
	imul	rbx, rax, 68				; 00000044H
	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+40], rax

; 59   :   if (chroma_format != KVZ_CSP_400) {

	test	ebp, ebp
	je	SHORT $LN14@encoder_st

; 60   :     frame->sao_chroma = MALLOC(sao_info_t, frame->width_in_lcu * frame->height_in_lcu);

	mov	rcx, rbx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi+48], rax
$LN14@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 116  :   state->tile->frame = kvz_videoframe_alloc(width, height, state->encoder_control->chroma_format);

	mov	rax, QWORD PTR [rsi+48]
	lea	rbx, QWORD PTR [rsi+48]
	mov	QWORD PTR [rax], rdi

; 117  :   
; 118  :   state->tile->frame->rec = NULL;

	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx+8], r13

; 119  :   
; 120  :   state->tile->frame->source = NULL;

	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rcx], r13

; 121  : 
; 122  :   if (!state->tile->frame) {

	mov	rax, QWORD PTR [rbx]
	cmp	QWORD PTR [rax], r13
	jne	SHORT $LN5@encoder_st

; 123  :     printf("Error allocating videoframe!\r\n");

	lea	rcx, OFFSET FLAT:$SG4294953178
	call	printf

; 124  :     return 0;

	xor	eax, eax
	jmp	$LN1@encoder_st
$LN5@encoder_st:

; 125  :   }
; 126  : 
; 127  :   state->tile->lcu_offset_x = lcu_offset_x;

	mov	DWORD PTR [rax+12], r12d

; 128  :   state->tile->lcu_offset_y = lcu_offset_y;
; 129  :   state->tile->offset_x     = lcu_offset_x * LCU_WIDTH;

	mov	ecx, r12d
	mov	rax, QWORD PTR [rbx]
	shl	ecx, 6

; 130  :   state->tile->offset_y     = lcu_offset_y * LCU_WIDTH;
; 131  : 
; 132  :   state->tile->lcu_offset_in_ts = encoder->tiles_ctb_addr_rs_to_ts[lcu_offset_x + lcu_offset_y * encoder->in.width_in_lcu];
; 133  :   
; 134  :   // hor_buf_search and ver_buf_search store single row/col from each LCU row/col.
; 135  :   // Because these lines are independent, the chroma subsampling only matters in one
; 136  :   // of the directions, .
; 137  :   unsigned luma_size = LCU_WIDTH * state->tile->frame->width_in_lcu * state->tile->frame->height_in_lcu;
; 138  :   unsigned chroma_sizes_hor[] = { 0, luma_size / 2, luma_size / 2, luma_size };

	mov	DWORD PTR chroma_sizes_hor$[rsp], r13d

; 139  :   unsigned chroma_sizes_ver[] = { 0, luma_size / 2, luma_size, luma_size };

	mov	DWORD PTR chroma_sizes_ver$[rsp], r13d
	mov	DWORD PTR [rax+16], r15d
	mov	rax, QWORD PTR [rbx]
	mov	DWORD PTR [rax+20], ecx
	mov	ecx, r15d
	mov	rax, QWORD PTR [rbx]
	shl	ecx, 6
	mov	DWORD PTR [rax+24], ecx
	mov	eax, DWORD PTR [r14+2536]
	mov	rcx, QWORD PTR [rbx]
	imul	eax, r15d
	add	eax, r12d
	movsxd	rdx, eax
	mov	rax, QWORD PTR [r14+6408]
	mov	eax, DWORD PTR [rax+rdx*4]
	mov	DWORD PTR [rcx+28], eax
	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax]
	mov	edi, DWORD PTR [rcx+28]
	imul	edi, DWORD PTR [rcx+24]
	shl	edi, 6
	mov	eax, edi
	mov	DWORD PTR chroma_sizes_hor$[rsp+12], edi
	shr	eax, 1
	mov	DWORD PTR chroma_sizes_hor$[rsp+4], eax
	mov	DWORD PTR chroma_sizes_hor$[rsp+8], eax
	mov	DWORD PTR chroma_sizes_ver$[rsp+4], eax

; 140  :   unsigned chroma_size_hor = chroma_sizes_hor[state->encoder_control->chroma_format];

	mov	rax, QWORD PTR [rsi]
	mov	DWORD PTR chroma_sizes_ver$[rsp+8], edi
	mov	DWORD PTR chroma_sizes_ver$[rsp+12], edi
	movsxd	rcx, DWORD PTR [rax+2596]
	mov	esi, DWORD PTR chroma_sizes_hor$[rsp+rcx*4]

; 141  :   unsigned chroma_size_ver = chroma_sizes_ver[state->encoder_control->chroma_format];
; 142  : 
; 143  :   state->tile->hor_buf_search = kvz_yuv_t_alloc(luma_size, chroma_size_hor);

	mov	edx, esi
	mov	ebp, DWORD PTR chroma_sizes_ver$[rsp+rcx*4]
	mov	ecx, edi
	call	kvz_yuv_t_alloc
	mov	rcx, rax

; 144  :   state->tile->ver_buf_search = kvz_yuv_t_alloc(luma_size, chroma_size_ver);

	mov	edx, ebp
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+32], rcx
	mov	ecx, edi
	call	kvz_yuv_t_alloc
	mov	r8, rax
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+40], r8

; 145  : 
; 146  :   if (encoder->cfg.sao_type) {

	cmp	DWORD PTR [r14+44], r13d
	je	SHORT $LN6@encoder_st

; 147  :     state->tile->hor_buf_before_sao = kvz_yuv_t_alloc(luma_size, chroma_size_hor);

	mov	edx, esi
	mov	ecx, edi
	call	kvz_yuv_t_alloc
	mov	r8, rax

; 148  :     state->tile->ver_buf_before_sao = kvz_yuv_t_alloc(luma_size, chroma_size_ver);

	mov	edx, ebp
	mov	rax, QWORD PTR [rbx]
	mov	ecx, edi
	mov	QWORD PTR [rax+48], r8
	call	kvz_yuv_t_alloc
	mov	rcx, rax
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+56], rcx

; 149  :   } else {

	jmp	SHORT $LN7@encoder_st
$LN6@encoder_st:

; 150  :     state->tile->hor_buf_before_sao = NULL;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+48], r13

; 151  :     state->tile->ver_buf_before_sao = NULL;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+56], r13
$LN7@encoder_st:

; 152  :   }
; 153  : 
; 154  :   if (encoder->cfg.wpp) {

	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [r14+168], r13d
	je	$LN8@encoder_st

; 155  :     int num_jobs = state->tile->frame->width_in_lcu * state->tile->frame->height_in_lcu;

	mov	rax, QWORD PTR [rax]
	mov	esi, DWORD PTR [rax+28]
	imul	esi, DWORD PTR [rax+24]

; 156  :     state->tile->wf_jobs = MALLOC(threadqueue_job_t*, num_jobs);

	movsxd	rbp, esi
	lea	rcx, QWORD PTR [rbp*8]
	call	QWORD PTR __imp_malloc
	mov	edi, r13d
	mov	rcx, rax
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+64], rcx

; 157  :     for (int i = 0; i < num_jobs; ++i) {

	test	esi, esi
	jle	SHORT $LN19@encoder_st
	cmp	esi, 2
	jb	SHORT $LN19@encoder_st

; 158  :       state->tile->wf_jobs[i] = NULL;

	mov	rdx, QWORD PTR [rbx]
	lea	eax, DWORD PTR [rsi-1]
	add	rdx, 64					; 00000040H
	movsxd	rcx, eax
	mov	r9, QWORD PTR [rdx]
	lea	rax, QWORD PTR [r9+rcx*8]
	cmp	r9, rbx
	ja	SHORT $LN20@encoder_st

; 155  :     int num_jobs = state->tile->frame->width_in_lcu * state->tile->frame->height_in_lcu;

	cmp	rax, rbx
	jae	SHORT $LN19@encoder_st
$LN20@encoder_st:
	cmp	r9, rdx
	ja	SHORT $LN21@encoder_st
	cmp	rax, rdx
	jae	SHORT $LN19@encoder_st
$LN21@encoder_st:
	mov	eax, esi
	and	eax, -2147483647			; ffffffff80000001H
	jge	SHORT $LN26@encoder_st
	dec	eax
	or	eax, -2
	inc	eax
$LN26@encoder_st:
	sub	esi, eax
	npad	7
$LL4@encoder_st:

; 157  :     for (int i = 0; i < num_jobs; ++i) {

	add	edi, 2
	cmp	edi, esi
	jl	SHORT $LL4@encoder_st

; 155  :     int num_jobs = state->tile->frame->width_in_lcu * state->tile->frame->height_in_lcu;

	lea	eax, DWORD PTR [rsi+1]
	mov	rcx, r9
	cdq
	sub	eax, edx
	xor	edx, edx
	sar	eax, 1
	movsxd	r8, eax
	shl	r8, 4
	and	r8, -8
	call	memset
$LN19@encoder_st:
	movsxd	rdx, edi

; 157  :     for (int i = 0; i < num_jobs; ++i) {

	cmp	rdx, rbp
	jge	SHORT $LN3@encoder_st
	npad	4
$LL18@encoder_st:

; 158  :       state->tile->wf_jobs[i] = NULL;

	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax+64]
	mov	QWORD PTR [rcx+rdx*8], r13
	inc	rdx
	cmp	rdx, rbp
	jl	SHORT $LL18@encoder_st
$LN3@encoder_st:

; 159  :     }
; 160  :     if (!state->tile->wf_jobs) {

	mov	rax, QWORD PTR [rbx]
	cmp	QWORD PTR [rax+64], r13
	jne	SHORT $LN9@encoder_st

; 161  :       printf("Error allocating wf_jobs array!\n");

	lea	rcx, OFFSET FLAT:$SG4294953177
	call	printf

; 162  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN1@encoder_st
$LN8@encoder_st:

; 163  :     }
; 164  :   } else {
; 165  :     state->tile->wf_jobs = NULL;

	mov	QWORD PTR [rax+64], r13
	mov	rax, QWORD PTR [rbx]
$LN9@encoder_st:

; 166  :   }
; 167  :   state->tile->id = encoder->tiles_tile_id[state->tile->lcu_offset_in_ts];

	movsxd	rdx, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR [r14+6424]
	mov	edx, DWORD PTR [rcx+rdx*4]
	mov	DWORD PTR [rax+8], edx

; 168  :   return 1;

	mov	eax, 1
$LN1@encoder_st:

; 169  : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
encoder_state_config_tile_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
_TEXT	SEGMENT
state$ = 48
encoder_state_config_tile_finalize PROC

; 171  : static void encoder_state_config_tile_finalize(encoder_state_t * const state) {

	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 172  :   if (state->tile == NULL) return;

	mov	rbx, QWORD PTR [rcx+48]
	mov	rdi, rcx
	test	rbx, rbx
	je	$LN1@encoder_st

; 173  : 
; 174  :   kvz_yuv_t_free(state->tile->hor_buf_search);

	mov	rbx, QWORD PTR [rbx+32]
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], rsi
	mov	QWORD PTR [rsp+64], r14
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 213  :   if (yuv) {

	xor	r14d, r14d
	test	rbx, rbx
	je	SHORT $LN9@encoder_st

; 214  :     FREE_POINTER(yuv->y);

	mov	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp_free

; 215  :     FREE_POINTER(yuv->u);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], r14
	call	QWORD PTR __imp_free

; 216  :     FREE_POINTER(yuv->v);

	mov	rcx, QWORD PTR [rbx+24]
	mov	QWORD PTR [rbx+16], r14
	call	QWORD PTR __imp_free
	mov	QWORD PTR [rbx+24], r14
$LN9@encoder_st:

; 217  :   }
; 218  :   FREE_POINTER(yuv);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 175  :   kvz_yuv_t_free(state->tile->ver_buf_search);

	mov	rax, QWORD PTR [rdi+48]
	mov	rbx, QWORD PTR [rax+40]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 213  :   if (yuv) {

	test	rbx, rbx
	je	SHORT $LN12@encoder_st

; 214  :     FREE_POINTER(yuv->y);

	mov	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp_free

; 215  :     FREE_POINTER(yuv->u);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], r14
	call	QWORD PTR __imp_free

; 216  :     FREE_POINTER(yuv->v);

	mov	rcx, QWORD PTR [rbx+24]
	mov	QWORD PTR [rbx+16], r14
	call	QWORD PTR __imp_free
	mov	QWORD PTR [rbx+24], r14
$LN12@encoder_st:

; 217  :   }
; 218  :   FREE_POINTER(yuv);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 176  :   kvz_yuv_t_free(state->tile->hor_buf_before_sao);

	mov	rax, QWORD PTR [rdi+48]
	mov	rbx, QWORD PTR [rax+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 213  :   if (yuv) {

	test	rbx, rbx
	je	SHORT $LN15@encoder_st

; 214  :     FREE_POINTER(yuv->y);

	mov	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp_free

; 215  :     FREE_POINTER(yuv->u);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], r14
	call	QWORD PTR __imp_free

; 216  :     FREE_POINTER(yuv->v);

	mov	rcx, QWORD PTR [rbx+24]
	mov	QWORD PTR [rbx+16], r14
	call	QWORD PTR __imp_free
	mov	QWORD PTR [rbx+24], r14
$LN15@encoder_st:

; 217  :   }
; 218  :   FREE_POINTER(yuv);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 177  :   kvz_yuv_t_free(state->tile->ver_buf_before_sao);

	mov	rax, QWORD PTR [rdi+48]
	mov	rbx, QWORD PTR [rax+56]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 213  :   if (yuv) {

	test	rbx, rbx
	je	SHORT $LN18@encoder_st

; 214  :     FREE_POINTER(yuv->y);

	mov	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp_free

; 215  :     FREE_POINTER(yuv->u);

	mov	rcx, QWORD PTR [rbx+16]
	mov	QWORD PTR [rbx+8], r14
	call	QWORD PTR __imp_free

; 216  :     FREE_POINTER(yuv->v);

	mov	rcx, QWORD PTR [rbx+24]
	mov	QWORD PTR [rbx+16], r14
	call	QWORD PTR __imp_free
	mov	QWORD PTR [rbx+24], r14
$LN18@encoder_st:

; 217  :   }
; 218  :   FREE_POINTER(yuv);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 179  :   if (state->encoder_control->cfg.wpp) {

	mov	rax, QWORD PTR [rdi]
	cmp	DWORD PTR [rax+168], r14d
	je	SHORT $LN3@encoder_st

; 180  :     int num_jobs = state->tile->frame->width_in_lcu * state->tile->frame->height_in_lcu;

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+28]
	imul	eax, DWORD PTR [rcx+24]

; 181  :     for (int i = 0; i < num_jobs; ++i) {

	test	eax, eax
	jle	SHORT $LN3@encoder_st

; 180  :     int num_jobs = state->tile->frame->width_in_lcu * state->tile->frame->height_in_lcu;

	mov	rbx, r14
	mov	esi, eax
	npad	5
$LL4@encoder_st:

; 182  :       kvz_threadqueue_free_job(&state->tile->wf_jobs[i]);

	mov	rax, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rax+64]
	add	rcx, rbx
	call	kvz_threadqueue_free_job
	add	rbx, 8
	sub	rsi, 1
	jne	SHORT $LL4@encoder_st
$LN3@encoder_st:

; 186  :   kvz_videoframe_free(state->tile->frame);

	mov	rax, QWORD PTR [rdi+48]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	mov	ebp, -1
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 186  :   kvz_videoframe_free(state->tile->frame);

	mov	rsi, QWORD PTR [rax]
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c

; 73   :   kvz_image_free(frame->source);

	mov	rbx, QWORD PTR [rsi]
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	test	rbx, rbx
	je	SHORT $LN22@encoder_st

; 117  : 
; 118  :   int32_t new_refcount = KVZ_ATOMIC_DEC(&(im->refcount));

	mov	eax, ebp
	lock xadd DWORD PTR [rbx+88], eax
	sub	eax, 1

; 119  :   if (new_refcount > 0) {

	jg	SHORT $LN22@encoder_st

; 120  :     // There are still references so we don't free the data yet.
; 121  :     return;
; 122  :   }
; 123  : 
; 124  :   if (im->base_image != im) {

	mov	rcx, QWORD PTR [rbx+80]
	cmp	rcx, rbx
	je	SHORT $LN25@encoder_st

; 125  :     // Free our reference to the base image.
; 126  :     kvz_image_free(im->base_image);

	call	kvz_image_free

; 127  :   } else {

	jmp	SHORT $LN26@encoder_st
$LN25@encoder_st:

; 128  :     free(im->fulldata_buf);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
$LN26@encoder_st:

; 129  :   }
; 130  : 
; 131  :   // Make sure freed data won't be used.
; 132  :   im->base_image = NULL;
; 133  :   im->fulldata_buf = NULL;
; 134  :   im->fulldata = NULL;
; 135  :   im->y = im->u = im->v = NULL;
; 136  :   im->data[COLOR_Y] = im->data[COLOR_U] = im->data[COLOR_V] = NULL;
; 137  :   free(im);

	mov	rcx, rbx
	mov	QWORD PTR [rbx+80], r14
	mov	QWORD PTR [rbx], r14
	mov	QWORD PTR [rbx+8], r14
	mov	QWORD PTR [rbx+32], r14
	mov	QWORD PTR [rbx+24], r14
	mov	QWORD PTR [rbx+16], r14
	mov	QWORD PTR [rbx+56], r14
	mov	QWORD PTR [rbx+48], r14
	mov	QWORD PTR [rbx+40], r14
	call	QWORD PTR __imp_free
$LN22@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c

; 75   :   kvz_image_free(frame->rec);

	mov	rbx, QWORD PTR [rsi+8]
	mov	QWORD PTR [rsi], r14
; File F:\open_codec_learn_2021\kvazaar-master\src\image.c

; 116  :   if (im == NULL) return;

	test	rbx, rbx
	je	SHORT $LN28@encoder_st

; 117  : 
; 118  :   int32_t new_refcount = KVZ_ATOMIC_DEC(&(im->refcount));

	lock xadd DWORD PTR [rbx+88], ebp
	sub	ebp, 1

; 119  :   if (new_refcount > 0) {

	jg	SHORT $LN28@encoder_st

; 120  :     // There are still references so we don't free the data yet.
; 121  :     return;
; 122  :   }
; 123  : 
; 124  :   if (im->base_image != im) {

	mov	rcx, QWORD PTR [rbx+80]
	cmp	rcx, rbx
	je	SHORT $LN31@encoder_st

; 125  :     // Free our reference to the base image.
; 126  :     kvz_image_free(im->base_image);

	call	kvz_image_free

; 127  :   } else {

	jmp	SHORT $LN32@encoder_st
$LN31@encoder_st:

; 128  :     free(im->fulldata_buf);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_free
$LN32@encoder_st:

; 129  :   }
; 130  : 
; 131  :   // Make sure freed data won't be used.
; 132  :   im->base_image = NULL;
; 133  :   im->fulldata_buf = NULL;
; 134  :   im->fulldata = NULL;
; 135  :   im->y = im->u = im->v = NULL;
; 136  :   im->data[COLOR_Y] = im->data[COLOR_U] = im->data[COLOR_V] = NULL;
; 137  :   free(im);

	mov	rcx, rbx
	mov	QWORD PTR [rbx+80], r14
	mov	QWORD PTR [rbx], r14
	mov	QWORD PTR [rbx+8], r14
	mov	QWORD PTR [rbx+32], r14
	mov	QWORD PTR [rbx+24], r14
	mov	QWORD PTR [rbx+16], r14
	mov	QWORD PTR [rbx+56], r14
	mov	QWORD PTR [rbx+48], r14
	mov	QWORD PTR [rbx+40], r14
	call	QWORD PTR __imp_free
$LN28@encoder_st:
; File F:\open_codec_learn_2021\kvazaar-master\src\videoframe.c

; 78   :   kvz_cu_array_free(&frame->cu_array);

	lea	rcx, QWORD PTR [rsi+32]
	mov	QWORD PTR [rsi+8], r14
	call	kvz_cu_array_free

; 79   : 
; 80   :   FREE_POINTER(frame->sao_luma);

	mov	rcx, QWORD PTR [rsi+40]
	call	QWORD PTR __imp_free

; 81   :   FREE_POINTER(frame->sao_chroma);

	mov	rcx, QWORD PTR [rsi+48]
	mov	QWORD PTR [rsi+40], r14
	call	QWORD PTR __imp_free

; 82   : 
; 83   :   free(frame);

	mov	rcx, rsi
	mov	QWORD PTR [rsi+48], r14
	call	QWORD PTR __imp_free
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c

; 187  :   state->tile->frame = NULL;

	mov	rax, QWORD PTR [rdi+48]
	mov	QWORD PTR [rax], r14

; 188  :   FREE_POINTER(state->tile->wf_jobs);

	mov	rcx, QWORD PTR [rdi+48]
	mov	rcx, QWORD PTR [rcx+64]
	call	QWORD PTR __imp_free
	mov	rax, QWORD PTR [rdi+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+48]
	mov	QWORD PTR [rax+64], r14
	mov	r14, QWORD PTR [rsp+64]
$LN1@encoder_st:

; 189  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
encoder_state_config_tile_finalize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
_TEXT	SEGMENT
state$ = 48
start_address_in_ts$ = 56
end_address_in_ts$ = 64
encoder_state_config_slice_init PROC

; 194  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 195  :   state->slice->id = -1;

	mov	rax, QWORD PTR [rcx+56]
	mov	rbx, rcx

; 196  :   for (int i = 0; i < state->encoder_control->slice_count; ++i) {

	xor	r9d, r9d
	movsxd	rsi, r8d
	movsxd	rdi, edx
	mov	DWORD PTR [rax], -1
	mov	rax, QWORD PTR [rcx]
	movsxd	rcx, DWORD PTR [rax+6432]
	test	ecx, ecx
	jle	SHORT $LN3@encoder_st

; 197  :     if (state->encoder_control->slice_addresses_in_ts[i] == start_address_in_ts) {

	mov	rax, QWORD PTR [rax+6440]
	mov	r8d, r9d
	npad	3
$LL4@encoder_st:
	cmp	DWORD PTR [rax], edi
	je	SHORT $LN9@encoder_st

; 196  :   for (int i = 0; i < state->encoder_control->slice_count; ++i) {

	inc	r9d
	inc	r8
	add	rax, 4
	cmp	r8, rcx
	jl	SHORT $LL4@encoder_st

; 197  :     if (state->encoder_control->slice_addresses_in_ts[i] == start_address_in_ts) {

	jmp	SHORT $LN3@encoder_st
$LN9@encoder_st:

; 198  :       state->slice->id = i;

	mov	rax, QWORD PTR [rbx+56]
	mov	DWORD PTR [rax], r9d
$LN3@encoder_st:

; 199  :       break;
; 200  :     }
; 201  :   }
; 202  :   assert(state->slice->id != -1);

	mov	rax, QWORD PTR [rbx+56]
	cmp	DWORD PTR [rax], -1
	jne	SHORT $LN7@encoder_st
	mov	r8d, 202				; 000000caH
	lea	rdx, OFFSET FLAT:$SG4294953176
	lea	rcx, OFFSET FLAT:$SG4294953175
	call	QWORD PTR __imp__wassert
	mov	rax, QWORD PTR [rbx+56]
$LN7@encoder_st:

; 203  : 
; 204  :   state->slice->start_in_ts = start_address_in_ts;

	mov	DWORD PTR [rax+4], edi

; 205  :   state->slice->end_in_ts = end_address_in_ts;

	mov	rax, QWORD PTR [rbx+56]
	mov	DWORD PTR [rax+8], esi

; 206  :   
; 207  :   state->slice->start_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[start_address_in_ts];

	mov	rax, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx+56]
	mov	rcx, QWORD PTR [rax+6416]
	mov	eax, DWORD PTR [rcx+rdi*4]
	mov	DWORD PTR [rdx+12], eax

; 208  :   state->slice->end_in_rs = state->encoder_control->tiles_ctb_addr_ts_to_rs[end_address_in_ts];

	mov	rax, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rbx+56]

; 209  :   return 1;
; 210  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rcx, QWORD PTR [rax+6416]
	mov	eax, DWORD PTR [rcx+rsi*4]
	mov	rsi, QWORD PTR [rsp+56]
	mov	DWORD PTR [rdx+16], eax
	mov	eax, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
encoder_state_config_slice_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\encoder_state-ctors_dtors.c
_TEXT	SEGMENT
state$ = 8
lcu_offset_y$ = 16
encoder_state_config_wfrow_init PROC

; 214  :   
; 215  :   state->wfrow->lcu_offset_y = lcu_offset_y;

	mov	rax, QWORD PTR [rcx+64]
	mov	DWORD PTR [rax], edx

; 216  :   return 1;

	mov	eax, 1

; 217  : }

	ret	0
encoder_state_config_wfrow_init ENDP
_TEXT	ENDS
END
