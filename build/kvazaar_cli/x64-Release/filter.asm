; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	kvz_g_luma_filter
PUBLIC	kvz_g_chroma_filter
PUBLIC	kvz_g_beta_table_8x8
PUBLIC	kvz_g_tc_table_8x8
	ORG $+8
kvz_g_luma_filter DB 00H
	DB	00H
	DB	00H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	04H
	DB	0f6H
	DB	03aH
	DB	011H
	DB	0fbH
	DB	01H
	DB	00H
	DB	0ffH
	DB	04H
	DB	0f5H
	DB	028H
	DB	028H
	DB	0f5H
	DB	04H
	DB	0ffH
	DB	00H
	DB	01H
	DB	0fbH
	DB	011H
	DB	03aH
	DB	0f6H
	DB	04H
	DB	0ffH
kvz_g_chroma_filter DB 00H
	DB	040H
	DB	00H
	DB	00H
	DB	0feH
	DB	03aH
	DB	0aH
	DB	0feH
	DB	0fcH
	DB	036H
	DB	010H
	DB	0feH
	DB	0faH
	DB	02eH
	DB	01cH
	DB	0fcH
	DB	0fcH
	DB	024H
	DB	024H
	DB	0fcH
	DB	0fcH
	DB	01cH
	DB	02eH
	DB	0faH
	DB	0feH
	DB	010H
	DB	036H
	DB	0fcH
	DB	0feH
	DB	0aH
	DB	03aH
	DB	0feH
cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
kvz_g_beta_table_8x8 DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	014H
	DB	016H
	DB	018H
	DB	01aH
	DB	01cH
	DB	01eH
	DB	020H
	DB	022H
	DB	024H
	DB	026H
	DB	028H
	DB	02aH
	DB	02cH
	DB	02eH
	DB	030H
	DB	032H
	DB	034H
	DB	036H
	DB	038H
	DB	03aH
	DB	03cH
	DB	03eH
	DB	040H
	ORG $+12
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
kvz_g_tc_table_8x8 DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0dH
	DB	0eH
	DB	010H
	DB	012H
	DB	014H
	DB	016H
	DB	018H
	ORG $+10
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
PUBLIC	kvz_filter_deblock_lcu
pdata	SEGMENT
$pdata$filter_deblock_lcu_rightmost DD imagerel filter_deblock_lcu_rightmost
	DD	imagerel filter_deblock_lcu_rightmost+1290
	DD	imagerel $unwind$filter_deblock_lcu_rightmost
$pdata$filter_deblock_lcu_inside DD imagerel filter_deblock_lcu_inside
	DD	imagerel filter_deblock_lcu_inside+72
	DD	imagerel $unwind$filter_deblock_lcu_inside
$pdata$3$filter_deblock_lcu_inside DD imagerel filter_deblock_lcu_inside+72
	DD	imagerel filter_deblock_lcu_inside+504
	DD	imagerel $chain$3$filter_deblock_lcu_inside
$pdata$4$filter_deblock_lcu_inside DD imagerel filter_deblock_lcu_inside+504
	DD	imagerel filter_deblock_lcu_inside+515
	DD	imagerel $chain$4$filter_deblock_lcu_inside
$pdata$filter_deblock_unit DD imagerel filter_deblock_unit
	DD	imagerel filter_deblock_unit+45
	DD	imagerel $unwind$filter_deblock_unit
$pdata$0$filter_deblock_unit DD imagerel filter_deblock_unit+45
	DD	imagerel filter_deblock_unit+207
	DD	imagerel $chain$0$filter_deblock_unit
$pdata$1$filter_deblock_unit DD imagerel filter_deblock_unit+207
	DD	imagerel filter_deblock_unit+229
	DD	imagerel $chain$1$filter_deblock_unit
$pdata$filter_deblock_edge_chroma DD imagerel filter_deblock_edge_chroma
	DD	imagerel filter_deblock_edge_chroma+271
	DD	imagerel $unwind$filter_deblock_edge_chroma
$pdata$0$filter_deblock_edge_chroma DD imagerel filter_deblock_edge_chroma+271
	DD	imagerel filter_deblock_edge_chroma+1307
	DD	imagerel $chain$0$filter_deblock_edge_chroma
$pdata$1$filter_deblock_edge_chroma DD imagerel filter_deblock_edge_chroma+1307
	DD	imagerel filter_deblock_edge_chroma+1322
	DD	imagerel $chain$1$filter_deblock_edge_chroma
$pdata$filter_deblock_edge_luma DD imagerel filter_deblock_edge_luma
	DD	imagerel filter_deblock_edge_luma+3392
	DD	imagerel $unwind$filter_deblock_edge_luma
$pdata$scatter_deblock_pixels DD imagerel scatter_deblock_pixels
	DD	imagerel scatter_deblock_pixels+74
	DD	imagerel $unwind$scatter_deblock_pixels
$pdata$gather_deblock_pixels DD imagerel gather_deblock_pixels
	DD	imagerel gather_deblock_pixels+160
	DD	imagerel $unwind$gather_deblock_pixels
$pdata$get_qp_y_pred DD imagerel get_qp_y_pred
	DD	imagerel get_qp_y_pred+207
	DD	imagerel $unwind$get_qp_y_pred
$pdata$is_pu_boundary DD imagerel is_pu_boundary
	DD	imagerel is_pu_boundary+260
	DD	imagerel $unwind$is_pu_boundary
$pdata$is_tu_boundary DD imagerel is_tu_boundary
	DD	imagerel is_tu_boundary+102
	DD	imagerel $unwind$is_tu_boundary
$pdata$kvz_filter_deblock_chroma DD imagerel kvz_filter_deblock_chroma
	DD	imagerel kvz_filter_deblock_chroma+192
	DD	imagerel $unwind$kvz_filter_deblock_chroma
$pdata$kvz_filter_deblock_luma_weak DD imagerel kvz_filter_deblock_luma_weak
	DD	imagerel kvz_filter_deblock_luma_weak+119
	DD	imagerel $unwind$kvz_filter_deblock_luma_weak
$pdata$0$kvz_filter_deblock_luma_weak DD imagerel kvz_filter_deblock_luma_weak+119
	DD	imagerel kvz_filter_deblock_luma_weak+375
	DD	imagerel $chain$0$kvz_filter_deblock_luma_weak
$pdata$1$kvz_filter_deblock_luma_weak DD imagerel kvz_filter_deblock_luma_weak+375
	DD	imagerel kvz_filter_deblock_luma_weak+411
	DD	imagerel $chain$1$kvz_filter_deblock_luma_weak
$pdata$kvz_filter_deblock_luma_strong DD imagerel kvz_filter_deblock_luma_strong
	DD	imagerel kvz_filter_deblock_luma_strong+322
	DD	imagerel $unwind$kvz_filter_deblock_luma_strong
$pdata$kvz_filter_deblock_lcu DD imagerel $LN140
	DD	imagerel $LN140+1522
	DD	imagerel $unwind$kvz_filter_deblock_lcu
xdata	SEGMENT
$unwind$filter_deblock_lcu_rightmost DD 091e01H
	DD	0f01a821eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
	DD	0300fH
$unwind$filter_deblock_lcu_inside DD 050e01H
	DD	0f00a820eH
	DD	06006c008H
	DD	05005H
$chain$3$filter_deblock_lcu_inside DD 081421H
	DD	06e414H
	DD	07d40fH
	DD	08740aH
	DD	0e3405H
	DD	imagerel filter_deblock_lcu_inside
	DD	imagerel filter_deblock_lcu_inside+72
	DD	imagerel $unwind$filter_deblock_lcu_inside
$chain$4$filter_deblock_lcu_inside DD 021H
	DD	imagerel filter_deblock_lcu_inside
	DD	imagerel filter_deblock_lcu_inside+72
	DD	imagerel $unwind$filter_deblock_lcu_inside
$unwind$filter_deblock_unit DD 081501H
	DD	0b7415H
	DD	0a6415H
	DD	095415H
	DD	0e0115215H
$chain$0$filter_deblock_unit DD 020521H
	DD	083405H
	DD	imagerel filter_deblock_unit
	DD	imagerel filter_deblock_unit+45
	DD	imagerel $unwind$filter_deblock_unit
$chain$1$filter_deblock_unit DD 021H
	DD	imagerel filter_deblock_unit
	DD	imagerel filter_deblock_unit+45
	DD	imagerel $unwind$filter_deblock_unit
$unwind$filter_deblock_edge_chroma DD 080f01H
	DD	0f00bb20fH
	DD	0c007e009H
	DD	060047005H
	DD	030025003H
$chain$0$filter_deblock_edge_chroma DD 020521H
	DD	0bd405H
	DD	imagerel filter_deblock_edge_chroma
	DD	imagerel filter_deblock_edge_chroma+271
	DD	imagerel $unwind$filter_deblock_edge_chroma
$chain$1$filter_deblock_edge_chroma DD 021H
	DD	imagerel filter_deblock_edge_chroma
	DD	imagerel filter_deblock_edge_chroma+271
	DD	imagerel $unwind$filter_deblock_edge_chroma
$unwind$filter_deblock_edge_luma DD 0a2601H
	DD	0170126H
	DD	0e018f01aH
	DD	0c014d016H
	DD	060117012H
	DD	0500f3010H
$unwind$scatter_deblock_pixels DD 020501H
	DD	013405H
$unwind$gather_deblock_pixels DD 020501H
	DD	013405H
$unwind$get_qp_y_pred DD 083f01H
	DD	06743fH
	DD	08540fH
	DD	07340fH
	DD	0600b320fH
$unwind$is_pu_boundary DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$is_tu_boundary DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$kvz_filter_deblock_chroma DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
$unwind$kvz_filter_deblock_luma_weak DD 091401H
	DD	076414H
	DD	065414H
	DD	053414H
	DD	0e012f014H
	DD	07010H
$chain$0$kvz_filter_deblock_luma_weak DD 020521H
	DD	04c405H
	DD	imagerel kvz_filter_deblock_luma_weak
	DD	imagerel kvz_filter_deblock_luma_weak+119
	DD	imagerel $unwind$kvz_filter_deblock_luma_weak
$chain$1$kvz_filter_deblock_luma_weak DD 021H
	DD	imagerel kvz_filter_deblock_luma_weak
	DD	imagerel kvz_filter_deblock_luma_weak+119
	DD	imagerel $unwind$kvz_filter_deblock_luma_weak
$unwind$kvz_filter_deblock_luma_strong DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
$unwind$kvz_filter_deblock_lcu DD 0b5b01H
	DD	09f45bH
	DD	0a5454H
	DD	0e012a216H
	DD	0c00ed010H
	DD	0600b700cH
	DD	0300aH
	ORG $+14
$SG4294943790 DB '!', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'n', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '-', 00H, '>', 00H, 'c'
	DB	00H, 'f', 00H, 'g', 00H, '.', 00H, 'l', 00H, 'o', 00H, 's', 00H
	DB	's', 00H, 'l', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H, 00H
	ORG $+4
$SG4294943791 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'f', 00H
	DB	'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c'
	DB	00H, 00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
tv1434 = 48
tv1435 = 52
tv1432 = 56
tu_boundary$1$ = 144
state$ = 144
x_px$ = 152
tv1419 = 160
y_px$ = 160
tv1429 = 168
kvz_filter_deblock_lcu PROC

; 784  : {

$LN140:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 88					; 00000058H

; 785  :   assert(!state->encoder_control->cfg.lossless);

	mov	rax, QWORD PTR [rcx]
	mov	r13d, r8d
	mov	esi, edx
	mov	r14, rcx
	cmp	DWORD PTR [rax+2392], 0
	je	SHORT $LN4@kvz_filter
	mov	r8d, 785				; 00000311H
	lea	rdx, OFFSET FLAT:$SG4294943791
	lea	rcx, OFFSET FLAT:$SG4294943790
	call	QWORD PTR __imp__wassert
$LN4@kvz_filter:

; 703  :   const int end_x = MIN(x + LCU_WIDTH, state->tile->frame->width);

	mov	rax, QWORD PTR [r14+48]
	lea	edi, DWORD PTR [rsi+64]

; 704  :   const int end_y = MIN(y + LCU_WIDTH, state->tile->frame->height);

	lea	ebx, DWORD PTR [r13+64]
	mov	QWORD PTR [rsp+80], rbp
	mov	ecx, edi
	mov	QWORD PTR [rsp+72], r15

; 682  :   }
; 683  : }
; 684  : 
; 685  : 
; 686  : /**
; 687  :  * \brief Deblock PU and TU boundaries inside an LCU.
; 688  :  *
; 689  :  * \param state     encoder state
; 690  :  * \param x_px      block x-position in pixels
; 691  :  * \param y_px      block y-position in pixels
; 692  :  * \param dir       direction of the edges to filter
; 693  :  *
; 694  :  * Recursively traverse the CU/TU quadtree. At the lowest level, apply the
; 695  :  * deblocking filter to the left edge (when dir == EDGE_VER) or the top edge
; 696  :  * (when dir == EDGE_HOR) as needed. Both luma and chroma are filtered.
; 697  :  */
; 698  : static void filter_deblock_lcu_inside(encoder_state_t * const state,
; 699  :                                       int32_t x,
; 700  :                                       int32_t y,
; 701  :                                       edge_dir dir)
; 702  : {
; 703  :   const int end_x = MIN(x + LCU_WIDTH, state->tile->frame->width);

	mov	DWORD PTR tv1434[rsp], edi

; 705  : 
; 706  :   for (int edge_y = y; edge_y < end_y; edge_y += 8) {

	mov	r12d, r13d
	mov	rdx, QWORD PTR [rax]
	mov	DWORD PTR tv1429[rsp], ebx
	cmp	edi, DWORD PTR [rdx+16]
	mov	eax, DWORD PTR [rdx+20]
	cmovge	ecx, DWORD PTR [rdx+16]
	cmp	ebx, eax
	mov	edx, ebx
	mov	DWORD PTR tv1435[rsp], ecx
	cmovge	edx, eax
	mov	DWORD PTR tv1432[rsp], edx
	cmp	r13d, edx
	jge	$LN7@kvz_filter
	npad	2
$LL8@kvz_filter:

; 707  :     for (int edge_x = x; edge_x < end_x; edge_x += 8) {

	mov	ebx, esi
	cmp	esi, ecx
	jge	$LN6@kvz_filter
	mov	r13d, r12d
	shr	r13d, 2
	npad	15
$LL11@kvz_filter:

; 207  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r14+48]
	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	ebx, DWORD PTR [rdi+16]
	jb	SHORT $LN25@kvz_filter
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN25@kvz_filter:

; 102  :   assert(y_px < cua->height);

	cmp	r12d, DWORD PTR [rdi+20]
	jb	SHORT $LN26@kvz_filter
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN26@kvz_filter:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
	mov	esi, ebx
	sar	eax, 2
	imul	eax, r13d
	shr	esi, 2
	add	eax, esi
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	mov	rax, QWORD PTR [rdi+8]
	movzx	ecx, BYTE PTR [rax+rcx*4+1]
	mov	eax, 64					; 00000040H
	and	ecx, 7
	sar	eax, cl

; 213  :   } else {
; 214  :     return (x & (tu_width - 1)) == 0;

	dec	eax
	and	eax, ebx
	sete	cl
	mov	BYTE PTR tu_boundary$1$[rsp], cl

; 709  :       if (tu_boundary || is_pu_boundary(state, edge_x, edge_y, dir)) {

	test	eax, eax
	je	$LN13@kvz_filter

; 233  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r14+48]
	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	ebx, DWORD PTR [rdi+16]
	jb	SHORT $LN38@kvz_filter
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN38@kvz_filter:

; 102  :   assert(y_px < cua->height);

	cmp	r12d, DWORD PTR [rdi+20]
	jb	SHORT $LN39@kvz_filter
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN39@kvz_filter:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	ebp, 64					; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	sar	eax, 2
	imul	eax, r13d
	add	eax, esi
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	rax, QWORD PTR [rdi+8]
	movzx	ecx, BYTE PTR [rax+rcx*4]

; 237  :   const int32_t x_cu = x & ~(cu_width - 1);
; 238  :   const int32_t y_cu = y & ~(cu_width - 1);
; 239  :   const cu_info_t *const cu =

	mov	rax, QWORD PTR [r14+48]
	shr	ecx, 2
	and	ecx, 7
	sar	ebp, cl
	mov	rcx, QWORD PTR [rax]
	lea	edi, DWORD PTR [rbp-1]
	mov	r15, QWORD PTR [rcx+32]
	not	edi
	mov	esi, edi
	and	edi, r12d
	and	esi, ebx
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	esi, DWORD PTR [r15+16]
	jb	SHORT $LN42@kvz_filter
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN42@kvz_filter:

; 102  :   assert(y_px < cua->height);

	cmp	edi, DWORD PTR [r15+20]
	jb	SHORT $LN43@kvz_filter
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN43@kvz_filter:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [r15+24]
	mov	eax, esi
	sar	ecx, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 243  :   for (int i = 0; i < num_pu; i++) {

	xor	r8d, r8d
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	shr	eax, 2
	shr	edi, 2
	imul	ecx, edi
	add	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	mov	rax, QWORD PTR [r15+8]
	lea	r15, OFFSET FLAT:__ImageBase
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	lea	rcx, QWORD PTR [rcx+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	movzx	edx, BYTE PTR [rax+rcx*4]
	shr	rdx, 5
	movzx	eax, BYTE PTR kvz_part_mode_num_parts[rdx+r15]

; 243  :   for (int i = 0; i < num_pu; i++) {

	test	al, al
	je	$LN9@kvz_filter
	lea	rcx, QWORD PTR kvz_part_mode_offsets[r15]
	mov	r9d, eax
	lea	rcx, QWORD PTR [rcx+rdx*8]
	npad	5
$LL30@kvz_filter:

; 247  : 
; 248  :     } else {
; 249  :       int x_pu = PU_GET_X(cu->part_size, cu_width, x_cu, i);

	movzx	eax, BYTE PTR [rcx]
	imul	eax, ebp
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, esi

; 250  :       if (x_pu == x) return true;

	cmp	eax, ebx
	je	SHORT $LN138@kvz_filter

; 243  :   for (int i = 0; i < num_pu; i++) {

	inc	r8
	add	rcx, 2
	cmp	r8, r9
	jl	SHORT $LL30@kvz_filter

; 246  :       if (y_pu == y) return true;

	jmp	SHORT $LN9@kvz_filter
$LN138@kvz_filter:

; 250  :       if (x_pu == x) return true;

	movzx	ecx, BYTE PTR tu_boundary$1$[rsp]
$LN13@kvz_filter:

; 648  :   if (x == 0 && dir == EDGE_VER) return;

	test	ebx, ebx
	je	SHORT $LN9@kvz_filter

; 669  :     }
; 670  :   } else {
; 671  :     length   = height;
; 672  :     length_c = height >> 1;
; 673  :   }
; 674  : 
; 675  :   filter_deblock_edge_luma(state, x, y, length, dir, tu_boundary);

	mov	BYTE PTR [rsp+40], cl
	mov	r9d, 8
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], 0
	mov	r8d, r12d
	mov	edx, ebx
	call	filter_deblock_edge_luma

; 676  : 
; 677  :   // Chroma pixel coordinates.
; 678  :   const int32_t x_c = x >> 1;
; 679  :   const int32_t y_c = y >> 1;
; 680  :   if (state->encoder_control->chroma_format != KVZ_CSP_400 && is_on_8x8_grid(x_c, y_c, dir)) {

	mov	rax, QWORD PTR [r14]
	mov	edx, ebx
	sar	edx, 1
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN9@kvz_filter

; 271  :     return (x & 7) == 0;

	test	dl, 7

; 680  :   if (state->encoder_control->chroma_format != KVZ_CSP_400 && is_on_8x8_grid(x_c, y_c, dir)) {

	jne	SHORT $LN9@kvz_filter

; 681  :     filter_deblock_edge_chroma(state, x_c, y_c, length_c, dir, tu_boundary);

	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], 0
	sar	r8d, 1
	mov	r9d, 4
	mov	rcx, r14
	call	filter_deblock_edge_chroma
$LN9@kvz_filter:

; 707  :     for (int edge_x = x; edge_x < end_x; edge_x += 8) {

	mov	ecx, DWORD PTR tv1435[rsp]
	add	ebx, 8
	cmp	ebx, ecx
	jl	$LL11@kvz_filter
	mov	edx, DWORD PTR tv1432[rsp]
	mov	esi, DWORD PTR x_px$[rsp]
$LN6@kvz_filter:

; 705  : 
; 706  :   for (int edge_y = y; edge_y < end_y; edge_y += 8) {

	add	r12d, 8
	cmp	r12d, edx
	jl	$LL8@kvz_filter
	mov	r13d, DWORD PTR y_px$[rsp]
	mov	edi, DWORD PTR tv1434[rsp]
	mov	ebx, DWORD PTR tv1429[rsp]
$LN7@kvz_filter:

; 786  : 
; 787  :   filter_deblock_lcu_inside(state, x_px, y_px, EDGE_VER);
; 788  :   if (x_px > 0) {

	test	esi, esi
	jle	SHORT $LN2@kvz_filter

; 789  :     filter_deblock_lcu_rightmost(state, x_px, y_px);

	mov	r8d, r13d
	mov	edx, esi
	mov	rcx, r14
	call	filter_deblock_lcu_rightmost
$LN2@kvz_filter:

; 703  :   const int end_x = MIN(x + LCU_WIDTH, state->tile->frame->width);

	mov	rax, QWORD PTR [r14+48]
	mov	rcx, QWORD PTR [rax]

; 704  :   const int end_y = MIN(y + LCU_WIDTH, state->tile->frame->height);

	cmp	edi, DWORD PTR [rcx+16]
	cmovge	edi, DWORD PTR [rcx+16]

; 705  : 
; 706  :   for (int edge_y = y; edge_y < end_y; edge_y += 8) {

	cmp	ebx, DWORD PTR [rcx+20]
	mov	DWORD PTR tv1434[rsp], edi
	cmovge	ebx, DWORD PTR [rcx+20]
	mov	DWORD PTR tv1429[rsp], ebx
	cmp	r13d, ebx
	jge	$LN59@kvz_filter
	mov	eax, ebx
$LL60@kvz_filter:

; 707  :     for (int edge_x = x; edge_x < end_x; edge_x += 8) {

	mov	ebx, esi
	cmp	esi, edi
	jge	$LN58@kvz_filter
	mov	ebp, r13d
	shr	ebp, 2
	mov	DWORD PTR tv1419[rsp], ebp
	npad	4
$LL63@kvz_filter:

; 207  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r14+48]
	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	ebx, DWORD PTR [rdi+16]
	jb	SHORT $LN77@kvz_filter
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN77@kvz_filter:

; 102  :   assert(y_px < cua->height);

	cmp	r13d, DWORD PTR [rdi+20]
	jb	SHORT $LN78@kvz_filter
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN78@kvz_filter:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
	mov	esi, ebx
	sar	eax, 2
	imul	eax, ebp
	shr	esi, 2
	add	eax, esi
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	mov	rax, QWORD PTR [rdi+8]
	movzx	ecx, BYTE PTR [rax+rcx*4+1]
	mov	eax, 64					; 00000040H
	and	ecx, 7
	sar	eax, cl

; 210  : 
; 211  :   if (dir == EDGE_HOR) {
; 212  :     return (y & (tu_width - 1)) == 0;

	dec	eax
	and	eax, r13d
	sete	r12b

; 709  :       if (tu_boundary || is_pu_boundary(state, edge_x, edge_y, dir)) {

	test	eax, eax
	je	$LN65@kvz_filter

; 233  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r14+48]
	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	ebx, DWORD PTR [rdi+16]
	jb	SHORT $LN90@kvz_filter
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN90@kvz_filter:

; 102  :   assert(y_px < cua->height);

	cmp	r13d, DWORD PTR [rdi+20]
	jb	SHORT $LN91@kvz_filter
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN91@kvz_filter:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
	sar	eax, 2
	imul	eax, ebp
	add	eax, esi
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	esi, 64					; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	rax, QWORD PTR [rdi+8]
	movzx	ecx, BYTE PTR [rax+rcx*4]

; 237  :   const int32_t x_cu = x & ~(cu_width - 1);
; 238  :   const int32_t y_cu = y & ~(cu_width - 1);
; 239  :   const cu_info_t *const cu =

	mov	rax, QWORD PTR [r14+48]
	shr	ecx, 2
	and	ecx, 7
	sar	esi, cl
	mov	rcx, QWORD PTR [rax]
	lea	edi, DWORD PTR [rsi-1]
	mov	rbp, QWORD PTR [rcx+32]
	not	edi
	mov	r15d, edi
	and	edi, r13d
	and	r15d, ebx
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r15d, DWORD PTR [rbp+16]
	jb	SHORT $LN94@kvz_filter
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN94@kvz_filter:

; 102  :   assert(y_px < cua->height);

	cmp	edi, DWORD PTR [rbp+20]
	jb	SHORT $LN95@kvz_filter
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN95@kvz_filter:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rbp+24]
	mov	eax, edi
	sar	ecx, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 243  :   for (int i = 0; i < num_pu; i++) {

	xor	r8d, r8d
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	shr	eax, 2
	imul	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	mov	rax, QWORD PTR [rbp+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	shr	r15d, 2
	add	ecx, r15d
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	lea	r15, OFFSET FLAT:__ImageBase
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	lea	rcx, QWORD PTR [rcx+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	movzx	edx, BYTE PTR [rax+rcx*4]
	shr	rdx, 5
	movzx	eax, BYTE PTR kvz_part_mode_num_parts[rdx+r15]

; 243  :   for (int i = 0; i < num_pu; i++) {

	test	al, al
	je	$LN61@kvz_filter
	lea	rcx, QWORD PTR kvz_part_mode_offsets[r15+1]
	mov	r9d, eax
	lea	rcx, QWORD PTR [rcx+rdx*8]
	npad	10
$LL82@kvz_filter:

; 244  :     if (dir == EDGE_HOR) {
; 245  :       int y_pu = PU_GET_Y(cu->part_size, cu_width, y_cu, i);

	movzx	eax, BYTE PTR [rcx]
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, edi

; 246  :       if (y_pu == y) return true;

	cmp	eax, r13d
	je	SHORT $LN65@kvz_filter

; 243  :   for (int i = 0; i < num_pu; i++) {

	inc	r8
	add	rcx, 2
	cmp	r8, r9
	jl	SHORT $LL82@kvz_filter

; 246  :       if (y_pu == y) return true;

	jmp	$LN61@kvz_filter
$LN65@kvz_filter:

; 649  :   if (y == 0 && dir == EDGE_HOR) return;

	test	r13d, r13d
	je	SHORT $LN61@kvz_filter

; 650  : 
; 651  :   // Length of luma and chroma edges.
; 652  :   int32_t length;
; 653  :   int32_t length_c;
; 654  : 
; 655  :   if (dir == EDGE_HOR) {
; 656  :     const videoframe_t * const frame = state->tile->frame;
; 657  :     const int32_t x_right             = x + width;
; 658  :     const bool rightmost_4px_of_lcu   = x_right % LCU_WIDTH == 0;

	lea	edx, DWORD PTR [rbx+8]
	mov	eax, edx
	and	eax, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN137@kvz_filter
	dec	eax
	or	eax, -64				; ffffffffffffffc0H
	inc	eax
$LN137@kvz_filter:
	test	eax, eax

; 660  : 
; 661  :     if (rightmost_4px_of_lcu && !rightmost_4px_of_frame) {

	jne	SHORT $LN136@kvz_filter

; 659  :     const bool rightmost_4px_of_frame = x_right == frame->width;

	mov	rax, QWORD PTR [r14+48]
	mov	rcx, QWORD PTR [rax]
	cmp	edx, DWORD PTR [rcx+16]

; 660  : 
; 661  :     if (rightmost_4px_of_lcu && !rightmost_4px_of_frame) {

	je	SHORT $LN136@kvz_filter

; 662  :       // The last 4 pixels will be deblocked when processing the next LCU.
; 663  :       length   = width - 4;
; 664  :       length_c = (width >> 1) - 4;

	xor	edi, edi
	lea	r9d, QWORD PTR [rdi+4]

; 665  : 
; 666  :     } else {

	jmp	SHORT $LN102@kvz_filter
$LN136@kvz_filter:

; 667  :       length   = width;
; 668  :       length_c = width >> 1;

	mov	edi, 4
	lea	r9d, QWORD PTR [rdi+4]
$LN102@kvz_filter:

; 669  :     }
; 670  :   } else {
; 671  :     length   = height;
; 672  :     length_c = height >> 1;
; 673  :   }
; 674  : 
; 675  :   filter_deblock_edge_luma(state, x, y, length, dir, tu_boundary);

	mov	BYTE PTR [rsp+40], r12b
	mov	r8d, r13d
	mov	edx, ebx
	mov	DWORD PTR [rsp+32], 1
	mov	rcx, r14
	call	filter_deblock_edge_luma

; 676  : 
; 677  :   // Chroma pixel coordinates.
; 678  :   const int32_t x_c = x >> 1;
; 679  :   const int32_t y_c = y >> 1;
; 680  :   if (state->encoder_control->chroma_format != KVZ_CSP_400 && is_on_8x8_grid(x_c, y_c, dir)) {

	mov	rax, QWORD PTR [r14]
	mov	r8d, r13d
	sar	r8d, 1
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN61@kvz_filter

; 269  :     return (y & 7) == 0;

	test	r8b, 7

; 680  :   if (state->encoder_control->chroma_format != KVZ_CSP_400 && is_on_8x8_grid(x_c, y_c, dir)) {

	jne	SHORT $LN61@kvz_filter

; 681  :     filter_deblock_edge_chroma(state, x_c, y_c, length_c, dir, tu_boundary);

	mov	edx, ebx
	mov	DWORD PTR [rsp+32], 1
	sar	edx, 1
	mov	r9d, edi
	mov	rcx, r14
	call	filter_deblock_edge_chroma
$LN61@kvz_filter:

; 707  :     for (int edge_x = x; edge_x < end_x; edge_x += 8) {

	mov	edi, DWORD PTR tv1434[rsp]
	add	ebx, 8
	mov	ebp, DWORD PTR tv1419[rsp]
	cmp	ebx, edi
	jl	$LL63@kvz_filter
	mov	esi, DWORD PTR x_px$[rsp]
	mov	eax, DWORD PTR tv1429[rsp]
$LN58@kvz_filter:

; 705  : 
; 706  :   for (int edge_y = y; edge_y < end_y; edge_y += 8) {

	add	r13d, 8
	cmp	r13d, eax
	jl	$LL60@kvz_filter
$LN59@kvz_filter:
	mov	r15, QWORD PTR [rsp+72]

; 790  :   }
; 791  :   filter_deblock_lcu_inside(state, x_px, y_px, EDGE_HOR);
; 792  : }

	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 88					; 00000058H
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
kvz_filter_deblock_lcu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$dead$ = 24
cbf_is_set PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	lea	rdx, OFFSET FLAT:cbf_masks
	test	WORD PTR [rdx+rax*2], cx
	mov	eax, 0
	setne	al

; 519  : }

	ret	0
cbf_is_set ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
line$ = 8
tc$ = 16
kvz_filter_deblock_luma_strong PROC

; 98   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi

; 99   :   const kvz_pixel m0 = line[0];
; 100  :   const kvz_pixel m1 = line[1];
; 101  :   const kvz_pixel m2 = line[2];
; 102  :   const kvz_pixel m3 = line[3];
; 103  :   const kvz_pixel m4 = line[4];
; 104  :   const kvz_pixel m5 = line[5];
; 105  :   const kvz_pixel m6 = line[6];
; 106  :   const kvz_pixel m7 = line[7];
; 107  : 
; 108  :   line[1] = CLIP(m1 - 2*tc, m1 + 2*tc, (2*m0 + 3*m1 +   m2 +   m3 +   m4 + 4) >> 3);

	movzx	esi, BYTE PTR [rcx+4]
	mov	rbp, rcx
	movzx	edi, BYTE PTR [rcx+3]
	mov	r8d, edx
	movzx	r9d, BYTE PTR [rcx+1]
	movzx	r11d, BYTE PTR [rcx+2]
	movzx	edx, BYTE PTR [rcx]

; 109  :   line[2] = CLIP(m2 - 2*tc, m2 + 2*tc, (  m1 +   m2 +   m3 +   m4        + 2) >> 2);
; 110  :   line[3] = CLIP(m3 - 2*tc, m3 + 2*tc, (  m1 + 2*m2 + 2*m3 + 2*m4 +   m5 + 4) >> 3);

	movzx	r10d, BYTE PTR [rbp+5]
	lea	ebx, DWORD PTR [r8+r8]

; 111  :   line[4] = CLIP(m4 - 2*tc, m4 + 2*tc, (  m2 + 2*m3 + 2*m4 + 2*m5 +   m6 + 4) >> 3);

	movzx	r8d, BYTE PTR [rbp+6]
	add	edx, 2
	lea	eax, DWORD PTR [r9+r11]
	lea	ecx, DWORD PTR [rax+r9*2]
	lea	eax, DWORD PTR [rcx+rdx*2]
	add	eax, edi
	lea	ecx, DWORD PTR [rbx+r9]
	add	eax, esi
	lea	edx, DWORD PTR [r11+rdi]
	shr	eax, 3
	cmp	ecx, eax
	cmovge	ecx, eax
	mov	eax, r9d
	sub	eax, ebx
	cmp	eax, ecx
	cmovg	ecx, eax
	add	edx, esi
	mov	BYTE PTR [rbp+1], cl
	lea	eax, DWORD PTR [r9+2]
	add	eax, edx
	lea	ecx, DWORD PTR [rbx+r11]
	shr	eax, 2
	cmp	ecx, eax
	cmovge	ecx, eax
	mov	eax, r11d
	sub	eax, ebx
	cmp	eax, ecx
	cmovg	ecx, eax
	add	edx, 2
	mov	BYTE PTR [rbp+2], cl
	lea	ecx, DWORD PTR [rbx+rdi]
	lea	eax, DWORD PTR [r9+rdx*2]
	add	eax, r10d
	lea	edx, DWORD PTR [rbx+rsi]
	shr	eax, 3
	cmp	ecx, eax
	cmovge	ecx, eax
	mov	eax, edi
	sub	eax, ebx
	cmp	eax, ecx
	cmovg	ecx, eax
	lea	eax, DWORD PTR [rdi+2]
	add	eax, r10d
	mov	BYTE PTR [rbp+3], cl
	add	eax, esi
	lea	ecx, DWORD PTR [r8+rax*2]
	mov	eax, esi
	add	ecx, r11d
	shr	ecx, 3
	cmp	edx, ecx
	cmovge	edx, ecx
	sub	eax, ebx
	cmp	eax, edx

; 112  :   line[5] = CLIP(m5 - 2*tc, m5 + 2*tc, (  m3 +   m4 +   m5 +   m6        + 2) >> 2);

	lea	ecx, DWORD PTR [r10+2]
	cmovg	edx, eax
	lea	eax, DWORD PTR [rdi+rsi]
	add	eax, r8d
	mov	BYTE PTR [rbp+4], dl
	add	ecx, eax
	lea	edx, DWORD PTR [r10+rbx]
	shr	ecx, 2
	mov	eax, r10d
	cmp	edx, ecx
	cmovge	edx, ecx
	sub	eax, ebx
	cmp	eax, edx
	cmovg	edx, eax

; 113  :   line[6] = CLIP(m6 - 2*tc, m6 + 2*tc, (  m3 +   m4 +   m5 + 3*m6 + 2*m7 + 4) >> 3);

	lea	eax, DWORD PTR [r8+r10]
	mov	BYTE PTR [rbp+5], dl
	lea	ecx, DWORD PTR [rax+r8*2]
	movzx	edx, BYTE PTR [rbp+7]
	lea	eax, DWORD PTR [rcx+rdx*2]
	add	esi, 4
	lea	ecx, DWORD PTR [r8+rbx]
	add	eax, esi

; 114  : 
; 115  :   return 3;
; 116  : }

	mov	rsi, QWORD PTR [rsp+24]
	add	eax, edi
	mov	rdi, QWORD PTR [rsp+32]
	shr	eax, 3
	cmp	ecx, eax
	cmovge	ecx, eax
	sub	r8d, ebx
	mov	rbx, QWORD PTR [rsp+8]
	cmp	r8d, ecx
	mov	eax, 3
	cmovg	ecx, r8d
	mov	BYTE PTR [rbp+6], cl
	mov	rbp, QWORD PTR [rsp+16]
	ret	0
kvz_filter_deblock_luma_strong ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
encoder$ = 32
line$ = 40
tc$ = 48
p_2nd$ = 56
q_2nd$ = 64
kvz_filter_deblock_luma_weak PROC

; 132  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r14
	push	r15

; 133  :   const kvz_pixel m1 = line[1];
; 134  :   const kvz_pixel m2 = line[2];
; 135  :   const kvz_pixel m3 = line[3];
; 136  :   const kvz_pixel m4 = line[4];
; 137  :   const kvz_pixel m5 = line[5];
; 138  :   const kvz_pixel m6 = line[6];
; 139  : 
; 140  :   int32_t delta = (9 * (m4 - m3) - 3 * (m5 - m2) + 8) >> 4;

	movzx	r15d, BYTE PTR [rdx+4]
	mov	rbp, rcx
	movzx	r14d, BYTE PTR [rdx+3]
	movzx	esi, r9b
	movzx	edi, BYTE PTR [rdx+5]
	mov	eax, r15d
	movzx	ebx, BYTE PTR [rdx+2]
	sub	eax, r14d
	mov	r10, rdx
	mov	r11d, r8d
	lea	ecx, DWORD PTR [rax+rax*2]
	sub	ecx, edi
	add	ecx, ebx
	lea	r9d, DWORD PTR [rcx+4]
	lea	r9d, DWORD PTR [rcx+r9*2]
	sar	r9d, 4

; 141  : 
; 142  :   if (abs(delta) >= tc * 10) {

	lea	ecx, DWORD PTR [r8+r8*4]
	mov	eax, r9d
	add	ecx, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ecx
	jl	SHORT $LN2@kvz_filter

; 143  :     return 0;

	xor	eax, eax
	jmp	$LN7@kvz_filter
$LN2@kvz_filter:

; 144  :   } else {
; 145  :     int32_t tc2 = tc >> 1;
; 146  :     delta = CLIP(-tc, tc, delta);
; 147  :     line[3] = CLIP(0, (1 << encoder->bitdepth) - 1, (m3 + delta));

	movzx	ecx, BYTE PTR [rbp+2592]
	mov	eax, 1
	sar	r8d, 1
	cmp	r11d, r9d
	mov	QWORD PTR [rsp+32], r12
	cmovl	r9d, r11d
	neg	r11d
	cmp	r11d, r9d
	cmovg	r9d, r11d
	shl	eax, cl
	lea	ecx, DWORD PTR [rax-1]
	lea	eax, DWORD PTR [r14+r9]
	cmp	ecx, eax
	cmovge	ecx, eax
	xor	r12d, r12d
	test	ecx, ecx

; 148  :     line[4] = CLIP(0, (1 << encoder->bitdepth) - 1, (m4 - delta));

	mov	eax, 1
	cmovs	ecx, r12d
	mov	BYTE PTR [r10+3], cl
	movzx	ecx, BYTE PTR [rbp+2592]
	shl	eax, cl
	lea	ecx, DWORD PTR [rax-1]
	mov	eax, r15d
	sub	eax, r9d
	cmp	ecx, eax
	cmovge	ecx, eax
	test	ecx, ecx
	cmovs	ecx, r12d
	mov	BYTE PTR [r10+4], cl

; 149  : 
; 150  :     if (p_2nd) {

	test	sil, sil
	je	SHORT $LN4@kvz_filter

; 151  :       int32_t delta1 = CLIP(-tc2, tc2, (((m1 + m3 + 1) >> 1) - m2 + delta) >> 1);

	movzx	ecx, BYTE PTR [r10+1]
	mov	edx, r8d
	inc	ecx
	mov	eax, r8d
	add	ecx, r14d
	shr	ecx, 1
	sub	ecx, ebx
	add	ecx, r9d
	sar	ecx, 1
	cmp	r8d, ecx
	cmovge	edx, ecx

; 152  :       line[2] = CLIP(0, (1 << encoder->bitdepth) - 1, m2 + delta1);

	movzx	ecx, BYTE PTR [rbp+2592]
	neg	eax
	cmp	eax, edx
	cmovg	edx, eax
	mov	eax, 1
	shl	eax, cl
	lea	ecx, DWORD PTR [rax-1]
	lea	eax, DWORD PTR [rbx+rdx]
	cmp	ecx, eax
	cmovge	ecx, eax
	test	ecx, ecx
	cmovs	ecx, r12d
	mov	BYTE PTR [r10+2], cl
$LN4@kvz_filter:

; 153  :     }
; 154  :     if (q_2nd) {

	movzx	r11d, BYTE PTR q_2nd$[rsp]
	test	r11b, r11b
	je	SHORT $LN5@kvz_filter

; 155  :       int32_t delta2 = CLIP(-tc2, tc2, (((m6 + m4 + 1) >> 1) - m5 - delta) >> 1);

	movzx	ecx, BYTE PTR [r10+6]
	mov	edx, r8d
	inc	ecx

; 156  :       line[5] = CLIP(0, (1 << encoder->bitdepth) - 1, m5 + delta2);

	mov	eax, 1
	add	ecx, r15d
	shr	ecx, 1
	sub	ecx, edi
	sub	ecx, r9d
	sar	ecx, 1
	cmp	r8d, ecx
	cmovge	edx, ecx
	movzx	ecx, BYTE PTR [rbp+2592]
	neg	r8d
	cmp	r8d, edx
	cmovg	edx, r8d
	shl	eax, cl
	lea	ecx, DWORD PTR [rax-1]
	lea	eax, DWORD PTR [rdi+rdx]
	cmp	ecx, eax
	cmovge	ecx, eax
	test	ecx, ecx
	cmovs	ecx, r12d
	mov	BYTE PTR [r10+5], cl
$LN5@kvz_filter:

; 157  :     }
; 158  :     
; 159  :     if (p_2nd || q_2nd) {

	mov	r12, QWORD PTR [rsp+32]
	test	sil, sil
	jne	SHORT $LN8@kvz_filter

; 161  :     } else {
; 162  :       return 1;

	mov	eax, 1
	test	r11b, r11b
	je	SHORT $LN7@kvz_filter
$LN8@kvz_filter:

; 160  :       return 2;

	mov	eax, 2
$LN7@kvz_filter:

; 163  :     }
; 164  :   }
; 165  : }

	mov	rbx, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	pop	r15
	pop	r14
	pop	rdi
	ret	0
kvz_filter_deblock_luma_weak ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
encoder$ = 8
src$ = 16
offset$ = 24
tc$ = 32
part_P_nofilter$dead$ = 40
part_Q_nofilter$dead$ = 48
kvz_filter_deblock_chroma PROC

; 176  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi

; 177  :   int32_t delta;
; 178  :   int16_t m2 = src[-offset * 2];
; 179  :   int16_t m3 = src[-offset];
; 180  :   int16_t m4 = src[0];
; 181  :   int16_t m5 = src[offset];
; 182  : 
; 183  :   delta = CLIP(-tc,tc, (((m4 - m3) * 4) + m2 - m5 + 4 ) >> 3);

	movzx	edi, BYTE PTR [rdx]
	mov	r11, rdx
	movsxd	r10, r8d
	mov	rbx, rdx
	neg	r8d
	sub	rbx, r10
	mov	rbp, rcx
	movzx	esi, BYTE PTR [rbx]
	lea	eax, DWORD PTR [r8+r8]
	cdqe
	mov	r8d, r9d
	movzx	edx, BYTE PTR [rax+rdx]
	movzx	eax, BYTE PTR [r10+r11]
	sub	edx, eax
	mov	eax, edi
	sub	eax, esi
	inc	eax
	lea	ecx, DWORD PTR [rdx+rax*4]
	sar	ecx, 3
	cmp	r9d, ecx
	mov	eax, ecx
	cmovl	eax, r9d
	neg	r8d
	cmp	r8d, eax
	jg	SHORT $LN7@kvz_filter
	cmp	r9d, ecx
	mov	r8d, ecx
	cmovl	r8d, r9d
$LN7@kvz_filter:

; 184  :   if(!part_P_nofilter) {
; 185  :     src[-offset] = CLIP(0, (1 << encoder->bitdepth) - 1, m3 + delta);

	movzx	ecx, BYTE PTR [rbp+2592]
	mov	edx, 1
	mov	eax, edx
	shl	eax, cl
	lea	ecx, DWORD PTR [rax-1]
	lea	eax, DWORD PTR [rsi+r8]

; 186  :   }
; 187  :   if(!part_Q_nofilter) {
; 188  :     src[0] = CLIP(0, (1 << encoder->bitdepth) - 1, m4 - delta);
; 189  :   }
; 190  : }

	mov	rsi, QWORD PTR [rsp+24]
	cmp	ecx, eax
	cmovge	ecx, eax
	xor	r9d, r9d
	test	ecx, ecx
	cmovs	ecx, r9d
	sub	edi, r8d
	mov	BYTE PTR [rbx], cl
	movzx	ecx, BYTE PTR [rbp+2592]
	mov	rbx, QWORD PTR [rsp+8]
	mov	rbp, QWORD PTR [rsp+16]
	shl	edx, cl
	lea	eax, DWORD PTR [rdx-1]
	cmp	eax, edi
	cmovge	eax, edi
	mov	rdi, QWORD PTR [rsp+32]
	test	eax, eax
	cmovs	eax, r9d
	mov	BYTE PTR [r11], al
	ret	0
kvz_filter_deblock_chroma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
state$ = 48
x$ = 56
y$ = 64
dir$ = 72
is_tu_boundary PROC

; 206  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 207  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [rcx+48]
	mov	ebx, r9d
	mov	edi, r8d
	mov	esi, edx
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx+32]
	call	kvz_cu_array_at_const

; 208  :     kvz_cu_array_at_const(state->tile->frame->cu_array, x, y);
; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	movzx	ecx, BYTE PTR [rax+1]
	mov	eax, 64					; 00000040H
	and	ecx, 7
	sar	eax, cl
	dec	eax

; 210  : 
; 211  :   if (dir == EDGE_HOR) {

	cmp	ebx, 1
	jne	SHORT $LN2@is_tu_boun

; 212  :     return (y & (tu_width - 1)) == 0;

	test	eax, edi

; 213  :   } else {
; 214  :     return (x & (tu_width - 1)) == 0;
; 215  :   }
; 216  : }

	sete	al
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@is_tu_boun:
	mov	rbx, QWORD PTR [rsp+48]
	test	eax, esi
	mov	rsi, QWORD PTR [rsp+56]
	sete	al
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
is_tu_boundary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
state$ = 64
x$ = 72
y$ = 80
dir$ = 88
is_pu_boundary PROC

; 232  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 233  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [rcx+48]
	mov	rbx, rcx
	mov	ebp, r9d
	mov	r15d, r8d
	mov	r12d, edx
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx+32]
	call	kvz_cu_array_at_const

; 234  :     kvz_cu_array_at_const(state->tile->frame->cu_array, x, y);
; 235  :   // Get the containing CU.
; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	edi, 64					; 00000040H
	movzx	ecx, BYTE PTR [rax]

; 237  :   const int32_t x_cu = x & ~(cu_width - 1);
; 238  :   const int32_t y_cu = y & ~(cu_width - 1);
; 239  :   const cu_info_t *const cu =

	mov	rax, QWORD PTR [rbx+48]
	shr	ecx, 2
	and	ecx, 7
	sar	edi, cl
	mov	rcx, QWORD PTR [rax]
	lea	esi, DWORD PTR [rdi-1]
	mov	rcx, QWORD PTR [rcx+32]
	not	esi
	mov	r14d, esi
	and	esi, r15d
	and	r14d, r12d
	mov	r8d, esi
	mov	edx, r14d
	call	kvz_cu_array_at_const

; 240  :     kvz_cu_array_at_const(state->tile->frame->cu_array, x_cu, y_cu);
; 241  : 
; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	ecx, BYTE PTR [rax]
	shr	rcx, 5
	movzx	eax, BYTE PTR kvz_part_mode_num_parts[rcx+rdx]

; 243  :   for (int i = 0; i < num_pu; i++) {

	test	al, al
	je	SHORT $LN3@is_pu_boun
	xor	r8d, r8d
	lea	rcx, QWORD PTR kvz_part_mode_offsets[rcx*8]
	add	rcx, rdx
	mov	r9d, eax
	npad	7
$LL4@is_pu_boun:

; 244  :     if (dir == EDGE_HOR) {

	cmp	ebp, 1
	jne	SHORT $LN5@is_pu_boun

; 245  :       int y_pu = PU_GET_Y(cu->part_size, cu_width, y_cu, i);

	movzx	eax, BYTE PTR [rcx+1]
	imul	eax, edi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, esi

; 246  :       if (y_pu == y) return true;

	cmp	eax, r15d

; 247  : 
; 248  :     } else {

	jmp	SHORT $LN16@is_pu_boun
$LN5@is_pu_boun:

; 249  :       int x_pu = PU_GET_X(cu->part_size, cu_width, x_cu, i);

	movzx	eax, BYTE PTR [rcx]
	imul	eax, edi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, r14d

; 250  :       if (x_pu == x) return true;

	cmp	eax, r12d
$LN16@is_pu_boun:

; 243  :   for (int i = 0; i < num_pu; i++) {

	je	SHORT $LN12@is_pu_boun
	inc	r8
	add	rcx, 2
	cmp	r8, r9
	jl	SHORT $LL4@is_pu_boun
$LN3@is_pu_boun:

; 251  :     }
; 252  :   }
; 253  : 
; 254  :   return false;

	xor	al, al
$LN1@is_pu_boun:

; 255  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
$LN12@is_pu_boun:

; 250  :       if (x_pu == x) return true;

	mov	al, 1
	jmp	SHORT $LN1@is_pu_boun
is_pu_boundary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
x$ = 8
y$ = 16
dir$ = 24
is_on_8x8_grid PROC

; 268  :   if (dir == EDGE_HOR) {

	cmp	r8d, 1
	jne	SHORT $LN2@is_on_8x8_

; 269  :     return (y & 7) == 0;

	test	dl, 7

; 272  :   }
; 273  : }

	sete	al
	ret	0
$LN2@is_on_8x8_:

; 270  :   } else {
; 271  :     return (x & 7) == 0;

	test	cl, 7

; 272  :   }
; 273  : }

	sete	al
	ret	0
is_on_8x8_grid ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
state$ = 48
x$ = 56
y$ = 64
dir$ = 72
get_qp_y_pred PROC

; 276  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 32					; 00000020H

; 277  :   if (state->encoder_control->max_qp_delta_depth < 0) {

	mov	rax, QWORD PTR [rcx]
	mov	esi, r8d
	mov	ebp, edx
	mov	rbx, rcx
	cmp	BYTE PTR [rax+6520], 0
	jge	SHORT $LN2@get_qp_y_p

; 278  :     return state->qp;

	movzx	eax, BYTE PTR [rcx+384]

; 292  :     kvz_cu_array_at_const(state->tile->frame->cu_array, x, y)->qp;
; 293  : 
; 294  :   return (qp_p + qp_q + 1) >> 1;
; 295  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@get_qp_y_p:
	mov	QWORD PTR [rsp+48], rdi

; 279  :   }
; 280  : 
; 281  :   int32_t qp_p;
; 282  :   if (dir == EDGE_HOR && y > 0) {

	cmp	r9d, 1
	jne	SHORT $LN3@get_qp_y_p
	test	esi, esi
	jle	SHORT $LN5@get_qp_y_p

; 283  :     qp_p = kvz_cu_array_at_const(state->tile->frame->cu_array, x, y - 1)->qp;

	mov	rax, QWORD PTR [rcx+48]
	dec	r8d
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx+32]
	call	kvz_cu_array_at_const
	movzx	edi, BYTE PTR [rax+6]
	jmp	SHORT $LN9@get_qp_y_p
$LN3@get_qp_y_p:

; 284  :   } else if (dir == EDGE_VER && x > 0) {

	test	r9d, r9d
	jne	SHORT $LN5@get_qp_y_p
	test	ebp, ebp
	jle	SHORT $LN5@get_qp_y_p

; 285  :     qp_p = kvz_cu_array_at_const(state->tile->frame->cu_array, x - 1, y)->qp;

	mov	rax, QWORD PTR [rcx+48]
	dec	edx
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx+32]
	call	kvz_cu_array_at_const
	movzx	edi, BYTE PTR [rax+6]

; 286  :   } else {

	jmp	SHORT $LN9@get_qp_y_p
$LN5@get_qp_y_p:

; 287  :     // TODO: This seems to be dead code. Investigate.
; 288  :     qp_p = state->encoder_control->cfg.set_qp_in_cu ? 26 : state->frame->QP;

	cmp	BYTE PTR [rax+2463], 0
	je	SHORT $LN8@get_qp_y_p
	mov	edi, 26
	jmp	SHORT $LN9@get_qp_y_p
$LN8@get_qp_y_p:
	mov	rax, QWORD PTR [rcx+40]
	movsx	edi, BYTE PTR [rax+24]
$LN9@get_qp_y_p:

; 289  :   }
; 290  : 
; 291  :   const int32_t qp_q =

	mov	rax, QWORD PTR [rbx+48]
	mov	r8d, esi
	mov	edx, ebp
	mov	rcx, QWORD PTR [rax]
	mov	rcx, QWORD PTR [rcx+32]
	call	kvz_cu_array_at_const

; 292  :     kvz_cu_array_at_const(state->tile->frame->cu_array, x, y)->qp;
; 293  : 
; 294  :   return (qp_p + qp_q + 1) >> 1;
; 295  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	movzx	eax, BYTE PTR [rax+6]
	inc	eax
	add	eax, edi
	mov	rdi, QWORD PTR [rsp+48]
	sar	eax, 1
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
get_qp_y_pred ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
src$ = 8
step$ = 16
stride$ = 24
reach$dead$ = 32
dst$ = 40
gather_deblock_pixels PROC

; 306  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	r10, QWORD PTR dst$[rsp]

; 307  :   for (int i = -reach; i < +reach; ++i) {
; 308  :     dst[i + 4] = src[i * step + stride];

	lea	eax, DWORD PTR [rdx*4]
	mov	rbx, rcx
	mov	r11d, edx
	mov	r9d, r8d
	sub	r9d, eax
	movsxd	rax, r9d
	movzx	r9d, BYTE PTR [rax+rcx]
	lea	eax, DWORD PTR [rdx+rdx*2]
	mov	BYTE PTR [r10], r9b
	mov	r9d, r8d
	sub	r9d, eax
	movsxd	rax, r9d
	movzx	edx, BYTE PTR [rax+rcx]
	lea	eax, DWORD PTR [r11+r11]
	mov	BYTE PTR [r10+1], dl
	mov	ecx, r8d
	sub	ecx, eax
	movsxd	rax, ecx
	movzx	ecx, BYTE PTR [rax+rbx]
	mov	eax, r8d
	sub	eax, r11d
	mov	BYTE PTR [r10+2], cl
	cdqe
	movzx	ecx, BYTE PTR [rax+rbx]
	mov	BYTE PTR [r10+3], cl
	movsxd	rax, r8d
	movzx	ecx, BYTE PTR [rax+rbx]
	lea	eax, DWORD PTR [r11+r8]
	mov	BYTE PTR [r10+4], cl
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+rbx]
	mov	BYTE PTR [r10+5], al
	lea	eax, DWORD PTR [r8+r11*2]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+rbx]
	mov	BYTE PTR [r10+6], al
	lea	eax, DWORD PTR [r8+r11*2]
	add	eax, r11d
	cdqe
	movzx	ecx, BYTE PTR [rax+rbx]

; 309  :   }
; 310  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	BYTE PTR [r10+7], cl
	ret	0
gather_deblock_pixels ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
src$ = 8
step$ = 16
stride$ = 24
reach$ = 32
dst$ = 40
scatter_deblock_pixels PROC

; 321  : {

	mov	QWORD PTR [rsp+8], rbx

; 322  :   for (int i = -reach; i < +reach; ++i) {

	mov	ebx, r9d
	neg	ebx
	cmp	ebx, r9d
	jge	SHORT $LN3@scatter_de
	movsxd	rax, ebx
	lea	r10, QWORD PTR [rcx+4]
	add	r10, rax
	movsxd	r11, edx
	mov	eax, ebx
	imul	eax, edx
	add	eax, r8d
	cdqe
	add	rax, QWORD PTR dst$[rsp]
	sub	r9d, ebx
	mov	edx, r9d
$LL4@scatter_de:

; 323  :     dst[i * step + stride] = src[i + 4];

	movzx	ecx, BYTE PTR [r10]
	lea	r10, QWORD PTR [r10+1]
	mov	BYTE PTR [rax], cl
	add	rax, r11
	sub	rdx, 1
	jne	SHORT $LL4@scatter_de
$LN3@scatter_de:

; 324  :   }
; 325  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
scatter_deblock_pixels ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
b$1$ = 32
m6$1$ = 32
tv8445 = 33
b$2$ = 34
x_stride$1$ = 36
tv8488 = 40
tv7195 = 40
dq$1$ = 44
tv8484 = 44
dp$1$ = 48
tv8480 = 48
b$1 = 56
y_stride$1$ = 88
block_idx$1$ = 92
tv7249 = 96
tv7304 = 104
tv7287 = 104
tc_offset_div2$1$ = 112
qp$1$ = 116
tv7313 = 120
tv7264 = 124
tv7204 = 128
tv7202 = 132
tv7201 = 136
num_4px_parts$1$ = 140
frame$1$ = 144
src$1$ = 152
encoder$1$ = 160
state$ = 256
x$ = 264
y$ = 272
sw$1$ = 280
tv8443 = 280
length$ = 280
dir$ = 288
tu_boundary$ = 296
filter_deblock_edge_luma PROC

; 358  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-15]
	sub	rsp, 184				; 000000b8H

; 359  :   videoframe_t * const frame = state->tile->frame;
; 360  :   const encoder_control_t * const encoder = state->encoder_control;

	mov	r15, QWORD PTR [rcx]
	mov	esi, r9d
	mov	rax, QWORD PTR [rcx+48]
	mov	r13d, r8d

; 361  : 
; 362  :   {
; 363  :     int32_t stride = frame->rec->stride;
; 364  :     int32_t beta_offset_div2 = encoder->cfg.deblock_beta;
; 365  :     int32_t tc_offset_div2   = encoder->cfg.deblock_tc;
; 366  :     // TODO: support 10+bits
; 367  :     kvz_pixel *orig_src = &frame->rec->y[x + y*stride];
; 368  :     kvz_pixel *src = orig_src;
; 369  : 
; 370  :     const int32_t qp = get_qp_y_pred(state, x, y, dir);

	mov	r9d, DWORD PTR dir$[rbp-169]
	mov	r14d, edx
	mov	r12, rcx
	mov	QWORD PTR encoder$1$[rbp-169], r15
	mov	ebx, DWORD PTR [r15+96]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR frame$1$[rbp-169], rax
	mov	r10, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [r15+100]
	mov	DWORD PTR tc_offset_div2$1$[rbp-169], eax
	mov	edi, DWORD PTR [r10+72]
	mov	eax, edi
	imul	eax, r8d
	add	eax, edx
	cdqe
	add	rax, QWORD PTR [r10+16]
	mov	QWORD PTR src$1$[rbp-169], rax
	call	get_qp_y_pred

; 371  : 
; 372  :     int8_t strength = 0;
; 373  :     int32_t bitdepth_scale  = 1 << (encoder->bitdepth - 8);

	movsx	r8d, BYTE PTR [r15+2592]

; 374  :     int32_t b_index         = CLIP(0, 51, qp + (beta_offset_div2 << 1));

	xor	r9d, r9d
	movsx	ecx, al
	add	r8d, -8
	mov	DWORD PTR qp$1$[rbp-169], ecx
	mov	DWORD PTR tv7313[rbp-169], r8d
	lea	eax, DWORD PTR [rcx+rbx*2]
	cmp	eax, 51					; 00000033H
	jg	SHORT $LN264@filter_deb
	test	eax, eax
	cmovs	eax, r9d
	jmp	SHORT $LN40@filter_deb
$LN264@filter_deb:
	mov	eax, 51					; 00000033H
$LN40@filter_deb:

; 375  :     int32_t beta            = kvz_g_beta_table_8x8[b_index] * bitdepth_scale;

	cdqe
	lea	r11, OFFSET FLAT:__ImageBase
	mov	ecx, r8d

; 376  :     int32_t side_threshold  = (beta + (beta >>1 )) >> 3;
; 377  :     int32_t tc_index;
; 378  :     int32_t tc;
; 379  : 
; 380  :     uint32_t num_4px_parts  = length / 4;
; 381  : 
; 382  :     // Transpose the image by swapping x and y strides when doing horizontal
; 383  :     // edges.
; 384  :     const int32_t x_stride = (dir == EDGE_VER) ? 1 : stride;

	mov	r15d, edi
	movzx	edx, BYTE PTR kvz_g_beta_table_8x8[rax+r11]
	shl	edx, cl
	mov	ecx, DWORD PTR dir$[rbp-169]
	mov	eax, edx
	sar	eax, 1
	add	eax, edx
	mov	DWORD PTR tv7264[rbp-169], edx
	sar	eax, 3
	mov	DWORD PTR tv7249[rbp-169], eax
	mov	eax, esi
	cdq
	and	edx, 3
	add	edx, eax
	mov	eax, 1
	sar	edx, 2
	test	ecx, ecx
	mov	DWORD PTR num_4px_parts$1$[rbp-169], edx
	cmove	r15d, eax

; 385  :     const int32_t y_stride = (dir == EDGE_VER) ? stride : 1;

	cmove	eax, edi
	mov	DWORD PTR y_stride$1$[rbp-169], eax
	mov	eax, r9d
	mov	DWORD PTR block_idx$1$[rbp-169], eax
	mov	DWORD PTR x_stride$1$[rsp], r15d

; 386  : 
; 387  :     // TODO: add CU based QP calculation
; 388  : 
; 389  :     // For each 4-pixel part in the edge
; 390  :     for (uint32_t block_idx = 0; block_idx < num_4px_parts; ++block_idx) {

	test	edx, edx
	je	$LN3@filter_deb
	npad	2
$LL4@filter_deb:

; 391  :       {
; 392  :         // CUs on both sides of the edge
; 393  :         cu_info_t *cu_p;
; 394  :         cu_info_t *cu_q;
; 395  :         if (dir == EDGE_VER) {

	mov	rbx, QWORD PTR frame$1$[rbp-169]
	lea	eax, DWORD PTR [rax*4]
	mov	rbx, QWORD PTR [rbx+32]
	test	ecx, ecx
	jne	$LN8@filter_deb

; 396  :           int32_t y_coord = y + 4 * block_idx;
; 397  :           cu_p = kvz_cu_array_at(frame->cu_array, x - 1, y_coord);

	mov	edi, DWORD PTR x$[rbp-169]
	lea	r14d, DWORD PTR [rax+r13]
	dec	edi
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	edi, DWORD PTR [rbx+16]
	jb	SHORT $LN73@filter_deb
	lea	r8d, QWORD PTR [rcx+101]
	lea	rcx, OFFSET FLAT:$SG4294944407
	lea	rdx, OFFSET FLAT:$SG4294944408
	call	QWORD PTR __imp__wassert
$LN73@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	r14d, DWORD PTR [rbx+20]
	jb	SHORT $LN74@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN74@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rbx+24]
	mov	esi, r14d
	sar	eax, 2
	shr	edi, 2
	shr	esi, 2
	imul	eax, esi
	add	eax, edi
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+8]
	lea	rbx, QWORD PTR [rax+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 398  :           cu_q = kvz_cu_array_at(frame->cu_array, x,     y_coord);

	mov	rax, QWORD PTR frame$1$[rbp-169]
	mov	rdi, QWORD PTR [rax+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	mov	eax, DWORD PTR x$[rbp-169]
	cmp	eax, DWORD PTR [rdi+16]
	jb	SHORT $LN79@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN79@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	r14d, DWORD PTR [rdi+20]
	jb	SHORT $LN80@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN80@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rdi+24]
	mov	eax, DWORD PTR x$[rbp-169]
	sar	ecx, 2
	imul	ecx, esi
	shr	eax, 2
	add	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 400  :         } else {

	jmp	$LN275@filter_deb
$LN8@filter_deb:

; 401  :           int32_t x_coord = x + 4 * block_idx;

	add	r14d, eax

; 402  :           cu_p = kvz_cu_array_at(frame->cu_array, x_coord, y - 1);

	lea	edi, DWORD PTR [r13-1]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r14d, DWORD PTR [rbx+16]
	jb	SHORT $LN85@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN85@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	edi, DWORD PTR [rbx+20]
	jb	SHORT $LN86@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN86@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rbx+24]
	mov	esi, r14d
	sar	eax, 2
	shr	edi, 2
	imul	eax, edi
	shr	esi, 2
	add	eax, esi
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+8]
	lea	rbx, QWORD PTR [rax+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 403  :           cu_q = kvz_cu_array_at(frame->cu_array, x_coord, y    );

	mov	rax, QWORD PTR frame$1$[rbp-169]
	mov	rdi, QWORD PTR [rax+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r14d, DWORD PTR [rdi+16]
	jb	SHORT $LN91@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN91@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	r13d, DWORD PTR [rdi+20]
	jb	SHORT $LN92@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN92@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rdi+24]
	mov	eax, r13d
	sar	ecx, 2
	shr	eax, 2
	imul	ecx, eax
	add	ecx, esi
$LN275@filter_deb:
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 406  :         bool nonzero_coeffs = cbf_is_set(cu_q->cbf, cu_q->tr_depth, COLOR_Y)

	mov	rax, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	r8, QWORD PTR [rax+rcx*4]
	movzx	eax, BYTE PTR [rax+rcx*4+1]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	r11, OFFSET FLAT:__ImageBase
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 406  :         bool nonzero_coeffs = cbf_is_set(cu_q->cbf, cu_q->tr_depth, COLOR_Y)

	and	eax, 7
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[r11+rax*2]
	test	ax, WORD PTR [r8+4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 406  :         bool nonzero_coeffs = cbf_is_set(cu_q->cbf, cu_q->tr_depth, COLOR_Y)

	jne	SHORT $LN43@filter_deb
	movzx	eax, BYTE PTR [rbx+1]
	and	eax, 7
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR cbf_masks[r11+rax*2]
	test	ax, WORD PTR [rbx+4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 406  :         bool nonzero_coeffs = cbf_is_set(cu_q->cbf, cu_q->tr_depth, COLOR_Y)

	jne	SHORT $LN43@filter_deb
	xor	eax, eax
	mov	ecx, eax
	jmp	SHORT $LN44@filter_deb
$LN43@filter_deb:
	mov	ecx, 1
$LN44@filter_deb:

; 407  :                            || cbf_is_set(cu_p->cbf, cu_p->tr_depth, COLOR_Y);
; 408  : 
; 409  :         // Filter strength
; 410  :         strength = 0;
; 411  :         if (cu_q->type == CU_INTRA || cu_p->type == CU_INTRA) {

	movzx	eax, BYTE PTR [r8]
	xor	r9b, r9b
	and	al, 3
	cmp	al, 1
	je	$LN12@filter_deb
	movzx	eax, BYTE PTR [rbx]
	and	al, 3
	cmp	al, 1
	je	$LN12@filter_deb

; 413  :         } else if (tu_boundary && nonzero_coeffs) {

	cmp	BYTE PTR tu_boundary$[rbp-169], r9b
	je	SHORT $LN13@filter_deb
	test	ecx, ecx
	je	SHORT $LN13@filter_deb

; 414  :           // Non-zero residual/coeffs and transform boundary
; 415  :           // Neither CU is intra so tr_depth <= MAX_DEPTH.
; 416  :           strength = 1;       

	mov	r9b, 1
	jmp	$LN25@filter_deb
$LN13@filter_deb:

; 417  :         } else if (cu_p->inter.mv_dir != 3 && cu_q->inter.mv_dir != 3 &&

	movzx	r11d, BYTE PTR [rbx+18]
	movzx	eax, r11b
	and	al, 192					; 000000c0H
	cmp	al, 192					; 000000c0H
	je	$LN265@filter_deb
	movzx	edi, BYTE PTR [r8+18]
	movzx	r10d, dil
	shr	r10b, 6
	cmp	r10b, 3
	je	$LN265@filter_deb
	mov	esi, edi
	mov	r14d, r11d
	shr	rsi, 6
	shr	r14, 6
	movsx	eax, WORD PTR [r8+rsi*4+4]
	movsx	ecx, WORD PTR [rbx+r14*4+4]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	SHORT $LN17@filter_deb
	movsx	ecx, WORD PTR [rbx+r14*4+6]
	movsx	eax, WORD PTR [r8+rsi*4+6]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	SHORT $LN17@filter_deb

; 418  :                  ((abs(cu_q->inter.mv[cu_q->inter.mv_dir - 1][0] - cu_p->inter.mv[cu_p->inter.mv_dir - 1][0]) >= 4) ||
; 419  :                   (abs(cu_q->inter.mv[cu_q->inter.mv_dir - 1][1] - cu_p->inter.mv[cu_p->inter.mv_dir - 1][1]) >= 4))) {
; 420  :           // Absolute motion vector diff between blocks >= 1 (Integer pixel)
; 421  :           strength = 1;
; 422  :         } else if (cu_p->inter.mv_dir != 3 && cu_q->inter.mv_dir != 3 &&

	cmp	r10b, 3
	je	SHORT $LN265@filter_deb
	mov	eax, r11d
	mov	ecx, edi
	shr	rax, 6
	shr	rcx, 6
	movzx	eax, BYTE PTR [rax+rbx+15]
	cmp	BYTE PTR [rcx+r8+15], al
	je	SHORT $LN265@filter_deb
$LN17@filter_deb:

; 476  :                            (abs(mvQ0[1] - mvP0[1]) >= 4) ||
; 477  :                            (abs(mvQ1[0] - mvP1[0]) >= 4) ||
; 478  :                            (abs(mvQ1[1] - mvP1[1]) >= 4)) &&
; 479  :                           ((abs(mvQ1[0] - mvP0[0]) >= 4) ||
; 480  :                            (abs(mvQ1[1] - mvP0[1]) >= 4) ||
; 481  :                            (abs(mvQ0[0] - mvP1[0]) >= 4) ||
; 482  :                            (abs(mvQ0[1] - mvP1[1]) >= 4)) ? 1 : 0;
; 483  :             }
; 484  :           } else {
; 485  :             strength = 1;
; 486  :           }
; 487  :         }
; 488  : 
; 489  :         tc_index        = CLIP(0, 51 + 2, (int32_t)(qp + 2*(strength - 1) + (tc_offset_div2 << 1)));

	mov	r9b, 1
$LN274@filter_deb:
	lea	r11, OFFSET FLAT:__ImageBase
$LN25@filter_deb:
	mov	ecx, DWORD PTR qp$1$[rbp-169]
	movzx	eax, r9b
	add	eax, DWORD PTR tc_offset_div2$1$[rbp-169]
	lea	ecx, DWORD PTR [rcx+rax*2]
	add	ecx, -2
	cmp	ecx, 53					; 00000035H
	jg	$LN266@filter_deb
	test	ecx, ecx
	mov	eax, 0
	cmovs	ecx, eax
	jmp	$LN64@filter_deb
$LN265@filter_deb:

; 423  :                    cu_q->inter.mv_ref[cu_q->inter.mv_dir - 1] != cu_p->inter.mv_ref[cu_p->inter.mv_dir - 1]) {
; 424  :           strength = 1;
; 425  :         }
; 426  :         
; 427  :         // B-slice related checks
; 428  :         if(!strength && state->frame->slicetype == KVZ_SLICE_B) {

	mov	rax, QWORD PTR [r12+40]
	cmp	DWORD PTR [rax+88], 0
	jne	SHORT $LN274@filter_deb

; 429  : 
; 430  :           // Zero all undefined motion vectors for easier usage
; 431  :           if(!(cu_q->inter.mv_dir & 1)) {

	movzx	eax, BYTE PTR [r8+18]
	shr	al, 6
	test	al, 1
	jne	SHORT $LN20@filter_deb

; 432  :             cu_q->inter.mv[0][0] = 0;

	xor	ecx, ecx
	mov	DWORD PTR [r8+8], ecx
$LN20@filter_deb:

; 433  :             cu_q->inter.mv[0][1] = 0;
; 434  :           }
; 435  :           if(!(cu_q->inter.mv_dir & 2)) {

	test	al, 2
	jne	SHORT $LN21@filter_deb

; 436  :             cu_q->inter.mv[1][0] = 0;

	mov	DWORD PTR [r8+12], 0
$LN21@filter_deb:

; 437  :             cu_q->inter.mv[1][1] = 0;
; 438  :           }
; 439  : 
; 440  :           if(!(cu_p->inter.mv_dir & 1)) {

	movzx	edx, BYTE PTR [rbx+18]
	shr	dl, 6
	movzx	eax, dl
	and	al, 1
	jne	SHORT $LN22@filter_deb

; 441  :             cu_p->inter.mv[0][0] = 0;

	mov	DWORD PTR [rbx+8], 0
$LN22@filter_deb:

; 442  :             cu_p->inter.mv[0][1] = 0;
; 443  :           }
; 444  :           if(!(cu_p->inter.mv_dir & 2)) {

	and	dl, 2
	jne	SHORT $LN23@filter_deb

; 445  :             cu_p->inter.mv[1][0] = 0;

	mov	DWORD PTR [rbx+12], 0
$LN23@filter_deb:

; 446  :             cu_p->inter.mv[1][1] = 0;
; 447  :           }
; 448  :           const int refP0 = (cu_p->inter.mv_dir & 1) ? state->frame->ref_LX[0][cu_p->inter.mv_ref[0]] : -1;

	test	al, al
	je	SHORT $LN45@filter_deb
	movzx	ecx, BYTE PTR [rbx+16]
	mov	rax, QWORD PTR [r12+40]
	movzx	r9d, BYTE PTR [rcx+rax+49]
	jmp	SHORT $LN46@filter_deb
$LN45@filter_deb:
	mov	r9d, -1
$LN46@filter_deb:

; 449  :           const int refP1 = (cu_p->inter.mv_dir & 2) ? state->frame->ref_LX[1][cu_p->inter.mv_ref[1]] : -1;

	test	dl, dl
	je	SHORT $LN47@filter_deb
	movzx	ecx, BYTE PTR [rbx+17]
	mov	rax, QWORD PTR [r12+40]
	movzx	edi, BYTE PTR [rcx+rax+65]
	jmp	SHORT $LN48@filter_deb
$LN47@filter_deb:
	mov	edi, -1
$LN48@filter_deb:

; 450  :           const int refQ0 = (cu_q->inter.mv_dir & 1) ? state->frame->ref_LX[0][cu_q->inter.mv_ref[0]] : -1;

	movzx	edx, BYTE PTR [r8+18]
	shr	dl, 6
	test	dl, 1
	je	SHORT $LN49@filter_deb
	movzx	ecx, BYTE PTR [r8+16]
	mov	rax, QWORD PTR [r12+40]
	movzx	r10d, BYTE PTR [rcx+rax+49]
	jmp	SHORT $LN50@filter_deb
$LN49@filter_deb:
	mov	r10d, -1
$LN50@filter_deb:

; 451  :           const int refQ1 = (cu_q->inter.mv_dir & 2) ? state->frame->ref_LX[1][cu_q->inter.mv_ref[1]] : -1;

	test	dl, 2
	je	SHORT $LN51@filter_deb
	movzx	ecx, BYTE PTR [r8+17]
	mov	rax, QWORD PTR [r12+40]
	movzx	edx, BYTE PTR [rcx+rax+65]
	jmp	SHORT $LN52@filter_deb
$LN51@filter_deb:
	mov	edx, -1
$LN52@filter_deb:

; 452  :           const int16_t* mvQ0 = cu_q->inter.mv[0];
; 453  :           const int16_t* mvQ1 = cu_q->inter.mv[1];
; 454  : 
; 455  :           const int16_t* mvP0 = cu_p->inter.mv[0];
; 456  :           const int16_t* mvP1 = cu_p->inter.mv[1];
; 457  : 
; 458  :           if(( refP0 == refQ0 &&  refP1 == refQ1 ) || ( refP0 == refQ1 && refP1==refQ0 ))

	cmp	r9d, r10d
	jne	SHORT $LN27@filter_deb
	cmp	edi, edx
	je	SHORT $LN26@filter_deb
$LN27@filter_deb:
	cmp	r9d, edx
	jne	$LN17@filter_deb
	cmp	edi, r10d
	jne	$LN17@filter_deb
$LN26@filter_deb:

; 459  :           {
; 460  :             // Different L0 & L1
; 461  :             if ( refP0 != refP1 ) {          

	movsx	r11d, WORD PTR [rbx+8]
	cmp	r9d, edi
	je	$LN28@filter_deb

; 462  :               if ( refP0 == refQ0 ) {

	cmp	r9d, r10d
	jne	SHORT $LN30@filter_deb

; 463  :                 strength  = ((abs(mvQ0[0] - mvP0[0]) >= 4) ||

	movsx	eax, WORD PTR [r8+8]
	sub	eax, r11d
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
	movsx	ecx, WORD PTR [rbx+10]
	movsx	eax, WORD PTR [r8+10]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
	movsx	ecx, WORD PTR [rbx+12]
	movsx	eax, WORD PTR [r8+12]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
	movsx	eax, WORD PTR [r8+14]
$LN279@filter_deb:

; 476  :                            (abs(mvQ0[1] - mvP0[1]) >= 4) ||
; 477  :                            (abs(mvQ1[0] - mvP1[0]) >= 4) ||
; 478  :                            (abs(mvQ1[1] - mvP1[1]) >= 4)) &&
; 479  :                           ((abs(mvQ1[0] - mvP0[0]) >= 4) ||
; 480  :                            (abs(mvQ1[1] - mvP0[1]) >= 4) ||
; 481  :                            (abs(mvQ0[0] - mvP1[0]) >= 4) ||
; 482  :                            (abs(mvQ0[1] - mvP1[1]) >= 4)) ? 1 : 0;
; 483  :             }
; 484  :           } else {
; 485  :             strength = 1;
; 486  :           }
; 487  :         }
; 488  : 
; 489  :         tc_index        = CLIP(0, 51 + 2, (int32_t)(qp + 2*(strength - 1) + (tc_offset_div2 << 1)));

	movsx	ecx, WORD PTR [rbx+14]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
$LN59@filter_deb:
	xor	r9b, r9b
	jmp	$LN274@filter_deb
$LN30@filter_deb:

; 464  :                              (abs(mvQ0[1] - mvP0[1]) >= 4) ||
; 465  :                              (abs(mvQ1[0] - mvP1[0]) >= 4) ||
; 466  :                              (abs(mvQ1[1] - mvP1[1]) >= 4)) ? 1 : 0;
; 467  :               } else {
; 468  :                 strength  = ((abs(mvQ1[0] - mvP0[0]) >= 4) ||

	movsx	eax, WORD PTR [r8+12]
	sub	eax, r11d
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
	movsx	ecx, WORD PTR [rbx+10]
	movsx	eax, WORD PTR [r8+14]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
	movsx	ecx, WORD PTR [rbx+12]
	movsx	eax, WORD PTR [r8+8]
	sub	eax, ecx
$LN278@filter_deb:

; 476  :                            (abs(mvQ0[1] - mvP0[1]) >= 4) ||
; 477  :                            (abs(mvQ1[0] - mvP1[0]) >= 4) ||
; 478  :                            (abs(mvQ1[1] - mvP1[1]) >= 4)) &&
; 479  :                           ((abs(mvQ1[0] - mvP0[0]) >= 4) ||
; 480  :                            (abs(mvQ1[1] - mvP0[1]) >= 4) ||
; 481  :                            (abs(mvQ0[0] - mvP1[0]) >= 4) ||
; 482  :                            (abs(mvQ0[1] - mvP1[1]) >= 4)) ? 1 : 0;
; 483  :             }
; 484  :           } else {
; 485  :             strength = 1;
; 486  :           }
; 487  :         }
; 488  : 
; 489  :         tc_index        = CLIP(0, 51 + 2, (int32_t)(qp + 2*(strength - 1) + (tc_offset_div2 << 1)));

	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
	movsx	eax, WORD PTR [r8+10]
	jmp	SHORT $LN279@filter_deb
$LN28@filter_deb:

; 469  :                              (abs(mvQ1[1] - mvP0[1]) >= 4) ||
; 470  :                              (abs(mvQ0[0] - mvP1[0]) >= 4) ||
; 471  :                              (abs(mvQ0[1] - mvP1[1]) >= 4)) ? 1 : 0;
; 472  :               }
; 473  :             // Same L0 & L1
; 474  :             } else {  
; 475  :               strength  = ((abs(mvQ0[0] - mvP0[0]) >= 4) ||

	movsx	r9d, WORD PTR [r8+8]
	mov	eax, r9d
	sub	eax, r11d
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	SHORT $LN57@filter_deb
	movsx	ecx, WORD PTR [rbx+10]
	movsx	eax, WORD PTR [r8+10]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	SHORT $LN57@filter_deb
	movsx	ecx, WORD PTR [rbx+12]
	movsx	eax, WORD PTR [r8+12]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	SHORT $LN57@filter_deb
	movsx	ecx, WORD PTR [rbx+14]
	movsx	eax, WORD PTR [r8+14]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jl	$LN59@filter_deb
$LN57@filter_deb:
	movsx	eax, WORD PTR [r8+12]
	sub	eax, r11d
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
	movsx	ecx, WORD PTR [rbx+10]
	movsx	eax, WORD PTR [r8+14]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 4
	jge	$LN17@filter_deb
	movsx	ecx, WORD PTR [rbx+12]
	sub	r9d, ecx
	mov	eax, r9d
	jmp	$LN278@filter_deb
$LN12@filter_deb:

; 412  :           strength = 2;

	mov	r9b, 2

; 423  :                    cu_q->inter.mv_ref[cu_q->inter.mv_dir - 1] != cu_p->inter.mv_ref[cu_p->inter.mv_dir - 1]) {
; 424  :           strength = 1;
; 425  :         }
; 426  :         
; 427  :         // B-slice related checks
; 428  :         if(!strength && state->frame->slicetype == KVZ_SLICE_B) {

	jmp	$LN25@filter_deb
$LN266@filter_deb:

; 476  :                            (abs(mvQ0[1] - mvP0[1]) >= 4) ||
; 477  :                            (abs(mvQ1[0] - mvP1[0]) >= 4) ||
; 478  :                            (abs(mvQ1[1] - mvP1[1]) >= 4)) &&
; 479  :                           ((abs(mvQ1[0] - mvP0[0]) >= 4) ||
; 480  :                            (abs(mvQ1[1] - mvP0[1]) >= 4) ||
; 481  :                            (abs(mvQ0[0] - mvP1[0]) >= 4) ||
; 482  :                            (abs(mvQ0[1] - mvP1[1]) >= 4)) ? 1 : 0;
; 483  :             }
; 484  :           } else {
; 485  :             strength = 1;
; 486  :           }
; 487  :         }
; 488  : 
; 489  :         tc_index        = CLIP(0, 51 + 2, (int32_t)(qp + 2*(strength - 1) + (tc_offset_div2 << 1)));

	mov	ecx, 53					; 00000035H
$LN64@filter_deb:

; 490  :         tc              = kvz_g_tc_table_8x8[tc_index] * bitdepth_scale;

	movsxd	rax, ecx
	mov	ecx, DWORD PTR tv7313[rbp-169]
	movzx	r12d, BYTE PTR kvz_g_tc_table_8x8[rax+r11]
	shl	r12d, cl

; 491  :       }
; 492  : 
; 493  :       if (strength == 0) continue;

	test	r9b, r9b
	je	$LN2@filter_deb

; 308  :     dst[i + 4] = src[i * step + stride];

	movsxd	r11, DWORD PTR x_stride$1$[rsp]
	mov	eax, r15d

; 494  : 
; 495  :       //                   +-- edge_src
; 496  :       //                   v
; 497  :       // line0 p3 p2 p1 p0 q0 q1 q2 q3
; 498  :       kvz_pixel *edge_src = &src[block_idx * 4 * y_stride];

	mov	r13d, DWORD PTR block_idx$1$[rbp-169]

; 308  :     dst[i + 4] = src[i * step + stride];

	neg	eax

; 494  : 
; 495  :       //                   +-- edge_src
; 496  :       //                   v
; 497  :       // line0 p3 p2 p1 p0 q0 q1 q2 q3
; 498  :       kvz_pixel *edge_src = &src[block_idx * 4 * y_stride];

	mov	r8d, DWORD PTR y_stride$1$[rbp-169]

; 308  :     dst[i + 4] = src[i * step + stride];

	mov	edx, r11d
	imul	r9d, r15d, -3
	neg	edx

; 494  : 
; 495  :       //                   +-- edge_src
; 496  :       //                   v
; 497  :       // line0 p3 p2 p1 p0 q0 q1 q2 q3
; 498  :       kvz_pixel *edge_src = &src[block_idx * 4 * y_stride];

	imul	r13d, r8d

; 308  :     dst[i + 4] = src[i * step + stride];

	lea	ecx, DWORD PTR [rax*4]
	mov	DWORD PTR tv7304[rbp-169], edx
	movsxd	rax, ecx
	lea	r8d, DWORD PTR [r8+r8*2]
	mov	DWORD PTR tv7204[rbp-169], ecx
	mov	DWORD PTR tv7202[rbp-169], r9d

; 494  : 
; 495  :       //                   +-- edge_src
; 496  :       //                   v
; 497  :       // line0 p3 p2 p1 p0 q0 q1 q2 q3
; 498  :       kvz_pixel *edge_src = &src[block_idx * 4 * y_stride];

	shl	r13d, 2
	add	r13, QWORD PTR src$1$[rbp-169]

; 308  :     dst[i + 4] = src[i * step + stride];

	movzx	eax, BYTE PTR [rax+r13]
	movzx	r14d, BYTE PTR [r11+r13]
	mov	BYTE PTR tv8445[rsp], al
	mov	BYTE PTR b$1[rbp-169], al
	movsxd	rax, r9d
	mov	BYTE PTR b$1[rbp-164], r14b
	movzx	r15d, BYTE PTR [rax+r13]
	mov	eax, r11d
	neg	eax
	mov	BYTE PTR b$1[rbp-168], r15b
	lea	r10d, DWORD PTR [rax+rax]
	movsxd	rax, r10d
	mov	DWORD PTR tv7201[rbp-169], r10d
	movzx	ebx, BYTE PTR [rax+r13]
	movsxd	rax, edx
	mov	BYTE PTR b$1[rbp-167], bl
	movzx	eax, BYTE PTR [rax+r13]
	mov	DWORD PTR tv8480[rbp-169], eax
	mov	BYTE PTR b$1[rbp-166], al
	movzx	eax, BYTE PTR [r13]
	mov	BYTE PTR b$1[rbp-165], al
	lea	eax, DWORD PTR [r11+r11]
	cdqe
	movzx	esi, BYTE PTR [rax+r13]
	lea	eax, DWORD PTR [r11+r11*2]
	cdqe
	mov	BYTE PTR b$1[rbp-163], sil
	movzx	eax, BYTE PTR [rax+r13]
	mov	BYTE PTR tv8443[rbp-169], al
	mov	BYTE PTR b$1[rbp-162], al
	lea	eax, DWORD PTR [rcx+r8]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$2$[rsp], al
	mov	BYTE PTR b$1[rbp-145], al
	lea	eax, DWORD PTR [r9+r8]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [r10+r8]
	movzx	edi, BYTE PTR [rcx+r13]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [rdx+r8]
	mov	BYTE PTR b$1[rbp-144], dil
	movzx	r9d, BYTE PTR [rcx+r13]
	movsxd	rcx, eax
	mov	BYTE PTR b$1[rbp-143], r9b
	movzx	eax, BYTE PTR [rcx+r13]
	mov	DWORD PTR tv8484[rbp-169], eax
	mov	BYTE PTR b$1[rbp-142], al
	movsxd	rax, r8d
	movzx	ecx, BYTE PTR [rax+r13]
	lea	eax, DWORD PTR [r8+r11]
	mov	DWORD PTR tv8488[rsp], ecx
	mov	BYTE PTR b$1[rbp-141], cl
	movsxd	rcx, eax
	movzx	r11d, BYTE PTR [rcx+r13]
	mov	ecx, DWORD PTR x_stride$1$[rsp]
	add	ecx, ecx
	mov	BYTE PTR b$1[rbp-140], r11b
	add	ecx, r8d
	movsxd	rdx, ecx
	mov	ecx, DWORD PTR x_stride$1$[rsp]
	movzx	r10d, BYTE PTR [rdx+r13]
	mov	BYTE PTR b$1[rbp-139], r10b
	lea	ecx, DWORD PTR [rcx+rcx*2]
	add	ecx, r8d

; 506  :       int_fast32_t dq0 = abs(b[0][4] - 2 * b[0][5] + b[0][6]);

	add	r14d, r14d
	movzx	r8d, BYTE PTR [r13]
	sub	esi, r14d

; 507  :       int_fast32_t dp3 = abs(b[3][1] - 2 * b[3][2] + b[3][3]);

	add	r9d, r9d

; 308  :     dst[i + 4] = src[i * step + stride];

	movsxd	rdx, ecx

; 507  :       int_fast32_t dp3 = abs(b[3][1] - 2 * b[3][2] + b[3][3]);

	sub	edi, r9d
	add	ebx, ebx
	sub	r15d, ebx

; 508  :       int_fast32_t dq3 = abs(b[3][4] - 2 * b[3][5] + b[3][6]);

	add	r11d, r11d
	mov	ebx, DWORD PTR tv8480[rbp-169]
	sub	r10d, r11d

; 308  :     dst[i + 4] = src[i * step + stride];

	movzx	eax, BYTE PTR [rdx+r13]

; 508  :       int_fast32_t dq3 = abs(b[3][4] - 2 * b[3][5] + b[3][6]);

	mov	r11d, DWORD PTR tv8488[rsp]

; 308  :     dst[i + 4] = src[i * step + stride];

	mov	BYTE PTR b$1$[rsp], al
	mov	BYTE PTR b$1[rbp-138], al

; 499  : 
; 500  :       // Gather the lines of pixels required for the filter on/off decision.
; 501  :       kvz_pixel b[4][8];
; 502  :       gather_deblock_pixels(edge_src, x_stride, 0 * y_stride, 4, &b[0][0]);
; 503  :       gather_deblock_pixels(edge_src, x_stride, 3 * y_stride, 4, &b[3][0]);
; 504  : 
; 505  :       int_fast32_t dp0 = abs(b[0][1] - 2 * b[0][2] + b[0][3]);

	lea	eax, DWORD PTR [rbx+r15]
	cdq
	mov	r15d, eax

; 506  :       int_fast32_t dq0 = abs(b[0][4] - 2 * b[0][5] + b[0][6]);

	lea	eax, DWORD PTR [r8+rsi]

; 507  :       int_fast32_t dp3 = abs(b[3][1] - 2 * b[3][2] + b[3][3]);

	mov	esi, DWORD PTR tv8484[rbp-169]
	xor	r15d, edx
	sub	r15d, edx
	cdq
	mov	r14d, eax
	xor	r14d, edx
	sub	r14d, edx
	lea	eax, DWORD PTR [rsi+rdi]

; 509  :       int_fast32_t dp = dp0 + dp3;
; 510  :       int_fast32_t dq = dq0 + dq3;
; 511  : 
; 512  :       if (dp + dq < beta) {

	mov	edi, DWORD PTR tv7264[rbp-169]
	cdq
	mov	r9d, eax
	lea	eax, DWORD PTR [r11+r10]
	xor	r9d, edx
	sub	r9d, edx
	cdq
	mov	r10d, eax
	xor	r10d, edx
	sub	r10d, edx
	lea	ecx, DWORD PTR [r9+r15]
	mov	DWORD PTR dp$1$[rbp-169], ecx
	lea	eax, DWORD PTR [r10+r14]
	add	ecx, eax
	mov	DWORD PTR dq$1$[rbp-169], eax
	cmp	ecx, edi
	jge	$LN271@filter_deb

; 513  :         // Strong filtering flag checking
; 514  :         int8_t sw = 2 * (dp0 + dq0) < beta >> 2 &&

	mov	ecx, edi
	lea	eax, DWORD PTR [r14+r15]
	sar	ecx, 2
	add	eax, eax
	cmp	eax, ecx
	jge	$LN67@filter_deb
	lea	eax, DWORD PTR [r10+r9]
	add	eax, eax
	cmp	eax, ecx
	jge	$LN67@filter_deb
	mov	eax, ebx
	lea	ecx, DWORD PTR [r12*4+1]
	sub	eax, r8d
	add	ecx, r12d
	cdq
	sar	ecx, 1
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ecx
	jge	SHORT $LN67@filter_deb
	mov	eax, esi
	sub	eax, r11d
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ecx
	jge	SHORT $LN67@filter_deb
	movzx	ecx, BYTE PTR tv8443[rbp-169]
	mov	r9d, edi
	sub	r8d, ecx
	sar	r9d, 3
	mov	eax, r8d
	cdq
	mov	ecx, eax
	movzx	eax, BYTE PTR tv8445[rsp]
	xor	ecx, edx
	sub	eax, ebx
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	add	ecx, eax
	cmp	ecx, r9d
	jge	SHORT $LN67@filter_deb
	movzx	eax, BYTE PTR b$2$[rsp]
	movzx	ecx, BYTE PTR b$1$[rsp]
	sub	eax, esi
	cdq
	mov	BYTE PTR sw$1$[rbp-169], 1
	mov	r8d, eax
	sub	r11d, ecx
	xor	r8d, edx
	mov	eax, r11d
	sub	r8d, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	add	r8d, eax
	cmp	r8d, r9d
	jl	SHORT $LL68@filter_deb
$LN67@filter_deb:
	mov	BYTE PTR sw$1$[rbp-169], 0
	npad	15
$LL68@filter_deb:

; 308  :     dst[i + 4] = src[i * step + stride];

	movsxd	rdx, DWORD PTR y_stride$1$[rbp-169]
	mov	r9d, DWORD PTR tv7204[rbp-169]
	mov	esi, DWORD PTR x_stride$1$[rsp]
	mov	r8d, DWORD PTR tv7304[rbp-169]
	mov	r10d, DWORD PTR tv7202[rbp-169]
	mov	r11d, DWORD PTR tv7201[rbp-169]
	lea	eax, DWORD PTR [r9+rdx]
	movsxd	rcx, eax
	lea	ebx, DWORD PTR [rsi+rsi]
	lea	edi, DWORD PTR [rsi+rsi*2]

; 515  :                     2 * (dp3 + dq3) < beta >> 2 &&
; 516  :                     abs(b[0][3] - b[0][4]) < (5 * tc + 1) >> 1 &&
; 517  :                     abs(b[3][3] - b[3][4]) < (5 * tc + 1) >> 1 &&
; 518  :                     abs(b[0][0] - b[0][3]) + abs(b[0][4] - b[0][7]) < beta >> 3 &&
; 519  :                     abs(b[3][0] - b[3][3]) + abs(b[3][4] - b[3][7]) < beta >> 3;
; 520  : 
; 521  :         // Read lines 1 and 2. Weak filtering doesn't use the outermost pixels
; 522  :         // but let's give them anyway to simplify control flow.
; 523  :         gather_deblock_pixels(edge_src, x_stride, 1 * y_stride, 4, &b[1][0]);
; 524  :         gather_deblock_pixels(edge_src, x_stride, 2 * y_stride, 4, &b[2][0]);
; 525  : 
; 526  :         for (int i = 0; i < 4; ++i) {

	mov	QWORD PTR tv7287[rbp-169], 4

; 308  :     dst[i + 4] = src[i * step + stride];

	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-161], al
	lea	eax, DWORD PTR [r10+rdx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-160], al
	lea	eax, DWORD PTR [r11+rdx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-159], al
	lea	eax, DWORD PTR [r8+rdx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	movzx	ecx, BYTE PTR [rdx+r13]
	mov	BYTE PTR b$1[rbp-158], al
	lea	eax, DWORD PTR [rdx+rsi]
	mov	BYTE PTR b$1[rbp-157], cl
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-156], al
	lea	eax, DWORD PTR [rbx+rdx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-155], al
	lea	eax, DWORD PTR [rdi+rdx]
	movsxd	rcx, eax
	add	edx, edx
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-154], al
	lea	eax, DWORD PTR [rdx+r9]
	movsxd	rcx, eax

; 515  :                     2 * (dp3 + dq3) < beta >> 2 &&
; 516  :                     abs(b[0][3] - b[0][4]) < (5 * tc + 1) >> 1 &&
; 517  :                     abs(b[3][3] - b[3][4]) < (5 * tc + 1) >> 1 &&
; 518  :                     abs(b[0][0] - b[0][3]) + abs(b[0][4] - b[0][7]) < beta >> 3 &&
; 519  :                     abs(b[3][0] - b[3][3]) + abs(b[3][4] - b[3][7]) < beta >> 3;
; 520  : 
; 521  :         // Read lines 1 and 2. Weak filtering doesn't use the outermost pixels
; 522  :         // but let's give them anyway to simplify control flow.
; 523  :         gather_deblock_pixels(edge_src, x_stride, 1 * y_stride, 4, &b[1][0]);
; 524  :         gather_deblock_pixels(edge_src, x_stride, 2 * y_stride, 4, &b[2][0]);
; 525  : 
; 526  :         for (int i = 0; i < 4; ++i) {

	lea	r9, QWORD PTR b$1[rbp-168]

; 308  :     dst[i + 4] = src[i * step + stride];

	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-153], al
	lea	eax, DWORD PTR [rdx+r10]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-152], al
	lea	eax, DWORD PTR [r11+rdx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-151], al
	lea	eax, DWORD PTR [r8+rdx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-150], al
	movsxd	rax, edx
	movzx	ecx, BYTE PTR [rax+r13]
	lea	eax, DWORD PTR [rdx+rsi]
	mov	BYTE PTR b$1[rbp-149], cl
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-148], al
	lea	eax, DWORD PTR [rbx+rdx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-147], al
	lea	eax, DWORD PTR [rdi+rdx]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r13]
	mov	BYTE PTR b$1[rbp-146], al

; 515  :                     2 * (dp3 + dq3) < beta >> 2 &&
; 516  :                     abs(b[0][3] - b[0][4]) < (5 * tc + 1) >> 1 &&
; 517  :                     abs(b[3][3] - b[3][4]) < (5 * tc + 1) >> 1 &&
; 518  :                     abs(b[0][0] - b[0][3]) + abs(b[0][4] - b[0][7]) < beta >> 3 &&
; 519  :                     abs(b[3][0] - b[3][3]) + abs(b[3][4] - b[3][7]) < beta >> 3;
; 520  : 
; 521  :         // Read lines 1 and 2. Weak filtering doesn't use the outermost pixels
; 522  :         // but let's give them anyway to simplify control flow.
; 523  :         gather_deblock_pixels(edge_src, x_stride, 1 * y_stride, 4, &b[1][0]);
; 524  :         gather_deblock_pixels(edge_src, x_stride, 2 * y_stride, 4, &b[2][0]);
; 525  : 
; 526  :         for (int i = 0; i < 4; ++i) {

	xor	eax, eax
	mov	DWORD PTR tv7195[rsp], eax
$LL7@filter_deb:

; 527  :           int filter_reach;
; 528  :           if (sw) {

	cmp	BYTE PTR sw$1$[rbp-169], 0
	movzx	r15d, BYTE PTR [r9+5]
	movzx	r11d, BYTE PTR [r9]
	movzx	r14d, BYTE PTR [r9+4]
	movzx	edi, BYTE PTR [r9+3]
	movzx	ebx, BYTE PTR [r9+2]
	movzx	esi, BYTE PTR [r9+1]
	mov	BYTE PTR m6$1$[rsp], r15b
	je	$LN34@filter_deb

; 108  :   line[1] = CLIP(m1 - 2*tc, m1 + 2*tc, (2*m0 + 3*m1 +   m2 +   m3 +   m4 + 4) >> 3);

	movzx	edx, BYTE PTR [r9-1]
	lea	eax, DWORD PTR [r11+rdi]
	lea	ecx, DWORD PTR [rax+r11*2]
	add	edx, 2
	mov	r10d, r11d
	lea	r11d, DWORD PTR [r12+r12]
	lea	r8d, DWORD PTR [rcx+rdx*2]
	mov	ecx, r10d
	add	r8d, esi
	lea	edx, DWORD PTR [r11+r10]
	add	r8d, ebx
	sub	ecx, r11d
	shr	r8d, 3
	mov	eax, edx
	cmp	edx, r8d
	cmovge	eax, r8d
	cmp	ecx, eax
	jg	SHORT $LN121@filter_deb
	cmp	edx, r8d
	mov	ecx, r8d
	cmovl	ecx, edx
$LN121@filter_deb:
	mov	BYTE PTR [r9], cl

; 109  :   line[2] = CLIP(m2 - 2*tc, m2 + 2*tc, (  m1 +   m2 +   m3 +   m4        + 2) >> 2);

	lea	r8d, DWORD PTR [r11+rsi]
	lea	r15d, DWORD PTR [rdi+rsi]
	mov	ecx, esi
	sub	ecx, r11d
	lea	edx, DWORD PTR [rbx+2]
	add	edx, r15d
	mov	eax, r8d
	add	edx, r10d
	shr	edx, 2
	cmp	r8d, edx
	cmovge	eax, edx
	cmp	ecx, eax
	jg	SHORT $LN127@filter_deb
	cmp	r8d, edx
	mov	ecx, edx
	cmovl	ecx, r8d
$LN127@filter_deb:
	mov	BYTE PTR [r9+1], cl

; 110  :   line[3] = CLIP(m3 - 2*tc, m3 + 2*tc, (  m1 + 2*m2 + 2*m3 + 2*m4 +   m5 + 4) >> 3);

	lea	r8d, DWORD PTR [r11+rbx]
	lea	ecx, DWORD PTR [rbx+2]
	mov	edx, ebx
	add	ecx, r15d
	sub	edx, r11d
	mov	eax, r8d
	lea	ecx, DWORD PTR [r10+rcx*2]
	add	ecx, r14d
	shr	ecx, 3
	cmp	r8d, ecx
	cmovge	eax, ecx
	cmp	edx, eax
	jg	SHORT $LN133@filter_deb
	cmp	r8d, ecx
	mov	edx, ecx
	cmovl	edx, r8d
$LN133@filter_deb:

; 111  :   line[4] = CLIP(m4 - 2*tc, m4 + 2*tc, (  m2 + 2*m3 + 2*m4 + 2*m5 +   m6 + 4) >> 3);

	movzx	r8d, BYTE PTR m6$1$[rsp]
	lea	r10d, DWORD PTR [r11+rdi]
	mov	BYTE PTR [r9+2], dl
	lea	eax, DWORD PTR [rdi+2]
	add	eax, ebx
	mov	edx, edi
	add	eax, r14d
	sub	edx, r11d
	lea	ecx, DWORD PTR [r8+rax*2]
	mov	eax, r10d
	add	ecx, esi
	shr	ecx, 3
	cmp	r10d, ecx
	cmovge	eax, ecx
	cmp	edx, eax
	jg	SHORT $LN139@filter_deb
	cmp	r10d, ecx
	mov	edx, ecx
	cmovl	edx, r10d
$LN139@filter_deb:
	mov	BYTE PTR [r9+3], dl

; 112  :   line[5] = CLIP(m5 - 2*tc, m5 + 2*tc, (  m3 +   m4 +   m5 +   m6        + 2) >> 2);

	lea	r10d, DWORD PTR [r11+r14]
	lea	edx, DWORD PTR [rdi+2]
	mov	ecx, r14d
	add	edx, ebx
	sub	ecx, r11d
	add	edx, r8d
	mov	eax, r10d
	add	edx, r14d
	shr	edx, 2
	cmp	r10d, edx
	cmovge	eax, edx
	cmp	ecx, eax
	jg	SHORT $LN145@filter_deb
	cmp	r10d, edx
	mov	ecx, edx
	cmovl	ecx, r10d
$LN145@filter_deb:

; 113  :   line[6] = CLIP(m6 - 2*tc, m6 + 2*tc, (  m3 +   m4 +   m5 + 3*m6 + 2*m7 + 4) >> 3);

	movzx	r10d, BYTE PTR [r9+6]
	lea	eax, DWORD PTR [r8+rbx]
	mov	BYTE PTR [r9+4], cl
	lea	ecx, DWORD PTR [r8+2]
	lea	ecx, DWORD PTR [rax+rcx*2]
	lea	r10d, DWORD PTR [rcx+r10*2]
	add	r10d, edi
	lea	ecx, DWORD PTR [r11+r8]
	add	r10d, r14d
	sub	r8d, r11d
	shr	r10d, 3
	mov	eax, ecx
	cmp	ecx, r10d
	cmovge	eax, r10d
	cmp	r8d, eax
	jg	SHORT $LN151@filter_deb
	cmp	ecx, r10d
	mov	r8d, r10d
	cmovl	r8d, ecx
$LN151@filter_deb:

; 529  :             filter_reach = kvz_filter_deblock_luma_strong(&b[i][0], tc);

	mov	eax, -3

; 113  :   line[6] = CLIP(m6 - 2*tc, m6 + 2*tc, (  m3 +   m4 +   m5 + 3*m6 + 2*m7 + 4) >> 3);

	mov	BYTE PTR [r9+5], r8b

; 529  :             filter_reach = kvz_filter_deblock_luma_strong(&b[i][0], tc);

	lea	r10d, QWORD PTR [rax+6]
	lea	r8, QWORD PTR [r10-6]

; 530  :           } else {

	jmp	$LN270@filter_deb
$LN34@filter_deb:

; 140  :   int32_t delta = (9 * (m4 - m3) - 3 * (m5 - m2) + 8) >> 4;

	mov	eax, edi
	sub	eax, ebx
	lea	ecx, DWORD PTR [rax+rax*2]
	sub	ecx, r14d
	add	ecx, esi
	lea	r10d, DWORD PTR [rcx+4]
	lea	r10d, DWORD PTR [rcx+r10*2]
	sar	r10d, 4

; 141  : 
; 142  :   if (abs(delta) >= tc * 10) {

	lea	ecx, DWORD PTR [r12+r12*4]
	mov	eax, r10d
	add	ecx, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ecx
	jge	$LN272@filter_deb

; 143  :     return 0;
; 144  :   } else {
; 145  :     int32_t tc2 = tc >> 1;
; 146  :     delta = CLIP(-tc, tc, delta);

	mov	eax, r12d
	mov	r8d, r12d
	sar	r8d, 1
	cmp	r12d, r10d
	cmovl	r10d, r12d
	neg	eax
	cmp	eax, r10d
	cmovg	r10d, eax

; 147  :     line[3] = CLIP(0, (1 << encoder->bitdepth) - 1, (m3 + delta));

	mov	rax, QWORD PTR encoder$1$[rbp-169]
	movzx	ecx, BYTE PTR [rax+2592]
	lea	edx, DWORD PTR [rbx+r10]
	mov	eax, 1
	shl	eax, cl
	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, edx
	mov	eax, ecx
	cmovge	eax, edx
	test	eax, eax
	jns	SHORT $LN170@filter_deb
	xor	eax, eax
	mov	edx, eax
	jmp	SHORT $LN168@filter_deb
$LN170@filter_deb:
	cmp	ecx, edx
	cmovl	edx, ecx
$LN168@filter_deb:
	mov	BYTE PTR [r9+2], dl

; 148  :     line[4] = CLIP(0, (1 << encoder->bitdepth) - 1, (m4 - delta));

	mov	eax, ecx
	mov	edx, edi
	sub	edx, r10d
	cmp	ecx, edx
	cmovge	eax, edx
	test	eax, eax
	jns	SHORT $LN176@filter_deb
	xor	eax, eax
	mov	edx, eax
	jmp	SHORT $LN174@filter_deb
$LN176@filter_deb:
	cmp	ecx, edx
	cmovl	edx, ecx
$LN174@filter_deb:

; 149  : 
; 150  :     if (p_2nd) {

	mov	eax, DWORD PTR dp$1$[rbp-169]
	mov	BYTE PTR [r9+3], dl
	cmp	eax, DWORD PTR tv7249[rbp-169]
	jge	SHORT $LN158@filter_deb

; 151  :       int32_t delta1 = CLIP(-tc2, tc2, (((m1 + m3 + 1) >> 1) - m2 + delta) >> 1);

	lea	edx, DWORD PTR [r11+1]
	mov	eax, r8d
	add	edx, ebx
	mov	r11d, r8d
	shr	edx, 1
	neg	r11d
	sub	edx, esi
	add	edx, r10d
	sar	edx, 1
	cmp	r8d, edx
	cmovge	eax, edx
	cmp	r11d, eax
	jg	SHORT $LN180@filter_deb
	cmp	r8d, edx
	mov	r11d, edx
	cmovl	r11d, r8d
$LN180@filter_deb:

; 152  :       line[2] = CLIP(0, (1 << encoder->bitdepth) - 1, m2 + delta1);

	lea	edx, DWORD PTR [rsi+r11]
	mov	eax, ecx
	cmp	ecx, edx
	cmovge	eax, edx
	test	eax, eax
	jns	SHORT $LN188@filter_deb
	xor	eax, eax
	mov	edx, eax
	jmp	SHORT $LN186@filter_deb
$LN188@filter_deb:
	cmp	ecx, edx
	cmovl	edx, ecx
$LN186@filter_deb:
	mov	BYTE PTR [r9+1], dl
$LN158@filter_deb:

; 153  :     }
; 154  :     if (q_2nd) {

	mov	r11d, DWORD PTR tv7249[rbp-169]
	mov	eax, DWORD PTR dq$1$[rbp-169]
	cmp	eax, r11d
	jge	SHORT $LN269@filter_deb

; 155  :       int32_t delta2 = CLIP(-tc2, tc2, (((m6 + m4 + 1) >> 1) - m5 - delta) >> 1);

	lea	edx, DWORD PTR [r15+1]
	mov	eax, r8d
	add	edx, edi
	shr	edx, 1
	sub	edx, r14d
	sub	edx, r10d
	mov	r10d, r8d
	sar	edx, 1
	neg	r10d
	cmp	r8d, edx
	cmovge	eax, edx
	cmp	r10d, eax
	jg	SHORT $LN192@filter_deb
	cmp	r8d, edx
	mov	r10d, edx
	cmovl	r10d, r8d
$LN192@filter_deb:

; 156  :       line[5] = CLIP(0, (1 << encoder->bitdepth) - 1, m5 + delta2);

	lea	edx, DWORD PTR [r14+r10]
	mov	eax, ecx
	cmp	ecx, edx
	cmovge	eax, edx
	test	eax, eax
	jns	SHORT $LN200@filter_deb
	xor	eax, eax
	mov	edx, eax
	jmp	SHORT $LN198@filter_deb
$LN200@filter_deb:
	cmp	ecx, edx
	cmovl	edx, ecx
$LN198@filter_deb:
	mov	eax, DWORD PTR dq$1$[rbp-169]
	mov	BYTE PTR [r9+4], dl
$LN269@filter_deb:

; 157  :     }
; 158  :     
; 159  :     if (p_2nd || q_2nd) {

	cmp	DWORD PTR dp$1$[rbp-169], r11d
	jl	SHORT $LN162@filter_deb
	cmp	eax, r11d
	jl	SHORT $LN162@filter_deb

; 161  :     } else {
; 162  :       return 1;

	mov	eax, -1
	lea	r10d, QWORD PTR [rax+2]
	lea	r8, QWORD PTR [r10-2]
	jmp	SHORT $LN270@filter_deb
$LN162@filter_deb:

; 160  :       return 2;

	mov	eax, -2
	lea	r10d, QWORD PTR [rax+4]
	lea	r8, QWORD PTR [r10-4]
$LN270@filter_deb:

; 531  :             bool p_2nd = dp < side_threshold;
; 532  :             bool q_2nd = dq < side_threshold;
; 533  :             filter_reach = kvz_filter_deblock_luma_weak(encoder, &b[i][0], tc, p_2nd, q_2nd);
; 534  :           }
; 535  :           scatter_deblock_pixels(&b[i][0], x_stride, i * y_stride, filter_reach, edge_src);

	mov	r15d, DWORD PTR x_stride$1$[rsp]
	imul	eax, r15d
	add	eax, DWORD PTR tv7195[rsp]
	npad	11
$LL205@filter_deb:

; 323  :     dst[i * step + stride] = src[i + 4];

	movzx	ecx, BYTE PTR [r9+r8+3]
	inc	r8
	movsxd	rdx, eax
	add	eax, r15d
	mov	BYTE PTR [rdx+r13], cl
	cmp	r8, r10
	jl	SHORT $LL205@filter_deb

; 142  :   if (abs(delta) >= tc * 10) {

	jmp	SHORT $LN5@filter_deb
$LN272@filter_deb:
	mov	r15d, DWORD PTR x_stride$1$[rsp]
$LN5@filter_deb:

; 515  :                     2 * (dp3 + dq3) < beta >> 2 &&
; 516  :                     abs(b[0][3] - b[0][4]) < (5 * tc + 1) >> 1 &&
; 517  :                     abs(b[3][3] - b[3][4]) < (5 * tc + 1) >> 1 &&
; 518  :                     abs(b[0][0] - b[0][3]) + abs(b[0][4] - b[0][7]) < beta >> 3 &&
; 519  :                     abs(b[3][0] - b[3][3]) + abs(b[3][4] - b[3][7]) < beta >> 3;
; 520  : 
; 521  :         // Read lines 1 and 2. Weak filtering doesn't use the outermost pixels
; 522  :         // but let's give them anyway to simplify control flow.
; 523  :         gather_deblock_pixels(edge_src, x_stride, 1 * y_stride, 4, &b[1][0]);
; 524  :         gather_deblock_pixels(edge_src, x_stride, 2 * y_stride, 4, &b[2][0]);
; 525  : 
; 526  :         for (int i = 0; i < 4; ++i) {

	mov	eax, DWORD PTR y_stride$1$[rbp-169]
	add	r9, 8
	add	DWORD PTR tv7195[rsp], eax
	sub	QWORD PTR tv7287[rbp-169], 1
	jne	$LL7@filter_deb

; 509  :       int_fast32_t dp = dp0 + dp3;
; 510  :       int_fast32_t dq = dq0 + dq3;
; 511  : 
; 512  :       if (dp + dq < beta) {

	jmp	SHORT $LN277@filter_deb
$LN271@filter_deb:
	mov	r15d, DWORD PTR x_stride$1$[rsp]
$LN277@filter_deb:

; 386  : 
; 387  :     // TODO: add CU based QP calculation
; 388  : 
; 389  :     // For each 4-pixel part in the edge
; 390  :     for (uint32_t block_idx = 0; block_idx < num_4px_parts; ++block_idx) {

	mov	r13d, DWORD PTR y$[rbp-169]
$LN2@filter_deb:
	mov	eax, DWORD PTR block_idx$1$[rbp-169]
	mov	r12, QWORD PTR state$[rbp-169]
	inc	eax
	mov	r14d, DWORD PTR x$[rbp-169]
	mov	ecx, DWORD PTR dir$[rbp-169]
	mov	DWORD PTR block_idx$1$[rbp-169], eax
	cmp	eax, DWORD PTR num_4px_parts$1$[rbp-169]
	jb	$LL4@filter_deb
$LN3@filter_deb:

; 536  :         }
; 537  :       }
; 538  :     }
; 539  :   }
; 540  : }

	add	rsp, 184				; 000000b8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
filter_deblock_edge_luma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
num_4px_parts$1$ = 32
frame$1$ = 40
tv1682 = 48
$T1 = 56
src$2 = 64
tv1693 = 160
state$ = 160
step$1$ = 168
x$ = 168
blk_idx$1$ = 176
y$ = 176
y_px$1$ = 184
length$ = 184
dir$ = 192
x_px$1$ = 200
tu_boundary$dead$ = 200
filter_deblock_edge_chroma PROC

; 573  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 96					; 00000060H

; 574  :   const encoder_control_t * const encoder = state->encoder_control;
; 575  :   const videoframe_t * const frame = state->tile->frame;

	mov	rax, QWORD PTR [rcx+48]

; 576  : 
; 577  :   // For each subpart
; 578  :   {
; 579  :     int32_t stride = frame->rec->stride >> 1;
; 580  :     int32_t tc_offset_div2 = encoder->cfg.deblock_tc;
; 581  :     // TODO: support 10+bits
; 582  :     kvz_pixel *src[] = {
; 583  :       &frame->rec->u[x + y*stride],
; 584  :       &frame->rec->v[x + y*stride],
; 585  :     };
; 586  :     int8_t strength = 2;
; 587  : 
; 588  :     const int32_t luma_qp  = get_qp_y_pred(state, x << 1, y << 1, dir);

	lea	r14d, DWORD PTR [r8+r8]
	mov	r15, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	r11d, edx
	mov	DWORD PTR y_px$1$[rsp], r14d
	mov	ebp, r9d
	mov	r9d, DWORD PTR dir$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	edi, DWORD PTR [r15+100]
	mov	QWORD PTR frame$1$[rsp], rax
	mov	r10, QWORD PTR [rax+8]
	mov	esi, DWORD PTR [r10+72]
	mov	rcx, QWORD PTR [r10+24]
	sar	esi, 1
	mov	eax, esi
	imul	eax, r8d
	mov	r8d, r14d
	add	eax, edx
	movsxd	rdx, eax
	lea	eax, DWORD PTR [r11+r11]
	add	rcx, rdx
	mov	DWORD PTR x_px$1$[rsp], eax
	mov	QWORD PTR src$2[rsp], rcx
	mov	rcx, QWORD PTR [r10+32]
	add	rcx, rdx
	mov	edx, eax
	mov	QWORD PTR src$2[rsp+8], rcx
	mov	rcx, rbx
	call	get_qp_y_pred

; 589  :     int32_t QP             = kvz_g_chroma_scale[luma_qp];
; 590  :     int32_t bitdepth_scale = 1 << (encoder->bitdepth-8);

	movsx	edx, BYTE PTR [r15+2592]
	lea	r9, OFFSET FLAT:__ImageBase
	movsx	rcx, al

; 591  :     int32_t TC_index       = CLIP(0, 51+2, (int32_t)(QP + 2*(strength-1) + (tc_offset_div2 << 1)));

	xor	r8d, r8d
	movzx	eax, BYTE PTR kvz_g_chroma_scale[rcx+r9]
	lea	ecx, DWORD PTR [rdi+1]
	lea	ecx, DWORD PTR [rax+rcx*2]
	cmp	ecx, 53					; 00000035H
	jg	SHORT $LN102@filter_deb
	test	ecx, ecx
	cmovs	ecx, r8d
	jmp	SHORT $LN19@filter_deb
$LN102@filter_deb:
	mov	ecx, 53					; 00000035H
$LN19@filter_deb:

; 592  :     int32_t Tc             = kvz_g_tc_table_8x8[TC_index]*bitdepth_scale;

	movsxd	rax, ecx
	mov	r12d, r8d
	lea	ecx, DWORD PTR [rdx-8]
	mov	DWORD PTR blk_idx$1$[rsp], r8d
	movzx	edi, BYTE PTR kvz_g_tc_table_8x8[rax+r9]

; 593  : 
; 594  :     const uint32_t num_4px_parts = length / 4;

	mov	eax, ebp
	cdq
	shl	edi, cl
	and	edx, 3

; 597  :     const int32_t step   = (dir == EDGE_HOR) ?      1 : stride;

	mov	r9d, 1
	lea	ecx, DWORD PTR [rdx+rax]
	mov	edx, DWORD PTR dir$[rsp]
	sar	ecx, 2
	mov	eax, esi
	cmp	edx, r9d
	mov	DWORD PTR num_4px_parts$1$[rsp], ecx
	cmove	eax, r9d
	mov	DWORD PTR step$1$[rsp], eax

; 598  : 
; 599  :     for (uint32_t blk_idx = 0; blk_idx < num_4px_parts; ++blk_idx)

	test	ecx, ecx
	je	$LN3@filter_deb

; 595  : 
; 596  :     const int32_t offset = (dir == EDGE_HOR) ? stride :      1;

	mov	ecx, r9d
	mov	QWORD PTR [rsp+88], r13
	cmp	edx, ecx
	cmove	ecx, esi
	movsxd	r13, ecx
	npad	4
$LL4@filter_deb:

; 600  :     {
; 601  :       // CUs on both sides of the edge
; 602  :       cu_info_t *cu_p;
; 603  :       cu_info_t *cu_q;
; 604  :       if (dir == EDGE_VER) {

	mov	rbx, QWORD PTR frame$1$[rsp]
	lea	eax, DWORD PTR [r12*8]
	mov	rbx, QWORD PTR [rbx+32]
	test	edx, edx
	jne	$LN11@filter_deb

; 605  :         int32_t y_coord = (y + 4 * blk_idx) << 1;
; 606  :         cu_p = kvz_cu_array_at(frame->cu_array, (x - 1) << 1, y_coord);

	mov	esi, DWORD PTR x_px$1$[rsp]
	lea	ebp, DWORD PTR [rax+r14]
	add	esi, -2					; fffffffeH
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	esi, DWORD PTR [rbx+16]
	jb	SHORT $LN26@filter_deb
	lea	r8d, QWORD PTR [rdx+101]
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN26@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	ebp, DWORD PTR [rbx+20]
	jb	SHORT $LN27@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN27@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rbx+24]
	mov	r14d, ebp
	sar	eax, 2
	shr	esi, 2
	shr	r14d, 2
	imul	eax, r14d
	add	eax, esi
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+8]
	lea	rsi, QWORD PTR [rax+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 607  :         cu_q = kvz_cu_array_at(frame->cu_array,  x      << 1, y_coord);

	mov	rax, QWORD PTR frame$1$[rsp]
	mov	rbx, QWORD PTR [rax+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	mov	eax, DWORD PTR x_px$1$[rsp]
	cmp	eax, DWORD PTR [rbx+16]
	jb	SHORT $LN32@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN32@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	ebp, DWORD PTR [rbx+20]
	jb	SHORT $LN33@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN33@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rbx+24]
	mov	eax, DWORD PTR x_px$1$[rsp]
	sar	ecx, 2
	imul	ecx, r14d
	shr	eax, 2
	add	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 609  :       } else {

	jmp	$LN103@filter_deb
$LN11@filter_deb:

; 610  :         int32_t x_coord = (x + 4 * blk_idx) << 1;

	mov	ebp, DWORD PTR x_px$1$[rsp]

; 611  :         cu_p = kvz_cu_array_at(frame->cu_array, x_coord, (y - 1) << 1);

	lea	esi, DWORD PTR [r14-2]
	add	ebp, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	ebp, DWORD PTR [rbx+16]
	jb	SHORT $LN38@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN38@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	esi, DWORD PTR [rbx+20]
	jb	SHORT $LN39@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN39@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rbx+24]
	mov	r14d, ebp
	sar	eax, 2
	shr	esi, 2
	imul	eax, esi
	shr	r14d, 2
	add	eax, r14d
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+8]
	lea	rsi, QWORD PTR [rax+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 612  :         cu_q = kvz_cu_array_at(frame->cu_array, x_coord, (y    ) << 1);

	mov	rax, QWORD PTR frame$1$[rsp]
	mov	rbx, QWORD PTR [rax+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	ebp, DWORD PTR [rbx+16]
	jb	SHORT $LN44@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN44@filter_deb:

; 102  :   assert(y_px < cua->height);

	mov	ebp, DWORD PTR y_px$1$[rsp]
	cmp	ebp, DWORD PTR [rbx+20]
	jb	SHORT $LN45@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN45@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rbx+24]
	mov	eax, ebp
	sar	ecx, 2
	shr	eax, 2
	imul	ecx, eax
	add	ecx, r14d
$LN103@filter_deb:
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 616  :       if (cu_q->type == CU_INTRA || cu_p->type == CU_INTRA) {

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, QWORD PTR [rcx+rcx*4]
	lea	rdx, QWORD PTR [rax+rcx*4]
	movzx	eax, BYTE PTR [rax+rcx*4]
	and	al, 3
	cmp	al, 1
	je	SHORT $LN14@filter_deb
	movzx	eax, BYTE PTR [rsi]
	and	al, 3
	cmp	al, 1
	jne	$LN2@filter_deb
$LN14@filter_deb:

; 617  :         for (int component = 0; component < 2; component++) {

	xor	ecx, ecx
	mov	ebp, edi
	neg	ebp
	mov	QWORD PTR $T1[rsp], rcx
	mov	rax, r13
	neg	rax
	lea	rdx, QWORD PTR [rax+rax]
	lea	eax, DWORD PTR [r12*4]
	mov	QWORD PTR tv1682[rsp], rdx
	mov	DWORD PTR tv1693[rsp], eax
	npad	10
$LL7@filter_deb:

; 619  :             kvz_filter_deblock_chroma(encoder, src[component] + step * (4*blk_idx + i), offset, Tc, 0, 0);

	mov	r12, QWORD PTR src$2[rsp+rcx*8]
	mov	esi, eax
	mov	r14d, 2
	npad	3
$LL10@filter_deb:
	mov	ebx, esi
	imul	ebx, DWORD PTR step$1$[rsp]
	add	rbx, r12

; 179  :   int16_t m3 = src[-offset];

	mov	r11, rbx
	sub	r11, r13

; 180  :   int16_t m4 = src[0];
; 181  :   int16_t m5 = src[offset];
; 182  : 
; 183  :   delta = CLIP(-tc,tc, (((m4 - m3) * 4) + m2 - m5 + 4 ) >> 3);

	movzx	ecx, BYTE PTR [rbx+r13]
	movzx	r8d, BYTE PTR [rbx]
	movzx	r10d, BYTE PTR [r11]
	mov	eax, r8d
	sub	eax, r10d
	lea	eax, DWORD PTR [rax*4+4]
	sub	eax, ecx
	movzx	ecx, BYTE PTR [rdx+rbx]
	add	eax, ecx
	mov	ecx, edi
	sar	eax, 3
	cmp	edi, eax
	cmovge	ecx, eax
	cmp	ebp, ecx
	jle	SHORT $LN54@filter_deb
	mov	eax, ebp
	jmp	SHORT $LN52@filter_deb
$LN54@filter_deb:
	cmp	edi, eax
	cmovl	eax, edi
$LN52@filter_deb:

; 184  :   if(!part_P_nofilter) {
; 185  :     src[-offset] = CLIP(0, (1 << encoder->bitdepth) - 1, m3 + delta);

	movzx	ecx, BYTE PTR [r15+2592]
	lea	edx, DWORD PTR [r10+rax]
	mov	r9d, 1
	shl	r9d, cl
	dec	r9d
	cmp	r9d, edx
	mov	ecx, r9d
	cmovge	ecx, edx
	test	ecx, ecx
	jns	SHORT $LN60@filter_deb
	xor	r9d, r9d
	mov	edx, r9d
	jmp	SHORT $LN58@filter_deb
$LN60@filter_deb:
	cmp	r9d, edx
	cmovl	edx, r9d
	xor	r9d, r9d
$LN58@filter_deb:
	mov	BYTE PTR [r11], dl

; 186  :   }
; 187  :   if(!part_Q_nofilter) {
; 188  :     src[0] = CLIP(0, (1 << encoder->bitdepth) - 1, m4 - delta);

	sub	r8d, eax
	movzx	ecx, BYTE PTR [r15+2592]
	mov	edx, 1
	shl	edx, cl
	dec	edx
	cmp	edx, r8d
	mov	eax, edx
	cmovge	eax, r8d
	test	eax, eax
	jns	SHORT $LN66@filter_deb
	mov	r8d, r9d
	jmp	SHORT $LN64@filter_deb
$LN66@filter_deb:
	cmp	edx, r8d
	cmovl	r8d, edx
$LN64@filter_deb:
	mov	BYTE PTR [rbx], r8b

; 619  :             kvz_filter_deblock_chroma(encoder, src[component] + step * (4*blk_idx + i), offset, Tc, 0, 0);

	lea	r10d, DWORD PTR [rsi+1]
	imul	r10d, DWORD PTR step$1$[rsp]
	add	r10, r12

; 179  :   int16_t m3 = src[-offset];

	mov	rbx, r10
	sub	rbx, r13

; 180  :   int16_t m4 = src[0];
; 181  :   int16_t m5 = src[offset];
; 182  : 
; 183  :   delta = CLIP(-tc,tc, (((m4 - m3) * 4) + m2 - m5 + 4 ) >> 3);

	movzx	edx, BYTE PTR [r10]
	mov	eax, edx
	movzx	r11d, BYTE PTR [rbx]
	sub	eax, r11d
	lea	r8d, DWORD PTR [rax*4+4]
	movzx	eax, BYTE PTR [r10+r13]
	sub	r8d, eax
	mov	rax, QWORD PTR tv1682[rsp]
	movzx	eax, BYTE PTR [rax+r10]
	add	r8d, eax
	mov	eax, edi
	sar	r8d, 3
	cmp	edi, r8d
	cmovge	eax, r8d
	cmp	ebp, eax
	jle	SHORT $LN77@filter_deb
	mov	r8d, ebp
	jmp	SHORT $LN78@filter_deb
$LN77@filter_deb:
	cmp	edi, r8d
	cmovl	r8d, edi
$LN78@filter_deb:

; 184  :   if(!part_P_nofilter) {
; 185  :     src[-offset] = CLIP(0, (1 << encoder->bitdepth) - 1, m3 + delta);

	movzx	ecx, BYTE PTR [r15+2592]
	mov	r9d, 1
	shl	r9d, cl
	lea	ecx, DWORD PTR [r11+r8]
	dec	r9d
	cmp	r9d, ecx
	mov	eax, r9d
	cmovge	eax, ecx
	test	eax, eax
	jns	SHORT $LN83@filter_deb
	xor	r9d, r9d
	mov	ecx, r9d
	jmp	SHORT $LN84@filter_deb
$LN83@filter_deb:
	cmp	r9d, ecx
	cmovl	ecx, r9d
	xor	r9d, r9d
$LN84@filter_deb:

; 186  :   }
; 187  :   if(!part_Q_nofilter) {
; 188  :     src[0] = CLIP(0, (1 << encoder->bitdepth) - 1, m4 - delta);

	sub	edx, r8d
	mov	BYTE PTR [rbx], cl
	movzx	ecx, BYTE PTR [r15+2592]
	mov	eax, 1
	shl	eax, cl
	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, edx
	mov	eax, ecx
	cmovge	eax, edx
	test	eax, eax
	jns	SHORT $LN90@filter_deb
	mov	edx, r9d
	jmp	SHORT $LN91@filter_deb
$LN90@filter_deb:
	cmp	ecx, edx
	cmovl	edx, ecx
$LN91@filter_deb:

; 618  :           for (int i = 0; i < 4; i++) {

	add	esi, 2

; 188  :     src[0] = CLIP(0, (1 << encoder->bitdepth) - 1, m4 - delta);

	mov	BYTE PTR [r10], dl

; 618  :           for (int i = 0; i < 4; i++) {

	mov	rdx, QWORD PTR tv1682[rsp]
	sub	r14, 1
	jne	$LL10@filter_deb

; 617  :         for (int component = 0; component < 2; component++) {

	mov	rcx, QWORD PTR $T1[rsp]
	mov	eax, DWORD PTR tv1693[rsp]
	inc	rcx
	mov	QWORD PTR $T1[rsp], rcx
	cmp	rcx, 2
	jl	$LL7@filter_deb
	mov	r12d, DWORD PTR blk_idx$1$[rsp]
$LN2@filter_deb:

; 598  : 
; 599  :     for (uint32_t blk_idx = 0; blk_idx < num_4px_parts; ++blk_idx)

	mov	r14d, DWORD PTR y_px$1$[rsp]
	inc	r12d
	mov	edx, DWORD PTR dir$[rsp]
	mov	DWORD PTR blk_idx$1$[rsp], r12d
	cmp	r12d, DWORD PTR num_4px_parts$1$[rsp]
	jb	$LL4@filter_deb
	mov	r13, QWORD PTR [rsp+88]
$LN3@filter_deb:

; 620  :           }
; 621  :         }
; 622  :       }
; 623  :     }
; 624  :   }
; 625  : }

	add	rsp, 96					; 00000060H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
filter_deblock_edge_chroma ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
state$ = 64
x$ = 72
y$ = 80
width$dead$ = 88
height$dead$ = 96
dir$ = 104
tu_boundary$ = 112
filter_deblock_unit PROC

; 646  : {

	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 647  :   // no filtering on borders (where filter would use pixels outside the picture)
; 648  :   if (x == 0 && dir == EDGE_VER) return;

	mov	edi, DWORD PTR dir$[rsp]
	mov	ebp, r8d
	mov	esi, edx
	mov	r14, rcx
	test	edx, edx
	jne	SHORT $LN2@filter_deb
	test	edi, edi
	je	$LN8@filter_deb
$LN2@filter_deb:
	mov	QWORD PTR [rsp+64], rbx

; 649  :   if (y == 0 && dir == EDGE_HOR) return;

	test	ebp, ebp
	jne	SHORT $LN3@filter_deb
	cmp	edi, 1
	je	$LN15@filter_deb
$LN4@filter_deb:

; 667  :       length   = width;
; 668  :       length_c = width >> 1;
; 669  :     }
; 670  :   } else {
; 671  :     length   = height;
; 672  :     length_c = height >> 1;
; 673  :   }
; 674  : 
; 675  :   filter_deblock_edge_luma(state, x, y, length, dir, tu_boundary);

	mov	r9d, 8
	lea	ebx, QWORD PTR [r9-4]
$LN5@filter_deb:
	movzx	eax, BYTE PTR tu_boundary$[rsp]
	mov	edx, esi
	mov	BYTE PTR [rsp+40], al
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], edi
	call	filter_deblock_edge_luma

; 676  : 
; 677  :   // Chroma pixel coordinates.
; 678  :   const int32_t x_c = x >> 1;
; 679  :   const int32_t y_c = y >> 1;
; 680  :   if (state->encoder_control->chroma_format != KVZ_CSP_400 && is_on_8x8_grid(x_c, y_c, dir)) {

	mov	rax, QWORD PTR [r14]
	sar	esi, 1
	sar	ebp, 1
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN15@filter_deb

; 268  :   if (dir == EDGE_HOR) {

	cmp	edi, 1
	jne	SHORT $LN11@filter_deb

; 269  :     return (y & 7) == 0;

	test	bpl, 7
	jmp	SHORT $LN16@filter_deb
$LN3@filter_deb:

; 650  : 
; 651  :   // Length of luma and chroma edges.
; 652  :   int32_t length;
; 653  :   int32_t length_c;
; 654  : 
; 655  :   if (dir == EDGE_HOR) {

	cmp	edi, 1
	jne	SHORT $LN4@filter_deb

; 656  :     const videoframe_t * const frame = state->tile->frame;
; 657  :     const int32_t x_right             = x + width;

	add	edx, 8

; 658  :     const bool rightmost_4px_of_lcu   = x_right % LCU_WIDTH == 0;

	mov	eax, edx
	and	eax, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN14@filter_deb
	dec	eax
	or	eax, -64				; ffffffffffffffc0H
	inc	eax
$LN14@filter_deb:
	test	eax, eax

; 660  : 
; 661  :     if (rightmost_4px_of_lcu && !rightmost_4px_of_frame) {

	jne	SHORT $LN4@filter_deb

; 659  :     const bool rightmost_4px_of_frame = x_right == frame->width;

	mov	rax, QWORD PTR [rcx+48]
	mov	rcx, QWORD PTR [rax]
	cmp	edx, DWORD PTR [rcx+16]

; 660  : 
; 661  :     if (rightmost_4px_of_lcu && !rightmost_4px_of_frame) {

	je	SHORT $LN4@filter_deb

; 662  :       // The last 4 pixels will be deblocked when processing the next LCU.
; 663  :       length   = width - 4;
; 664  :       length_c = (width >> 1) - 4;

	xor	ebx, ebx
	lea	r9d, QWORD PTR [rbx+4]

; 665  : 
; 666  :     } else {

	jmp	SHORT $LN5@filter_deb
$LN11@filter_deb:

; 271  :     return (x & 7) == 0;

	test	sil, 7
$LN16@filter_deb:

; 676  : 
; 677  :   // Chroma pixel coordinates.
; 678  :   const int32_t x_c = x >> 1;
; 679  :   const int32_t y_c = y >> 1;
; 680  :   if (state->encoder_control->chroma_format != KVZ_CSP_400 && is_on_8x8_grid(x_c, y_c, dir)) {

	sete	al
	test	al, al
	je	SHORT $LN15@filter_deb

; 681  :     filter_deblock_edge_chroma(state, x_c, y_c, length_c, dir, tu_boundary);

	mov	r9d, ebx
	mov	DWORD PTR [rsp+32], edi
	mov	r8d, ebp
	mov	edx, esi
	mov	rcx, r14
	call	filter_deblock_edge_chroma
$LN15@filter_deb:
	mov	rbx, QWORD PTR [rsp+64]
$LN8@filter_deb:

; 682  :   }
; 683  : }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
filter_deblock_unit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
state$ = 112
x$ = 120
tv497 = 128
y$ = 128
dir$ = 136
filter_deblock_lcu_inside PROC

; 702  : {

	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rsi
	push	r12
	push	r15
	sub	rsp, 72					; 00000048H

; 703  :   const int end_x = MIN(x + LCU_WIDTH, state->tile->frame->width);

	mov	rax, QWORD PTR [rcx+48]
	lea	r12d, DWORD PTR [rdx+64]
	mov	r15, rcx
	mov	esi, r9d

; 704  :   const int end_y = MIN(y + LCU_WIDTH, state->tile->frame->height);

	lea	ecx, DWORD PTR [r8+64]
	mov	ebp, r8d
	mov	r10, QWORD PTR [rax]
	cmp	r12d, DWORD PTR [r10+16]
	cmovge	r12d, DWORD PTR [r10+16]

; 705  : 
; 706  :   for (int edge_y = y; edge_y < end_y; edge_y += 8) {

	cmp	ecx, DWORD PTR [r10+20]
	cmovge	ecx, DWORD PTR [r10+20]
	mov	DWORD PTR tv497[rsp], ecx
	cmp	r8d, ecx
	jge	$LN3@filter_deb
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+64], rdi
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r14
	npad	4
$LL4@filter_deb:

; 707  :     for (int edge_x = x; edge_x < end_x; edge_x += 8) {

	mov	ebx, edx
	cmp	edx, r12d
	jge	$LN2@filter_deb
	mov	r13d, ebp
	shr	r13d, 2
	npad	14
$LL7@filter_deb:

; 207  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r15+48]
	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	ebx, DWORD PTR [rdi+16]
	jb	SHORT $LN21@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN21@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	ebp, DWORD PTR [rdi+20]
	jb	SHORT $LN22@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN22@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rdi+24]
	mov	eax, ebx
	sar	ecx, 2
	imul	ecx, r13d
	shr	eax, 2
	add	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	mov	rax, QWORD PTR [rdi+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	lea	rcx, QWORD PTR [rcx+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	movzx	ecx, BYTE PTR [rax+rcx*4+1]
	mov	eax, 64					; 00000040H
	and	ecx, 7
	sar	eax, cl
	dec	eax

; 210  : 
; 211  :   if (dir == EDGE_HOR) {

	cmp	esi, 1
	jne	SHORT $LN16@filter_deb

; 212  :     return (y & (tu_width - 1)) == 0;

	test	eax, ebp
	jmp	SHORT $LN45@filter_deb
$LN16@filter_deb:

; 213  :   } else {
; 214  :     return (x & (tu_width - 1)) == 0;

	test	eax, ebx
$LN45@filter_deb:

; 708  :       bool tu_boundary = is_tu_boundary(state, edge_x, edge_y, dir);
; 709  :       if (tu_boundary || is_pu_boundary(state, edge_x, edge_y, dir)) {

	sete	r14b
	test	r14b, r14b
	jne	SHORT $LN9@filter_deb
	mov	r9d, esi
	mov	r8d, ebp
	mov	edx, ebx
	mov	rcx, r15
	call	is_pu_boundary
	test	al, al
	je	$LN5@filter_deb
$LN9@filter_deb:

; 648  :   if (x == 0 && dir == EDGE_VER) return;

	test	ebx, ebx
	jne	SHORT $LN24@filter_deb
	test	esi, esi
	je	$LN5@filter_deb
$LN24@filter_deb:

; 649  :   if (y == 0 && dir == EDGE_HOR) return;

	test	ebp, ebp
	jne	SHORT $LN25@filter_deb
	cmp	esi, 1
	je	$LN5@filter_deb
$LN26@filter_deb:

; 667  :       length   = width;
; 668  :       length_c = width >> 1;
; 669  :     }
; 670  :   } else {
; 671  :     length   = height;
; 672  :     length_c = height >> 1;
; 673  :   }
; 674  : 
; 675  :   filter_deblock_edge_luma(state, x, y, length, dir, tu_boundary);

	mov	r9d, 8
	lea	edi, QWORD PTR [r9-4]
$LN27@filter_deb:
	mov	BYTE PTR [rsp+40], r14b
	mov	r8d, ebp
	mov	edx, ebx
	mov	DWORD PTR [rsp+32], esi
	mov	rcx, r15
	call	filter_deblock_edge_luma

; 676  : 
; 677  :   // Chroma pixel coordinates.
; 678  :   const int32_t x_c = x >> 1;
; 679  :   const int32_t y_c = y >> 1;
; 680  :   if (state->encoder_control->chroma_format != KVZ_CSP_400 && is_on_8x8_grid(x_c, y_c, dir)) {

	mov	rax, QWORD PTR [r15]
	mov	edx, ebx
	mov	r8d, ebp
	sar	edx, 1
	sar	r8d, 1
	cmp	DWORD PTR [rax+2596], 0
	je	SHORT $LN5@filter_deb

; 268  :   if (dir == EDGE_HOR) {

	cmp	esi, 1
	jne	SHORT $LN33@filter_deb

; 269  :     return (y & 7) == 0;

	test	r8b, 7
	jmp	SHORT $LN46@filter_deb
$LN25@filter_deb:

; 655  :   if (dir == EDGE_HOR) {

	cmp	esi, 1
	jne	SHORT $LN26@filter_deb

; 656  :     const videoframe_t * const frame = state->tile->frame;
; 657  :     const int32_t x_right             = x + width;

	lea	edx, DWORD PTR [rbx+8]

; 658  :     const bool rightmost_4px_of_lcu   = x_right % LCU_WIDTH == 0;

	mov	eax, edx
	and	eax, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN44@filter_deb
	dec	eax
	or	eax, -64				; ffffffffffffffc0H
	inc	eax
$LN44@filter_deb:
	test	eax, eax

; 660  : 
; 661  :     if (rightmost_4px_of_lcu && !rightmost_4px_of_frame) {

	jne	SHORT $LN26@filter_deb

; 659  :     const bool rightmost_4px_of_frame = x_right == frame->width;

	mov	rax, QWORD PTR [r15+48]
	mov	rcx, QWORD PTR [rax]
	cmp	edx, DWORD PTR [rcx+16]

; 660  : 
; 661  :     if (rightmost_4px_of_lcu && !rightmost_4px_of_frame) {

	je	SHORT $LN26@filter_deb

; 662  :       // The last 4 pixels will be deblocked when processing the next LCU.
; 663  :       length   = width - 4;
; 664  :       length_c = (width >> 1) - 4;

	xor	edi, edi
	lea	r9d, QWORD PTR [rdi+4]

; 665  : 
; 666  :     } else {

	jmp	SHORT $LN27@filter_deb
$LN33@filter_deb:

; 271  :     return (x & 7) == 0;

	test	dl, 7
$LN46@filter_deb:

; 680  :   if (state->encoder_control->chroma_format != KVZ_CSP_400 && is_on_8x8_grid(x_c, y_c, dir)) {

	sete	al
	test	al, al
	je	SHORT $LN5@filter_deb

; 681  :     filter_deblock_edge_chroma(state, x_c, y_c, length_c, dir, tu_boundary);

	mov	r9d, edi
	mov	DWORD PTR [rsp+32], esi
	mov	rcx, r15
	call	filter_deblock_edge_chroma
$LN5@filter_deb:

; 707  :     for (int edge_x = x; edge_x < end_x; edge_x += 8) {

	add	ebx, 8
	cmp	ebx, r12d
	jl	$LL7@filter_deb
	mov	edx, DWORD PTR x$[rsp]
	mov	ecx, DWORD PTR tv497[rsp]
$LN2@filter_deb:

; 705  : 
; 706  :   for (int edge_y = y; edge_y < end_y; edge_y += 8) {

	add	ebp, 8
	cmp	ebp, ecx
	jl	$LL4@filter_deb
	mov	r14, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+112]
$LN3@filter_deb:

; 710  :         filter_deblock_unit(state, edge_x, edge_y, 8, 8, dir, tu_boundary);
; 711  :       }
; 712  :     }
; 713  :   }
; 714  : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
filter_deblock_lcu_inside ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c
_TEXT	SEGMENT
tv1195 = 48
state$ = 144
x_px$ = 152
tv1201 = 160
y_px$ = 160
tu_boundary$1$ = 168
tv1203 = 168
filter_deblock_lcu_rightmost PROC

; 727  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 72					; 00000048H
	mov	r14, rcx

; 728  :   // Luma
; 729  :   const int x = x_px - 4;

	lea	r13d, DWORD PTR [rdx-4]

; 730  :   const int end = MIN(y_px + LCU_WIDTH, state->tile->frame->height);

	lea	ecx, DWORD PTR [r8+64]
	mov	r12d, r8d

; 731  :   for (int y = y_px; y < end; y += 8) {

	mov	ebx, r8d
	mov	rax, QWORD PTR [r14+48]
	mov	r9, QWORD PTR [rax]
	cmp	ecx, DWORD PTR [r9+20]
	cmovge	ecx, DWORD PTR [r9+20]
	cmp	r8d, ecx
	jge	$LN3@filter_deb
	mov	ebp, r13d
	mov	r12d, ecx
	shr	ebp, 2
	mov	DWORD PTR tv1195[rsp], ebp
	npad	11
$LL4@filter_deb:

; 207  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r14+48]
	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r13d, DWORD PTR [rdi+16]
	jb	SHORT $LN24@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN24@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	ebx, DWORD PTR [rdi+20]
	jb	SHORT $LN25@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN25@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
	mov	esi, ebx
	sar	eax, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	mov	r15d, 64				; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	shr	esi, 2
	imul	eax, esi
	add	eax, ebp
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	mov	rax, QWORD PTR [rdi+8]
	movzx	ecx, BYTE PTR [rax+rcx*4+1]

; 233  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r14+48]

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	and	ecx, 7
	sar	r15d, cl

; 210  : 
; 211  :   if (dir == EDGE_HOR) {
; 212  :     return (y & (tu_width - 1)) == 0;

	dec	r15d
	and	r15d, ebx

; 233  :   const cu_info_t *const scu =

	mov	rcx, QWORD PTR [rax]

; 212  :     return (y & (tu_width - 1)) == 0;

	sete	BYTE PTR tu_boundary$1$[rsp]

; 233  :   const cu_info_t *const scu =

	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r13d, DWORD PTR [rdi+16]
	jb	SHORT $LN37@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN37@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	ebx, DWORD PTR [rdi+20]
	jb	SHORT $LN38@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN38@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
	sar	eax, 2
	imul	eax, esi
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	esi, 64					; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	add	eax, ebp
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	rax, QWORD PTR [rdi+8]
	movzx	ecx, BYTE PTR [rax+rcx*4]

; 237  :   const int32_t x_cu = x & ~(cu_width - 1);
; 238  :   const int32_t y_cu = y & ~(cu_width - 1);
; 239  :   const cu_info_t *const cu =

	mov	rax, QWORD PTR state$[rsp]
	shr	ecx, 2
	and	ecx, 7
	sar	esi, cl
	mov	rax, QWORD PTR [rax+48]
	lea	edi, DWORD PTR [rsi-1]
	mov	rcx, QWORD PTR [rax]
	not	edi
	mov	r14d, edi
	and	edi, ebx
	and	r14d, r13d
	mov	rbp, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r14d, DWORD PTR [rbp+16]
	jb	SHORT $LN41@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN41@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	edi, DWORD PTR [rbp+20]
	jb	SHORT $LN42@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN42@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rbp+24]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	lea	r10, OFFSET FLAT:__ImageBase
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	sar	ecx, 2
	mov	eax, edi
	shr	eax, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 243  :   for (int i = 0; i < num_pu; i++) {

	xor	r8d, r8d
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	imul	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	mov	rax, QWORD PTR [rbp+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	shr	r14d, 2
	add	ecx, r14d
	lea	rcx, QWORD PTR [rcx+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	movzx	edx, BYTE PTR [rax+rcx*4]
	shr	rdx, 5
	movzx	eax, BYTE PTR kvz_part_mode_num_parts[rdx+r10]

; 243  :   for (int i = 0; i < num_pu; i++) {

	test	al, al
	je	SHORT $LN28@filter_deb
	lea	rcx, QWORD PTR kvz_part_mode_offsets[r10+1]
	mov	r9d, eax
	lea	rcx, QWORD PTR [rcx+rdx*8]
	npad	8
$LL29@filter_deb:

; 244  :     if (dir == EDGE_HOR) {
; 245  :       int y_pu = PU_GET_Y(cu->part_size, cu_width, y_cu, i);

	movzx	eax, BYTE PTR [rcx]
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, edi

; 246  :       if (y_pu == y) return true;

	cmp	eax, ebx
	je	SHORT $LN72@filter_deb

; 243  :   for (int i = 0; i < num_pu; i++) {

	inc	r8
	add	rcx, 2
	cmp	r8, r9
	jl	SHORT $LL29@filter_deb
$LN28@filter_deb:

; 247  : 
; 248  :     } else {
; 249  :       int x_pu = PU_GET_X(cu->part_size, cu_width, x_cu, i);
; 250  :       if (x_pu == x) return true;
; 251  :     }
; 252  :   }
; 253  : 
; 254  :   return false;

	xor	al, al
$LN26@filter_deb:

; 732  :     // The top edge of the whole frame is not filtered.
; 733  :     bool tu_boundary = is_tu_boundary(state, x, y, EDGE_HOR);
; 734  :     bool pu_boundary = is_pu_boundary(state, x, y, EDGE_HOR);
; 735  :     if (y > 0 && (tu_boundary || pu_boundary)) {

	test	ebx, ebx
	jle	SHORT $LN89@filter_deb
	test	r15d, r15d
	je	SHORT $LN9@filter_deb
	test	al, al
	je	SHORT $LN89@filter_deb
$LN9@filter_deb:

; 736  :       filter_deblock_edge_luma(state, x, y, 4, EDGE_HOR, tu_boundary);

	movzx	eax, BYTE PTR tu_boundary$1$[rsp]
	mov	r9d, 4
	mov	r14, QWORD PTR state$[rsp]
	mov	r8d, ebx
	mov	BYTE PTR [rsp+40], al
	mov	rcx, r14
	mov	edx, r13d
	mov	DWORD PTR [rsp+32], 1
	call	filter_deblock_edge_luma
	jmp	SHORT $LN2@filter_deb
$LN72@filter_deb:

; 246  :       if (y_pu == y) return true;

	mov	al, 1
	jmp	SHORT $LN26@filter_deb
$LN89@filter_deb:

; 731  :   for (int y = y_px; y < end; y += 8) {

	mov	r14, QWORD PTR state$[rsp]
$LN2@filter_deb:
	mov	ebp, DWORD PTR tv1195[rsp]
	add	ebx, 8
	cmp	ebx, r12d
	jl	$LL4@filter_deb
	mov	r12d, DWORD PTR y_px$[rsp]
	mov	edx, DWORD PTR x_px$[rsp]
$LN3@filter_deb:

; 737  :     }
; 738  :   }
; 739  : 
; 740  :   // Chroma
; 741  :   if (state->encoder_control->chroma_format != KVZ_CSP_400) {

	mov	rax, QWORD PTR [r14]
	cmp	DWORD PTR [rax+2596], 0
	je	$LN6@filter_deb

; 742  :     const int x_px_c = x_px >> 1;
; 743  :     const int y_px_c = y_px >> 1;
; 744  :     const int x_c = x_px_c - 4;
; 745  :     const int end_c = MIN(y_px_c + LCU_WIDTH_C, state->tile->frame->height >> 1);

	mov	rax, QWORD PTR [r14+48]
	sar	r12d, 1
	sar	edx, 1
	sub	edx, 4
	mov	rcx, QWORD PTR [rax]
	mov	DWORD PTR x_px$[rsp], edx
	mov	eax, DWORD PTR [rcx+20]
	lea	ecx, DWORD PTR [r12+32]
	sar	eax, 1

; 746  :     for (int y_c = y_px_c; y_c < end_c; y_c += 8) {

	cmp	ecx, eax
	cmovge	ecx, eax
	mov	DWORD PTR tv1201[rsp], ecx
	cmp	r12d, ecx
	jge	$LN6@filter_deb
	lea	r13d, DWORD PTR [rdx+rdx]
	npad	10
$LL7@filter_deb:

; 207  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r14+48]

; 747  :       // The top edge of the whole frame is not filtered.
; 748  :       bool tu_boundary = is_tu_boundary(state, x_c << 1, y_c << 1, EDGE_HOR);

	lea	ebx, DWORD PTR [r12+r12]

; 207  :   const cu_info_t *const scu =

	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r13d, DWORD PTR [rdi+16]
	jb	SHORT $LN49@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN49@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	ebx, DWORD PTR [rdi+20]
	jb	SHORT $LN50@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN50@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
	mov	esi, ebx
	sar	eax, 2
	mov	ebp, r13d
	shr	esi, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	mov	r15d, 64				; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	imul	eax, esi
	shr	ebp, 2
	add	eax, ebp
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	mov	rax, QWORD PTR [rdi+8]
	movzx	ecx, BYTE PTR [rax+rcx*4+1]

; 233  :   const cu_info_t *const scu =

	mov	rax, QWORD PTR [r14+48]

; 209  :   const int tu_width = LCU_WIDTH >> scu->tr_depth;

	and	ecx, 7
	sar	r15d, cl

; 210  : 
; 211  :   if (dir == EDGE_HOR) {
; 212  :     return (y & (tu_width - 1)) == 0;

	dec	r15d
	and	r15d, ebx

; 233  :   const cu_info_t *const scu =

	mov	rcx, QWORD PTR [rax]
	mov	rdi, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r13d, DWORD PTR [rdi+16]
	jb	SHORT $LN62@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN62@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	ebx, DWORD PTR [rdi+20]
	jb	SHORT $LN63@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN63@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	eax, DWORD PTR [rdi+24]
	sar	eax, 2
	imul	eax, esi
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	esi, 64					; 00000040H
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	add	eax, ebp
	lea	rcx, QWORD PTR [rax+rax*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 236  :   const int32_t cu_width = LCU_WIDTH >> scu->depth;

	mov	rax, QWORD PTR [rdi+8]
	movzx	ecx, BYTE PTR [rax+rcx*4]

; 237  :   const int32_t x_cu = x & ~(cu_width - 1);
; 238  :   const int32_t y_cu = y & ~(cu_width - 1);
; 239  :   const cu_info_t *const cu =

	mov	rax, QWORD PTR state$[rsp]
	shr	ecx, 2
	and	ecx, 7
	sar	esi, cl
	mov	rax, QWORD PTR [rax+48]
	lea	edi, DWORD PTR [rsi-1]
	mov	rcx, QWORD PTR [rax]
	not	edi
	mov	r14d, edi
	and	edi, ebx
	and	r14d, r13d
	mov	rbp, QWORD PTR [rcx+32]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 101  :   assert(x_px < cua->width);

	cmp	r14d, DWORD PTR [rbp+16]
	jb	SHORT $LN66@filter_deb
	mov	r8d, 101				; 00000065H
	lea	rdx, OFFSET FLAT:$SG4294944408
	lea	rcx, OFFSET FLAT:$SG4294944407
	call	QWORD PTR __imp__wassert
$LN66@filter_deb:

; 102  :   assert(y_px < cua->height);

	cmp	edi, DWORD PTR [rbp+20]
	jb	SHORT $LN67@filter_deb
	mov	r8d, 102				; 00000066H
	lea	rdx, OFFSET FLAT:$SG4294944406
	lea	rcx, OFFSET FLAT:$SG4294944405
	call	QWORD PTR __imp__wassert
$LN67@filter_deb:

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	mov	ecx, DWORD PTR [rbp+24]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	lea	r10, OFFSET FLAT:__ImageBase
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	sar	ecx, 2
	mov	eax, edi
	shr	eax, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 243  :   for (int i = 0; i < num_pu; i++) {

	xor	r8d, r8d
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	imul	ecx, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	mov	rax, QWORD PTR [rbp+8]
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.c

; 103  :   return &(cua)->data[(x_px >> 2) + (y_px >> 2) * ((cua)->stride >> 2)];

	shr	r14d, 2
	add	ecx, r14d
	lea	rcx, QWORD PTR [rcx+rcx*4]
; File F:\open_codec_learn_2021\kvazaar-master\src\filter.c

; 242  :   const int num_pu = kvz_part_mode_num_parts[cu->part_size];

	movzx	edx, BYTE PTR [rax+rcx*4]
	shr	rdx, 5
	movzx	eax, BYTE PTR kvz_part_mode_num_parts[rdx+r10]

; 243  :   for (int i = 0; i < num_pu; i++) {

	test	al, al
	je	SHORT $LN53@filter_deb
	lea	rcx, QWORD PTR kvz_part_mode_offsets[r10+1]
	mov	r9d, eax
	lea	rcx, QWORD PTR [rcx+rdx*8]
	npad	6
$LL54@filter_deb:

; 244  :     if (dir == EDGE_HOR) {
; 245  :       int y_pu = PU_GET_Y(cu->part_size, cu_width, y_cu, i);

	movzx	eax, BYTE PTR [rcx]
	imul	eax, esi
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, edi

; 246  :       if (y_pu == y) return true;

	cmp	eax, ebx
	je	SHORT $LN73@filter_deb

; 243  :   for (int i = 0; i < num_pu; i++) {

	inc	r8
	add	rcx, 2
	cmp	r8, r9
	jl	SHORT $LL54@filter_deb
$LN53@filter_deb:

; 247  : 
; 248  :     } else {
; 249  :       int x_pu = PU_GET_X(cu->part_size, cu_width, x_cu, i);
; 250  :       if (x_pu == x) return true;
; 251  :     }
; 252  :   }
; 253  : 
; 254  :   return false;

	xor	al, al
$LN51@filter_deb:

; 749  :       bool pu_boundary = is_pu_boundary(state, x_c << 1, y_c << 1, EDGE_HOR);
; 750  :       if (y_c > 0 && (tu_boundary || pu_boundary)) {

	test	r12d, r12d
	jle	SHORT $LN87@filter_deb
	test	r15d, r15d
	je	SHORT $LN12@filter_deb
	test	al, al
	je	SHORT $LN87@filter_deb
$LN12@filter_deb:

; 751  :         filter_deblock_edge_chroma(state, x_c, y_c, 4, EDGE_HOR, tu_boundary);

	mov	r14, QWORD PTR state$[rsp]
	mov	r9d, 4
	mov	edx, DWORD PTR x_px$[rsp]
	mov	rcx, r14
	mov	r8d, r12d
	mov	DWORD PTR [rsp+32], 1
	call	filter_deblock_edge_chroma
	jmp	SHORT $LN5@filter_deb
$LN73@filter_deb:

; 246  :       if (y_pu == y) return true;

	mov	al, 1
	jmp	SHORT $LN51@filter_deb
$LN87@filter_deb:

; 746  :     for (int y_c = y_px_c; y_c < end_c; y_c += 8) {

	mov	r14, QWORD PTR state$[rsp]
$LN5@filter_deb:
	add	r12d, 8
	cmp	r12d, DWORD PTR tv1201[rsp]
	jl	$LL7@filter_deb
$LN6@filter_deb:

; 752  :       }
; 753  :     }
; 754  :   }
; 755  : }

	add	rsp, 72					; 00000048H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
filter_deblock_lcu_rightmost ENDP
_TEXT	ENDS
END
