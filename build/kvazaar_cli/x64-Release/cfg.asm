; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_atof:PROC
EXTRN	__imp___stdio_common_vfscanf:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp_strtok:PROC
$SG4294957705 DB 01H DUP (?)
	ALIGN	4

$SG4294957702 DB 01H DUP (?)
	ALIGN	4

$SG4294957695 DB 01H DUP (?)
	ALIGN	4

$SG4294957692 DB 01H DUP (?)
	ALIGN	4

$SG4294957676 DB 01H DUP (?)
_BSS	ENDS
?formats@?GA@??kvz_config_parse@@9@9 DD 00H		; `kvz_config_parse'::`96'::formats
	DD	01H
?range_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957707 ; `kvz_config_parse'::`2'::range_names
	DQ	FLAT:$SG4294957706
	DQ	0000000000000000H
?me_early_termination_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957651 ; `kvz_config_parse'::`2'::me_early_termination_names
	DQ	FLAT:$SG4294957650
	DQ	FLAT:$SG4294957649
	DQ	0000000000000000H
?videoformat_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957713 ; `kvz_config_parse'::`2'::videoformat_names
	DQ	FLAT:$SG4294957712
	DQ	FLAT:$SG4294957711
	DQ	FLAT:$SG4294957710
	DQ	FLAT:$SG4294957709
	DQ	FLAT:$SG4294957708
	DQ	0000000000000000H
?crypto_feature_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957656 ; `kvz_config_parse'::`2'::crypto_feature_names
	DQ	FLAT:$SG4294957655
	DQ	FLAT:$SG4294957654
	DQ	FLAT:$SG4294957653
	DQ	FLAT:$SG4294957652
	DQ	0000000000000000H
?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9 DD 087000H ; `validate_hevc_level'::`2'::LEVEL_CONSTRAINTS
	DD	09000H
	DD	080H
	DD	0384000H
	DD	01e000H
	DD	05dcH
	DD	0708000H
	DD	03c000H
	DD	0bb8H
	DD	0fd2000H
	DD	087000H
	DD	01770H
	DD	01fa4000H
	DD	0f0000H
	DD	02710H
	DD	03fc0000H
	DD	0220000H
	DD	02ee0H
	DD	07f80000H
	DD	0220000H
	DD	04e20H
	DD	0ff00000H
	DD	0880000H
	DD	061a8H
	DD	01fe00000H
	DD	0880000H
	DD	09c40H
	DD	03fc00000H
	DD	0880000H
	DD	0ea60H
	DD	03fc00000H
	DD	02200000H
	DD	0ea60H
	DD	07f800000H
	DD	02200000H
	DD	01d4c0H
	DD	0ff000000H
	DD	02200000H
	DD	03a980H
	ORG $+4
?preset_values@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957635 ; `kvz_config_parse'::`2'::preset_values
	DQ	FLAT:$SG4294957634
	DQ	FLAT:$SG4294957633
	DQ	FLAT:$SG4294957632
	DQ	FLAT:$SG4294957631
	DQ	FLAT:$SG4294957630
	DQ	FLAT:$SG4294957629
	DQ	FLAT:$SG4294957628
	DQ	FLAT:$SG4294957627
	DQ	FLAT:$SG4294957626
	DQ	FLAT:$SG4294957625
	DQ	FLAT:$SG4294957624
	DQ	FLAT:$SG4294957623
	DQ	FLAT:$SG4294957622
	DQ	FLAT:$SG4294957621
	DQ	FLAT:$SG4294957620
	DQ	FLAT:$SG4294957619
	DQ	FLAT:$SG4294957618
	DQ	FLAT:$SG4294957617
	DQ	FLAT:$SG4294957616
	DQ	FLAT:$SG4294957615
	DQ	FLAT:$SG4294957614
	DQ	FLAT:$SG4294957613
	DQ	FLAT:$SG4294957612
	DQ	FLAT:$SG4294957611
	DQ	FLAT:$SG4294957610
	DQ	FLAT:$SG4294957609
	DQ	FLAT:$SG4294957608
	DQ	FLAT:$SG4294957607
	DQ	FLAT:$SG4294957606
	DQ	FLAT:$SG4294957605
	DQ	FLAT:$SG4294957604
	DQ	FLAT:$SG4294957603
	DQ	FLAT:$SG4294957602
	DQ	FLAT:$SG4294957601
	DQ	FLAT:$SG4294957600
	DQ	FLAT:$SG4294957599
	DQ	FLAT:$SG4294957598
	DQ	FLAT:$SG4294957597
	DQ	FLAT:$SG4294957596
	DQ	FLAT:$SG4294957595
	DQ	FLAT:$SG4294957594
	DQ	FLAT:$SG4294957593
	DQ	FLAT:$SG4294957592
	DQ	FLAT:$SG4294957591
	DQ	FLAT:$SG4294957590
	DQ	FLAT:$SG4294957589
	DQ	FLAT:$SG4294957588
	DQ	FLAT:$SG4294957587
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957586
	DQ	FLAT:$SG4294957585
	DQ	FLAT:$SG4294957584
	DQ	FLAT:$SG4294957583
	DQ	FLAT:$SG4294957582
	DQ	FLAT:$SG4294957581
	DQ	FLAT:$SG4294957580
	DQ	FLAT:$SG4294957579
	DQ	FLAT:$SG4294957578
	DQ	FLAT:$SG4294957577
	DQ	FLAT:$SG4294957576
	DQ	FLAT:$SG4294957575
	DQ	FLAT:$SG4294957574
	DQ	FLAT:$SG4294957573
	DQ	FLAT:$SG4294957572
	DQ	FLAT:$SG4294957571
	DQ	FLAT:$SG4294957570
	DQ	FLAT:$SG4294957569
	DQ	FLAT:$SG4294957568
	DQ	FLAT:$SG4294957567
	DQ	FLAT:$SG4294957566
	DQ	FLAT:$SG4294957565
	DQ	FLAT:$SG4294957564
	DQ	FLAT:$SG4294957563
	DQ	FLAT:$SG4294957562
	DQ	FLAT:$SG4294957561
	DQ	FLAT:$SG4294957560
	DQ	FLAT:$SG4294957559
	DQ	FLAT:$SG4294957558
	DQ	FLAT:$SG4294957557
	DQ	FLAT:$SG4294957556
	DQ	FLAT:$SG4294957555
	DQ	FLAT:$SG4294957554
	DQ	FLAT:$SG4294957553
	DQ	FLAT:$SG4294957552
	DQ	FLAT:$SG4294957551
	DQ	FLAT:$SG4294957550
	DQ	FLAT:$SG4294957549
	DQ	FLAT:$SG4294957548
	DQ	FLAT:$SG4294957547
	DQ	FLAT:$SG4294957546
	DQ	FLAT:$SG4294957545
	DQ	FLAT:$SG4294957544
	DQ	FLAT:$SG4294957543
	DQ	FLAT:$SG4294957542
	DQ	FLAT:$SG4294957541
	DQ	FLAT:$SG4294957540
	DQ	FLAT:$SG4294957539
	DQ	FLAT:$SG4294957538
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957537
	DQ	FLAT:$SG4294957536
	DQ	FLAT:$SG4294957535
	DQ	FLAT:$SG4294957534
	DQ	FLAT:$SG4294957533
	DQ	FLAT:$SG4294957532
	DQ	FLAT:$SG4294957531
	DQ	FLAT:$SG4294957530
	DQ	FLAT:$SG4294957529
	DQ	FLAT:$SG4294957528
	DQ	FLAT:$SG4294957527
	DQ	FLAT:$SG4294957526
	DQ	FLAT:$SG4294957525
	DQ	FLAT:$SG4294957524
	DQ	FLAT:$SG4294957523
	DQ	FLAT:$SG4294957522
	DQ	FLAT:$SG4294957521
	DQ	FLAT:$SG4294957520
	DQ	FLAT:$SG4294957519
	DQ	FLAT:$SG4294957518
	DQ	FLAT:$SG4294957517
	DQ	FLAT:$SG4294957516
	DQ	FLAT:$SG4294957515
	DQ	FLAT:$SG4294957514
	DQ	FLAT:$SG4294957513
	DQ	FLAT:$SG4294957512
	DQ	FLAT:$SG4294957511
	DQ	FLAT:$SG4294957510
	DQ	FLAT:$SG4294957509
	DQ	FLAT:$SG4294957508
	DQ	FLAT:$SG4294957507
	DQ	FLAT:$SG4294957506
	DQ	FLAT:$SG4294957505
	DQ	FLAT:$SG4294957504
	DQ	FLAT:$SG4294957503
	DQ	FLAT:$SG4294957502
	DQ	FLAT:$SG4294957501
	DQ	FLAT:$SG4294957500
	DQ	FLAT:$SG4294957499
	DQ	FLAT:$SG4294957498
	DQ	FLAT:$SG4294957497
	DQ	FLAT:$SG4294957496
	DQ	FLAT:$SG4294957495
	DQ	FLAT:$SG4294957494
	DQ	FLAT:$SG4294957493
	DQ	FLAT:$SG4294957492
	DQ	FLAT:$SG4294957491
	DQ	FLAT:$SG4294957490
	DQ	FLAT:$SG4294957489
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957488
	DQ	FLAT:$SG4294957487
	DQ	FLAT:$SG4294957486
	DQ	FLAT:$SG4294957485
	DQ	FLAT:$SG4294957484
	DQ	FLAT:$SG4294957483
	DQ	FLAT:$SG4294957482
	DQ	FLAT:$SG4294957481
	DQ	FLAT:$SG4294957480
	DQ	FLAT:$SG4294957479
	DQ	FLAT:$SG4294957478
	DQ	FLAT:$SG4294957477
	DQ	FLAT:$SG4294957476
	DQ	FLAT:$SG4294957475
	DQ	FLAT:$SG4294957474
	DQ	FLAT:$SG4294957473
	DQ	FLAT:$SG4294957472
	DQ	FLAT:$SG4294957471
	DQ	FLAT:$SG4294957470
	DQ	FLAT:$SG4294957469
	DQ	FLAT:$SG4294957468
	DQ	FLAT:$SG4294957467
	DQ	FLAT:$SG4294957466
	DQ	FLAT:$SG4294957465
	DQ	FLAT:$SG4294957464
	DQ	FLAT:$SG4294957463
	DQ	FLAT:$SG4294957462
	DQ	FLAT:$SG4294957461
	DQ	FLAT:$SG4294957460
	DQ	FLAT:$SG4294957459
	DQ	FLAT:$SG4294957458
	DQ	FLAT:$SG4294957457
	DQ	FLAT:$SG4294957456
	DQ	FLAT:$SG4294957455
	DQ	FLAT:$SG4294957454
	DQ	FLAT:$SG4294957453
	DQ	FLAT:$SG4294957452
	DQ	FLAT:$SG4294957451
	DQ	FLAT:$SG4294957450
	DQ	FLAT:$SG4294957449
	DQ	FLAT:$SG4294957448
	DQ	FLAT:$SG4294957447
	DQ	FLAT:$SG4294957446
	DQ	FLAT:$SG4294957445
	DQ	FLAT:$SG4294957444
	DQ	FLAT:$SG4294957443
	DQ	FLAT:$SG4294957442
	DQ	FLAT:$SG4294957441
	DQ	FLAT:$SG4294957440
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957439
	DQ	FLAT:$SG4294957438
	DQ	FLAT:$SG4294957437
	DQ	FLAT:$SG4294957436
	DQ	FLAT:$SG4294957435
	DQ	FLAT:$SG4294957434
	DQ	FLAT:$SG4294957433
	DQ	FLAT:$SG4294957432
	DQ	FLAT:$SG4294957431
	DQ	FLAT:$SG4294957430
	DQ	FLAT:$SG4294957429
	DQ	FLAT:$SG4294957428
	DQ	FLAT:$SG4294957427
	DQ	FLAT:$SG4294957426
	DQ	FLAT:$SG4294957425
	DQ	FLAT:$SG4294957424
	DQ	FLAT:$SG4294957423
	DQ	FLAT:$SG4294957422
	DQ	FLAT:$SG4294957421
	DQ	FLAT:$SG4294957420
	DQ	FLAT:$SG4294957419
	DQ	FLAT:$SG4294957418
	DQ	FLAT:$SG4294957417
	DQ	FLAT:$SG4294957416
	DQ	FLAT:$SG4294957415
	DQ	FLAT:$SG4294957414
	DQ	FLAT:$SG4294957413
	DQ	FLAT:$SG4294957412
	DQ	FLAT:$SG4294957411
	DQ	FLAT:$SG4294957410
	DQ	FLAT:$SG4294957409
	DQ	FLAT:$SG4294957408
	DQ	FLAT:$SG4294957407
	DQ	FLAT:$SG4294957406
	DQ	FLAT:$SG4294957405
	DQ	FLAT:$SG4294957404
	DQ	FLAT:$SG4294957403
	DQ	FLAT:$SG4294957402
	DQ	FLAT:$SG4294957401
	DQ	FLAT:$SG4294957400
	DQ	FLAT:$SG4294957399
	DQ	FLAT:$SG4294957398
	DQ	FLAT:$SG4294957397
	DQ	FLAT:$SG4294957396
	DQ	FLAT:$SG4294957395
	DQ	FLAT:$SG4294957394
	DQ	FLAT:$SG4294957393
	DQ	FLAT:$SG4294957392
	DQ	FLAT:$SG4294957391
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957390
	DQ	FLAT:$SG4294957389
	DQ	FLAT:$SG4294957388
	DQ	FLAT:$SG4294957387
	DQ	FLAT:$SG4294957386
	DQ	FLAT:$SG4294957385
	DQ	FLAT:$SG4294957384
	DQ	FLAT:$SG4294957383
	DQ	FLAT:$SG4294957382
	DQ	FLAT:$SG4294957381
	DQ	FLAT:$SG4294957380
	DQ	FLAT:$SG4294957379
	DQ	FLAT:$SG4294957378
	DQ	FLAT:$SG4294957377
	DQ	FLAT:$SG4294957376
	DQ	FLAT:$SG4294957375
	DQ	FLAT:$SG4294957374
	DQ	FLAT:$SG4294957373
	DQ	FLAT:$SG4294957372
	DQ	FLAT:$SG4294957371
	DQ	FLAT:$SG4294957370
	DQ	FLAT:$SG4294957369
	DQ	FLAT:$SG4294957368
	DQ	FLAT:$SG4294957367
	DQ	FLAT:$SG4294957366
	DQ	FLAT:$SG4294957365
	DQ	FLAT:$SG4294957364
	DQ	FLAT:$SG4294957363
	DQ	FLAT:$SG4294957362
	DQ	FLAT:$SG4294957361
	DQ	FLAT:$SG4294957360
	DQ	FLAT:$SG4294957359
	DQ	FLAT:$SG4294957358
	DQ	FLAT:$SG4294957357
	DQ	FLAT:$SG4294957356
	DQ	FLAT:$SG4294957355
	DQ	FLAT:$SG4294957354
	DQ	FLAT:$SG4294957353
	DQ	FLAT:$SG4294957352
	DQ	FLAT:$SG4294957351
	DQ	FLAT:$SG4294957350
	DQ	FLAT:$SG4294957349
	DQ	FLAT:$SG4294957348
	DQ	FLAT:$SG4294957347
	DQ	FLAT:$SG4294957346
	DQ	FLAT:$SG4294957345
	DQ	FLAT:$SG4294957344
	DQ	FLAT:$SG4294957343
	DQ	FLAT:$SG4294957342
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957341
	DQ	FLAT:$SG4294957340
	DQ	FLAT:$SG4294957339
	DQ	FLAT:$SG4294957338
	DQ	FLAT:$SG4294957337
	DQ	FLAT:$SG4294957336
	DQ	FLAT:$SG4294957335
	DQ	FLAT:$SG4294957334
	DQ	FLAT:$SG4294957333
	DQ	FLAT:$SG4294957332
	DQ	FLAT:$SG4294957331
	DQ	FLAT:$SG4294957330
	DQ	FLAT:$SG4294957329
	DQ	FLAT:$SG4294957328
	DQ	FLAT:$SG4294957327
	DQ	FLAT:$SG4294957326
	DQ	FLAT:$SG4294957325
	DQ	FLAT:$SG4294957324
	DQ	FLAT:$SG4294957323
	DQ	FLAT:$SG4294957322
	DQ	FLAT:$SG4294957321
	DQ	FLAT:$SG4294957320
	DQ	FLAT:$SG4294957319
	DQ	FLAT:$SG4294957318
	DQ	FLAT:$SG4294957317
	DQ	FLAT:$SG4294957316
	DQ	FLAT:$SG4294957315
	DQ	FLAT:$SG4294957314
	DQ	FLAT:$SG4294957313
	DQ	FLAT:$SG4294957312
	DQ	FLAT:$SG4294957311
	DQ	FLAT:$SG4294957310
	DQ	FLAT:$SG4294957309
	DQ	FLAT:$SG4294957308
	DQ	FLAT:$SG4294957307
	DQ	FLAT:$SG4294957306
	DQ	FLAT:$SG4294957305
	DQ	FLAT:$SG4294957304
	DQ	FLAT:$SG4294957303
	DQ	FLAT:$SG4294957302
	DQ	FLAT:$SG4294957301
	DQ	FLAT:$SG4294957300
	DQ	FLAT:$SG4294957299
	DQ	FLAT:$SG4294957298
	DQ	FLAT:$SG4294957297
	DQ	FLAT:$SG4294957296
	DQ	FLAT:$SG4294957295
	DQ	FLAT:$SG4294957294
	DQ	FLAT:$SG4294957293
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957292
	DQ	FLAT:$SG4294957291
	DQ	FLAT:$SG4294957290
	DQ	FLAT:$SG4294957289
	DQ	FLAT:$SG4294957288
	DQ	FLAT:$SG4294957287
	DQ	FLAT:$SG4294957286
	DQ	FLAT:$SG4294957285
	DQ	FLAT:$SG4294957284
	DQ	FLAT:$SG4294957283
	DQ	FLAT:$SG4294957282
	DQ	FLAT:$SG4294957281
	DQ	FLAT:$SG4294957280
	DQ	FLAT:$SG4294957279
	DQ	FLAT:$SG4294957278
	DQ	FLAT:$SG4294957277
	DQ	FLAT:$SG4294957276
	DQ	FLAT:$SG4294957275
	DQ	FLAT:$SG4294957274
	DQ	FLAT:$SG4294957273
	DQ	FLAT:$SG4294957272
	DQ	FLAT:$SG4294957271
	DQ	FLAT:$SG4294957270
	DQ	FLAT:$SG4294957269
	DQ	FLAT:$SG4294957268
	DQ	FLAT:$SG4294957267
	DQ	FLAT:$SG4294957266
	DQ	FLAT:$SG4294957265
	DQ	FLAT:$SG4294957264
	DQ	FLAT:$SG4294957263
	DQ	FLAT:$SG4294957262
	DQ	FLAT:$SG4294957261
	DQ	FLAT:$SG4294957260
	DQ	FLAT:$SG4294957259
	DQ	FLAT:$SG4294957258
	DQ	FLAT:$SG4294957257
	DQ	FLAT:$SG4294957256
	DQ	FLAT:$SG4294957255
	DQ	FLAT:$SG4294957254
	DQ	FLAT:$SG4294957253
	DQ	FLAT:$SG4294957252
	DQ	FLAT:$SG4294957251
	DQ	FLAT:$SG4294957250
	DQ	FLAT:$SG4294957249
	DQ	FLAT:$SG4294957248
	DQ	FLAT:$SG4294957247
	DQ	FLAT:$SG4294957246
	DQ	FLAT:$SG4294957245
	DQ	FLAT:$SG4294957244
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957243
	DQ	FLAT:$SG4294957242
	DQ	FLAT:$SG4294957241
	DQ	FLAT:$SG4294957240
	DQ	FLAT:$SG4294957239
	DQ	FLAT:$SG4294957238
	DQ	FLAT:$SG4294957237
	DQ	FLAT:$SG4294957236
	DQ	FLAT:$SG4294957235
	DQ	FLAT:$SG4294957234
	DQ	FLAT:$SG4294957233
	DQ	FLAT:$SG4294957232
	DQ	FLAT:$SG4294957231
	DQ	FLAT:$SG4294957230
	DQ	FLAT:$SG4294957229
	DQ	FLAT:$SG4294957228
	DQ	FLAT:$SG4294957227
	DQ	FLAT:$SG4294957226
	DQ	FLAT:$SG4294957225
	DQ	FLAT:$SG4294957224
	DQ	FLAT:$SG4294957223
	DQ	FLAT:$SG4294957222
	DQ	FLAT:$SG4294957221
	DQ	FLAT:$SG4294957220
	DQ	FLAT:$SG4294957219
	DQ	FLAT:$SG4294957218
	DQ	FLAT:$SG4294957217
	DQ	FLAT:$SG4294957216
	DQ	FLAT:$SG4294957215
	DQ	FLAT:$SG4294957214
	DQ	FLAT:$SG4294957213
	DQ	FLAT:$SG4294957212
	DQ	FLAT:$SG4294957211
	DQ	FLAT:$SG4294957210
	DQ	FLAT:$SG4294957209
	DQ	FLAT:$SG4294957208
	DQ	FLAT:$SG4294957207
	DQ	FLAT:$SG4294957206
	DQ	FLAT:$SG4294957205
	DQ	FLAT:$SG4294957204
	DQ	FLAT:$SG4294957203
	DQ	FLAT:$SG4294957202
	DQ	FLAT:$SG4294957201
	DQ	FLAT:$SG4294957200
	DQ	FLAT:$SG4294957199
	DQ	FLAT:$SG4294957198
	DQ	FLAT:$SG4294957197
	DQ	FLAT:$SG4294957196
	DQ	FLAT:$SG4294957195
	DQ	0000000000000000H
	DQ	FLAT:$SG4294957194
	DQ	FLAT:$SG4294957193
	DQ	FLAT:$SG4294957192
	DQ	FLAT:$SG4294957191
	DQ	FLAT:$SG4294957190
	DQ	FLAT:$SG4294957189
	DQ	FLAT:$SG4294957188
	DQ	FLAT:$SG4294957187
	DQ	FLAT:$SG4294957186
	DQ	FLAT:$SG4294957185
	DQ	FLAT:$SG4294957184
	DQ	FLAT:$SG4294957183
	DQ	FLAT:$SG4294957182
	DQ	FLAT:$SG4294957181
	DQ	FLAT:$SG4294957180
	DQ	FLAT:$SG4294957179
	DQ	FLAT:$SG4294957178
	DQ	FLAT:$SG4294957177
	DQ	FLAT:$SG4294957176
	DQ	FLAT:$SG4294957175
	DQ	FLAT:$SG4294957174
	DQ	FLAT:$SG4294957173
	DQ	FLAT:$SG4294957172
	DQ	FLAT:$SG4294957171
	DQ	FLAT:$SG4294957170
	DQ	FLAT:$SG4294957169
	DQ	FLAT:$SG4294957168
	DQ	FLAT:$SG4294957167
	DQ	FLAT:$SG4294957166
	DQ	FLAT:$SG4294957165
	DQ	FLAT:$SG4294957164
	DQ	FLAT:$SG4294957163
	DQ	FLAT:$SG4294957162
	DQ	FLAT:$SG4294957161
	DQ	FLAT:$SG4294957160
	DQ	FLAT:$SG4294957159
	DQ	FLAT:$SG4294957158
	DQ	FLAT:$SG4294957157
	DQ	FLAT:$SG4294957156
	DQ	FLAT:$SG4294957155
	DQ	FLAT:$SG4294957154
	DQ	FLAT:$SG4294957153
	DQ	FLAT:$SG4294957152
	DQ	FLAT:$SG4294957151
	DQ	FLAT:$SG4294957150
	DQ	FLAT:$SG4294957149
	DQ	FLAT:$SG4294957148
	DQ	FLAT:$SG4294957147
	DQ	FLAT:$SG4294957146
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+392
?hash_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957663 ; `kvz_config_parse'::`2'::hash_names
	DQ	FLAT:$SG4294957662
	DQ	FLAT:$SG4294957661
	DQ	0000000000000000H
?transfer_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957695 ; `kvz_config_parse'::`2'::transfer_names
	DQ	FLAT:$SG4294957694
	DQ	FLAT:$SG4294957693
	DQ	FLAT:$SG4294957692
	DQ	FLAT:$SG4294957691
	DQ	FLAT:$SG4294957690
	DQ	FLAT:$SG4294957689
	DQ	FLAT:$SG4294957688
	DQ	FLAT:$SG4294957687
	DQ	FLAT:$SG4294957686
	DQ	FLAT:$SG4294957685
	DQ	FLAT:$SG4294957684
	DQ	FLAT:$SG4294957683
	DQ	FLAT:$SG4294957682
	DQ	FLAT:$SG4294957681
	DQ	FLAT:$SG4294957680
	DQ	0000000000000000H
?crypto_toggle_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957658 ; `kvz_config_parse'::`2'::crypto_toggle_names
	DQ	FLAT:$SG4294957657
	DQ	0000000000000000H
	ORG $+4
?format_names@?GA@??kvz_config_parse@@9@9 DQ FLAT:$SG4294957037 ; `kvz_config_parse'::`96'::format_names
	DQ	FLAT:$SG4294957036
	DQ	0000000000000000H
?file_format_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957638 ; `kvz_config_parse'::`2'::file_format_names
	DQ	FLAT:$SG4294957637
	DQ	FLAT:$SG4294957636
	DQ	0000000000000000H
?cu_split_termination_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957660 ; `kvz_config_parse'::`2'::cu_split_termination_names
	DQ	FLAT:$SG4294957659
	DQ	0000000000000000H
	ORG $+4
kvz_gop_ra8 DQ	03ff0000000000000r		; 1
	DB	00H
	DB	08H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	08H
	DB	0cH
	DB	010H
	ORG $+2
	ORG $+13
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DB	03H
	DB	04H
	DB	02H
	DB	01H
	DB	01H
	DB	04H
	ORG $+15
	DB	02H
	DB	04H
	DB	08H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	02H
	DB	03H
	DB	01H
	DB	02H
	DB	02H
	DB	06H
	ORG $+14
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	01H
	DB	04H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+13
	DB	01H
	DB	01H
	ORG $+2
	ORG $+15
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	03H
	DB	04H
	DB	00H
	DB	02H
	DB	01H
	DB	05H
	ORG $+14
	DB	02H
	DB	01H
	DB	03H
	ORG $+2
	ORG $+14
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	06H
	DB	03H
	DB	01H
	DB	01H
	DB	02H
	ORG $+15
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c019000000000000r		; -6.25
	DQ	03fd0000000000000r		; 0.25
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	05H
	DB	04H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	ORG $+14
	DB	02H
	DB	01H
	DB	05H
	ORG $+2
	ORG $+14
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
	DQ	03ff0000000000000r		; 1
	DB	08H
	DB	07H
	DB	04H
	DB	00H
	DB	01H
	DB	01H
	ORG $+15
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+2
	ORG $+13
	DQ	0c01c000000000000r		; -7
	DQ	03fcf5c28f5c28f5cr		; 0.245
kvz_gop_ra16 DQ	03ff0000000000000r		; 1
	DB	01H
	DB	010H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	010H
	DB	018H
	DB	020H
	ORG $+2
	ORG $+13
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DB	01H
	DB	08H
	DB	02H
	DB	01H
	DB	01H
	DB	08H
	ORG $+15
	DB	02H
	DB	08H
	DB	010H
	ORG $+2
	ORG $+14
	DQ	0c0138a0902de00d2r		; -4.8848
	DQ	03fca617c1bda511ar		; 0.2061
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	04H
	DB	03H
	DB	01H
	DB	02H
	DB	04H
	DB	0cH
	ORG $+14
	DB	02H
	DB	04H
	DB	0cH
	ORG $+2
	ORG $+14
	DQ	0c016fd8adab9f55ar		; -5.7476
	DQ	03fcd42c3c9eecbfbr		; 0.2286
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	02H
	DB	04H
	DB	01H
	DB	03H
	DB	02H
	DB	06H
	DB	0eH
	ORG $+13
	DB	02H
	DB	02H
	DB	0aH
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	01H
	DB	05H
	DB	00H
	DB	04H
	DB	01H
	DB	03H
	DB	07H
	DB	0fH
	ORG $+12
	DB	01H
	DB	01H
	ORG $+2
	ORG $+15
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	03H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	05H
	DB	0dH
	ORG $+13
	DB	02H
	DB	01H
	DB	03H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	06H
	DB	04H
	DB	01H
	DB	02H
	DB	02H
	DB	0aH
	ORG $+14
	DB	02H
	DB	02H
	DB	06H
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	05H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	0bH
	ORG $+13
	DB	02H
	DB	01H
	DB	05H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	07H
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	09H
	ORG $+14
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	0cH
	DB	03H
	DB	01H
	DB	01H
	DB	04H
	ORG $+15
	DB	02H
	DB	04H
	DB	0cH
	ORG $+2
	ORG $+14
	DQ	0c016fd8adab9f55ar		; -5.7476
	DQ	03fcd42c3c9eecbfbr		; 0.2286
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	0aH
	DB	04H
	DB	01H
	DB	02H
	DB	02H
	DB	06H
	ORG $+14
	DB	02H
	DB	02H
	DB	0aH
	ORG $+2
	ORG $+14
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	09H
	DB	05H
	DB	00H
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	ORG $+13
	DB	02H
	DB	01H
	DB	09H
	ORG $+2
	ORG $+14
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0bH
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	05H
	ORG $+14
	DB	03H
	DB	01H
	DB	03H
	DB	0bH
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	0eH
	DB	04H
	DB	01H
	DB	01H
	DB	02H
	ORG $+15
	DB	03H
	DB	02H
	DB	06H
	DB	0eH
	ORG $+2
	ORG $+13
	DQ	0c01799999999999ar		; -5.9
	DQ	03fcddcc63f141206r		; 0.2333
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0dH
	DB	05H
	DB	00H
	DB	02H
	DB	01H
	DB	03H
	ORG $+14
	DB	03H
	DB	01H
	DB	05H
	DB	0dH
	ORG $+2
	ORG $+13
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
	DQ	03ff0000000000000r		; 1
	DB	06H
	DB	0fH
	DB	05H
	DB	00H
	DB	01H
	DB	01H
	ORG $+15
	DB	04H
	DB	01H
	DB	03H
	DB	07H
	DB	0fH
	ORG $+2
	ORG $+12
	DQ	0c01c93dd97f62b6br		; -7.1444
	DQ	03fd3333333333333r		; 0.3
?overscan_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957716 ; `kvz_config_parse'::`2'::overscan_names
	DQ	FLAT:$SG4294957715
	DQ	FLAT:$SG4294957714
	DQ	0000000000000000H
?me_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957727 ; `kvz_config_parse'::`2'::me_names
	DQ	FLAT:$SG4294957726
	DQ	FLAT:$SG4294957725
	DQ	FLAT:$SG4294957724
	DQ	FLAT:$SG4294957723
	DQ	FLAT:$SG4294957722
	DQ	FLAT:$SG4294957721
	DQ	FLAT:$SG4294957720
	DQ	0000000000000000H
	ORG $+4
?colormatrix_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957679 ; `kvz_config_parse'::`2'::colormatrix_names
	DQ	FLAT:$SG4294957678
	DQ	FLAT:$SG4294957677
	DQ	FLAT:$SG4294957676
	DQ	FLAT:$SG4294957675
	DQ	FLAT:$SG4294957674
	DQ	FLAT:$SG4294957673
	DQ	FLAT:$SG4294957672
	DQ	FLAT:$SG4294957671
	DQ	FLAT:$SG4294957670
	DQ	FLAT:$SG4294957669
	DQ	0000000000000000H
?mv_constraint_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957668 ; `kvz_config_parse'::`2'::mv_constraint_names
	DQ	FLAT:$SG4294957667
	DQ	FLAT:$SG4294957666
	DQ	FLAT:$SG4294957665
	DQ	FLAT:$SG4294957664
	DQ	0000000000000000H
?sao_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957648 ; `kvz_config_parse'::`2'::sao_names
	DQ	FLAT:$SG4294957647
	DQ	FLAT:$SG4294957646
	DQ	FLAT:$SG4294957645
	DQ	0000000000000000H
	ORG $+4
?colorprim_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957705 ; `kvz_config_parse'::`2'::colorprim_names
	DQ	FLAT:$SG4294957704
	DQ	FLAT:$SG4294957703
	DQ	FLAT:$SG4294957702
	DQ	FLAT:$SG4294957701
	DQ	FLAT:$SG4294957700
	DQ	FLAT:$SG4294957699
	DQ	FLAT:$SG4294957698
	DQ	FLAT:$SG4294957697
	DQ	FLAT:$SG4294957696
	DQ	0000000000000000H
	ORG $+6
kvz_gop_lowdelay4 DQ 03ff0000000000000r		; 1
	DB	05H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	04H
	DB	01H
	DB	05H
	DB	09H
	DB	0dH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	04H
	DB	02H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	02H
	DB	06H
	DB	0aH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	05H
	DB	03H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	03H
	DB	07H
	DB	0bH
	ORG $+2
	ORG $+12
	DQ	0c01a000000000000r		; -6.5
	DQ	03fd09374bc6a7efar		; 0.259
	DQ	03ff0000000000000r		; 1
	DB	01H
	DB	04H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	ORG $+15
	DB	03H
	DB	01H
	DB	04H
	DB	08H
	DB	0cH
	ORG $+2
	ORG $+12
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
?source_scan_type_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957719 ; `kvz_config_parse'::`2'::source_scan_type_names
	DQ	FLAT:$SG4294957718
	DQ	FLAT:$SG4294957717
	DQ	0000000000000000H
?HIGH_TIER_BITRATES@?1??validate_hevc_level@@9@9 DD 07530H ; `validate_hevc_level'::`2'::HIGH_TIER_BITRATES
	DD	0c350H
	DD	0186a0H
	DD	027100H
	DD	03a980H
	DD	03a980H
	DD	075300H
	DD	0c3500H
?scaling_list_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957644 ; `kvz_config_parse'::`2'::scaling_list_names
	DQ	FLAT:$SG4294957643
	DQ	FLAT:$SG4294957642
	DQ	0000000000000000H
?rc_algorithm_names@?1??kvz_config_parse@@9@9 DQ FLAT:$SG4294957641 ; `kvz_config_parse'::`2'::rc_algorithm_names
	DQ	FLAT:$SG4294957640
	DQ	FLAT:$SG4294957639
	DQ	0000000000000000H
	ORG $+1
$SG4294957726 DB 'tz', 00H
	ORG $+1
$SG4294957720 DB 'dia', 00H
	ORG $+1
$SG4294957718 DB 'tff', 00H
	ORG $+1
$SG4294957717 DB 'bff', 00H
	ORG $+2
$SG4294957723 DB 'full16', 00H
	ORG $+1
$SG4294957712 DB 'pal', 00H
	ORG $+2
$SG4294957722 DB 'full32', 00H
	ORG $+1
$SG4294957709 DB 'mac', 00H
	ORG $+1
$SG4294957707 DB 'tv', 00H
	ORG $+2
$SG4294957721 DB 'full64', 00H
	ORG $+1
$SG4294957706 DB 'pc', 00H
	ORG $+2
$SG4294957701 DB 'bt470m', 00H
	ORG $+1
$SG4294957679 DB 'GBR', 00H
	ORG $+2
$SG4294957696 DB 'bt2020', 00H
	ORG $+1
$SG4294957675 DB 'fcc', 00H
	ORG $+2
$SG4294957691 DB 'bt470m', 00H
	ORG $+1
$SG4294957661 DB 'md5', 00H
	ORG $+1
$SG4294957659 DB 'off', 00H
$SG4294957658 DB 'off', 00H
	ORG $+2
$SG4294957687 DB 'linear', 00H
	ORG $+1
$SG4294957657 DB 'on', 00H
	ORG $+2
$SG4294957686 DB 'log100', 00H
	ORG $+1
$SG4294957656 DB 'mvs', 00H
	ORG $+1
$SG4294957651 DB 'off', 00H
	ORG $+2
$SG4294957685 DB 'log316', 00H
	ORG $+1
$SG4294957650 DB 'on', 00H
$SG4294957648 DB 'off', 00H
	ORG $+2
$SG4294957644 DB 'off', 00H
	ORG $+1
$SG4294957639 DB 'oba', 00H
	ORG $+2
$SG4294957643 DB 'custom', 00H
	ORG $+1
$SG4294957637 DB 'y4m', 00H
	ORG $+2
$SG4294957640 DB 'lambda', 00H
	ORG $+1
$SG4294957636 DB 'yuv', 00H
	ORG $+1
$SG4294957634 DB 'rd', 00H
	ORG $+2
$SG4294957633 DB '0', 00H
	ORG $+2
$SG4294957631 DB '2-3', 00H
	ORG $+2
$SG4294957629 DB '1-2', 00H
	ORG $+3
$SG4294957727 DB 'hexbs', 00H
	ORG $+2
$SG4294957628 DB 'me', 00H
	ORG $+2
$SG4294957626 DB 'gop', 00H
	ORG $+2
$SG4294957625 DB '8', 00H
	ORG $+2
$SG4294957624 DB 'ref', 00H
	ORG $+2
$SG4294957623 DB '1', 00H
	ORG $+3
$SG4294957724 DB 'full8', 00H
	ORG $+2
$SG4294957622 DB 'bipred', 00H
	ORG $+1
$SG4294957621 DB '1', 00H
	ORG $+3
$SG4294957716 DB 'undef', 00H
	ORG $+2
$SG4294957619 DB '0:0', 00H
	ORG $+1
$SG4294957617 DB '0', 00H
	ORG $+1
$SG4294957615 DB '0', 00H
	ORG $+1
$SG4294957614 DB 'sao', 00H
	ORG $+1
$SG4294957613 DB 'off', 00H
	ORG $+2
$SG4294957611 DB '0', 00H
	ORG $+2
$SG4294957609 DB '0', 00H
	ORG $+2
$SG4294957607 DB '0', 00H
	ORG $+2
$SG4294957606 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957605 DB '0', 00H
	ORG $+3
$SG4294957710 DB 'secam', 00H
	ORG $+2
$SG4294957603 DB '0', 00H
	ORG $+3
$SG4294957708 DB 'undef', 00H
	ORG $+2
$SG4294957602 DB 'smp', 00H
	ORG $+1
$SG4294957601 DB '0', 00H
	ORG $+1
$SG4294957600 DB 'amp', 00H
	ORG $+2
$SG4294957599 DB '0', 00H
	ORG $+1
$SG4294957593 DB '0', 00H
	ORG $+2
$SG4294957591 DB '1', 00H
	ORG $+2
$SG4294957589 DB '28', 00H
	ORG $+2
$SG4294957587 DB '5', 00H
	ORG $+3
$SG4294957704 DB 'bt709', 00H
	ORG $+2
$SG4294957585 DB 'rd', 00H
	ORG $+2
$SG4294957584 DB '0', 00H
	ORG $+2
$SG4294957582 DB '2-3', 00H
	ORG $+2
$SG4294957580 DB '1-2', 00H
	ORG $+2
$SG4294957579 DB 'me', 00H
	ORG $+3
$SG4294957703 DB 'undef', 00H
	ORG $+2
$SG4294957577 DB 'gop', 00H
	ORG $+3
$SG4294957694 DB 'bt709', 00H
	ORG $+2
$SG4294957576 DB '8', 00H
	ORG $+1
$SG4294957575 DB 'ref', 00H
	ORG $+1
$SG4294957574 DB '1', 00H
	ORG $+1
$SG4294957572 DB '1', 00H
	ORG $+1
$SG4294957570 DB '0:0', 00H
	ORG $+2
$SG4294957573 DB 'bipred', 00H
	ORG $+1
$SG4294957568 DB '0', 00H
	ORG $+2
$SG4294957566 DB '2', 00H
	ORG $+2
$SG4294957565 DB 'sao', 00H
	ORG $+2
$SG4294957562 DB '0', 00H
	ORG $+3
$SG4294957693 DB 'undef', 00H
	ORG $+2
$SG4294957560 DB '0', 00H
	ORG $+3
$SG4294957678 DB 'bt709', 00H
	ORG $+2
$SG4294957558 DB '0', 00H
	ORG $+1
$SG4294957556 DB '0', 00H
	ORG $+1
$SG4294957554 DB '0', 00H
	ORG $+2
$SG4294957557 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957553 DB 'smp', 00H
	ORG $+1
$SG4294957552 DB '0', 00H
	ORG $+2
$SG4294957551 DB 'amp', 00H
	ORG $+2
$SG4294957550 DB '0', 00H
	ORG $+2
$SG4294957544 DB '0', 00H
	ORG $+3
$SG4294957677 DB 'undef', 00H
	ORG $+2
$SG4294957542 DB '1', 00H
	ORG $+2
$SG4294957540 DB '28', 00H
	ORG $+2
$SG4294957538 DB '5', 00H
	ORG $+2
$SG4294957536 DB 'rd', 00H
	ORG $+2
$SG4294957535 DB '0', 00H
	ORG $+3
$SG4294957671 DB 'YCgCo', 00H
	ORG $+2
$SG4294957533 DB '2-3', 00H
	ORG $+3
$SG4294957667 DB 'frame', 00H
	ORG $+2
$SG4294957531 DB '1-3', 00H
	ORG $+1
$SG4294957530 DB 'me', 00H
	ORG $+1
$SG4294957528 DB 'gop', 00H
	ORG $+1
$SG4294957527 DB '8', 00H
	ORG $+1
$SG4294957526 DB 'ref', 00H
	ORG $+2
$SG4294957525 DB '1', 00H
	ORG $+2
$SG4294957524 DB 'bipred', 00H
	ORG $+1
$SG4294957523 DB '1', 00H
	ORG $+2
$SG4294957521 DB '0:0', 00H
	ORG $+2
$SG4294957519 DB '0', 00H
	ORG $+3
$SG4294957641 DB 'no-rc', 00H
	ORG $+2
$SG4294957517 DB '2', 00H
	ORG $+3
$SG4294957627 DB 'hexbs', 00H
	ORG $+2
$SG4294957516 DB 'sao', 00H
	ORG $+1
$SG4294957513 DB '0', 00H
	ORG $+1
$SG4294957511 DB '0', 00H
	ORG $+2
$SG4294957509 DB '0', 00H
	ORG $+1
$SG4294957507 DB '0', 00H
	ORG $+2
$SG4294957508 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957505 DB '0', 00H
	ORG $+2
$SG4294957504 DB 'smp', 00H
	ORG $+2
$SG4294957503 DB '0', 00H
	ORG $+3
$SG4294957616 DB 'subme', 00H
	ORG $+2
$SG4294957502 DB 'amp', 00H
	ORG $+2
$SG4294957501 DB '0', 00H
	ORG $+2
$SG4294957495 DB '0', 00H
	ORG $+2
$SG4294957493 DB '1', 00H
	ORG $+2
$SG4294957491 DB '28', 00H
	ORG $+3
$SG4294957578 DB 'hexbs', 00H
	ORG $+2
$SG4294957489 DB '5', 00H
	ORG $+3
$SG4294957567 DB 'subme', 00H
	ORG $+2
$SG4294957488 DB 'faster', 00H
	ORG $+1
$SG4294957487 DB 'rd', 00H
	ORG $+1
$SG4294957486 DB '0', 00H
	ORG $+1
$SG4294957484 DB '2-3', 00H
	ORG $+1
$SG4294957482 DB '1-3', 00H
	ORG $+1
$SG4294957481 DB 'me', 00H
	ORG $+2
$SG4294957479 DB 'gop', 00H
	ORG $+2
$SG4294957478 DB '8', 00H
	ORG $+2
$SG4294957477 DB 'ref', 00H
	ORG $+2
$SG4294957476 DB '1', 00H
	ORG $+3
$SG4294957529 DB 'hexbs', 00H
	ORG $+2
$SG4294957475 DB 'bipred', 00H
	ORG $+1
$SG4294957474 DB '1', 00H
	ORG $+3
$SG4294957518 DB 'subme', 00H
	ORG $+2
$SG4294957472 DB '0:0', 00H
	ORG $+1
$SG4294957470 DB '0', 00H
	ORG $+1
$SG4294957468 DB '4', 00H
	ORG $+2
$SG4294957467 DB 'sao', 00H
	ORG $+1
$SG4294957464 DB '0', 00H
	ORG $+2
$SG4294957462 DB '0', 00H
	ORG $+2
$SG4294957460 DB '0', 00H
	ORG $+2
$SG4294957459 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957458 DB '0', 00H
	ORG $+3
$SG4294957480 DB 'hexbs', 00H
	ORG $+2
$SG4294957456 DB '0', 00H
	ORG $+2
$SG4294957455 DB 'smp', 00H
	ORG $+2
$SG4294957454 DB '0', 00H
	ORG $+2
$SG4294957453 DB 'amp', 00H
	ORG $+2
$SG4294957452 DB '0', 00H
	ORG $+3
$SG4294957469 DB 'subme', 00H
	ORG $+2
$SG4294957446 DB '0', 00H
	ORG $+3
$SG4294957444 DB '1', 00H
	ORG $+1
$SG4294957442 DB '0', 00H
	ORG $+1
$SG4294957440 DB '5', 00H
	ORG $+1
$SG4294957438 DB 'rd', 00H
	ORG $+1
$SG4294957437 DB '0', 00H
	ORG $+2
$SG4294957435 DB '1-3', 00H
	ORG $+2
$SG4294957433 DB '1-3', 00H
	ORG $+2
$SG4294957432 DB 'me', 00H
	ORG $+2
$SG4294957430 DB 'gop', 00H
	ORG $+3
$SG4294957431 DB 'hexbs', 00H
	ORG $+2
$SG4294957429 DB '8', 00H
	ORG $+3
$SG4294957428 DB 'ref', 00H
	ORG $+1
$SG4294957427 DB '2', 00H
	ORG $+1
$SG4294957425 DB '1', 00H
	ORG $+2
$SG4294957426 DB 'bipred', 00H
	ORG $+1
$SG4294957423 DB '0:0', 00H
	ORG $+1
$SG4294957421 DB '0', 00H
	ORG $+2
$SG4294957419 DB '4', 00H
	ORG $+2
$SG4294957418 DB 'sao', 00H
	ORG $+2
$SG4294957415 DB '0', 00H
	ORG $+3
$SG4294957725 DB 'full', 00H
	ORG $+3
$SG4294957420 DB 'subme', 00H
	ORG $+2
$SG4294957413 DB '0', 00H
	ORG $+2
$SG4294957719 DB 'progressive', 00H
$SG4294957715 DB 'show', 00H
	ORG $+3
$SG4294957714 DB 'crop', 00H
	ORG $+3
$SG4294957411 DB '0', 00H
	ORG $+2
$SG4294957713 DB 'component', 00H
	ORG $+2
$SG4294957711 DB 'ntsc', 00H
	ORG $+3
$SG4294957410 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957409 DB '0', 00H
	ORG $+2
$SG4294957700 DB 'bt470bg', 00H
$SG4294957699 DB 'smpte170m', 00H
	ORG $+2
$SG4294957407 DB '0', 00H
	ORG $+2
$SG4294957698 DB 'smpte240m', 00H
	ORG $+2
$SG4294957697 DB 'film', 00H
	ORG $+3
$SG4294957406 DB 'smp', 00H
$SG4294957690 DB 'bt470bg', 00H
$SG4294957689 DB 'smpte170m', 00H
	ORG $+2
$SG4294957405 DB '0', 00H
	ORG $+2
$SG4294957688 DB 'smpte240m', 00H
	ORG $+2
$SG4294957404 DB 'amp', 00H
$SG4294957684 DB 'iec61966-2-4', 00H
	ORG $+3
$SG4294957683 DB 'bt1361e', 00H
$SG4294957682 DB 'iec61966-2-1', 00H
	ORG $+3
$SG4294957681 DB 'bt2020-10', 00H
	ORG $+2
$SG4294957403 DB '0', 00H
	ORG $+2
$SG4294957680 DB 'bt2020-12', 00H
	ORG $+2
$SG4294957397 DB '0', 00H
	ORG $+2
$SG4294957674 DB 'bt470bg', 00H
$SG4294957673 DB 'smpte170m', 00H
	ORG $+2
$SG4294957395 DB '1', 00H
	ORG $+2
$SG4294957672 DB 'smpte240m', 00H
	ORG $+2
$SG4294957393 DB '0', 00H
	ORG $+2
$SG4294957670 DB 'bt2020nc', 00H
	ORG $+3
$SG4294957391 DB '5', 00H
	ORG $+2
$SG4294957669 DB 'bt2020c', 00H
$SG4294957668 DB 'none', 00H
	ORG $+3
$SG4294957666 DB 'tile', 00H
	ORG $+3
$SG4294957665 DB 'frametile', 00H
	ORG $+2
$SG4294957390 DB 'medium', 00H
	ORG $+1
$SG4294957389 DB 'rd', 00H
	ORG $+1
$SG4294957664 DB 'frametilemargin', 00H
$SG4294957663 DB 'none', 00H
	ORG $+3
$SG4294957662 DB 'checksum', 00H
	ORG $+3
$SG4294957660 DB 'zero', 00H
	ORG $+3
$SG4294957388 DB '0', 00H
	ORG $+2
$SG4294957655 DB 'mv_signs', 00H
	ORG $+3
$SG4294957386 DB '1-4', 00H
$SG4294957654 DB 'trans_coeffs', 00H
	ORG $+3
$SG4294957653 DB 'trans_coeff_signs', 00H
	ORG $+2
$SG4294957384 DB '0-3', 00H
$SG4294957652 DB 'intra_pred_modes', 00H
	ORG $+3
$SG4294957383 DB 'me', 00H
	ORG $+1
$SG4294957649 DB 'sensitive', 00H
	ORG $+2
$SG4294957647 DB 'edge', 00H
	ORG $+3
$SG4294957646 DB 'band', 00H
	ORG $+3
$SG4294957645 DB 'full', 00H
	ORG $+3
$SG4294957382 DB 'hexbs', 00H
	ORG $+2
$SG4294957381 DB 'gop', 00H
$SG4294957642 DB 'default', 00H
$SG4294957638 DB 'auto', 00H
	ORG $+3
$SG4294957635 DB 'ultrafast', 00H
	ORG $+2
$SG4294957380 DB '16', 00H
	ORG $+1
$SG4294957632 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957630 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957620 DB 'deblock', 00H
$SG4294957618 DB 'signhide', 00H
	ORG $+3
$SG4294957612 DB 'rdoq', 00H
	ORG $+3
$SG4294957379 DB 'ref', 00H
$SG4294957610 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957378 DB '4', 00H
	ORG $+2
$SG4294957608 DB 'transform-skip', 00H
	ORG $+1
$SG4294957604 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957377 DB 'bipred', 00H
	ORG $+1
$SG4294957376 DB '1', 00H
	ORG $+2
$SG4294957598 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957597 DB 'zero', 00H
	ORG $+3
$SG4294957596 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957595 DB 'sensitive', 00H
	ORG $+2
$SG4294957374 DB '0:0', 00H
$SG4294957594 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957592 DB 'early-skip', 00H
	ORG $+1
$SG4294957372 DB '0', 00H
	ORG $+2
$SG4294957590 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957370 DB '4', 00H
	ORG $+2
$SG4294957588 DB 'max-merge', 00H
	ORG $+2
$SG4294957369 DB 'sao', 00H
$SG4294957586 DB 'superfast', 00H
	ORG $+2
$SG4294957366 DB '1', 00H
	ORG $+2
$SG4294957583 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957581 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957571 DB 'deblock', 00H
$SG4294957569 DB 'signhide', 00H
	ORG $+3
$SG4294957564 DB 'full', 00H
	ORG $+3
$SG4294957563 DB 'rdoq', 00H
	ORG $+3
$SG4294957371 DB 'subme', 00H
	ORG $+2
$SG4294957364 DB '0', 00H
	ORG $+2
$SG4294957561 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957362 DB '0', 00H
	ORG $+2
$SG4294957559 DB 'transform-skip', 00H
	ORG $+1
$SG4294957555 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957361 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957360 DB '0', 00H
	ORG $+2
$SG4294957549 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957548 DB 'zero', 00H
	ORG $+3
$SG4294957547 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957546 DB 'sensitive', 00H
	ORG $+2
$SG4294957358 DB '0', 00H
	ORG $+2
$SG4294957545 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957543 DB 'early-skip', 00H
	ORG $+1
$SG4294957357 DB 'smp', 00H
$SG4294957541 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957356 DB '0', 00H
	ORG $+2
$SG4294957539 DB 'max-merge', 00H
	ORG $+2
$SG4294957355 DB 'amp', 00H
$SG4294957537 DB 'veryfast', 00H
	ORG $+3
$SG4294957354 DB '0', 00H
	ORG $+2
$SG4294957534 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957532 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957522 DB 'deblock', 00H
$SG4294957520 DB 'signhide', 00H
	ORG $+3
$SG4294957515 DB 'full', 00H
	ORG $+3
$SG4294957514 DB 'rdoq', 00H
	ORG $+3
$SG4294957350 DB 'on', 00H
	ORG $+1
$SG4294957512 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957348 DB '0', 00H
	ORG $+2
$SG4294957510 DB 'transform-skip', 00H
	ORG $+1
$SG4294957506 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957346 DB '1', 00H
	ORG $+2
$SG4294957500 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957499 DB 'zero', 00H
	ORG $+3
$SG4294957498 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957497 DB 'sensitive', 00H
	ORG $+2
$SG4294957344 DB '0', 00H
	ORG $+2
$SG4294957496 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957494 DB 'early-skip', 00H
	ORG $+1
$SG4294957342 DB '5', 00H
	ORG $+2
$SG4294957492 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957340 DB 'rd', 00H
	ORG $+1
$SG4294957490 DB 'max-merge', 00H
	ORG $+2
$SG4294957339 DB '1', 00H
	ORG $+2
$SG4294957485 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957483 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957473 DB 'deblock', 00H
$SG4294957471 DB 'signhide', 00H
	ORG $+3
$SG4294957466 DB 'full', 00H
	ORG $+3
$SG4294957465 DB 'rdoq', 00H
	ORG $+3
$SG4294957337 DB '1-4', 00H
$SG4294957463 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957335 DB '0-3', 00H
$SG4294957461 DB 'transform-skip', 00H
	ORG $+1
$SG4294957457 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957334 DB 'me', 00H
	ORG $+1
$SG4294957451 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957450 DB 'zero', 00H
	ORG $+3
$SG4294957449 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957448 DB 'sensitive', 00H
	ORG $+2
$SG4294957332 DB 'gop', 00H
$SG4294957447 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957445 DB 'early-skip', 00H
	ORG $+1
$SG4294957331 DB '16', 00H
	ORG $+1
$SG4294957443 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957330 DB 'ref', 00H
$SG4294957441 DB 'max-merge', 00H
	ORG $+2
$SG4294957439 DB 'fast', 00H
	ORG $+3
$SG4294957333 DB 'hexbs', 00H
	ORG $+2
$SG4294957329 DB '4', 00H
	ORG $+2
$SG4294957436 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957434 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957424 DB 'deblock', 00H
$SG4294957422 DB 'signhide', 00H
	ORG $+3
$SG4294957417 DB 'full', 00H
	ORG $+3
$SG4294957416 DB 'rdoq', 00H
	ORG $+3
$SG4294957328 DB 'bipred', 00H
	ORG $+1
$SG4294957327 DB '1', 00H
	ORG $+2
$SG4294957414 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957325 DB '0:0', 00H
$SG4294957412 DB 'transform-skip', 00H
	ORG $+1
$SG4294957408 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957323 DB '0', 00H
	ORG $+2
$SG4294957402 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957401 DB 'zero', 00H
	ORG $+3
$SG4294957400 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957399 DB 'sensitive', 00H
	ORG $+2
$SG4294957321 DB '4', 00H
	ORG $+2
$SG4294957398 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957396 DB 'early-skip', 00H
	ORG $+1
$SG4294957320 DB 'sao', 00H
$SG4294957394 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957317 DB '1', 00H
	ORG $+2
$SG4294957392 DB 'max-merge', 00H
	ORG $+2
$SG4294957315 DB '0', 00H
	ORG $+2
$SG4294957387 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957385 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957375 DB 'deblock', 00H
$SG4294957373 DB 'signhide', 00H
	ORG $+3
$SG4294957368 DB 'full', 00H
	ORG $+3
$SG4294957367 DB 'rdoq', 00H
	ORG $+3
$SG4294957322 DB 'subme', 00H
	ORG $+2
$SG4294957313 DB '0', 00H
	ORG $+2
$SG4294957365 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957312 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957311 DB '0', 00H
	ORG $+2
$SG4294957363 DB 'transform-skip', 00H
	ORG $+1
$SG4294957359 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957309 DB '0', 00H
	ORG $+2
$SG4294957353 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957352 DB 'zero', 00H
	ORG $+3
$SG4294957351 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957349 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957347 DB 'early-skip', 00H
	ORG $+1
$SG4294957308 DB 'smp', 00H
$SG4294957345 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957307 DB '0', 00H
	ORG $+2
$SG4294957343 DB 'max-merge', 00H
	ORG $+2
$SG4294957341 DB 'slow', 00H
	ORG $+3
$SG4294957306 DB 'amp', 00H
$SG4294957338 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957336 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957326 DB 'deblock', 00H
$SG4294957324 DB 'signhide', 00H
	ORG $+3
$SG4294957319 DB 'full', 00H
	ORG $+3
$SG4294957318 DB 'rdoq', 00H
	ORG $+3
$SG4294957305 DB '0', 00H
	ORG $+2
$SG4294957316 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957301 DB 'on', 00H
	ORG $+1
$SG4294957314 DB 'transform-skip', 00H
	ORG $+1
$SG4294957310 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957299 DB '0', 00H
	ORG $+2
$SG4294957304 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957303 DB 'zero', 00H
	ORG $+3
$SG4294957302 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957300 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957298 DB 'early-skip', 00H
	ORG $+1
$SG4294957297 DB '1', 00H
	ORG $+2
$SG4294957296 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957295 DB '0', 00H
	ORG $+2
$SG4294957294 DB 'max-merge', 00H
	ORG $+2
$SG4294957293 DB '5', 00H
	ORG $+2
$SG4294957292 DB 'slower', 00H
	ORG $+1
$SG4294957291 DB 'rd', 00H
	ORG $+1
$SG4294957290 DB '2', 00H
	ORG $+2
$SG4294957289 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957288 DB '1-4', 00H
$SG4294957286 DB '0-3', 00H
$SG4294957287 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957285 DB 'me', 00H
	ORG $+1
$SG4294957284 DB 'hexbs', 00H
	ORG $+2
$SG4294957283 DB 'gop', 00H
$SG4294957282 DB '16', 00H
	ORG $+1
$SG4294957281 DB 'ref', 00H
$SG4294957280 DB '4', 00H
	ORG $+2
$SG4294957279 DB 'bipred', 00H
	ORG $+1
$SG4294957278 DB '1', 00H
	ORG $+2
$SG4294957277 DB 'deblock', 00H
$SG4294957276 DB '0:0', 00H
$SG4294957274 DB '1', 00H
	ORG $+2
$SG4294957275 DB 'signhide', 00H
	ORG $+3
$SG4294957273 DB 'subme', 00H
	ORG $+2
$SG4294957272 DB '4', 00H
	ORG $+2
$SG4294957271 DB 'sao', 00H
$SG4294957270 DB 'full', 00H
	ORG $+3
$SG4294957269 DB 'rdoq', 00H
	ORG $+3
$SG4294957268 DB '1', 00H
	ORG $+2
$SG4294957267 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957266 DB '0', 00H
	ORG $+2
$SG4294957265 DB 'transform-skip', 00H
	ORG $+1
$SG4294957264 DB '0', 00H
	ORG $+2
$SG4294957263 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957262 DB '0', 00H
	ORG $+2
$SG4294957261 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957260 DB '0', 00H
	ORG $+2
$SG4294957259 DB 'smp', 00H
$SG4294957258 DB '0', 00H
	ORG $+2
$SG4294957257 DB 'amp', 00H
$SG4294957256 DB '0', 00H
	ORG $+2
$SG4294957255 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957254 DB 'zero', 00H
	ORG $+3
$SG4294957253 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957252 DB 'off', 00H
$SG4294957250 DB '0', 00H
	ORG $+2
$SG4294957251 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957249 DB 'early-skip', 00H
	ORG $+1
$SG4294957248 DB '1', 00H
	ORG $+2
$SG4294957247 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957246 DB '0', 00H
	ORG $+2
$SG4294957245 DB 'max-merge', 00H
	ORG $+2
$SG4294957244 DB '5', 00H
	ORG $+2
$SG4294957243 DB 'veryslow', 00H
	ORG $+3
$SG4294957242 DB 'rd', 00H
	ORG $+1
$SG4294957241 DB '2', 00H
	ORG $+2
$SG4294957239 DB '1-4', 00H
$SG4294957240 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957238 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957237 DB '0-3', 00H
$SG4294957236 DB 'me', 00H
	ORG $+1
$SG4294957235 DB 'tz', 00H
	ORG $+1
$SG4294957234 DB 'gop', 00H
$SG4294957233 DB '16', 00H
	ORG $+1
$SG4294957232 DB 'ref', 00H
$SG4294957231 DB '4', 00H
	ORG $+2
$SG4294957230 DB 'bipred', 00H
	ORG $+1
$SG4294957229 DB '1', 00H
	ORG $+2
$SG4294957228 DB 'deblock', 00H
$SG4294957227 DB '0:0', 00H
$SG4294957225 DB '1', 00H
	ORG $+2
$SG4294957226 DB 'signhide', 00H
	ORG $+3
$SG4294957224 DB 'subme', 00H
	ORG $+2
$SG4294957223 DB '4', 00H
	ORG $+2
$SG4294957222 DB 'sao', 00H
$SG4294957221 DB 'full', 00H
	ORG $+3
$SG4294957220 DB 'rdoq', 00H
	ORG $+3
$SG4294957219 DB '1', 00H
	ORG $+2
$SG4294957218 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957217 DB '0', 00H
	ORG $+2
$SG4294957216 DB 'transform-skip', 00H
	ORG $+1
$SG4294957215 DB '1', 00H
	ORG $+2
$SG4294957214 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957213 DB '0', 00H
	ORG $+2
$SG4294957212 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957211 DB '0', 00H
	ORG $+2
$SG4294957210 DB 'smp', 00H
$SG4294957209 DB '1', 00H
	ORG $+2
$SG4294957208 DB 'amp', 00H
$SG4294957207 DB '0', 00H
	ORG $+2
$SG4294957206 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957205 DB 'zero', 00H
	ORG $+3
$SG4294957204 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957203 DB 'off', 00H
$SG4294957201 DB '0', 00H
	ORG $+2
$SG4294957202 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957200 DB 'early-skip', 00H
	ORG $+1
$SG4294957199 DB '1', 00H
	ORG $+2
$SG4294957198 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957197 DB '0', 00H
	ORG $+2
$SG4294957196 DB 'max-merge', 00H
	ORG $+2
$SG4294957195 DB '5', 00H
	ORG $+2
$SG4294957194 DB 'placebo', 00H
$SG4294957193 DB 'rd', 00H
	ORG $+1
$SG4294957192 DB '2', 00H
	ORG $+2
$SG4294957191 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957190 DB '1-4', 00H
$SG4294957188 DB '0-3', 00H
$SG4294957189 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957187 DB 'me', 00H
	ORG $+1
$SG4294957186 DB 'tz', 00H
	ORG $+1
$SG4294957185 DB 'gop', 00H
$SG4294957184 DB '16', 00H
	ORG $+1
$SG4294957183 DB 'ref', 00H
$SG4294957182 DB '4', 00H
	ORG $+2
$SG4294957181 DB 'bipred', 00H
	ORG $+1
$SG4294957180 DB '1', 00H
	ORG $+2
$SG4294957178 DB '0:0', 00H
$SG4294957179 DB 'deblock', 00H
$SG4294957177 DB 'signhide', 00H
	ORG $+3
$SG4294957176 DB '1', 00H
	ORG $+2
$SG4294957175 DB 'subme', 00H
	ORG $+2
$SG4294957174 DB '4', 00H
	ORG $+2
$SG4294957173 DB 'sao', 00H
$SG4294957172 DB 'full', 00H
	ORG $+3
$SG4294957171 DB 'rdoq', 00H
	ORG $+3
$SG4294957170 DB '1', 00H
	ORG $+2
$SG4294957168 DB '0', 00H
	ORG $+2
$SG4294957169 DB 'rdoq-skip', 00H
	ORG $+2
$SG4294957166 DB '1', 00H
	ORG $+2
$SG4294957167 DB 'transform-skip', 00H
	ORG $+1
$SG4294957165 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957164 DB '1', 00H
	ORG $+2
$SG4294957162 DB '0', 00H
	ORG $+2
$SG4294957163 DB 'full-intra-search', 00H
	ORG $+2
$SG4294957161 DB 'smp', 00H
$SG4294957160 DB '1', 00H
	ORG $+2
$SG4294957159 DB 'amp', 00H
$SG4294957158 DB '1', 00H
	ORG $+2
$SG4294957156 DB 'off', 00H
$SG4294957157 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957155 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957154 DB 'off', 00H
$SG4294957152 DB '0', 00H
	ORG $+2
$SG4294957153 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957151 DB 'early-skip', 00H
	ORG $+1
$SG4294957150 DB '0', 00H
	ORG $+2
$SG4294957149 DB 'fast-residual-cost', 00H
	ORG $+1
$SG4294957148 DB '0', 00H
	ORG $+2
$SG4294957147 DB 'max-merge', 00H
	ORG $+2
$SG4294957146 DB '5', 00H
	ORG $+2
$SG4294957037 DB 'P400', 00H
	ORG $+3
$SG4294957036 DB 'P420', 00H
PUBLIC	fscanf
PUBLIC	_vfscanf_l
PUBLIC	kvz_config_validate
PUBLIC	kvz_config_process_lp_gop
PUBLIC	kvz_config_destroy
PUBLIC	kvz_config_parse
PUBLIC	kvz_config_init
PUBLIC	kvz_config_alloc
pdata	SEGMENT
$pdata$validate_hevc_level DD imagerel validate_hevc_level
	DD	imagerel validate_hevc_level+560
	DD	imagerel $unwind$validate_hevc_level
$pdata$0$validate_hevc_level DD imagerel validate_hevc_level+560
	DD	imagerel validate_hevc_level+568
	DD	imagerel $chain$0$validate_hevc_level
$pdata$6$validate_hevc_level DD imagerel validate_hevc_level+568
	DD	imagerel validate_hevc_level+958
	DD	imagerel $chain$6$validate_hevc_level
$pdata$7$validate_hevc_level DD imagerel validate_hevc_level+958
	DD	imagerel validate_hevc_level+1042
	DD	imagerel $chain$7$validate_hevc_level
$pdata$8$validate_hevc_level DD imagerel validate_hevc_level+1042
	DD	imagerel validate_hevc_level+1123
	DD	imagerel $chain$8$validate_hevc_level
$pdata$9$validate_hevc_level DD imagerel validate_hevc_level+1123
	DD	imagerel validate_hevc_level+1229
	DD	imagerel $chain$9$validate_hevc_level
$pdata$10$validate_hevc_level DD imagerel validate_hevc_level+1229
	DD	imagerel validate_hevc_level+1397
	DD	imagerel $chain$10$validate_hevc_level
$pdata$parse_slice_specification DD imagerel parse_slice_specification
	DD	imagerel parse_slice_specification+427
	DD	imagerel $unwind$parse_slice_specification
$pdata$parse_pu_depth_list DD imagerel parse_pu_depth_list
	DD	imagerel parse_pu_depth_list+360
	DD	imagerel $unwind$parse_pu_depth_list
$pdata$parse_array DD imagerel parse_array
	DD	imagerel parse_array+308
	DD	imagerel $unwind$parse_array
$pdata$parse_uint8 DD imagerel parse_uint8
	DD	imagerel parse_uint8+112
	DD	imagerel $unwind$parse_uint8
$pdata$parse_tiles_specification DD imagerel parse_tiles_specification
	DD	imagerel parse_tiles_specification+129
	DD	imagerel $unwind$parse_tiles_specification
$pdata$0$parse_tiles_specification DD imagerel parse_tiles_specification+129
	DD	imagerel parse_tiles_specification+412
	DD	imagerel $chain$0$parse_tiles_specification
$pdata$1$parse_tiles_specification DD imagerel parse_tiles_specification+412
	DD	imagerel parse_tiles_specification+432
	DD	imagerel $chain$1$parse_tiles_specification
$pdata$parse_enum DD imagerel parse_enum
	DD	imagerel parse_enum+119
	DD	imagerel $unwind$parse_enum
$pdata$parse_enum_n DD imagerel parse_enum_n
	DD	imagerel parse_enum_n+121
	DD	imagerel $unwind$parse_enum_n
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fscanf DD imagerel $LN6
	DD	imagerel $LN6+69
	DD	imagerel $unwind$fscanf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfscanf_l DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$_vfscanf_l
pdata	ENDS
pdata	SEGMENT
$pdata$kvz_config_validate DD imagerel $LN108
	DD	imagerel $LN108+14
	DD	imagerel $unwind$kvz_config_validate
$pdata$1$kvz_config_validate DD imagerel $LN108+14
	DD	imagerel $LN108+30
	DD	imagerel $chain$1$kvz_config_validate
$pdata$3$kvz_config_validate DD imagerel $LN108+30
	DD	imagerel $LN108+1141
	DD	imagerel $chain$3$kvz_config_validate
$pdata$4$kvz_config_validate DD imagerel $LN108+1141
	DD	imagerel $LN108+1607
	DD	imagerel $chain$4$kvz_config_validate
$pdata$5$kvz_config_validate DD imagerel $LN108+1607
	DD	imagerel $LN108+1869
	DD	imagerel $chain$5$kvz_config_validate
$pdata$kvz_config_process_lp_gop DD imagerel $LN73
	DD	imagerel $LN73+17
	DD	imagerel $unwind$kvz_config_process_lp_gop
$pdata$2$kvz_config_process_lp_gop DD imagerel $LN73+17
	DD	imagerel $LN73+138
	DD	imagerel $chain$2$kvz_config_process_lp_gop
$pdata$6$kvz_config_process_lp_gop DD imagerel $LN73+138
	DD	imagerel $LN73+572
	DD	imagerel $chain$6$kvz_config_process_lp_gop
$pdata$7$kvz_config_process_lp_gop DD imagerel $LN73+572
	DD	imagerel $LN73+603
	DD	imagerel $chain$7$kvz_config_process_lp_gop
$pdata$8$kvz_config_process_lp_gop DD imagerel $LN73+603
	DD	imagerel $LN73+791
	DD	imagerel $chain$8$kvz_config_process_lp_gop
$pdata$kvz_config_destroy DD imagerel $LN5
	DD	imagerel $LN5+25
	DD	imagerel $unwind$kvz_config_destroy
$pdata$0$kvz_config_destroy DD imagerel $LN5+25
	DD	imagerel $LN5+190
	DD	imagerel $chain$0$kvz_config_destroy
$pdata$1$kvz_config_destroy DD imagerel $LN5+190
	DD	imagerel $LN5+210
	DD	imagerel $chain$1$kvz_config_destroy
$pdata$kvz_config_parse DD imagerel $LN1397
	DD	imagerel $LN1397+10729
	DD	imagerel $unwind$kvz_config_parse
$pdata$kvz_config_init DD imagerel $LN4
	DD	imagerel $LN4+691
	DD	imagerel $unwind$kvz_config_init
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfscanf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fscanf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
xdata	SEGMENT
$unwind$validate_hevc_level DD 072101H
	DD	066821H
	DD	012010bH
	DD	050037004H
	DD	03002H
$chain$0$validate_hevc_level DD 020821H
	DD	0186408H
	DD	imagerel validate_hevc_level
	DD	imagerel validate_hevc_level+560
	DD	imagerel $unwind$validate_hevc_level
$chain$6$validate_hevc_level DD 0c3921H
	DD	048839H
	DD	057830H
	DD	0ef41aH
	DD	0fe415H
	DD	010d410H
	DD	011c408H
	DD	imagerel validate_hevc_level+560
	DD	imagerel validate_hevc_level+568
	DD	imagerel $chain$0$validate_hevc_level
$chain$7$validate_hevc_level DD 080021H
	DD	048800H
	DD	057800H
	DD	0fe400H
	DD	010d400H
	DD	imagerel validate_hevc_level+560
	DD	imagerel validate_hevc_level+568
	DD	imagerel $chain$0$validate_hevc_level
$chain$8$validate_hevc_level DD 040021H
	DD	057800H
	DD	010d400H
	DD	imagerel validate_hevc_level+560
	DD	imagerel validate_hevc_level+568
	DD	imagerel $chain$0$validate_hevc_level
$chain$9$validate_hevc_level DD 020021H
	DD	057800H
	DD	imagerel validate_hevc_level+560
	DD	imagerel validate_hevc_level+568
	DD	imagerel $chain$0$validate_hevc_level
$chain$10$validate_hevc_level DD 021H
	DD	imagerel validate_hevc_level
	DD	imagerel validate_hevc_level+560
	DD	imagerel $unwind$validate_hevc_level
$unwind$parse_slice_specification DD 08a301H
	DD	01154a3H
	DD	012340dH
	DD	0e009b20dH
	DD	060067007H
$unwind$parse_pu_depth_list DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
$unwind$parse_array DD 081901H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	070155219H
$unwind$parse_uint8 DD 020601H
	DD	030025206H
$unwind$parse_tiles_specification DD 071001H
	DD	0223410H
	DD	01c0110H
	DD	07007e009H
	DD	06006H
$chain$0$parse_tiles_specification DD 020821H
	DD	0215408H
	DD	imagerel parse_tiles_specification
	DD	imagerel parse_tiles_specification+129
	DD	imagerel $unwind$parse_tiles_specification
$chain$1$parse_tiles_specification DD 021H
	DD	imagerel parse_tiles_specification
	DD	imagerel parse_tiles_specification+129
	DD	imagerel $unwind$parse_tiles_specification
$unwind$parse_enum DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
$unwind$parse_enum_n DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
$unwind$kvz_config_validate DD 050b01H
	DD	0d007620bH
	DD	07003c005H
	DD	03002H
$chain$1$kvz_config_validate DD 040d21H
	DD	0ee40dH
	DD	0d6405H
	DD	imagerel $LN108
	DD	imagerel $LN108+14
	DD	imagerel $unwind$kvz_config_validate
$chain$3$kvz_config_validate DD 04c421H
	DD	0c54c4H
	DD	06f405H
	DD	imagerel $LN108+14
	DD	imagerel $LN108+30
	DD	imagerel $chain$1$kvz_config_validate
$chain$4$kvz_config_validate DD 020021H
	DD	0c5400H
	DD	imagerel $LN108+14
	DD	imagerel $LN108+30
	DD	imagerel $chain$1$kvz_config_validate
$chain$5$kvz_config_validate DD 021H
	DD	imagerel $LN108
	DD	imagerel $LN108+14
	DD	imagerel $unwind$kvz_config_validate
$unwind$kvz_config_process_lp_gop DD 020601H
	DD	0c0029206H
$chain$2$kvz_config_process_lp_gop DD 061e21H
	DD	07e41eH
	DD	097416H
	DD	0d5405H
	DD	imagerel $LN73
	DD	imagerel $LN73+17
	DD	imagerel $unwind$kvz_config_process_lp_gop
$chain$6$kvz_config_process_lp_gop DD 082421H
	DD	0e6424H
	DD	06f419H
	DD	08d40aH
	DD	0c3405H
	DD	imagerel $LN73+17
	DD	imagerel $LN73+138
	DD	imagerel $chain$2$kvz_config_process_lp_gop
$chain$7$kvz_config_process_lp_gop DD 021H
	DD	imagerel $LN73+17
	DD	imagerel $LN73+138
	DD	imagerel $chain$2$kvz_config_process_lp_gop
$chain$8$kvz_config_process_lp_gop DD 021H
	DD	imagerel $LN73
	DD	imagerel $LN73+17
	DD	imagerel $unwind$kvz_config_process_lp_gop
$unwind$kvz_config_destroy DD 020601H
	DD	030023206H
$chain$0$kvz_config_destroy DD 020521H
	DD	067405H
	DD	imagerel $LN5
	DD	imagerel $LN5+25
	DD	imagerel $unwind$kvz_config_destroy
$chain$1$kvz_config_destroy DD 021H
	DD	imagerel $LN5
	DD	imagerel $LN5+25
	DD	imagerel $unwind$kvz_config_destroy
$unwind$kvz_config_parse DD 0a1701H
	DD	0123417H
	DD	0f0109217H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
$unwind$kvz_config_init DD 040a01H
	DD	06340aH
	DD	07006320aH
$SG4294957006 DB 'vaq', 00H
	ORG $+3
$SG4294957014 DB '%u.%u', 00H
	ORG $+2
$SG4294957021 DB '%d', 00H
	ORG $+1
$SG4294957026 DB '%d', 00H
	ORG $+1
$SG4294957027 DB '%d', 00H
	ORG $+3
$SG4294957017 DB 'level', 00H
	ORG $+2
$SG4294957029 DB 'rb', 00H
	ORG $+3
$SG4294957030 DB 'roi', 00H
$SG4294957045 DB 'key', 00H
$SG4294957053 DB 0aH, 00H
	ORG $+1
$SG4294957056 DB '0', 00H
	ORG $+1
$SG4294957069 DB 'lp-', 00H
	ORG $+3
$SG4294957047 DB 'crypto', 00H
	ORG $+1
$SG4294957070 DB 'gop', 00H
$SG4294957078 DB 'wpp', 00H
	ORG $+2
$SG4294957051 DB 'mv-rdo', 00H
	ORG $+1
$SG4294957082 DB 'owf', 00H
	ORG $+2
$SG4294957057 DB 'preset', 00H
	ORG $+1
$SG4294957083 DB 'wpp', 00H
$SG4294957106 DB 'aud', 00H
$SG4294957115 DB 'sar', 00H
	ORG $+2
$SG4294957059 DB 'bipred', 00H
	ORG $+1
$SG4294957119 DB 'me', 00H
	ORG $+3
$SG4294957074 DB 'cpuid', 00H
	ORG $+2
$SG4294957080 DB 'slices', 00H
	ORG $+1
$SG4294957123 DB 'rd', 00H
$SG4294956949 DB 'main', 00H
	ORG $+2
$SG4294956944 DB '%s: framerate of %g is too big for this level (%g) and '
	DB	'picture resolution (it has the sample rate of %llu, maximum i'
	DB	's %u', 0aH, 00H
	ORG $+6
$SG4294956945 DB '%s: picture resolution of %ix%i is too large for this l'
	DB	'evel (%g) (it has %llu samples, maximum is %u samples)', 0aH, 00H
	ORG $+1
$SG4294956946 DB '%s: picture height of %i is too large for this level (%'
	DB	'g), maximum dimension is %i', 0aH, 00H
$SG4294956950 DB 'high', 00H
	ORG $+7
$SG4294956947 DB '%s: picture width of %i is too large for this level (%g'
	DB	'), maximum dimension is %i', 0aH, 00H
	ORG $+5
$SG4294956951 DB 'Input error: high tier requires at least level 4', 0aH, 00H
	ORG $+6
$SG4294956948 DB '%s: target bitrate exceeds %i, which is the maximum %s '
	DB	'tier level %g bitrate', 0aH, 00H
	ORG $+2
$SG4294956952 DB 'Input error: %g is an invalid level value', 0aH, 00H
	ORG $+1
$SG4294957124 DB 'amp', 00H
$SG4294956953 DB 'Level error', 00H
$SG4294957125 DB 'smp', 00H
$SG4294956954 DB 'Level warning', 00H
	ORG $+2
$SG4294956955 DB 'Rate control algorithm set but bitrate not set.', 0aH, 00H
	ORG $+3
$SG4294957079 DB 'tiles', 00H
	ORG $+2
$SG4294957128 DB 'sao', 00H
$SG4294956956 DB 'Bitrate set but rc-algorithm is turned off.', 0aH, 00H
	ORG $+3
$SG4294956957 DB 'Input error: --scaling-list=custom does not work withou'
	DB	't --cqmfile=<FILE>.', 0aH, 00H
$SG4294957131 DB 'ref', 00H
$SG4294956958 DB 'Input error: --slices=wpp does not work without --wpp.', 0aH
	DB	00H
$SG4294956966 DB 'Input error: Intra PU depth min (%d) > max (%d)', 0aH, 00H
	ORG $+7
$SG4294956959 DB 'Input error: --implicit-rdpcm is not suppoted without -'
	DB	'-lossless', 0aH, 00H
	ORG $+6
$SG4294956968 DB 'Input error: Inter PU depth min (%d) > max (%d)', 0aH, 00H
	ORG $+7
$SG4294956960 DB 'Input error: last tile separation in height (%d) should'
	DB	' smaller than image height (%d)', 0aH, 00H
$SG4294956971 DB 'Input error: --intra-qp-offset out of range [-51..51]', 0aH
	DB	00H
	ORG $+1
$SG4294956961 DB 'Input error: tile separation in height %d (at %d) is no'
	DB	't at a multiple of LCU_WIDTH (%d)', 0aH, 00H
	ORG $+6
$SG4294956962 DB 'Input error: tile separations in height should be stric'
	DB	'tly monotonic (%d <= %d)', 0aH, 00H
	ORG $+7
$SG4294956970 DB 'Input error: --bitrate must be nonnegative', 0aH, 00H
$SG4294957041 DB 'tmvp', 00H
	ORG $+7
$SG4294956963 DB 'Input error: last x tile separation in width (%d) shoul'
	DB	'd smaller than image width (%d)', 0aH, 00H
$SG4294956972 DB 'Input error: --qp parameter out of range [0..51]', 0aH, 00H
	ORG $+6
$SG4294956964 DB 'Input error: tile separation in width %d (at %d) is not'
	DB	' at a multiple of LCU_WIDTH (%d)', 0aH, 00H
	ORG $+7
$SG4294956965 DB 'Input error: tile separations in width should be strict'
	DB	'ly monotonic (%d <= %d)', 0aH, 00H
$SG4294956967 DB 'Input error: illegal value for --pu-depth-intra (%d-%d)'
	DB	0aH, 00H
	ORG $+3
$SG4294957089 DB '%ux%u', 00H
	ORG $+2
$SG4294957133 DB 'period', 00H
	ORG $+1
$SG4294957134 DB 'qp', 00H
	ORG $+1
$SG4294956969 DB 'Input error: illegal value for --pu-depth-inter (%d-%d)'
	DB	0aH, 00H
	ORG $+3
$SG4294957090 DB 'tiles', 00H
	ORG $+2
$SG4294957140 DB 'height', 00H
	ORG $+1
$SG4294957144 DB 'no-', 00H
$SG4294956973 DB 'Input error: --owf must be nonnegative or -1', 0aH, 00H
	ORG $+2
$SG4294956974 DB 'Input error: --chromaloc parameter out of range [0..5]', 0aH
	DB	00H
$SG4294956975 DB 'Input error: invalid --subme parameter (must be in rang'
	DB	'e 0-4)', 0aH, 00H
	ORG $+1
$SG4294956976 DB 'Input error: --tr-depth-intra is out of range [0..4]', 0aH
	DB	00H
	ORG $+2
$SG4294956977 DB 'Input error: --rd parameter out of range [0..3]', 0aH, 00H
	ORG $+3
$SG4294957111 DB 'range', 00H
	ORG $+2
$SG4294957731 DB '%d', 00H
	ORG $+1
$SG4294956978 DB 'Input error: deblock tc parameter out of range [-6..6]', 0aH
	DB	00H
$SG4294956979 DB 'Input error: deblock beta parameter out of range [-6..6'
	DB	']', 0aH, 00H
	ORG $+2
$SG4294957734 DB ',', 00H
	ORG $+2
$SG4294956980 DB 'Input error: --ref out of range [1..%d]', 0aH, 00H
	ORG $+7
$SG4294956982 DB 'Input error: --input-fps denominator must be >0', 0aH, 00H
	ORG $+7
$SG4294956981 DB 'Input error: intra period (%d) not a multiple of B-gop '
	DB	'length (%d)', 0aH, 00H
$SG4294957736 DB ',', 00H
	ORG $+2
$SG4294956983 DB 'Input error: --input-fps must >=0', 0aH, 00H
	ORG $+1
$SG4294957744 DB '%d', 00H
	ORG $+1
$SG4294956984 DB 'Input error: --input-fps must be positive', 0aH, 00H
	ORG $+1
$SG4294957746 DB 'no', 00H
	ORG $+1
$SG4294956985 DB 'Input error: resolution %dx%d too large (max %u CTUs)', 0aH
	DB	00H
	ORG $+1
$SG4294956986 DB 'Input error: height must be a multiple of two', 0aH, 00H
	ORG $+1
$SG4294956987 DB 'Input error: width must be a multiple of two', 0aH, 00H
	ORG $+2
$SG4294956988 DB 'Input error: height must be positive', 0aH, 00H
	ORG $+2
$SG4294956989 DB 'Input error: width must be positive', 0aH, 00H
	ORG $+3
$SG4294956990 DB 'vaq strength must be positive', 0aH, 00H
	ORG $+1
$SG4294956991 DB 'stats-file-prefix', 00H
	ORG $+6
$SG4294956992 DB 'Invalid input file format %s. Valid values include %s, '
	DB	'%s, and %s', 0aH, 00H
	ORG $+1
$SG4294957748 DB '0', 00H
	ORG $+2
$SG4294956993 DB 'input-file-format', 00H
	ORG $+2
$SG4294957749 DB 'yes', 00H
$SG4294956994 DB 'clip-neighbour', 00H
	ORG $+1
$SG4294956995 DB 'intra-bits', 00H
	ORG $+5
$SG4294956996 DB 'Invalid rate control algorithm %s. Valid values include'
	DB	' %s, %s, and %s', 0aH, 00H
$SG4294956997 DB 'rc-algorithm', 00H
	ORG $+3
$SG4294956998 DB 'zero-coeff-rdo', 00H
	ORG $+1
$SG4294957002 DB 'ml-pu-depth-intra', 00H
	ORG $+6
$SG4294956999 DB 'invalid partial-coding options. Expected "%%u!%%u!%%u!%'
	DB	'%u", but got "%s"', 0aH, 00H
	ORG $+2
$SG4294957751 DB '1', 00H
	ORG $+2
$SG4294957000 DB '%u!%u!%u!%u', 00H
$SG4294957001 DB 'partial-coding', 00H
	ORG $+1
$SG4294957003 DB 'early-skip', 00H
	ORG $+2
$SG4294957004 DB 'max-merge needs to be between 1 and 5', 0aH, 00H
	ORG $+1
$SG4294957005 DB 'max-merge', 00H
	ORG $+2
$SG4294957007 DB 'fast-residual-cost', 00H
	ORG $+2
$SG4294957008 DB 'me-steps value is out of bounds: "%s"', 00H
	ORG $+2
$SG4294957009 DB 'Invalid me-steps value: "%s"', 00H
	ORG $+3
$SG4294957010 DB 'me-steps', 00H
	ORG $+3
$SG4294957114 DB '%d:%d', 00H
	ORG $+2
$SG4294957011 DB 'high-tier', 00H
$SG4294957012 DB 'Level value of %s is out of bounds', 0aH, 00H
$SG4294957013 DB 'Invalid level value: "%s"', 0aH, 00H
$SG4294957015 DB 'force-level', 00H
$SG4294957016 DB 'force-level', 00H
	ORG $+2
$SG4294957018 DB 'erp-aqp', 00H
$SG4294957019 DB 'set-qp-in-cu', 00H
	ORG $+3
$SG4294957020 DB 'Reading ROI file failed.', 0aH, 00H
	ORG $+2
$SG4294957022 DB 'Failed to allocate memory for ROI table.', 0aH, 00H
	ORG $+2
$SG4294957023 DB 'ROI dimensions exceed arbitrary value of 10000.', 0aH, 00H
	ORG $+3
$SG4294957118 DB 'subme', 00H
	ORG $+2
$SG4294957024 DB 'Invalid ROI size: %dx%d.', 0aH, 00H
	ORG $+2
$SG4294957025 DB 'Failed to read ROI size.', 0aH, 00H
$SG4294957028 DB 'Could not open ROI file.', 0aH, 00H
$SG4294957031 DB 'implicit-rdpcm', 00H
	ORG $+1
$SG4294957032 DB 'input-bitdepth can''t be set to larger than 8 because K'
	DB	'vazaar is compiled with KVZ_BIT_DEPTH=8.', 0aH, 00H
$SG4294957033 DB 'input-bitdepth not between 8 and 16.', 0aH, 00H
	ORG $+2
$SG4294957034 DB 'input-bitdepth', 00H
	ORG $+1
$SG4294957035 DB 'input-format not recognized.', 0aH, 00H
	ORG $+2
$SG4294957038 DB 'input-format', 00H
	ORG $+3
$SG4294957039 DB 'rdoq-skip', 00H
$SG4294957040 DB 'Cannot enable TMVP because tiles are used.', 0aH, 00H
$SG4294957042 DB 'lossless', 00H
	ORG $+3
$SG4294957129 DB '%d:%d', 00H
$SG4294957043 DB 'intra-rdo-et', 00H
	ORG $+3
$SG4294957044 DB 'me-early-termination', 00H
	ORG $+3
$SG4294957046 DB '--crypto cannot be enabled because it''s not compiled i'
	DB	'n.', 0aH, 00H
$SG4294957048 DB 'cu-split-termination', 00H
	ORG $+3
$SG4294957049 DB 'hash', 00H
	ORG $+3
$SG4294957050 DB 'psnr', 00H
	ORG $+3
$SG4294957052 DB 'Input error: unknown preset "%s"', 0aH, 00H
	ORG $+2
$SG4294957054 DB '--%s=%s ', 00H
	ORG $+3
$SG4294957135 DB '%d/%d', 00H
	ORG $+2
$SG4294957055 DB 'Using preset %s: ', 00H
$SG4294957058 DB 'bitrate', 00H
$SG4294957060 DB 'open-gop', 00H
	ORG $+3
$SG4294957061 DB 'auto', 00H
	ORG $+3
$SG4294957137 DB '%dx%d', 00H
$SG4294957062 DB 'intra-qp-offset', 00H
$SG4294957063 DB 'Input error: unsupported gop length, must be 0 or 8', 0aH
	DB	00H
	ORG $+3
$SG4294957064 DB 'gop.t must be between 1 and 15.', 0aH, 00H
	ORG $+3
$SG4294957141 DB 'width', 00H
$SG4294957065 DB 'gop.d must be between 1 and 8.', 0aH, 00H
$SG4294957066 DB 'gop.g must be between 1 and 32.', 0aH, 00H
	ORG $+3
$SG4294957143 DB 'false', 00H
$SG4294957067 DB 'Error in GOP syntax. Example: lp-g8d4t2', 0aH, 00H
	ORG $+3
$SG4294957735 DB '%d-%d', 00H
$SG4294957068 DB 'lp-g%ud%ut%u', 00H
	ORG $+3
$SG4294957071 DB 'info', 00H
	ORG $+3
$SG4294957072 DB 'pu-depth-intra', 00H
	ORG $+1
$SG4294957073 DB 'pu-depth-inter', 00H
	ORG $+1
$SG4294957075 DB 'auto', 00H
	ORG $+3
$SG4294957076 DB 'threads', 00H
$SG4294957077 DB 'tiles+wpp', 00H
	ORG $+2
$SG4294957081 DB 'auto', 00H
	ORG $+3
$SG4294957747 DB 'false', 00H
$SG4294957084 DB 'Disabling WPP because tiles were enabled.', 0aH, 00H
$SG4294957085 DB 'Disabling TMVP because tiles are used.', 0aH, 00H
$SG4294957086 DB 'Invalid number of tiles (0 < %d <= %d = MAX_TILES_PER_D'
	DB	'IM)!', 0aH, 00H
	ORG $+3
$SG4294957087 DB 'Invalid number of tiles (0 < %d <= %d = MAX_TILES_PER_D'
	DB	'IM)!', 0aH, 00H
	ORG $+3
$SG4294957088 DB 'Wrong format for tiles. Expected "%%ux%%u", but got "%s'
	DB	'"', 0aH, 00H
	ORG $+1
$SG4294957091 DB 'Disabling WPP because tiles were enabled.', 0aH, 00H
	ORG $+1
$SG4294957092 DB 'Disabling TMVP because tiles are used.', 0aH, 00H
$SG4294957093 DB 'tiles-height-split', 00H
	ORG $+2
$SG4294957094 DB 'Disabling WPP because tiles were enabled.', 0aH, 00H
$SG4294957095 DB 'Disabling TMVP because tiles are used.', 0aH, 00H
$SG4294957096 DB 'tiles-width-split', 00H
$SG4294957097 DB 'scaling-list', 00H
	ORG $+3
$SG4294957098 DB 'Failed to allocate memory for fast RD learning outfile '
	DB	'name.', 0aH, 00H
	ORG $+2
$SG4294957099 DB 'fastrd-outdir', 00H
	ORG $+2
$SG4294957100 DB 'fastrd-accuracy-check', 00H
	ORG $+2
$SG4294957101 DB 'fastrd-sampling', 00H
$SG4294957102 DB 'Failed to allocate memory for fast coeff table file nam'
	DB	'e.', 0aH, 00H
$SG4294957103 DB 'fast-coeff-table', 00H
$SG4294957104 DB 'Failed to allocate memory for CQM file name.', 0aH, 00H
	ORG $+2
$SG4294957105 DB 'cqmfile', 00H
$SG4294957107 DB 'chromaloc', 00H
$SG4294957108 DB 'colormatrix', 00H
$SG4294957109 DB 'transfer', 00H
$SG4294957110 DB 'colorprim', 00H
$SG4294957112 DB 'videoformat', 00H
$SG4294957113 DB 'overscan', 00H
$SG4294957116 DB 'mv-constraint', 00H
	ORG $+2
$SG4294957117 DB 'source-scan-type', 00H
	ORG $+6
$SG4294957120 DB 'tr-depth-intra', 00H
	ORG $+1
$SG4294957121 DB 'transform-skip', 00H
	ORG $+1
$SG4294957122 DB 'full-intra-search', 00H
	ORG $+6
$SG4294957126 DB 'signhide', 00H
	ORG $+3
$SG4294957127 DB 'rdoq', 00H
	ORG $+7
$SG4294957130 DB 'deblock', 00H
$SG4294957132 DB 'vps-period', 00H
	ORG $+5
$SG4294957136 DB 'input-fps', 00H
	ORG $+2
$SG4294957138 DB 'auto', 00H
	ORG $+7
$SG4294957139 DB 'input-res', 00H
	ORG $+2
$SG4294957142 DB 'true', 00H
	ORG $+3
$SG4294957145 DB 'true', 00H
	ORG $+7
$SG4294957728 DB 'Could not allocate array for slices', 0aH, 00H
	ORG $+3
$SG4294957729 DB 'Invalid number of slices (0 < %d <= %d = MAX_SLICES)!', 0aH
	DB	00H
	ORG $+1
$SG4294957730 DB 'Could not parse integer "%s"!', 0aH, 00H
	ORG $+1
$SG4294957732 DB 'Invalid number of tiles (0 < %d <= %d = MAX_SLICES)!', 0aH
	DB	00H
	ORG $+2
$SG4294957733 DB 'parsing failed : too many values.', 0aH, 00H
	ORG $+5
$SG4294957737 DB 'parsing failed : too few members.', 0aH, 00H
	ORG $+5
$SG4294957738 DB 'parsing failed : too many members.', 0aH, 00H
	ORG $+4
$SG4294957740 DB 'Expected number between %d and %d', 0aH, 00H
	ORG $+5
$SG4294957741 DB 'Could not allocate array for tiles', 0aH, 00H
	ORG $+4
$SG4294957742 DB 'Invalid number of tiles (1 <= %d <= %d = MAX_TILES_PER_'
	DB	'DIM)!', 0aH, 00H
	ORG $+2
$SG4294957743 DB 'Could not parse integer "%s"!', 0aH, 00H
	ORG $+1
$SG4294957745 DB 'Invalid number of tiles (1 <= %d <= %d = MAX_TILES_PER_'
	DB	'DIM)!', 0aH, 00H
	ORG $+2
$SG4294957750 DB 'true', 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
kvz_config_alloc PROC

; 45   :   return calloc(1, sizeof(kvz_config));

	mov	edx, 2528				; 000009e0H
	mov	ecx, 1
	rex_jmp	QWORD PTR __imp_calloc
kvz_config_alloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
cfg$ = 48
kvz_config_init PROC

; 49   : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 50   :   cfg->width           = 0;

	xor	edi, edi

; 51   :   cfg->height          = 0;
; 52   :   cfg->framerate       = 25; // deprecated and will be removed.
; 53   :   cfg->framerate_num   = 25;

	mov	DWORD PTR [rcx+32], 25
	mov	rax, 4627730092099895296		; 4039000000000000H
	mov	QWORD PTR [rcx+12], rdi
	mov	rbx, rcx
	mov	QWORD PTR [rcx+24], rax

; 54   :   cfg->framerate_denom = 1;

	mov	DWORD PTR [rcx+36], 1

; 55   :   cfg->qp              = 22;

	mov	DWORD PTR [rcx], 22

; 56   :   cfg->intra_qp_offset = 0;

	mov	WORD PTR [rcx+2460], 256		; 00000100H

; 57   :   cfg->intra_qp_offset_auto = true;
; 58   :   cfg->intra_period    = 64;

	mov	QWORD PTR [rcx+4], 64			; 00000040H

; 59   :   cfg->vps_period      = 0;
; 60   :   cfg->deblock_enable  = 1;

	mov	DWORD PTR [rcx+40], 1

; 61   :   cfg->deblock_beta    = 0;

	mov	QWORD PTR [rcx+96], rdi

; 62   :   cfg->deblock_tc      = 0;
; 63   :   cfg->sao_type        = 3;

	mov	DWORD PTR [rcx+44], 3

; 64   :   cfg->rdoq_enable     = 1;

	mov	DWORD PTR [rcx+48], 1

; 65   :   cfg->rdoq_skip       = 1;

	mov	DWORD PTR [rcx+2400], 1

; 66   :   cfg->signhide_enable = true;

	mov	QWORD PTR [rcx+52], 1

; 67   :   cfg->smp_enable      = false;
; 68   :   cfg->amp_enable      = false;

	mov	DWORD PTR [rcx+60], edi

; 69   :   cfg->rdo             = 1;

	mov	QWORD PTR [rcx+64], 1

; 70   :   cfg->mv_rdo          = 0;

	mov	BYTE PTR [rcx+2356], dil

; 71   :   cfg->full_intra_search = 0;
; 72   :   cfg->trskip_enable   = 0;

	mov	QWORD PTR [rcx+72], rdi

; 73   :   cfg->tr_depth_intra  = 0;
; 74   :   cfg->ime_algorithm   = 0; /* hexbs */

	mov	DWORD PTR [rcx+80], edi

; 75   :   cfg->fme_level       = 4;

	mov	DWORD PTR [rcx+84], 4

; 76   :   cfg->source_scan_type = 0; /* progressive */

	mov	BYTE PTR [rcx+88], dil

; 77   :   cfg->vui.sar_width   = 0;

	mov	QWORD PTR [rcx+104], rdi

; 78   :   cfg->vui.sar_height  = 0;
; 79   :   cfg->vui.overscan    = 0; /* undef */

	mov	DWORD PTR [rcx+112], 33555712		; 02000500H

; 80   :   cfg->vui.videoformat = 5; /* undef */
; 81   :   cfg->vui.fullrange   = 0; /* limited range */
; 82   :   cfg->vui.colorprim   = 2; /* undef */
; 83   :   cfg->vui.transfer    = 2; /* undef */

	mov	WORD PTR [rcx+116], 514			; 00000202H

; 84   :   cfg->vui.colormatrix = 2; /* undef */
; 85   :   cfg->vui.chroma_loc  = 0; /* left center */

	mov	QWORD PTR [rcx+120], rdi

; 86   :   cfg->aud_enable      = 0;
; 87   :   cfg->cqmfile         = NULL;

	mov	QWORD PTR [rcx+136], rdi

; 88   :   cfg->fast_coeff_table_fn = NULL;

	mov	QWORD PTR [rcx+2504], rdi

; 89   :   cfg->ref_frames      = 1;

	mov	DWORD PTR [rcx+128], 1

; 90   :   cfg->gop_len         = 4;

	mov	WORD PTR [rcx+300], 260			; 00000104H

; 91   :   cfg->gop_lowdelay    = true;
; 92   :   cfg->bipred          = 0;

	mov	DWORD PTR [rcx+92], edi

; 93   :   cfg->target_bitrate  = 0;

	mov	DWORD PTR [rcx+2352], edi

; 94   :   cfg->hash            = KVZ_HASH_CHECKSUM;

	mov	QWORD PTR [rcx+2364], 1

; 95   :   cfg->lossless        = false;

	mov	DWORD PTR [rcx+2392], edi

; 96   :   cfg->tmvp_enable     = true;

	mov	DWORD PTR [rcx+2396], 1

; 97   :   cfg->implicit_rdpcm  = false;

	mov	DWORD PTR [rcx+2420], edi

; 98   :   cfg->fast_residual_cost_limit = 0;

	mov	BYTE PTR [rcx+2462], dil

; 99   : 
; 100  :   cfg->cu_split_termination = KVZ_CU_SPLIT_TERMINATION_ZERO;
; 101  : 
; 102  :   cfg->tiles_width_count  = 1;

	mov	DWORD PTR [rcx+144], 1

; 103  :   cfg->tiles_height_count = 1;

	mov	DWORD PTR [rcx+148], 1

; 104  :   cfg->tiles_width_split  = NULL;

	mov	QWORD PTR [rcx+152], rdi

; 105  :   cfg->tiles_height_split = NULL;

	mov	QWORD PTR [rcx+160], rdi

; 106  : 
; 107  :   cfg->wpp = 1;

	mov	DWORD PTR [rcx+168], 1

; 108  :   cfg->owf = -1;

	mov	DWORD PTR [rcx+172], -1

; 109  :   cfg->slice_count = 1;

	mov	DWORD PTR [rcx+176], 1

; 110  :   cfg->slice_addresses_in_ts = MALLOC(int32_t, 1);

	lea	ecx, QWORD PTR [rdi+4]
	call	QWORD PTR __imp_malloc

; 111  :   cfg->slice_addresses_in_ts[0] = 0;
; 112  : 
; 113  :   cfg->threads = -1;
; 114  :   cfg->cpuid = 1;
; 115  : 
; 116  :   // Defaults for what sizes of PUs are tried.
; 117  :   memset( cfg->pu_depth_inter.min, -1, sizeof( cfg->pu_depth_inter.min ) );

	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	mov	QWORD PTR [rbx+184], rax
	mov	DWORD PTR [rax], edi
	mov	DWORD PTR [rbx+192], -1
	mov	DWORD PTR [rbx+196], 1
	movups	XMMWORD PTR [rbx+200], xmm0
	movq	QWORD PTR [rbx+216], xmm0

; 118  :   memset( cfg->pu_depth_inter.max, -1, sizeof( cfg->pu_depth_inter.max ) );

	movups	XMMWORD PTR [rbx+224], xmm0
	movq	QWORD PTR [rbx+240], xmm0

; 119  :   memset( cfg->pu_depth_intra.min, -1, sizeof( cfg->pu_depth_intra.min ) );

	movups	XMMWORD PTR [rbx+248], xmm0
	movq	QWORD PTR [rbx+264], xmm0

; 120  :   memset( cfg->pu_depth_intra.max, -1, sizeof( cfg->pu_depth_intra.max ) );

	movups	XMMWORD PTR [rbx+272], xmm0
	movq	QWORD PTR [rbx+288], xmm0

; 121  :   *cfg->pu_depth_inter.min = 2; // 0-3

	mov	DWORD PTR [rbx+200], 2

; 122  :   *cfg->pu_depth_inter.max = 3; // 0-3

	mov	DWORD PTR [rbx+224], 3

; 123  :   *cfg->pu_depth_intra.min = 2; // 0-4

	mov	DWORD PTR [rbx+248], 2

; 124  :   *cfg->pu_depth_intra.max = 3; // 0-4

	mov	DWORD PTR [rbx+272], 3

; 125  : 
; 126  :   cfg->add_encoder_info = true;

	mov	DWORD PTR [rbx+296], 1

; 127  :   cfg->calc_psnr = true;

	mov	BYTE PTR [rbx+2357], 1

; 128  : 
; 129  :   cfg->mv_constraint = KVZ_MV_CONSTRAIN_NONE;

	mov	DWORD PTR [rbx+2360], edi

; 130  :   cfg->crypto_features = KVZ_CRYPTO_OFF;

	mov	DWORD PTR [rbx+2372], edi

; 131  : 
; 132  :   cfg->me_early_termination = 1;

	mov	QWORD PTR [rbx+2384], 1

; 133  :   cfg->intra_rdo_et         = 0;
; 134  : 
; 135  :   cfg->input_format = KVZ_FORMAT_P420;

	mov	DWORD PTR [rbx+2404], 1

; 136  :   cfg->input_bitdepth = 8;

	mov	DWORD PTR [rbx+2408], 8

; 137  : 
; 138  :   cfg->gop_lp_definition.d = 3;

	mov	DWORD PTR [rbx+2412], 3

; 139  :   cfg->gop_lp_definition.t = 1;

	mov	DWORD PTR [rbx+2416], 1

; 140  :   cfg->open_gop = true;
; 141  : 
; 142  :   cfg->roi.width = 0;
; 143  :   cfg->roi.height = 0;
; 144  :   cfg->roi.dqps = NULL;
; 145  :   cfg->set_qp_in_cu = false;

	mov	WORD PTR [rbx+2463], 256		; 00000100H
	mov	QWORD PTR [rbx+2424], rdi
	mov	QWORD PTR [rbx+2432], rdi

; 146  : 
; 147  :   cfg->erp_aqp = false;
; 148  : 
; 149  :   cfg->slices = KVZ_SLICES_NONE;

	mov	QWORD PTR [rbx+2440], rdi

; 150  : 
; 151  :   cfg->optional_key = NULL;

	mov	QWORD PTR [rbx+2376], rdi

; 152  : 
; 153  :   cfg->level = 62; // default hevc level, 6.2 (the highest)

	mov	WORD PTR [rbx+2448], 318		; 0000013eH

; 154  :   cfg->force_level = true; // don't care about level limits by-default
; 155  :   cfg->high_tier = false;

	mov	BYTE PTR [rbx+2450], dil

; 156  : 
; 157  :   cfg->me_max_steps = (uint32_t)-1;

	mov	DWORD PTR [rbx+2456], -1		; ffffffffH

; 158  : 
; 159  :   cfg->vaq = 0;

	mov	DWORD PTR [rbx+2468], edi

; 160  : 
; 161  :   cfg->scaling_list = KVZ_SCALING_LIST_OFF;
; 162  : 
; 163  :   cfg->max_merge = 5;
; 164  :   cfg->early_skip = true;
; 165  : 
; 166  :   cfg->ml_pu_depth_intra = false;
; 167  : 
; 168  :   cfg->partial_coding.startCTU_x = 0;
; 169  :   cfg->partial_coding.startCTU_y = 0;
; 170  :   cfg->partial_coding.fullWidth = 0;
; 171  :   cfg->partial_coding.fullHeight = 0;
; 172  : 
; 173  :   cfg->zero_coeff_rdo = true;
; 174  : 
; 175  :   cfg->rc_algorithm = KVZ_NO_RC;
; 176  :   cfg->intra_bit_allocation = false;
; 177  :   cfg->clip_neighbour = true;
; 178  : 
; 179  :   cfg->file_format = KVZ_FORMAT_AUTO;
; 180  : 
; 181  :   cfg->stats_file_prefix = NULL;
; 182  : 
; 183  :   cfg->fastrd_sampling_on = 0;
; 184  :   cfg->fastrd_accuracy_check_on = 0;
; 185  :   cfg->fastrd_learning_outdir_fn = NULL;
; 186  :   return 1;

	lea	eax, QWORD PTR [rdi+1]
	mov	QWORD PTR [rbx+2472], 66816		; 00010500H
	mov	WORD PTR [rbx+2480], di
	mov	BYTE PTR [rbx+2482], 1
	mov	WORD PTR [rbx+2484], di
	mov	BYTE PTR [rbx+2486], 1
	mov	DWORD PTR [rbx+2488], edi
	mov	QWORD PTR [rbx+2496], rdi
	mov	WORD PTR [rbx+2513], di
	mov	QWORD PTR [rbx+2520], rdi

; 187  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
kvz_config_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
fullWidth$1 = 48
number$2 = 48
fullHeight$3 = 52
gop$4 = 56
cfg$ = 144
firstCTU_x$5 = 152
tailptr$6 = 152
num_first$7 = 152
height$8 = 152
height$9 = 152
beta$10 = 152
fps_num$11 = 152
name$ = 152
value$ = 160
firstCTU_y$12 = 168
num_second$13 = 168
width$14 = 168
width$15 = 168
tc$16 = 168
fps_denom$17 = 168
kvz_config_parse PROC

; 445  : {

$LN1397:
	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 80					; 00000050H
	mov	rbx, rdx
	mov	rsi, rcx

; 446  :   static const char * const me_names[]          = { "hexbs", "tz", "full", "full8", "full16", "full32", "full64", "dia", NULL };
; 447  :   static const char * const source_scan_type_names[] = { "progressive", "tff", "bff", NULL };
; 448  : 
; 449  :   static const char * const overscan_names[]    = { "undef", "show", "crop", NULL };
; 450  :   static const char * const videoformat_names[] = { "component", "pal", "ntsc", "secam", "mac", "undef", NULL };
; 451  :   static const char * const range_names[]       = { "tv", "pc", NULL };
; 452  :   static const char * const colorprim_names[]   = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m",
; 453  :                                                     "smpte240m", "film", "bt2020", NULL };
; 454  :   static const char * const transfer_names[]    = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m",
; 455  :                                                     "smpte240m", "linear", "log100", "log316", "iec61966-2-4",
; 456  :                                                     "bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-12", NULL };
; 457  :   static const char * const colormatrix_names[] = { "GBR", "bt709", "undef", "", "fcc", "bt470bg", "smpte170m",
; 458  :                                                     "smpte240m", "YCgCo", "bt2020nc", "bt2020c", NULL };
; 459  :   static const char * const mv_constraint_names[] = { "none", "frame", "tile", "frametile", "frametilemargin", NULL };
; 460  :   static const char * const hash_names[] = { "none", "checksum", "md5", NULL };
; 461  : 
; 462  :   static const char * const cu_split_termination_names[] = { "zero", "off", NULL };
; 463  :   static const char * const crypto_toggle_names[] = { "off", "on", NULL };
; 464  :   static const char * const crypto_feature_names[] = { "mvs", "mv_signs", "trans_coeffs", "trans_coeff_signs", "intra_pred_modes", NULL };
; 465  : 
; 466  :   static const char * const me_early_termination_names[] = { "off", "on", "sensitive", NULL };
; 467  : 
; 468  :   static const char * const sao_names[] = { "off", "edge", "band", "full", NULL };
; 469  : 
; 470  :   static const char * const scaling_list_names[] = { "off", "custom", "default", NULL };
; 471  : 
; 472  :   static const char * const rc_algorithm_names[] = { "no-rc", "lambda", "oba", NULL };
; 473  : 
; 474  :   static const char * const file_format_names[] = {"auto", "y4m", "yuv", NULL};
; 475  : 
; 476  :   static const char * const preset_values[11][25*2] = {
; 477  :       {
; 478  :         "ultrafast",
; 479  :         "rd", "0",
; 480  :         "pu-depth-intra", "2-3",
; 481  :         "pu-depth-inter", "1-2",
; 482  :         "me", "hexbs",
; 483  :         "gop", "8",
; 484  :         "ref", "1",
; 485  :         "bipred", "1",
; 486  :         "deblock", "0:0",
; 487  :         "signhide", "0",
; 488  :         "subme", "0",
; 489  :         "sao", "off",
; 490  :         "rdoq", "0",
; 491  :         "rdoq-skip", "0",
; 492  :         "transform-skip", "0",
; 493  :         "mv-rdo", "0",
; 494  :         "full-intra-search", "0",
; 495  :         "smp", "0",
; 496  :         "amp", "0",
; 497  :         "cu-split-termination", "zero",
; 498  :         "me-early-termination", "sensitive",
; 499  :         "intra-rdo-et", "0",
; 500  :         "early-skip", "1",
; 501  :         "fast-residual-cost", "28",
; 502  :         "max-merge", "5",
; 503  :         NULL
; 504  :       },
; 505  :       {
; 506  :         "superfast",
; 507  :         "rd", "0",
; 508  :         "pu-depth-intra", "2-3",
; 509  :         "pu-depth-inter", "1-2",
; 510  :         "me", "hexbs",
; 511  :         "gop", "8",
; 512  :         "ref", "1",
; 513  :         "bipred", "1",
; 514  :         "deblock", "0:0",
; 515  :         "signhide", "0",
; 516  :         "subme", "2",
; 517  :         "sao", "full",
; 518  :         "rdoq", "0",
; 519  :         "rdoq-skip", "0",
; 520  :         "transform-skip", "0",
; 521  :         "mv-rdo", "0",
; 522  :         "full-intra-search", "0",
; 523  :         "smp", "0",
; 524  :         "amp", "0",
; 525  :         "cu-split-termination", "zero",
; 526  :         "me-early-termination", "sensitive",
; 527  :         "intra-rdo-et", "0",
; 528  :         "early-skip", "1",
; 529  :         "fast-residual-cost", "28",
; 530  :         "max-merge", "5",
; 531  :         NULL
; 532  :       },
; 533  :       {
; 534  :         "veryfast",
; 535  :         "rd", "0",
; 536  :         "pu-depth-intra", "2-3",
; 537  :         "pu-depth-inter", "1-3",
; 538  :         "me", "hexbs",
; 539  :         "gop", "8",
; 540  :         "ref", "1",
; 541  :         "bipred", "1",
; 542  :         "deblock", "0:0",
; 543  :         "signhide", "0",
; 544  :         "subme", "2",
; 545  :         "sao", "full",
; 546  :         "rdoq", "0",
; 547  :         "rdoq-skip", "0",
; 548  :         "transform-skip", "0",
; 549  :         "mv-rdo", "0",
; 550  :         "full-intra-search", "0",
; 551  :         "smp", "0",
; 552  :         "amp", "0",
; 553  :         "cu-split-termination", "zero",
; 554  :         "me-early-termination", "sensitive",
; 555  :         "intra-rdo-et", "0",
; 556  :         "early-skip", "1",
; 557  :         "fast-residual-cost", "28",
; 558  :         "max-merge", "5",
; 559  :         NULL
; 560  :       },
; 561  :       {
; 562  :         "faster",
; 563  :         "rd", "0",
; 564  :         "pu-depth-intra", "2-3",
; 565  :         "pu-depth-inter", "1-3",
; 566  :         "me", "hexbs",
; 567  :         "gop", "8",
; 568  :         "ref", "1",
; 569  :         "bipred", "1",
; 570  :         "deblock", "0:0",
; 571  :         "signhide", "0",
; 572  :         "subme", "4",
; 573  :         "sao", "full",
; 574  :         "rdoq", "0",
; 575  :         "rdoq-skip", "0",
; 576  :         "transform-skip", "0",
; 577  :         "mv-rdo", "0",
; 578  :         "full-intra-search", "0",
; 579  :         "smp", "0",
; 580  :         "amp", "0",
; 581  :         "cu-split-termination", "zero",
; 582  :         "me-early-termination", "sensitive",
; 583  :         "intra-rdo-et", "0",
; 584  :         "early-skip", "1",
; 585  :         "fast-residual-cost", "0",
; 586  :         "max-merge", "5",
; 587  :         NULL
; 588  :       },
; 589  :       {
; 590  :         "fast",
; 591  :         "rd", "0",
; 592  :         "pu-depth-intra", "1-3",
; 593  :         "pu-depth-inter", "1-3",
; 594  :         "me", "hexbs",
; 595  :         "gop", "8",
; 596  :         "ref", "2",
; 597  :         "bipred", "1",
; 598  :         "deblock", "0:0",
; 599  :         "signhide", "0",
; 600  :         "subme", "4",
; 601  :         "sao", "full",
; 602  :         "rdoq", "0",
; 603  :         "rdoq-skip", "0",
; 604  :         "transform-skip", "0",
; 605  :         "mv-rdo", "0",
; 606  :         "full-intra-search", "0",
; 607  :         "smp", "0",
; 608  :         "amp", "0",
; 609  :         "cu-split-termination", "zero",
; 610  :         "me-early-termination", "sensitive",
; 611  :         "intra-rdo-et", "0",
; 612  :         "early-skip", "1",
; 613  :         "fast-residual-cost", "0",
; 614  :         "max-merge", "5",
; 615  :         NULL
; 616  :       },
; 617  :       {
; 618  :         "medium",
; 619  :         "rd", "0",
; 620  :         "pu-depth-intra", "1-4",
; 621  :         "pu-depth-inter", "0-3",
; 622  :         "me", "hexbs",
; 623  :         "gop", "16",
; 624  :         "ref", "4",
; 625  :         "bipred", "1",
; 626  :         "deblock", "0:0",
; 627  :         "signhide", "0",
; 628  :         "subme", "4",
; 629  :         "sao", "full",
; 630  :         "rdoq", "1",
; 631  :         "rdoq-skip", "0",
; 632  :         "transform-skip", "0",
; 633  :         "mv-rdo", "0",
; 634  :         "full-intra-search", "0",
; 635  :         "smp", "0",
; 636  :         "amp", "0",
; 637  :         "cu-split-termination", "zero",
; 638  :         "me-early-termination", "on",
; 639  :         "intra-rdo-et", "0",
; 640  :         "early-skip", "1",
; 641  :         "fast-residual-cost", "0",
; 642  :         "max-merge", "5",
; 643  :         NULL
; 644  :       },
; 645  :       {
; 646  :         "slow",
; 647  :         "rd", "1",
; 648  :         "pu-depth-intra", "1-4",
; 649  :         "pu-depth-inter", "0-3",
; 650  :         "me", "hexbs",
; 651  :         "gop", "16",
; 652  :         "ref", "4",
; 653  :         "bipred", "1",
; 654  :         "deblock", "0:0",
; 655  :         "signhide", "0",
; 656  :         "subme", "4",
; 657  :         "sao", "full",
; 658  :         "rdoq", "1",
; 659  :         "rdoq-skip", "0",
; 660  :         "transform-skip", "0",
; 661  :         "mv-rdo", "0",
; 662  :         "full-intra-search", "0",
; 663  :         "smp", "0",
; 664  :         "amp", "0",
; 665  :         "cu-split-termination", "zero",
; 666  :         "me-early-termination", "on",
; 667  :         "intra-rdo-et", "0",
; 668  :         "early-skip", "1",
; 669  :         "fast-residual-cost", "0",
; 670  :         "max-merge", "5",
; 671  :         NULL
; 672  :       },
; 673  :       {
; 674  :         "slower",
; 675  :         "rd", "2",
; 676  :         "pu-depth-intra", "1-4",
; 677  :         "pu-depth-inter", "0-3",
; 678  :         "me", "hexbs",
; 679  :         "gop", "16",
; 680  :         "ref", "4",
; 681  :         "bipred", "1",
; 682  :         "deblock", "0:0",
; 683  :         "signhide", "1",
; 684  :         "subme", "4",
; 685  :         "sao", "full",
; 686  :         "rdoq", "1",
; 687  :         "rdoq-skip", "0",
; 688  :         "transform-skip", "0",
; 689  :         "mv-rdo", "0",
; 690  :         "full-intra-search", "0",
; 691  :         "smp", "0",
; 692  :         "amp", "0",
; 693  :         "cu-split-termination", "zero",
; 694  :         "me-early-termination", "off",
; 695  :         "intra-rdo-et", "0",
; 696  :         "early-skip", "1",
; 697  :         "fast-residual-cost", "0",
; 698  :         "max-merge", "5",
; 699  :         NULL
; 700  :       },
; 701  :       {
; 702  :         "veryslow",
; 703  :         "rd", "2",
; 704  :         "pu-depth-intra", "1-4",
; 705  :         "pu-depth-inter", "0-3",
; 706  :         "me", "tz",
; 707  :         "gop", "16",
; 708  :         "ref", "4",
; 709  :         "bipred", "1",
; 710  :         "deblock", "0:0",
; 711  :         "signhide", "1",
; 712  :         "subme", "4",
; 713  :         "sao", "full",
; 714  :         "rdoq", "1",
; 715  :         "rdoq-skip", "0",
; 716  :         "transform-skip", "1",
; 717  :         "mv-rdo", "0",
; 718  :         "full-intra-search", "0",
; 719  :         "smp", "1",
; 720  :         "amp", "0",
; 721  :         "cu-split-termination", "zero",
; 722  :         "me-early-termination", "off",
; 723  :         "intra-rdo-et", "0",
; 724  :         "early-skip", "1",
; 725  :         "fast-residual-cost", "0",
; 726  :         "max-merge", "5",
; 727  :         NULL
; 728  :       },
; 729  :       {
; 730  :         "placebo",
; 731  :         "rd", "2",
; 732  :         "pu-depth-intra", "1-4",
; 733  :         "pu-depth-inter", "0-3",
; 734  :         "me", "tz",
; 735  :         "gop", "16",
; 736  :         "ref", "4",
; 737  :         "bipred", "1",
; 738  :         "deblock", "0:0",
; 739  :         "signhide", "1",
; 740  :         "subme", "4",
; 741  :         "sao", "full",
; 742  :         "rdoq", "1",
; 743  :         "rdoq-skip", "0",
; 744  :         "transform-skip", "1",
; 745  :         "mv-rdo", "1",
; 746  :         "full-intra-search", "0",
; 747  :         "smp", "1",
; 748  :         "amp", "1",
; 749  :         "cu-split-termination", "off",
; 750  :         "me-early-termination", "off",
; 751  :         "intra-rdo-et", "0",
; 752  :         "early-skip", "0",
; 753  :         "fast-residual-cost", "0",
; 754  :         "max-merge", "5",
; 755  :         NULL
; 756  :       },
; 757  :       { NULL }
; 758  :   };
; 759  : 
; 760  :   if (!name)

	test	rdx, rdx
	je	$LN287@kvz_config

; 761  :     return 0;
; 762  : 
; 763  :   if (!value)
; 764  :     value = "true";
; 765  : 
; 766  :   // Treat "--no-param" as --param 0
; 767  :   if ((!strncmp(name, "no-", 3))) {

	test	r8, r8
	lea	rdi, OFFSET FLAT:$SG4294957145
	lea	rdx, OFFSET FLAT:$SG4294957144
	mov	rcx, rbx
	cmovne	rdi, r8
	mov	r8d, 3
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	jne	SHORT $LN15@kvz_config

; 768  :     name += 3;
; 769  :     value = atobool(value) ? "false" : "true";

	mov	rcx, rdi
	add	rbx, 3
	call	atobool
	test	eax, eax
	lea	rcx, OFFSET FLAT:$SG4294957143
	lea	rdi, OFFSET FLAT:$SG4294957142
	cmovne	rdi, rcx
$LN15@kvz_config:

; 770  :   }
; 771  : 
; 772  : #define OPT(STR) (!strcmp(name, STR))
; 773  :   if OPT("width")

	lea	r8, OFFSET FLAT:$SG4294957141
	mov	rax, rbx
	sub	r8, rbx
	npad	5
$LL1247@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1248@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1247@kvz_config
$LN1248@kvz_config:
	test	edx, edx
	jne	SHORT $LN16@kvz_config

; 774  :     cfg->width = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+12], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN16@kvz_config:

; 775  :   else if OPT("height")

	lea	r8, OFFSET FLAT:$SG4294957140
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1245@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1246@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1245@kvz_config
$LN1246@kvz_config:
	test	edx, edx
	jne	SHORT $LN18@kvz_config

; 776  :     cfg->height = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+16], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN18@kvz_config:

; 777  :   else if OPT("input-res")

	lea	r8, OFFSET FLAT:$SG4294957139
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1243@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1244@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1243@kvz_config
$LN1244@kvz_config:
	test	edx, edx
	jne	SHORT $LN20@kvz_config

; 778  :     if (!strcmp(value, "auto")) {

	lea	r8, OFFSET FLAT:$SG4294957138
	mov	rax, rdi
	sub	r8, rdi
$LL1241@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1242@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1241@kvz_config
$LN1242@kvz_config:
	test	edx, edx
	je	$LN200@kvz_config

; 779  :       return 1;
; 780  :     } else {
; 781  :       return (sscanf(value, "%dx%d", &cfg->width, &cfg->height) == 2);

	lea	r9, QWORD PTR [rsi+16]
	lea	r8, QWORD PTR [rsi+12]
	lea	rdx, OFFSET FLAT:$SG4294957137
$LN1394@kvz_config:

; 1430 : }

	mov	rcx, rdi
	call	sscanf
	xor	r14d, r14d
	cmp	eax, 2
	sete	r14b
	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN20@kvz_config:

; 782  :     }
; 783  :   else if OPT("input-fps") {

	lea	r8, OFFSET FLAT:$SG4294957136
	mov	rax, rbx
	sub	r8, rbx
	npad	11
$LL1239@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1240@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1239@kvz_config
$LN1240@kvz_config:
	test	edx, edx
	jne	SHORT $LN24@kvz_config

; 784  :     int32_t fps_num, fps_denom;
; 785  :     if (sscanf(value, "%d/%d", &fps_num, &fps_denom) == 2) {

	lea	r9, QWORD PTR fps_denom$17[rbp-80]
	mov	rcx, rdi
	lea	r8, QWORD PTR fps_num$11[rbp-80]
	lea	rdx, OFFSET FLAT:$SG4294957135
	call	sscanf
	cmp	eax, 2
	jne	SHORT $LN26@kvz_config

; 786  :       cfg->framerate_num = fps_num;

	mov	eax, DWORD PTR fps_num$11[rbp-80]
	mov	DWORD PTR [rsi+32], eax

; 787  :       cfg->framerate_denom = fps_denom;

	mov	eax, DWORD PTR fps_denom$17[rbp-80]
	mov	DWORD PTR [rsi+36], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN26@kvz_config:

; 788  :     } else {
; 789  :       // Accept decimal notation, making sure not to round 0 to 1.
; 790  :       cfg->framerate_num = (int)(atof(value) * 1000 + 0.49);

	mov	rcx, rdi
	call	QWORD PTR __imp_atof
	mulsd	xmm0, QWORD PTR __real@408f400000000000

; 791  :       cfg->framerate_denom = 1000;

	mov	DWORD PTR [rsi+36], 1000		; 000003e8H
	addsd	xmm0, QWORD PTR __real@3fdf5c28f5c28f5c
	cvttsd2si eax, xmm0
	mov	DWORD PTR [rsi+32], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN24@kvz_config:

; 792  :     }
; 793  :   }
; 794  :   else if OPT("qp")

	lea	r8, OFFSET FLAT:$SG4294957134
	mov	rax, rbx
	sub	r8, rbx
	npad	9
$LL1237@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1238@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1237@kvz_config
$LN1238@kvz_config:
	test	edx, edx
	jne	SHORT $LN28@kvz_config

; 795  :     cfg->qp = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN28@kvz_config:

; 796  :   else if OPT("period")

	lea	r8, OFFSET FLAT:$SG4294957133
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1235@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1236@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1235@kvz_config
$LN1236@kvz_config:
	test	edx, edx
	jne	SHORT $LN30@kvz_config

; 797  :     cfg->intra_period = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+4], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN30@kvz_config:

; 798  :   else if OPT("vps-period")

	lea	r8, OFFSET FLAT:$SG4294957132
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1233@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1234@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1233@kvz_config
$LN1234@kvz_config:
	test	edx, edx
	jne	SHORT $LN32@kvz_config

; 799  :     cfg->vps_period = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+8], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN32@kvz_config:

; 800  :   else if OPT("ref")

	lea	r8, OFFSET FLAT:$SG4294957131
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1231@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1232@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1231@kvz_config
$LN1232@kvz_config:
	test	edx, edx
	jne	SHORT $LN34@kvz_config

; 801  :     cfg->ref_frames = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+128], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN34@kvz_config:

; 802  :   else if OPT("deblock") {

	lea	r8, OFFSET FLAT:$SG4294957130
	mov	rax, rbx
	sub	r8, rbx
	npad	3
$LL1229@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1230@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1229@kvz_config
$LN1230@kvz_config:
	test	edx, edx
	jne	SHORT $LN36@kvz_config

; 803  :     int beta, tc;
; 804  :     if (2 == sscanf(value, "%d:%d", &beta, &tc)) {

	lea	r9, QWORD PTR tc$16[rbp-80]
	mov	rcx, rdi
	lea	r8, QWORD PTR beta$10[rbp-80]
	lea	rdx, OFFSET FLAT:$SG4294957129
	call	sscanf
	cmp	eax, 2
	jne	SHORT $LN38@kvz_config

; 805  :       cfg->deblock_enable = 1;
; 806  :       cfg->deblock_beta   = beta;

	mov	eax, DWORD PTR beta$10[rbp-80]
	mov	DWORD PTR [rsi+96], eax

; 807  :       cfg->deblock_tc     = tc;

	mov	eax, DWORD PTR tc$16[rbp-80]
	mov	DWORD PTR [rsi+100], eax
	mov	eax, 1

; 810  :     }
; 811  :   }

	mov	DWORD PTR [rsi+40], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	jmp	$LN1@kvz_config
$LN38@kvz_config:

; 808  :     } else {
; 809  :       cfg->deblock_enable = atobool(value);

	mov	rcx, rdi
	call	atobool

; 810  :     }
; 811  :   }

	mov	DWORD PTR [rsi+40], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN36@kvz_config:

; 812  :   else if OPT("sao") {

	lea	r8, OFFSET FLAT:$SG4294957128
	mov	rax, rbx
	sub	r8, rbx
	npad	2
$LL1227@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1228@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1227@kvz_config
$LN1228@kvz_config:
	test	edx, edx
	jne	SHORT $LN40@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?sao_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	8
$LL297@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN906@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?sao_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL297@kvz_config

; 813  :     int8_t sao_type = 0;
; 814  :     if (!parse_enum(value, sao_names, &sao_type)) sao_type = atobool(value) ? 3 : 0;

	mov	rcx, rdi
	call	atobool
	neg	eax
	sbb	r14b, r14b
	and	r14b, 3
$LN906@kvz_config:

; 815  :     cfg->sao_type = sao_type;

	movsx	eax, r14b
	mov	DWORD PTR [rsi+44], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN40@kvz_config:

; 816  :   }
; 817  :   else if OPT("rdoq")

	lea	r8, OFFSET FLAT:$SG4294957127
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1225@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1226@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1225@kvz_config
$LN1226@kvz_config:
	test	edx, edx
	jne	SHORT $LN43@kvz_config

; 818  :     cfg->rdoq_enable = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+48], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN43@kvz_config:

; 819  :   else if OPT("signhide")

	lea	r8, OFFSET FLAT:$SG4294957126
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1223@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1224@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1223@kvz_config
$LN1224@kvz_config:
	test	edx, edx
	jne	SHORT $LN45@kvz_config

; 820  :     cfg->signhide_enable = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	xor	r14d, r14d
	test	eax, eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	setne	r14b
	mov	DWORD PTR [rsi+52], r14d
	jmp	$LN1@kvz_config
$LN45@kvz_config:

; 821  :   else if OPT("smp")

	lea	r8, OFFSET FLAT:$SG4294957125
	mov	rax, rbx
	sub	r8, rbx
$LL1221@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1222@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1221@kvz_config
$LN1222@kvz_config:
	test	edx, edx
	jne	SHORT $LN47@kvz_config

; 822  :     cfg->smp_enable = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	xor	r14d, r14d
	test	eax, eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	setne	r14b
	mov	DWORD PTR [rsi+56], r14d
	jmp	$LN1@kvz_config
$LN47@kvz_config:

; 823  :   else if OPT("amp")

	lea	r8, OFFSET FLAT:$SG4294957124
	mov	rax, rbx
	sub	r8, rbx
	npad	10
$LL1219@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1220@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1219@kvz_config
$LN1220@kvz_config:
	test	edx, edx
	jne	SHORT $LN49@kvz_config

; 824  :     cfg->amp_enable = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	xor	r14d, r14d
	test	eax, eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	setne	r14b
	mov	DWORD PTR [rsi+60], r14d
	jmp	$LN1@kvz_config
$LN49@kvz_config:

; 825  :   else if OPT("rd")

	lea	r8, OFFSET FLAT:$SG4294957123
	mov	rax, rbx
	sub	r8, rbx
$LL1217@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1218@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1217@kvz_config
$LN1218@kvz_config:
	test	edx, edx
	jne	SHORT $LN51@kvz_config

; 826  :     cfg->rdo = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+64], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN51@kvz_config:

; 827  :   else if OPT("full-intra-search")

	lea	r8, OFFSET FLAT:$SG4294957122
	mov	rax, rbx
	sub	r8, rbx
	npad	3
$LL1215@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1216@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1215@kvz_config
$LN1216@kvz_config:
	test	edx, edx
	jne	SHORT $LN53@kvz_config

; 828  :     cfg->full_intra_search = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+68], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN53@kvz_config:

; 829  :   else if OPT("transform-skip")

	lea	r8, OFFSET FLAT:$SG4294957121
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1213@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1214@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1213@kvz_config
$LN1214@kvz_config:
	test	edx, edx
	jne	SHORT $LN55@kvz_config

; 830  :     cfg->trskip_enable = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+72], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN55@kvz_config:

; 831  :   else if OPT("tr-depth-intra")

	lea	r8, OFFSET FLAT:$SG4294957120
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1211@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1212@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1211@kvz_config
$LN1212@kvz_config:
	test	edx, edx
	jne	SHORT $LN57@kvz_config

; 832  :     cfg->tr_depth_intra = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+76], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN57@kvz_config:

; 833  :   else if OPT("me") {

	lea	r8, OFFSET FLAT:$SG4294957119
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1209@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1210@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1209@kvz_config
$LN1210@kvz_config:
	test	edx, edx
	jne	SHORT $LN59@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?me_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	8
$LL305@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN61@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?me_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL305@kvz_config

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	jmp	$LN287@kvz_config
$LN61@kvz_config:

; 834  :     int8_t ime_algorithm = 0;
; 835  :     if (!parse_enum(value, me_names, &ime_algorithm)) return 0;
; 836  :     cfg->ime_algorithm = ime_algorithm;

	movsx	eax, r14b
	mov	DWORD PTR [rsi+80], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN59@kvz_config:

; 837  :   }
; 838  :   else if OPT("subme")

	lea	r8, OFFSET FLAT:$SG4294957118
	mov	rax, rbx
	sub	r8, rbx
	npad	3
$LL1207@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1208@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1207@kvz_config
$LN1208@kvz_config:
	test	edx, edx
	jne	SHORT $LN62@kvz_config

; 839  :     cfg->fme_level = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+84], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN62@kvz_config:

; 840  :   else if OPT("source-scan-type")

	lea	r8, OFFSET FLAT:$SG4294957117
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1205@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1206@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1205@kvz_config
$LN1206@kvz_config:
	test	edx, edx
	jne	SHORT $LN64@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?source_scan_type_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	8
$LL313@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN908@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?source_scan_type_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL313@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 841  :     return parse_enum(value, source_scan_type_names, &cfg->source_scan_type);

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN908@kvz_config:

; 224  :       *dst = i;

	mov	BYTE PTR [rsi+88], r14b

; 225  :       return 1;

	mov	r14d, 1

; 841  :     return parse_enum(value, source_scan_type_names, &cfg->source_scan_type);

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN64@kvz_config:

; 842  :   else if OPT("mv-constraint")

	lea	r8, OFFSET FLAT:$SG4294957116
	mov	rax, rbx
	sub	r8, rbx
$LL1203@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1204@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1203@kvz_config
$LN1204@kvz_config:
	test	edx, edx
	jne	SHORT $LN66@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?mv_constraint_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase

; 843  :   {
; 844  :     int8_t constraint = KVZ_MV_CONSTRAIN_NONE;

	xor	r15b, r15b

; 222  :   for (i = 0; names[i]; i++) {

	xor	r14b, r14b
	npad	1
$LL321@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN909@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?mv_constraint_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL321@kvz_config

; 845  :     int result = parse_enum(value, mv_constraint_names, &constraint);
; 846  :     cfg->mv_constraint = constraint;

	movsx	eax, r15b

; 229  :   return 0;

	xor	r14d, r14d

; 845  :     int result = parse_enum(value, mv_constraint_names, &constraint);
; 846  :     cfg->mv_constraint = constraint;

	mov	DWORD PTR [rsi+2360], eax

; 847  :     return result;

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN909@kvz_config:

; 224  :       *dst = i;

	movzx	r15d, r14b

; 225  :       return 1;

	mov	r14d, 1

; 845  :     int result = parse_enum(value, mv_constraint_names, &constraint);
; 846  :     cfg->mv_constraint = constraint;

	movsx	eax, r15b
	mov	DWORD PTR [rsi+2360], eax

; 847  :     return result;

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN66@kvz_config:

; 848  :   }
; 849  :   else if OPT("sar")

	lea	r8, OFFSET FLAT:$SG4294957115
	mov	rax, rbx
	sub	r8, rbx
	npad	8
$LL1201@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1202@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1201@kvz_config
$LN1202@kvz_config:
	test	edx, edx
	jne	SHORT $LN68@kvz_config

; 850  :     return sscanf(value, "%d:%d", &cfg->vui.sar_width, &cfg->vui.sar_height) == 2;

	lea	r9, QWORD PTR [rsi+108]
	lea	r8, QWORD PTR [rsi+104]
	lea	rdx, OFFSET FLAT:$SG4294957114
	jmp	$LN1394@kvz_config
$LN68@kvz_config:

; 851  :   else if OPT("overscan")

	lea	r8, OFFSET FLAT:$SG4294957113
	mov	rax, rbx
	sub	r8, rbx
	npad	8
$LL1199@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1200@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1199@kvz_config
$LN1200@kvz_config:
	test	edx, edx
	jne	SHORT $LN70@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?overscan_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	8
$LL329@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN910@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?overscan_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL329@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN910@kvz_config:

; 224  :       *dst = i;

	mov	BYTE PTR [rsi+112], r14b

; 225  :       return 1;

	mov	r14d, 1

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN70@kvz_config:

; 852  :     return parse_enum(value, overscan_names, &cfg->vui.overscan);
; 853  :   else if OPT("videoformat")

	lea	r8, OFFSET FLAT:$SG4294957112
	mov	rax, rbx
	sub	r8, rbx
$LL1197@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1198@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1197@kvz_config
$LN1198@kvz_config:
	test	edx, edx
	jne	SHORT $LN72@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?videoformat_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	4
$LL337@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN911@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?videoformat_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL337@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN911@kvz_config:

; 224  :       *dst = i;

	mov	BYTE PTR [rsi+113], r14b

; 225  :       return 1;

	mov	r14d, 1

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN72@kvz_config:

; 854  :     return parse_enum(value, videoformat_names, &cfg->vui.videoformat);
; 855  :   else if OPT("range")

	lea	r8, OFFSET FLAT:$SG4294957111
	mov	rax, rbx
	sub	r8, rbx
$LL1195@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1196@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1195@kvz_config
$LN1196@kvz_config:
	test	edx, edx
	jne	SHORT $LN74@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?range_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	4
$LL345@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN912@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?range_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL345@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN912@kvz_config:

; 224  :       *dst = i;

	mov	BYTE PTR [rsi+114], r14b

; 225  :       return 1;

	mov	r14d, 1

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN74@kvz_config:

; 856  :     return parse_enum(value, range_names, &cfg->vui.fullrange);
; 857  :   else if OPT("colorprim")

	lea	r8, OFFSET FLAT:$SG4294957110
	mov	rax, rbx
	sub	r8, rbx
$LL1193@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1194@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1193@kvz_config
$LN1194@kvz_config:
	test	edx, edx
	jne	SHORT $LN76@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?colorprim_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	4
$LL353@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN913@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?colorprim_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL353@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN913@kvz_config:

; 224  :       *dst = i;

	mov	BYTE PTR [rsi+115], r14b

; 225  :       return 1;

	mov	r14d, 1

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN76@kvz_config:

; 858  :     return parse_enum(value, colorprim_names, &cfg->vui.colorprim);
; 859  :   else if OPT("transfer")

	lea	r8, OFFSET FLAT:$SG4294957109
	mov	rax, rbx
	sub	r8, rbx
$LL1191@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1192@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1191@kvz_config
$LN1192@kvz_config:
	test	edx, edx
	jne	SHORT $LN78@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?transfer_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	4
$LL361@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN914@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?transfer_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL361@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN914@kvz_config:

; 224  :       *dst = i;

	mov	BYTE PTR [rsi+116], r14b

; 225  :       return 1;

	mov	r14d, 1

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN78@kvz_config:

; 860  :     return parse_enum(value, transfer_names, &cfg->vui.transfer);
; 861  :   else if OPT("colormatrix")

	lea	r8, OFFSET FLAT:$SG4294957108
	mov	rax, rbx
	sub	r8, rbx
$LL1189@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1190@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1189@kvz_config
$LN1190@kvz_config:
	test	edx, edx
	jne	SHORT $LN80@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?colormatrix_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	4
$LL369@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN915@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?colormatrix_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL369@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN915@kvz_config:

; 224  :       *dst = i;

	mov	BYTE PTR [rsi+117], r14b

; 225  :       return 1;

	mov	r14d, 1

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN80@kvz_config:

; 862  :     return parse_enum(value, colormatrix_names, &cfg->vui.colormatrix);
; 863  :   else if OPT("chromaloc")

	lea	r8, OFFSET FLAT:$SG4294957107
	mov	rax, rbx
	sub	r8, rbx
$LL1187@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1188@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1187@kvz_config
$LN1188@kvz_config:
	test	edx, edx
	jne	SHORT $LN82@kvz_config

; 864  :     cfg->vui.chroma_loc = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+120], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN82@kvz_config:

; 865  :   else if OPT("aud")

	lea	r8, OFFSET FLAT:$SG4294957106
	mov	rax, rbx
	sub	r8, rbx
	npad	2
$LL1185@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1186@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1185@kvz_config
$LN1186@kvz_config:
	test	edx, edx
	jne	SHORT $LN84@kvz_config

; 866  :     cfg->aud_enable = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+124], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN84@kvz_config:

; 867  :   else if OPT("cqmfile") {

	lea	r8, OFFSET FLAT:$SG4294957105
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1183@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1184@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1183@kvz_config
$LN1184@kvz_config:
	test	edx, edx
	jne	SHORT $LN86@kvz_config

; 868  :     char* cqmfile = strdup(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_strdup
	mov	rbx, rax

; 869  :     if (!cqmfile) {

	test	rax, rax
	jne	SHORT $LN88@kvz_config

; 870  :       fprintf(stderr, "Failed to allocate memory for CQM file name.\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957104
	call	fprintf

; 871  :       return 0;

	jmp	$LN287@kvz_config
$LN88@kvz_config:

; 872  :     }
; 873  :     FREE_POINTER(cfg->cqmfile);

	mov	rcx, QWORD PTR [rsi+136]
	call	QWORD PTR __imp_free

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	mov	QWORD PTR [rsi+136], rbx
	mov	BYTE PTR [rsi+2472], 1
	jmp	$LN1@kvz_config
$LN86@kvz_config:

; 874  :     cfg->cqmfile = cqmfile;
; 875  :     cfg->scaling_list = KVZ_SCALING_LIST_CUSTOM;
; 876  :   }
; 877  :   else if OPT("fast-coeff-table") {

	lea	r8, OFFSET FLAT:$SG4294957103
	mov	rax, rbx
	sub	r8, rbx
	npad	9
$LL1181@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1182@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1181@kvz_config
$LN1182@kvz_config:
	test	edx, edx
	jne	SHORT $LN89@kvz_config

; 878  :     char* fast_coeff_table_fn = strdup(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_strdup
	mov	rbx, rax

; 879  :     if (!fast_coeff_table_fn) {

	test	rax, rax
	jne	SHORT $LN91@kvz_config

; 880  :       fprintf(stderr, "Failed to allocate memory for fast coeff table file name.\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957102
	call	fprintf

; 881  :       return 0;

	jmp	$LN287@kvz_config
$LN91@kvz_config:

; 882  :     }
; 883  :     FREE_POINTER(cfg->fast_coeff_table_fn);

	mov	rcx, QWORD PTR [rsi+2504]
	call	QWORD PTR __imp_free

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	mov	QWORD PTR [rsi+2504], rbx
	jmp	$LN1@kvz_config
$LN89@kvz_config:

; 884  :     cfg->fast_coeff_table_fn = fast_coeff_table_fn;
; 885  :   }
; 886  :   else if OPT("fastrd-sampling") {

	lea	r8, OFFSET FLAT:$SG4294957101
	mov	rax, rbx
	sub	r8, rbx
$LL1179@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1180@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1179@kvz_config
$LN1180@kvz_config:
	test	edx, edx
	jne	SHORT $LN92@kvz_config

; 887  :     cfg->fastrd_sampling_on = 1;

	mov	BYTE PTR [rsi+2513], 1

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [rdx+1]
	jmp	$LN1@kvz_config
$LN92@kvz_config:

; 888  :   }
; 889  :   else if OPT("fastrd-accuracy-check") {

	lea	r8, OFFSET FLAT:$SG4294957100
	mov	rax, rbx
	sub	r8, rbx
$LL1177@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1178@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1177@kvz_config
$LN1178@kvz_config:
	test	edx, edx
	jne	SHORT $LN94@kvz_config

; 890  :     cfg->fastrd_accuracy_check_on = 1;

	mov	BYTE PTR [rsi+2514], 1

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [rdx+1]
	jmp	$LN1@kvz_config
$LN94@kvz_config:

; 891  :   }
; 892  :   else if OPT("fastrd-outdir") {

	lea	r8, OFFSET FLAT:$SG4294957099
	mov	rax, rbx
	sub	r8, rbx
	npad	10
$LL1175@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1176@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1175@kvz_config
$LN1176@kvz_config:
	test	edx, edx
	jne	SHORT $LN96@kvz_config

; 893  :     char *fastrd_learning_outdir_fn = strdup(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_strdup
	mov	rbx, rax

; 894  :     if (!fastrd_learning_outdir_fn) {

	test	rax, rax
	jne	SHORT $LN98@kvz_config

; 895  :       fprintf(stderr, "Failed to allocate memory for fast RD learning outfile name.\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957098
	call	fprintf

; 896  :       return 0;

	jmp	$LN287@kvz_config
$LN98@kvz_config:

; 897  :     }
; 898  :     FREE_POINTER(cfg->fastrd_learning_outdir_fn);

	mov	rcx, QWORD PTR [rsi+2520]
	call	QWORD PTR __imp_free

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	mov	QWORD PTR [rsi+2520], rbx
	jmp	$LN1@kvz_config
$LN96@kvz_config:

; 899  :     cfg->fastrd_learning_outdir_fn = fastrd_learning_outdir_fn;
; 900  :   }
; 901  :   else if OPT("scaling-list") {    

	lea	r8, OFFSET FLAT:$SG4294957097
	mov	rax, rbx
	sub	r8, rbx
$LL1173@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1174@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1173@kvz_config
$LN1174@kvz_config:
	test	edx, edx
	jne	SHORT $LN99@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?scaling_list_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase

; 902  :     int8_t scaling_list = KVZ_SCALING_LIST_OFF;

	xor	r15b, r15b

; 222  :   for (i = 0; names[i]; i++) {

	xor	r14b, r14b
	npad	5
$LL377@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN916@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?scaling_list_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL377@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 903  :     int result = parse_enum(value, scaling_list_names, &scaling_list);
; 904  :     cfg->scaling_list = scaling_list;

	mov	BYTE PTR [rsi+2472], r15b

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN916@kvz_config:

; 224  :       *dst = i;

	movzx	r15d, r14b

; 225  :       return 1;

	mov	r14d, 1

; 1430 : }

	mov	eax, r14d
	mov	BYTE PTR [rsi+2472], r15b
	jmp	$LN1@kvz_config
$LN99@kvz_config:

; 905  :     return result;
; 906  :   }
; 907  :   else if OPT("tiles-width-split") {

	lea	r8, OFFSET FLAT:$SG4294957096
	mov	rax, rbx
	sub	r8, rbx
$LL1171@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1172@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1171@kvz_config
$LN1172@kvz_config:
	test	edx, edx
	jne	SHORT $LN101@kvz_config

; 908  :     int retval = parse_tiles_specification(value, &cfg->tiles_width_count, &cfg->tiles_width_split);

	lea	r8, QWORD PTR [rsi+152]
	mov	rcx, rdi
	lea	rdx, QWORD PTR [rsi+144]
	call	parse_tiles_specification

; 909  : 
; 910  :     if (cfg->tiles_width_count > 1 && cfg->tmvp_enable) {

	xor	r14d, r14d
	mov	edi, eax
	cmp	DWORD PTR [rsi+144], 1
	jle	SHORT $LN103@kvz_config
	cmp	DWORD PTR [rsi+2396], r14d
	je	SHORT $LN103@kvz_config

; 911  :       cfg->tmvp_enable = false;
; 912  :       fprintf(stderr, "Disabling TMVP because tiles are used.\n");

	lea	ecx, QWORD PTR [r14+2]
	mov	DWORD PTR [rsi+2396], r14d
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957095
	call	fprintf
$LN103@kvz_config:

; 913  :     }
; 914  : 
; 915  :     if (cfg->wpp) {

	cmp	DWORD PTR [rsi+168], r14d
	je	SHORT $LN104@kvz_config

; 916  :       cfg->wpp = false;
; 917  :       fprintf(stderr, "Disabling WPP because tiles were enabled.\n");

	mov	ecx, 2
	mov	DWORD PTR [rsi+168], r14d
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957094
	call	fprintf
$LN104@kvz_config:

; 918  :     }
; 919  : 
; 920  :     return retval;

	mov	eax, edi
	jmp	$LN1@kvz_config
$LN101@kvz_config:

; 921  :   }
; 922  :   else if OPT("tiles-height-split") {

	lea	r8, OFFSET FLAT:$SG4294957093
	mov	rax, rbx
	sub	r8, rbx
$LL1169@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1170@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1169@kvz_config
$LN1170@kvz_config:
	test	edx, edx
	jne	$LN105@kvz_config

; 923  :     int retval = parse_tiles_specification(value, &cfg->tiles_height_count, &cfg->tiles_height_split);

	lea	r8, QWORD PTR [rsi+160]
	mov	rcx, rdi
	lea	rdx, QWORD PTR [rsi+148]
	call	parse_tiles_specification

; 924  : 
; 925  :     if (cfg->tiles_height_count > 1 && cfg->tmvp_enable) {

	xor	r14d, r14d
	mov	edi, eax
	cmp	DWORD PTR [rsi+148], 1
	jle	SHORT $LN107@kvz_config
	cmp	DWORD PTR [rsi+2396], r14d
	je	SHORT $LN107@kvz_config

; 926  :       cfg->tmvp_enable = false;
; 927  :       fprintf(stderr, "Disabling TMVP because tiles are used.\n");

	lea	ecx, QWORD PTR [r14+2]
	mov	DWORD PTR [rsi+2396], r14d
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957092
	call	fprintf
$LN107@kvz_config:

; 928  :     }
; 929  : 
; 930  :     if (cfg->wpp) {

	cmp	DWORD PTR [rsi+168], r14d
	je	$LN104@kvz_config

; 931  :       cfg->wpp = false;
; 932  :       fprintf(stderr, "Disabling WPP because tiles were enabled.\n");

	mov	ecx, 2
	mov	DWORD PTR [rsi+168], r14d
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957091
	call	fprintf

; 933  :     }
; 934  : 
; 935  :     return retval;

	mov	eax, edi
	jmp	$LN1@kvz_config
$LN105@kvz_config:

; 936  :   }
; 937  :   else if OPT("tiles")

	lea	r8, OFFSET FLAT:$SG4294957090
	mov	rax, rbx
	sub	r8, rbx
	npad	2
$LL1167@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1168@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1167@kvz_config
$LN1168@kvz_config:
	test	edx, edx
	jne	$LN109@kvz_config

; 938  :   {
; 939  :     // A simpler interface for setting tiles, accepting only uniform split.
; 940  :     unsigned width;
; 941  :     unsigned height;
; 942  :     if (2 != sscanf(value, "%ux%u", &width, &height)) {

	lea	r9, QWORD PTR height$9[rbp-80]
	mov	rcx, rdi
	lea	r8, QWORD PTR width$15[rbp-80]
	lea	rdx, OFFSET FLAT:$SG4294957089
	call	sscanf
	cmp	eax, 2
	je	SHORT $LN111@kvz_config

; 943  :       fprintf(stderr, "Wrong format for tiles. Expected \"%%ux%%u\", but got \"%s\"\n", value);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294957088

; 944  :       return 0;

	jmp	$LN1395@kvz_config
$LN111@kvz_config:

; 945  :     }
; 946  : 
; 947  :     if (MAX_TILES_PER_DIM <= width || 1 > width) {

	mov	eax, DWORD PTR width$15[rbp-80]
	dec	eax
	cmp	eax, 46					; 0000002eH
	ja	$LN113@kvz_config

; 950  :     }
; 951  :     if (MAX_TILES_PER_DIM <= height || 1 > height) {

	mov	eax, DWORD PTR height$9[rbp-80]
	dec	eax
	cmp	eax, 46					; 0000002eH
	ja	$LN115@kvz_config

; 954  :     }
; 955  : 
; 956  :     // Free split arrays incase they have already been set by another parameter.
; 957  :     FREE_POINTER(cfg->tiles_width_split);

	mov	rcx, QWORD PTR [rsi+152]
	call	QWORD PTR __imp_free

; 958  :     FREE_POINTER(cfg->tiles_height_split);

	mov	rcx, QWORD PTR [rsi+160]
	xor	r14d, r14d
	mov	QWORD PTR [rsi+152], r14
	call	QWORD PTR __imp_free

; 959  :     cfg->tiles_width_count = width;

	mov	eax, DWORD PTR width$15[rbp-80]
	mov	DWORD PTR [rsi+144], eax

; 960  :     cfg->tiles_height_count = height;

	mov	eax, DWORD PTR height$9[rbp-80]
	mov	DWORD PTR [rsi+148], eax
	mov	QWORD PTR [rsi+160], r14

; 961  : 
; 962  :     if (cfg->tmvp_enable) {

	cmp	DWORD PTR [rsi+2396], r14d
	je	SHORT $LN116@kvz_config

; 963  :       cfg->tmvp_enable = false;
; 964  :       fprintf(stderr, "Disabling TMVP because tiles are used.\n");

	lea	ecx, QWORD PTR [r14+2]
	mov	DWORD PTR [rsi+2396], r14d
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957085
	call	fprintf
$LN116@kvz_config:

; 965  :     }
; 966  : 
; 967  :     if (cfg->wpp) {

	cmp	DWORD PTR [rsi+168], r14d
	je	$LN200@kvz_config

; 968  :       cfg->wpp = false;
; 969  :       fprintf(stderr, "Disabling WPP because tiles were enabled.\n");

	mov	ecx, 2
	mov	DWORD PTR [rsi+168], r14d
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957084
	call	fprintf

; 1430 : }

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN115@kvz_config:

; 952  :       fprintf(stderr, "Invalid number of tiles (0 < %d <= %d = MAX_TILES_PER_DIM)!\n", height, MAX_TILES_PER_DIM);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, DWORD PTR height$9[rbp-80]
	lea	rdx, OFFSET FLAT:$SG4294957086
	mov	rcx, rax
	mov	r9d, 48					; 00000030H
	call	fprintf

; 953  :       return 0;

	jmp	$LN287@kvz_config
$LN113@kvz_config:

; 948  :       fprintf(stderr, "Invalid number of tiles (0 < %d <= %d = MAX_TILES_PER_DIM)!\n", width, MAX_TILES_PER_DIM);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, DWORD PTR width$15[rbp-80]
	lea	rdx, OFFSET FLAT:$SG4294957087
	mov	rcx, rax
	mov	r9d, 48					; 00000030H
	call	fprintf

; 949  :       return 0;

	jmp	$LN287@kvz_config
$LN109@kvz_config:

; 970  :     }
; 971  : 
; 972  :     return 1;
; 973  :   }
; 974  :   else if OPT("wpp")

	lea	r8, OFFSET FLAT:$SG4294957083
	mov	rax, rbx
	sub	r8, rbx
	npad	9
$LL1165@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1166@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1165@kvz_config
$LN1166@kvz_config:
	test	edx, edx
	jne	SHORT $LN118@kvz_config

; 975  :     cfg->wpp = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+168], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN118@kvz_config:

; 976  :   else if OPT("owf") {

	lea	r8, OFFSET FLAT:$SG4294957082
	mov	rax, rbx
	sub	r8, rbx
	npad	4
$LL1163@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1164@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1163@kvz_config
$LN1164@kvz_config:
	test	edx, edx
	jne	SHORT $LN120@kvz_config

; 977  :     cfg->owf = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+172], eax

; 978  :     if (cfg->owf == 0 && !strcmp(value, "auto")) {

	test	eax, eax
	jne	$LN288@kvz_config
	lea	rdx, OFFSET FLAT:$SG4294957081
	sub	rdx, rdi
	npad	8
$LL1161@kvz_config:
	movzx	ecx, BYTE PTR [rdi]
	movzx	eax, BYTE PTR [rdi+rdx]
	sub	ecx, eax
	jne	SHORT $LN1162@kvz_config
	inc	rdi
	test	eax, eax
	jne	SHORT $LL1161@kvz_config
$LN1162@kvz_config:
	test	ecx, ecx
	jne	$LN288@kvz_config

; 979  :       // -1 means automatic selection
; 980  :       cfg->owf = -1;

	mov	DWORD PTR [rsi+172], -1

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [rcx+1]
	jmp	$LN1@kvz_config
$LN120@kvz_config:

; 981  :     }
; 982  :   } else if OPT("slices") {

	lea	r8, OFFSET FLAT:$SG4294957080
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1159@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1160@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1159@kvz_config
$LN1160@kvz_config:
	test	edx, edx
	jne	$LN123@kvz_config

; 983  :     if (!strcmp(value, "tiles")) {

	lea	r8, OFFSET FLAT:$SG4294957079
	mov	rax, rdi
	sub	r8, rdi
	npad	8
$LL1157@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1158@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1157@kvz_config
$LN1158@kvz_config:
	test	edx, edx
	jne	SHORT $LN125@kvz_config

; 984  :       cfg->slices = KVZ_SLICES_TILES;

	mov	DWORD PTR [rsi+2440], 1
$LN200@kvz_config:

; 1430 : }

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN125@kvz_config:

; 985  :       return 1;
; 986  :     } else if (!strcmp(value, "wpp")) {

	lea	r8, OFFSET FLAT:$SG4294957078
	mov	rax, rdi
	sub	r8, rdi
	npad	8
$LL1155@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1156@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1155@kvz_config
$LN1156@kvz_config:
	test	edx, edx
	jne	SHORT $LN127@kvz_config

; 987  :       cfg->slices = KVZ_SLICES_WPP;

	mov	DWORD PTR [rsi+2440], 2

; 988  :       return 1;

	lea	eax, QWORD PTR [rdx+1]
	jmp	$LN1@kvz_config
$LN127@kvz_config:

; 989  :     } else if (!strcmp(value, "tiles+wpp")) {

	lea	r8, OFFSET FLAT:$SG4294957077
	mov	rax, rdi
	sub	r8, rdi
	npad	10
$LL1153@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1154@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1153@kvz_config
$LN1154@kvz_config:
	test	edx, edx
	jne	SHORT $LN129@kvz_config

; 990  :       cfg->slices = KVZ_SLICES_TILES | KVZ_SLICES_WPP;

	mov	DWORD PTR [rsi+2440], 3

; 991  :       return 1;

	lea	eax, QWORD PTR [rdx+1]
	jmp	$LN1@kvz_config
$LN129@kvz_config:

; 992  :     } else {
; 993  :       return parse_slice_specification(value, &cfg->slice_count, &cfg->slice_addresses_in_ts);

	lea	r8, QWORD PTR [rsi+184]
	mov	rcx, rdi
	lea	rdx, QWORD PTR [rsi+176]
	call	parse_slice_specification
	jmp	$LN1@kvz_config
$LN123@kvz_config:

; 994  :     }
; 995  : 
; 996  :   } else if OPT("threads") {

	lea	r8, OFFSET FLAT:$SG4294957076
	mov	rax, rbx
	sub	r8, rbx
$LL1151@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1152@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1151@kvz_config
$LN1152@kvz_config:
	test	edx, edx
	jne	SHORT $LN131@kvz_config

; 997  :     cfg->threads = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+192], eax

; 998  :     if (cfg->threads == 0 && !strcmp(value, "auto")) {

	test	eax, eax
	jne	$LN288@kvz_config
	lea	rdx, OFFSET FLAT:$SG4294957075
	sub	rdx, rdi
	npad	7
$LL1149@kvz_config:
	movzx	ecx, BYTE PTR [rdi]
	movzx	eax, BYTE PTR [rdi+rdx]
	sub	ecx, eax
	jne	SHORT $LN1150@kvz_config
	inc	rdi
	test	eax, eax
	jne	SHORT $LL1149@kvz_config
$LN1150@kvz_config:
	test	ecx, ecx
	jne	$LN288@kvz_config

; 999  :       // -1 means automatic selection
; 1000 :       cfg->threads = -1;

	mov	DWORD PTR [rsi+192], -1

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [rcx+1]
	jmp	$LN1@kvz_config
$LN131@kvz_config:

; 1001 :     }
; 1002 :   }
; 1003 :   else if OPT("cpuid")

	lea	r8, OFFSET FLAT:$SG4294957074
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1147@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1148@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1147@kvz_config
$LN1148@kvz_config:
	test	edx, edx
	jne	SHORT $LN134@kvz_config

; 1004 :     cfg->cpuid = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+196], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN134@kvz_config:

; 1005 :   else if OPT("pu-depth-inter")

	lea	r8, OFFSET FLAT:$SG4294957073
	mov	rax, rbx
	sub	r8, rbx
	npad	4
$LL1145@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1146@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1145@kvz_config
$LN1146@kvz_config:
	test	edx, edx
	jne	SHORT $LN136@kvz_config

; 1006 :     return parse_pu_depth_list(value, cfg->pu_depth_inter.min, cfg->pu_depth_inter.max, KVZ_MAX_GOP_LAYERS);

	lea	r8, QWORD PTR [rsi+224]
	mov	rcx, rdi
	lea	rdx, QWORD PTR [rsi+200]
	call	parse_pu_depth_list
	jmp	$LN1@kvz_config
$LN136@kvz_config:

; 1007 :   else if OPT("pu-depth-intra")

	lea	r8, OFFSET FLAT:$SG4294957072
	mov	rax, rbx
	sub	r8, rbx
	npad	1
$LL1143@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1144@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1143@kvz_config
$LN1144@kvz_config:
	test	edx, edx
	jne	SHORT $LN138@kvz_config

; 1008 :     return parse_pu_depth_list(value, cfg->pu_depth_intra.min, cfg->pu_depth_intra.max, KVZ_MAX_GOP_LAYERS);

	lea	r8, QWORD PTR [rsi+272]
	mov	rcx, rdi
	lea	rdx, QWORD PTR [rsi+248]
	call	parse_pu_depth_list
	jmp	$LN1@kvz_config
$LN138@kvz_config:

; 1009 :   else if OPT("info")

	lea	r8, OFFSET FLAT:$SG4294957071
	mov	rax, rbx
	sub	r8, rbx
	npad	1
$LL1141@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1142@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1141@kvz_config
$LN1142@kvz_config:
	test	edx, edx
	jne	SHORT $LN140@kvz_config

; 1010 :     cfg->add_encoder_info = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+296], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN140@kvz_config:

; 1011 :   else if OPT("gop") {

	lea	r9, OFFSET FLAT:$SG4294957070
	mov	rax, rbx
	sub	r9, rbx
	npad	4
$LL1139@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN1140@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1139@kvz_config
$LN1140@kvz_config:
	test	edx, edx
	jne	$LN142@kvz_config

; 1012 :     if (!strncmp(value, "lp-", 3)) {  // Handle GOPs starting with "lp-".

	lea	r8d, QWORD PTR [rdx+3]
	mov	rcx, rdi
	lea	rdx, OFFSET FLAT:$SG4294957069
	call	QWORD PTR __imp_strncmp
	mov	rcx, rdi
	test	eax, eax
	jne	$LN144@kvz_config

; 1013 :       struct {
; 1014 :         unsigned g;  // length
; 1015 :         unsigned d;  // depth
; 1016 :         unsigned t;  // temporal
; 1017 :       } gop = { 0, 0, 0 };

	xor	r14d, r14d

; 1018 : 
; 1019 :       // Parse --gop=lp-g#d#t#
; 1020 :       if (sscanf(value, "lp-g%ud%ut%u", &gop.g, &gop.d, &gop.t) != 3) {

	lea	rax, QWORD PTR gop$4[rbp-72]
	lea	r9, QWORD PTR gop$4[rbp-76]
	mov	QWORD PTR gop$4[rbp-80], r14
	lea	r8, QWORD PTR gop$4[rbp-80]
	mov	DWORD PTR gop$4[rbp-72], r14d
	lea	rdx, OFFSET FLAT:$SG4294957068
	mov	QWORD PTR [rsp+32], rax
	call	sscanf
	cmp	eax, 3
	je	SHORT $LN146@kvz_config

; 1021 :         fprintf(stderr, "Error in GOP syntax. Example: lp-g8d4t2\n");

	lea	ecx, QWORD PTR [r14+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957067
	call	fprintf

; 1022 :         return 0;

	jmp	$LN287@kvz_config
$LN146@kvz_config:

; 1023 :       }
; 1024 : 
; 1025 :       if (gop.g < 1 || gop.g > 32) {

	mov	eax, DWORD PTR gop$4[rbp-80]
	dec	eax
	cmp	eax, 31
	ja	$LN148@kvz_config

; 1028 :       }
; 1029 :       if (gop.d < 1 || gop.d > 8) {

	mov	ecx, DWORD PTR gop$4[rbp-76]
	lea	eax, DWORD PTR [rcx-1]
	cmp	eax, 7
	ja	SHORT $LN150@kvz_config

; 1032 :       }
; 1033 :       if (gop.t < 1 || gop.t > 15) {

	mov	edx, DWORD PTR gop$4[rbp-72]
	lea	eax, DWORD PTR [rdx-1]
	cmp	eax, 14
	ja	SHORT $LN152@kvz_config

; 1036 :       }
; 1037 : 
; 1038 :       cfg->gop_lowdelay = true;
; 1039 :       cfg->gop_len = gop.g;

	movzx	eax, BYTE PTR gop$4[rbp-80]
	mov	BYTE PTR [rsi+300], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	mov	BYTE PTR [rsi+301], 1
	mov	DWORD PTR [rsi+2412], ecx
	mov	DWORD PTR [rsi+2416], edx
	mov	WORD PTR [rsi+2485], 1
	jmp	$LN1@kvz_config
$LN152@kvz_config:

; 1034 :         fprintf(stderr, "gop.t must be between 1 and 15.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957064
	call	fprintf

; 1035 :         return 0;

	jmp	$LN287@kvz_config
$LN150@kvz_config:

; 1030 :         fprintf(stderr, "gop.d must be between 1 and 8.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957065
	call	fprintf

; 1031 :         return 0;

	jmp	$LN287@kvz_config
$LN148@kvz_config:

; 1026 :         fprintf(stderr, "gop.g must be between 1 and 32.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957066
	call	fprintf

; 1027 :         return 0;

	jmp	$LN287@kvz_config
$LN144@kvz_config:

; 1040 :       cfg->gop_lp_definition.d = gop.d;
; 1041 :       cfg->gop_lp_definition.t = gop.t;
; 1042 : 
; 1043 :       cfg->intra_bit_allocation = true;
; 1044 :       cfg->clip_neighbour = false;
; 1045 :     } else if (atoi(value) == 8) {

	call	QWORD PTR __imp_atoi
	cmp	eax, 8
	jne	$LN153@kvz_config

; 1046 :       cfg->gop_lowdelay = 0;
; 1047 :       cfg->gop_len = sizeof(kvz_gop_ra8) / sizeof(kvz_gop_ra8[0]);

	mov	WORD PTR [rsi+300], ax

; 1048 :       memcpy(cfg->gop, kvz_gop_ra8, sizeof(kvz_gop_ra8));

	lea	rcx, OFFSET FLAT:kvz_gop_ra8
	lea	rax, QWORD PTR [rsi+304]
	mov	edx, 4
	npad	1
$LL1138@kvz_config:
	lea	rax, QWORD PTR [rax+128]
	movups	xmm0, XMMWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+128]
	movups	XMMWORD PTR [rax-128], xmm0
	movups	xmm1, XMMWORD PTR [rcx-112]
	movups	XMMWORD PTR [rax-112], xmm1
	movups	xmm0, XMMWORD PTR [rcx-96]
	movups	XMMWORD PTR [rax-96], xmm0
	movups	xmm1, XMMWORD PTR [rcx-80]
	movups	XMMWORD PTR [rax-80], xmm1
	movups	xmm0, XMMWORD PTR [rcx-64]
	movups	XMMWORD PTR [rax-64], xmm0
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [rax-48], xmm1
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [rax-32], xmm0
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [rax-16], xmm1
	sub	rdx, 1
	jne	SHORT $LL1138@kvz_config

; 1049 :       cfg->intra_bit_allocation = false;

	mov	WORD PTR [rsi+2485], 256		; 00000100H

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [rdx+1]
	jmp	$LN1@kvz_config
$LN153@kvz_config:

; 1050 :       cfg->clip_neighbour = true;
; 1051 : 
; 1052 :     } else if (atoi(value) == 16) {

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	cmp	eax, 16
	jne	$LN155@kvz_config

; 1053 :       cfg->gop_lowdelay = 0;
; 1054 :       cfg->gop_len = sizeof(kvz_gop_ra16) / sizeof(kvz_gop_ra16[0]);

	mov	WORD PTR [rsi+300], ax

; 1055 :       memcpy(cfg->gop, kvz_gop_ra16, sizeof(kvz_gop_ra16));

	lea	rcx, OFFSET FLAT:kvz_gop_ra16
	lea	rax, QWORD PTR [rsi+304]
	mov	edx, 8
$LL1137@kvz_config:
	lea	rax, QWORD PTR [rax+128]
	movups	xmm0, XMMWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+128]
	movups	XMMWORD PTR [rax-128], xmm0
	movups	xmm1, XMMWORD PTR [rcx-112]
	movups	XMMWORD PTR [rax-112], xmm1
	movups	xmm0, XMMWORD PTR [rcx-96]
	movups	XMMWORD PTR [rax-96], xmm0
	movups	xmm1, XMMWORD PTR [rcx-80]
	movups	XMMWORD PTR [rax-80], xmm1
	movups	xmm0, XMMWORD PTR [rcx-64]
	movups	XMMWORD PTR [rax-64], xmm0
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [rax-48], xmm1
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [rax-32], xmm0
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [rax-16], xmm1
	sub	rdx, 1
	jne	SHORT $LL1137@kvz_config

; 1056 :       cfg->intra_bit_allocation = false;

	mov	WORD PTR [rsi+2485], 256		; 00000100H

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [rdx+1]
	jmp	$LN1@kvz_config
$LN155@kvz_config:

; 1057 :       cfg->clip_neighbour = true;
; 1058 : 
; 1059 :     } else if (atoi(value) == 0) {

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	test	eax, eax
	jne	SHORT $LN157@kvz_config

; 1060 :       //Disable gop
; 1061 :       cfg->gop_len = 0;
; 1062 :       cfg->gop_lowdelay = 0;
; 1063 :       cfg->gop_lp_definition.d = 0;

	xor	r14d, r14d
	mov	WORD PTR [rsi+300], ax
	mov	QWORD PTR [rsi+2412], r14

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [r14+1]
	jmp	$LN1@kvz_config
$LN157@kvz_config:

; 1064 :       cfg->gop_lp_definition.t = 0;
; 1065 :     } else if (atoi(value)) {

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	test	eax, eax
	je	$LN288@kvz_config

; 1066 :       fprintf(stderr, "Input error: unsupported gop length, must be 0 or 8\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957063
	call	fprintf

; 1067 :       return 0;

	jmp	$LN287@kvz_config
$LN142@kvz_config:

; 1068 :     }
; 1069 :   }
; 1070 :   else if OPT("intra-qp-offset") {

	lea	r8, OFFSET FLAT:$SG4294957062
	mov	rax, rbx
	sub	r8, rbx
	npad	8
$LL1135@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1136@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1135@kvz_config
$LN1136@kvz_config:
	test	edx, edx
	jne	SHORT $LN160@kvz_config

; 1071 :     cfg->intra_qp_offset = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	BYTE PTR [rsi+2460], al

; 1072 :     if( cfg->intra_qp_offset == 0 && !strcmp( value, "auto" ) )

	test	al, al
	jne	SHORT $LN162@kvz_config
	lea	rdx, OFFSET FLAT:$SG4294957061
	sub	rdx, rdi
$LL1133@kvz_config:
	movzx	ecx, BYTE PTR [rdi]
	movzx	eax, BYTE PTR [rdi+rdx]
	sub	ecx, eax
	jne	SHORT $LN1134@kvz_config
	inc	rdi
	test	eax, eax
	jne	SHORT $LL1133@kvz_config
$LN1134@kvz_config:
	test	ecx, ecx
	jne	SHORT $LN162@kvz_config

; 1073 :     {
; 1074 :         cfg->intra_qp_offset_auto = true;

	mov	al, 1

; 1077 :     }
; 1078 :   }

	mov	BYTE PTR [rsi+2461], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [rcx+1]
	jmp	$LN1@kvz_config
$LN162@kvz_config:

; 1075 :     } else {
; 1076 :         cfg->intra_qp_offset_auto = false;

	xor	al, al

; 1077 :     }
; 1078 :   }

	mov	BYTE PTR [rsi+2461], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN160@kvz_config:

; 1079 :   else if OPT("open-gop") {

	lea	r8, OFFSET FLAT:$SG4294957060
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1131@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1132@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1131@kvz_config
$LN1132@kvz_config:
	test	edx, edx
	jne	SHORT $LN164@kvz_config

; 1080 :     cfg->open_gop = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	test	eax, eax
	setne	al
	mov	BYTE PTR [rsi+2464], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN164@kvz_config:

; 1081 :   }
; 1082 :   else if OPT("bipred")

	lea	r8, OFFSET FLAT:$SG4294957059
	mov	rax, rbx
	sub	r8, rbx
$LL1129@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1130@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1129@kvz_config
$LN1130@kvz_config:
	test	edx, edx
	jne	SHORT $LN166@kvz_config

; 1083 :     cfg->bipred = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+92], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN166@kvz_config:

; 1084 :   else if OPT("bitrate") {

	lea	r8, OFFSET FLAT:$SG4294957058
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1127@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1128@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1127@kvz_config
$LN1128@kvz_config:
	test	edx, edx
	jne	SHORT $LN168@kvz_config

; 1085 :     cfg->target_bitrate = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi

; 1086 :     if (!cfg->rc_algorithm) {

	cmp	BYTE PTR [rsi+2484], 0
	mov	DWORD PTR [rsi+2352], eax
	jne	$LN288@kvz_config

; 1087 :       cfg->rc_algorithm = KVZ_LAMBDA;

	mov	BYTE PTR [rsi+2484], 1

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN168@kvz_config:

; 1088 :     }
; 1089 :   }
; 1090 :   else if OPT("preset") {

	lea	r8, OFFSET FLAT:$SG4294957057
	mov	rax, rbx
	sub	r8, rbx
$LL1125@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1126@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1125@kvz_config
$LN1126@kvz_config:
	test	edx, edx
	jne	$LN171@kvz_config

; 1091 :     int preset_line = 0;
; 1092 : 
; 1093 :     // Accept numbers from 0 to 9.
; 1094 :     if ((atoi(value) == 0 && !strcmp(value, "0")) || (atoi(value) >= 1 && atoi(value) <= 9)) {

	mov	rcx, rdi
	xor	r14d, r14d
	call	QWORD PTR __imp_atoi
	lea	r12, OFFSET FLAT:?preset_values@?1??kvz_config_parse@@9@9
	test	eax, eax
	jne	SHORT $LN176@kvz_config
	lea	r8, OFFSET FLAT:$SG4294957056
	mov	rax, rdi
	sub	r8, rdi
$LL1123@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1124@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1123@kvz_config
$LN1124@kvz_config:
	test	edx, edx
	je	SHORT $LN175@kvz_config
$LN176@kvz_config:
	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	cmp	eax, 1
	jl	SHORT $LN894@kvz_config
	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	cmp	eax, 9
	jg	SHORT $LN894@kvz_config
$LN175@kvz_config:

; 1095 :       preset_line = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	r14d, eax

; 1096 :     } else {

	jmp	SHORT $LN1357@kvz_config
$LN894@kvz_config:

; 1097 :       // Find the selected preset from the list
; 1098 :       while (preset_values[preset_line][0] != NULL) {

	mov	r8, QWORD PTR ?preset_values@?1??kvz_config_parse@@9@9
	test	r8, r8
	je	SHORT $LN1357@kvz_config
	mov	r9, r14
$LL2@kvz_config:

; 1099 :         if (!strcmp(value, preset_values[preset_line][0])) {

	mov	rax, rdi
	sub	r8, rdi
	npad	10
$LL1121@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1122@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1121@kvz_config
$LN1122@kvz_config:
	test	edx, edx
	je	SHORT $LN1357@kvz_config

; 1100 :           break;
; 1101 :         }
; 1102 :         preset_line++;

	inc	r9
	inc	r14d
	imul	rax, r9, 400				; 00000190H
	mov	r8, QWORD PTR [rax+r12]
	test	r8, r8
	jne	SHORT $LL2@kvz_config
$LN1357@kvz_config:

; 1103 :       }
; 1104 :     }
; 1105 : 
; 1106 :     if (preset_values[preset_line][0] != NULL) {

	movsxd	r14, r14d
	mov	ecx, 2
	imul	rbx, r14, 400				; 00000190H
	cmp	QWORD PTR [rbx+r12], 0
	je	$LN178@kvz_config

; 1107 :       fprintf(stderr, "Using preset %s: ", value);

	call	QWORD PTR __imp___acrt_iob_func
	mov	r8, rdi
	lea	rdx, OFFSET FLAT:$SG4294957055
	mov	rcx, rax
	call	fprintf

; 1108 :       // Loop all the name and value pairs and push to the config parser
; 1109 :       for (int preset_value = 1; preset_values[preset_line][preset_value] != NULL; preset_value += 2) {

	cmp	QWORD PTR [rbx+r12+8], 0
	je	SHORT $LN5@kvz_config

; 1152 :         cfg->crypto_features = KVZ_CRYPTO_ON;

	imul	rdi, r14, 400				; 00000190H
	lea	r14, QWORD PTR [rbx+8]
	add	rbx, 8
	lea	rax, OFFSET FLAT:?preset_values@?1??kvz_config_parse@@9@9+8
	add	rdi, rax
	add	rbx, r12
	mov	r15, QWORD PTR [rdi]
	npad	10
$LL6@kvz_config:

; 1110 :         fprintf(stderr, "--%s=%s ", preset_values[preset_line][preset_value], preset_values[preset_line][preset_value + 1]);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, QWORD PTR [r14+r12+8]
	lea	rdx, OFFSET FLAT:$SG4294957054
	mov	rcx, rax
	mov	r8, r15
	call	fprintf

; 1111 :         kvz_config_parse(cfg, preset_values[preset_line][preset_value], preset_values[preset_line][preset_value + 1]);

	mov	r8, QWORD PTR [r14+r12+8]
	mov	rcx, rsi
	mov	rdx, QWORD PTR [rdi]
	call	kvz_config_parse
	mov	r15, QWORD PTR [rbx+16]
	add	rbx, 16
	mov	r14, rbx
	mov	rdi, rbx
	sub	r14, r12
	test	r15, r15
	jne	SHORT $LL6@kvz_config
$LN5@kvz_config:

; 1112 :       }
; 1113 :       fprintf(stderr, "\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957053
	call	fprintf

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN178@kvz_config:

; 1114 :     } else {
; 1115 :       fprintf(stderr, "Input error: unknown preset \"%s\"\n", value);

	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294957052

; 1116 :       return 0;

	jmp	$LN1395@kvz_config
$LN171@kvz_config:

; 1117 :     }
; 1118 :   }
; 1119 :   else if OPT("mv-rdo")

	lea	r8, OFFSET FLAT:$SG4294957051
	mov	rax, rbx
	sub	r8, rbx
	npad	5
$LL1119@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1120@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1119@kvz_config
$LN1120@kvz_config:
	test	edx, edx
	jne	SHORT $LN180@kvz_config

; 1120 :     cfg->mv_rdo = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	BYTE PTR [rsi+2356], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN180@kvz_config:

; 1121 :   else if OPT("psnr")

	lea	r8, OFFSET FLAT:$SG4294957050
	mov	rax, rbx
	sub	r8, rbx
	npad	4
$LL1117@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1118@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1117@kvz_config
$LN1118@kvz_config:
	test	edx, edx
	jne	SHORT $LN182@kvz_config

; 1122 :     cfg->calc_psnr = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	test	eax, eax
	setne	al
	mov	BYTE PTR [rsi+2357], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN182@kvz_config:

; 1123 :   else if OPT("hash")

	lea	r8, OFFSET FLAT:$SG4294957049
	mov	rax, rbx
	sub	r8, rbx
$LL1115@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1116@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1115@kvz_config
$LN1116@kvz_config:
	test	edx, edx
	jne	SHORT $LN184@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?hash_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r15b, r15b
	npad	7
$LL826@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN918@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r15b
	movsx	rax, r15b
	mov	rax, QWORD PTR ?hash_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL826@kvz_config

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	r14d, r14d

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN918@kvz_config:

; 1124 :   {
; 1125 :     int8_t hash;
; 1126 :     int result;
; 1127 :     if ((result = parse_enum(value, hash_names, &hash))) {
; 1128 :       cfg->hash = hash;

	movsx	eax, r15b

; 225  :       return 1;

	mov	r14d, 1

; 1124 :   {
; 1125 :     int8_t hash;
; 1126 :     int result;
; 1127 :     if ((result = parse_enum(value, hash_names, &hash))) {
; 1128 :       cfg->hash = hash;

	mov	DWORD PTR [rsi+2364], eax

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN184@kvz_config:

; 1129 :     }
; 1130 :     return result;
; 1131 :   }
; 1132 :   else if OPT("cu-split-termination")

	lea	r8, OFFSET FLAT:$SG4294957048
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1113@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1114@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1113@kvz_config
$LN1114@kvz_config:
	test	edx, edx
	jne	SHORT $LN187@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?cu_split_termination_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase

; 1133 :   {
; 1134 :     int8_t mode = KVZ_CU_SPLIT_TERMINATION_ZERO;

	xor	r15b, r15b

; 222  :   for (i = 0; names[i]; i++) {

	xor	r14b, r14b
	npad	5
$LL834@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN919@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?cu_split_termination_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL834@kvz_config

; 1135 :     int result = parse_enum(value, cu_split_termination_names, &mode);
; 1136 :     cfg->cu_split_termination = mode;

	movsx	eax, r15b

; 229  :   return 0;

	xor	r14d, r14d

; 1135 :     int result = parse_enum(value, cu_split_termination_names, &mode);
; 1136 :     cfg->cu_split_termination = mode;

	mov	DWORD PTR [rsi+2368], eax

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN919@kvz_config:

; 224  :       *dst = i;

	movzx	r15d, r14b

; 225  :       return 1;

	mov	r14d, 1

; 1135 :     int result = parse_enum(value, cu_split_termination_names, &mode);
; 1136 :     cfg->cu_split_termination = mode;

	movsx	eax, r15b
	mov	DWORD PTR [rsi+2368], eax

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN187@kvz_config:

; 1137 :     return result;
; 1138 :   }
; 1139 :   else if OPT("crypto")

	lea	r8, OFFSET FLAT:$SG4294957047
	mov	rax, rbx
	sub	r8, rbx
	npad	8
$LL1111@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1112@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1111@kvz_config
$LN1112@kvz_config:
	test	edx, edx
	jne	$LN189@kvz_config

; 1140 :   {
; 1141 :     // on, off, feature1+feature2
; 1142 : 
; 1143 :     const char *token_begin = value;
; 1144 :     const char *cur = token_begin;
; 1145 : 
; 1146 :     cfg->crypto_features = KVZ_CRYPTO_OFF;

	xor	r14d, r14d

; 222  :   for (i = 0; names[i]; i++) {

	lea	rbx, OFFSET FLAT:__ImageBase

; 1140 :   {
; 1141 :     // on, off, feature1+feature2
; 1142 : 
; 1143 :     const char *token_begin = value;
; 1144 :     const char *cur = token_begin;
; 1145 : 
; 1146 :     cfg->crypto_features = KVZ_CRYPTO_OFF;

	mov	DWORD PTR [rsi+2372], r14d
	mov	r12, rdi

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?crypto_toggle_names@?1??kvz_config_parse@@9@9
	xor	r15b, r15b
	npad	7
$LL842@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	$LN1023@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r15b
	movsx	rax, r15b
	mov	rax, QWORD PTR ?crypto_toggle_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL842@kvz_config
	npad	2
$LL7@kvz_config:

; 1153 :       }
; 1154 :     } else {
; 1155 :       // Try and parse "feature1+feature2" type list.
; 1156 :       for (;;) {
; 1157 :         if (*cur == '+' || *cur == '\0') {

	movzx	eax, BYTE PTR [r12]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN195@kvz_config
	test	al, al
	jne	SHORT $LN1012@kvz_config
$LN195@kvz_config:

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?crypto_feature_names@?1??kvz_config_parse@@9@9
	xor	r15b, r15b
	mov	r13, r12
	sub	r13, rdi
	mov	r13d, r13d
$LL848@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8, r13
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN921@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r15b
	movsx	rax, r15b
	mov	rax, QWORD PTR ?crypto_feature_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL848@kvz_config

; 1430 : }

	mov	DWORD PTR [rsi+2372], r14d
	jmp	$LN287@kvz_config
$LN921@kvz_config:

; 1158 :           int8_t feature = 0;
; 1159 :           int num_chars = cur - token_begin;
; 1160 :           if (parse_enum_n(token_begin, num_chars, crypto_feature_names, &feature)) {
; 1161 :             cfg->crypto_features |= (1 << feature);

	mov	ecx, DWORD PTR [rsi+2372]

; 1162 :           } else {
; 1163 :             cfg->crypto_features = KVZ_CRYPTO_OFF;
; 1164 :             return 0;
; 1165 :           }
; 1166 :           token_begin = cur + 1;

	lea	rdi, QWORD PTR [r12+1]
	movsx	eax, r15b
	bts	ecx, eax
	mov	DWORD PTR [rsi+2372], ecx

; 1167 :         }
; 1168 : 
; 1169 :         if (*cur == '\0') {

	cmp	BYTE PTR [r12], r14b
	je	SHORT $LN988@kvz_config
$LN1012@kvz_config:

; 1170 :           break;
; 1171 :         } else {
; 1172 :           ++cur;

	inc	r12

; 1173 :         }
; 1174 :       }

	jmp	SHORT $LL7@kvz_config
$LN1023@kvz_config:

; 1147 : 
; 1148 :     // If value is on or off, set all features to on or off.
; 1149 :     int8_t toggle = 0;
; 1150 :     if (parse_enum(token_begin, crypto_toggle_names, &toggle)) {
; 1151 :       if (toggle == 1) {

	cmp	r15b, 1
	jne	SHORT $LN1029@kvz_config

; 1152 :         cfg->crypto_features = KVZ_CRYPTO_ON;

	mov	ecx, 31
	mov	DWORD PTR [rsi+2372], ecx
	jmp	SHORT $LN988@kvz_config
$LN1029@kvz_config:
	mov	ecx, DWORD PTR [rsi+2372]
$LN988@kvz_config:

; 1175 :     }
; 1176 : 
; 1177 :     // Disallow turning on the encryption when it's not compiled in.
; 1178 :     bool encryption_compiled_in = false;
; 1179 : #ifdef KVZ_SEL_ENCRYPTION
; 1180 :     encryption_compiled_in = true;
; 1181 : #endif
; 1182 :     if (!encryption_compiled_in && cfg->crypto_features) {

	test	ecx, ecx
	je	$LN200@kvz_config

; 1183 :       fprintf(stderr, "--crypto cannot be enabled because it's not compiled in.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957046
	call	fprintf

; 1430 : }

	mov	DWORD PTR [rsi+2372], r14d
	jmp	$LN287@kvz_config
$LN189@kvz_config:

; 1184 :       cfg->crypto_features = KVZ_CRYPTO_OFF;
; 1185 :       return 0;
; 1186 :     }
; 1187 : 
; 1188 :     return 1;
; 1189 :   }
; 1190 :   else if OPT("key"){

	lea	r8, OFFSET FLAT:$SG4294957045
	mov	rax, rbx
	sub	r8, rbx
	npad	6
$LL1109@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1110@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1109@kvz_config
$LN1110@kvz_config:
	test	edx, edx
	jne	SHORT $LN201@kvz_config

; 1191 :     int size_key = 16;
; 1192 :     FREE_POINTER(cfg->optional_key);

	mov	rcx, QWORD PTR [rsi+2376]
	call	QWORD PTR __imp_free
	xor	r14d, r14d
	mov	QWORD PTR [rsi+2376], r14

; 1193 :     cfg->optional_key = (uint8_t *)malloc(sizeof(uint8_t)*size_key);

	lea	ecx, QWORD PTR [r14+16]
	call	QWORD PTR __imp_malloc

; 1194 :     return parse_array(value, cfg->optional_key, size_key, 0, 255);

	mov	rdx, rax
	mov	QWORD PTR [rsi+2376], rax
	mov	rcx, rdi
	call	parse_array
	jmp	$LN1@kvz_config
$LN201@kvz_config:

; 1195 :   }
; 1196 :   else if OPT("me-early-termination"){

	lea	r8, OFFSET FLAT:$SG4294957044
	mov	rax, rbx
	sub	r8, rbx
	npad	4
$LL1107@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1108@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1107@kvz_config
$LN1108@kvz_config:
	test	edx, edx
	jne	SHORT $LN203@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?me_early_termination_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase

; 1197 :     int8_t mode = 0;

	xor	r15b, r15b

; 222  :   for (i = 0; names[i]; i++) {

	xor	r14b, r14b
	npad	5
$LL856@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN923@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?me_early_termination_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL856@kvz_config

; 1198 :     int result = parse_enum(value, me_early_termination_names, &mode);
; 1199 :     cfg->me_early_termination = mode;

	movsx	eax, r15b

; 229  :   return 0;

	xor	r14d, r14d

; 1198 :     int result = parse_enum(value, me_early_termination_names, &mode);
; 1199 :     cfg->me_early_termination = mode;

	mov	DWORD PTR [rsi+2384], eax

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN923@kvz_config:

; 224  :       *dst = i;

	movzx	r15d, r14b

; 225  :       return 1;

	mov	r14d, 1

; 1198 :     int result = parse_enum(value, me_early_termination_names, &mode);
; 1199 :     cfg->me_early_termination = mode;

	movsx	eax, r15b
	mov	DWORD PTR [rsi+2384], eax

; 1430 : }

	mov	eax, r14d
	jmp	$LN1@kvz_config
$LN203@kvz_config:

; 1200 :     return result;
; 1201 :   }
; 1202 :   else if OPT("intra-rdo-et")

	lea	r8, OFFSET FLAT:$SG4294957043
	mov	rax, rbx
	sub	r8, rbx
	npad	8
$LL1105@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1106@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1105@kvz_config
$LN1106@kvz_config:
	test	edx, edx
	jne	SHORT $LN205@kvz_config

; 1203 :     cfg->intra_rdo_et = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	xor	r14d, r14d
	test	eax, eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	setne	r14b
	mov	DWORD PTR [rsi+2388], r14d
	jmp	$LN1@kvz_config
$LN205@kvz_config:

; 1204 :   else if OPT("lossless")

	lea	r8, OFFSET FLAT:$SG4294957042
	mov	rax, rbx
	sub	r8, rbx
	npad	10
$LL1103@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1104@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1103@kvz_config
$LN1104@kvz_config:
	test	edx, edx
	jne	SHORT $LN207@kvz_config

; 1205 :     cfg->lossless = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	xor	r14d, r14d
	test	eax, eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	setne	r14b
	mov	DWORD PTR [rsi+2392], r14d
	jmp	$LN1@kvz_config
$LN207@kvz_config:

; 1206 :   else if OPT("tmvp") {

	lea	r8, OFFSET FLAT:$SG4294957041
	mov	rax, rbx
	sub	r8, rbx
	npad	10
$LL1101@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1102@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1101@kvz_config
$LN1102@kvz_config:
	test	edx, edx
	jne	SHORT $LN209@kvz_config

; 1207 :     cfg->tmvp_enable = atobool(value);

	mov	rcx, rdi
	call	atobool

; 1208 :     if (cfg->tiles_width_count > 1 || cfg->tiles_height_count > 1) {

	cmp	DWORD PTR [rsi+144], 1
	mov	DWORD PTR [rsi+2396], eax
	jg	SHORT $LN212@kvz_config
	cmp	DWORD PTR [rsi+148], 1
	jle	$LN288@kvz_config
$LN212@kvz_config:

; 1209 :       fprintf(stderr, "Cannot enable TMVP because tiles are used.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957040
	call	fprintf

; 1210 :       cfg->tmvp_enable = false;

	xor	r14d, r14d
	mov	DWORD PTR [rsi+2396], r14d

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [r14+1]
	jmp	$LN1@kvz_config
$LN209@kvz_config:

; 1211 :     }
; 1212 :   }
; 1213 :   else if OPT("rdoq-skip"){

	lea	r8, OFFSET FLAT:$SG4294957039
	mov	rax, rbx
	sub	r8, rbx
	npad	11
$LL1099@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1100@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1099@kvz_config
$LN1100@kvz_config:
	test	edx, edx
	jne	SHORT $LN213@kvz_config

; 1214 :     cfg->rdoq_skip = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	DWORD PTR [rsi+2400], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN213@kvz_config:

; 1215 :   }
; 1216 :   else if OPT("input-format") {

	lea	r8, OFFSET FLAT:$SG4294957038
	mov	rax, rbx
	sub	r8, rbx
	npad	4
$LL1097@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1098@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1097@kvz_config
$LN1098@kvz_config:
	test	edx, edx
	jne	SHORT $LN215@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?format_names@?GA@??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	8
$LL864@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN217@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?format_names@?GA@??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL864@kvz_config

; 1217 :     static enum kvz_input_format const formats[] = { KVZ_FORMAT_P400, KVZ_FORMAT_P420 };
; 1218 :     static const char * const format_names[] = { "P400", "P420", NULL };
; 1219 : 
; 1220 :     int8_t format = 0;
; 1221 :     if (!parse_enum(value, format_names, &format)) {
; 1222 :       fprintf(stderr, "input-format not recognized.\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957035
	call	fprintf

; 1223 :       return 0;

	jmp	$LN287@kvz_config
$LN217@kvz_config:

; 1224 :     }
; 1225 : 
; 1226 :     cfg->input_format = formats[format];

	movsx	rax, r14b
	mov	eax, DWORD PTR ?formats@?GA@??kvz_config_parse@@9@9[rbx+rax*4]
	mov	DWORD PTR [rsi+2404], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN215@kvz_config:

; 1227 :   }
; 1228 :   else if OPT("input-bitdepth") {

	lea	r8, OFFSET FLAT:$SG4294957034
	mov	rax, rbx
	sub	r8, rbx
	npad	1
$LL1095@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1096@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1095@kvz_config
$LN1096@kvz_config:
	test	edx, edx
	jne	SHORT $LN218@kvz_config

; 1229 :     cfg->input_bitdepth = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+2408], eax

; 1230 :     if (cfg->input_bitdepth < 8 || cfg->input_bitdepth > 16) {

	lea	ecx, DWORD PTR [rax-8]
	cmp	ecx, 8
	ja	SHORT $LN221@kvz_config

; 1233 :     }
; 1234 :     if (cfg->input_bitdepth > 8 && KVZ_BIT_DEPTH == 8) {

	cmp	eax, 8
	jle	$LN288@kvz_config

; 1235 :       // Because the image is read straight into the reference buffers,
; 1236 :       // reading >8 bit samples doesn't work when sizeof(kvz_pixel)==1.
; 1237 :       fprintf(stderr, "input-bitdepth can't be set to larger than 8 because"

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957032
	call	fprintf

; 1238 :                       " Kvazaar is compiled with KVZ_BIT_DEPTH=8.\n");
; 1239 :       return 0;

	jmp	$LN287@kvz_config
$LN221@kvz_config:

; 1231 :       fprintf(stderr, "input-bitdepth not between 8 and 16.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957033
	call	fprintf

; 1232 :       return 0;

	jmp	$LN287@kvz_config
$LN218@kvz_config:

; 1240 :     }
; 1241 :   }
; 1242 :   else if OPT("implicit-rdpcm")

	lea	r8, OFFSET FLAT:$SG4294957031
	mov	rax, rbx
	sub	r8, rbx
$LL1093@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1094@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1093@kvz_config
$LN1094@kvz_config:
	test	edx, edx
	jne	SHORT $LN223@kvz_config

; 1243 :     cfg->implicit_rdpcm = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	xor	r14d, r14d
	test	eax, eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	setne	r14b
	mov	DWORD PTR [rsi+2420], r14d
	jmp	$LN1@kvz_config
$LN223@kvz_config:

; 1244 :   else if OPT("roi") {

	lea	r8, OFFSET FLAT:$SG4294957030
	mov	rax, rbx
	sub	r8, rbx
	npad	8
$LL1091@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1092@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1091@kvz_config
$LN1092@kvz_config:
	test	edx, edx
	jne	$LN225@kvz_config

; 1245 :     // The ROI description is as follows:
; 1246 :     // First number is width, second number is height,
; 1247 :     // then follows width * height number of dqp values.
; 1248 :     FILE* f = fopen(value, "rb");

	lea	rdx, OFFSET FLAT:$SG4294957029
	mov	rcx, rdi
	call	QWORD PTR __imp_fopen
	mov	rbx, rax

; 1249 :     if (!f) {

	test	rax, rax
	jne	SHORT $LN227@kvz_config

; 1250 :       fprintf(stderr, "Could not open ROI file.\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957028
	call	fprintf

; 1251 :       return 0;

	jmp	$LN287@kvz_config
$LN227@kvz_config:

; 1252 :     }
; 1253 : 
; 1254 :     int width = 0;

	xor	r14d, r14d

; 1255 :     int height = 0;
; 1256 :     if (!fscanf(f, "%d", &width) || !fscanf(f, "%d", &height)) {

	lea	r8, QWORD PTR width$14[rbp-80]
	lea	rdx, OFFSET FLAT:$SG4294957027
	mov	DWORD PTR width$14[rbp-80], r14d
	mov	rcx, rbx
	mov	DWORD PTR height$8[rbp-80], r14d
	call	fscanf
	test	eax, eax
	je	$LN229@kvz_config
	lea	r8, QWORD PTR height$8[rbp-80]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG4294957026
	call	fscanf
	test	eax, eax
	je	$LN229@kvz_config

; 1260 :     }
; 1261 : 
; 1262 :     if (width <= 0 || height <= 0) {

	mov	eax, DWORD PTR width$14[rbp-80]
	test	eax, eax
	jle	$LN231@kvz_config
	mov	r15d, DWORD PTR height$8[rbp-80]
	test	r15d, r15d
	jle	$LN231@kvz_config

; 1266 :     }
; 1267 : 
; 1268 :     if (width > 10000 || height > 10000) {

	cmp	eax, 10000				; 00002710H
	jg	$LN233@kvz_config
	cmp	r15d, 10000				; 00002710H
	jg	$LN233@kvz_config

; 1272 :     }
; 1273 : 
; 1274 :     const unsigned size = width * height;

	imul	r15d, eax

; 1275 :     int8_t *dqp_array  = calloc((size_t)size, sizeof(cfg->roi.dqps[0]));

	lea	edx, QWORD PTR [r14+1]
	mov	ecx, r15d
	call	QWORD PTR __imp_calloc
	mov	rdi, rax

; 1276 :     if (!dqp_array) {

	test	rax, rax
	jne	SHORT $LN234@kvz_config

; 1277 :       fprintf(stderr, "Failed to allocate memory for ROI table.\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957022
	call	fprintf

; 1278 :       fclose(f);

	mov	rcx, rbx
	call	QWORD PTR __imp_fclose

; 1279 :       return 0;

	jmp	$LN287@kvz_config
$LN234@kvz_config:

; 1280 :     }
; 1281 : 
; 1282 :     FREE_POINTER(cfg->roi.dqps);

	mov	rcx, QWORD PTR [rsi+2432]
	call	QWORD PTR __imp_free

; 1283 :     cfg->roi.dqps   = dqp_array;
; 1284 :     cfg->roi.width  = width;

	mov	eax, DWORD PTR width$14[rbp-80]
	mov	DWORD PTR [rsi+2424], eax

; 1285 :     cfg->roi.height = height;

	mov	eax, DWORD PTR height$8[rbp-80]
	mov	DWORD PTR [rsi+2428], eax
	mov	QWORD PTR [rsi+2432], rdi

; 1286 : 
; 1287 :     for (int i = 0; i < size; ++i) {

	test	r15d, r15d
	je	SHORT $LN11@kvz_config

; 1152 :         cfg->crypto_features = KVZ_CRYPTO_ON;

	mov	esi, 51					; 00000033H
	lea	r12d, QWORD PTR [rsi-102]
	npad	12
$LL12@kvz_config:

; 1288 :       int number; // Need a pointer to int for fscanf
; 1289 :       if (fscanf(f, "%d", &number) != 1) {

	lea	r8, QWORD PTR number$2[rbp-80]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG4294957021
	call	fscanf
	cmp	eax, 1
	jne	SHORT $LN925@kvz_config

; 1293 :       }
; 1294 :       dqp_array[i] = CLIP(-51, 51, number);

	mov	eax, DWORD PTR number$2[rbp-80]
	cmp	eax, esi
	cmovg	eax, esi
	cmp	eax, r12d
	cmovl	eax, r12d
	inc	r14d
	mov	BYTE PTR [rdi], al
	inc	rdi
	cmp	r14d, r15d
	jb	SHORT $LL12@kvz_config
$LN11@kvz_config:

; 1295 :     }
; 1296 : 
; 1297 :     fclose(f);

	mov	rcx, rbx
	call	QWORD PTR __imp_fclose

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN925@kvz_config:

; 1290 :         fprintf(stderr, "Reading ROI file failed.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957020
	call	fprintf

; 1291 :         fclose(f);

	mov	rcx, rbx
	call	QWORD PTR __imp_fclose

; 1292 :         return 0;

	jmp	$LN287@kvz_config
$LN233@kvz_config:

; 1269 :       fprintf(stderr, "ROI dimensions exceed arbitrary value of 10000.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957023
	call	fprintf

; 1270 :       fclose(f);

	mov	rcx, rbx
	call	QWORD PTR __imp_fclose

; 1271 :       return 0;

	jmp	$LN287@kvz_config
$LN231@kvz_config:

; 1263 :       fprintf(stderr, "Invalid ROI size: %dx%d.\n", width, height);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR height$8[rbp-80]
	lea	rdx, OFFSET FLAT:$SG4294957024
	mov	r8d, DWORD PTR width$14[rbp-80]
	mov	rcx, rax
	call	fprintf

; 1264 :       fclose(f);

	mov	rcx, rbx
	call	QWORD PTR __imp_fclose

; 1265 :       return 0;

	jmp	$LN287@kvz_config
$LN229@kvz_config:

; 1257 :       fprintf(stderr, "Failed to read ROI size.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957025
	call	fprintf

; 1258 :       fclose(f);

	mov	rcx, rbx
	call	QWORD PTR __imp_fclose

; 1259 :       return 0;

	jmp	$LN287@kvz_config
$LN225@kvz_config:

; 1298 :   }
; 1299 :   else if OPT("set-qp-in-cu") {

	lea	r8, OFFSET FLAT:$SG4294957019
	mov	rax, rbx
	sub	r8, rbx
	npad	4
$LL1089@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1090@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1089@kvz_config
$LN1090@kvz_config:
	test	edx, edx
	jne	SHORT $LN236@kvz_config

; 1300 :     cfg->set_qp_in_cu = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	test	eax, eax
	setne	al
	mov	BYTE PTR [rsi+2463], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN236@kvz_config:

; 1301 :   }
; 1302 :   else if OPT("erp-aqp") {

	lea	r8, OFFSET FLAT:$SG4294957018
	mov	rax, rbx
	sub	r8, rbx
$LL1087@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1088@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1087@kvz_config
$LN1088@kvz_config:
	test	edx, edx
	jne	SHORT $LN238@kvz_config

; 1303 :     cfg->erp_aqp = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	xor	r14d, r14d
	test	eax, eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	setne	r14b
	mov	DWORD PTR [rsi+2444], r14d
	jmp	$LN1@kvz_config
$LN238@kvz_config:

; 1304 :   }
; 1305 :   else if (OPT("level") || OPT("force-level")) {

	lea	r8, OFFSET FLAT:$SG4294957017
	mov	rax, rbx
	sub	r8, rbx
	npad	9
$LL1085@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1086@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1085@kvz_config
$LN1086@kvz_config:
	test	edx, edx
	je	$LN242@kvz_config
	lea	r8, OFFSET FLAT:$SG4294957016
	mov	rax, rbx
	sub	r8, rbx
	npad	8
$LL1083@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1084@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1083@kvz_config
$LN1084@kvz_config:
	test	edx, edx
	je	$LN242@kvz_config

; 1337 :   }
; 1338 :   else if (OPT("high-tier")) {

	lea	r8, OFFSET FLAT:$SG4294957011
	mov	rax, rbx
	sub	r8, rbx
	npad	8
$LL1081@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1082@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1081@kvz_config
$LN1082@kvz_config:
	test	edx, edx
	jne	SHORT $LN253@kvz_config

; 1339 :     cfg->high_tier = true;

	mov	BYTE PTR [rsi+2450], 1

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	lea	eax, QWORD PTR [rdx+1]
	jmp	$LN1@kvz_config
$LN253@kvz_config:

; 1340 :   }
; 1341 :   else if (OPT("me-steps")) {

	lea	r8, OFFSET FLAT:$SG4294957010
	mov	rax, rbx
	sub	r8, rbx
$LL1079@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1080@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1079@kvz_config
$LN1080@kvz_config:
	test	edx, edx
	jne	SHORT $LN255@kvz_config

; 1342 :     char * tailptr = NULL;

	xor	r14d, r14d

; 1343 :     long steps = strtol(value, &tailptr, 0);

	lea	rdx, QWORD PTR tailptr$6[rbp-80]
	xor	r8d, r8d
	mov	QWORD PTR tailptr$6[rbp-80], r14
	mov	rcx, rdi
	call	QWORD PTR __imp_strtol

; 1344 : 
; 1345 :     if (*tailptr != '\0') {

	mov	rcx, QWORD PTR tailptr$6[rbp-80]
	cmp	BYTE PTR [rcx], r14b
	je	SHORT $LN257@kvz_config

; 1346 :       fprintf(stderr, "Invalid me-steps value: \"%s\"", value);

	lea	ecx, QWORD PTR [r14+2]
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294957009

; 1347 :       return 0;

	jmp	$LN1395@kvz_config
$LN257@kvz_config:

; 1348 :     }
; 1349 :     if (steps < -1 || steps > UINT32_MAX) {

	cmp	eax, -1
	jl	SHORT $LN259@kvz_config

; 1352 :     }
; 1353 : 
; 1354 :     cfg->me_max_steps = (uint32_t)steps;

	mov	DWORD PTR [rsi+2456], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN259@kvz_config:

; 1350 :       fprintf(stderr, "me-steps value is out of bounds: \"%s\"", value);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294957008

; 1351 :       return 0;

	jmp	$LN1395@kvz_config
$LN255@kvz_config:

; 1355 :   }
; 1356 :   else if (OPT("fast-residual-cost"))

	lea	r8, OFFSET FLAT:$SG4294957007
	mov	rax, rbx
	sub	r8, rbx
	npad	7
$LL1077@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1078@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1077@kvz_config
$LN1078@kvz_config:
	test	edx, edx
	jne	SHORT $LN260@kvz_config

; 1357 :     cfg->fast_residual_cost_limit = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	BYTE PTR [rsi+2462], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN260@kvz_config:

; 1358 :   else if (OPT("vaq")) {

	lea	r8, OFFSET FLAT:$SG4294957006
	mov	rax, rbx
	sub	r8, rbx
	npad	3
$LL1075@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1076@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1075@kvz_config
$LN1076@kvz_config:
	test	edx, edx
	jne	SHORT $LN262@kvz_config

; 1359 :     cfg->vaq = (int)atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi+2468], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN262@kvz_config:

; 1360 :   }
; 1361 :   else if (OPT("max-merge")) {

	lea	r8, OFFSET FLAT:$SG4294957005
	mov	rax, rbx
	sub	r8, rbx
	npad	3
$LL1073@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1074@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1073@kvz_config
$LN1074@kvz_config:
	test	edx, edx
	jne	SHORT $LN264@kvz_config

; 1362 :     int max_merge = atoi(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_atoi

; 1363 :     if (max_merge < 1 || max_merge > 5) {

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, 4
	ja	SHORT $LN267@kvz_config

; 1366 :     }
; 1367 :     cfg->max_merge = (uint8_t)max_merge;

	mov	BYTE PTR [rsi+2473], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN267@kvz_config:

; 1364 :       fprintf(stderr, "max-merge needs to be between 1 and 5\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957004
	call	fprintf

; 1365 :       return 0;

	jmp	$LN287@kvz_config
$LN264@kvz_config:

; 1368 :   }
; 1369 :   else if OPT("early-skip") {

	lea	r8, OFFSET FLAT:$SG4294957003
	mov	rax, rbx
	sub	r8, rbx
$LL1071@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1072@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1071@kvz_config
$LN1072@kvz_config:
	test	edx, edx
	jne	SHORT $LN268@kvz_config

; 1370 :     cfg->early_skip = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	test	eax, eax
	setne	al
	mov	BYTE PTR [rsi+2474], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN268@kvz_config:

; 1371 :   }
; 1372 :   else if OPT("ml-pu-depth-intra") {

	lea	r8, OFFSET FLAT:$SG4294957002
	mov	rax, rbx
	sub	r8, rbx
	npad	11
$LL1069@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1070@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1069@kvz_config
$LN1070@kvz_config:
	test	edx, edx
	jne	SHORT $LN270@kvz_config

; 1373 :     cfg->ml_pu_depth_intra = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	test	eax, eax
	setne	al
	mov	BYTE PTR [rsi+2475], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN270@kvz_config:

; 1374 :   }
; 1375 :   else if OPT("partial-coding") {

	lea	r8, OFFSET FLAT:$SG4294957001
	mov	rax, rbx
	sub	r8, rbx
$LL1067@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1068@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1067@kvz_config
$LN1068@kvz_config:
	test	edx, edx
	jne	SHORT $LN272@kvz_config

; 1376 :     uint32_t firstCTU_x;
; 1377 :     uint32_t firstCTU_y;
; 1378 :     uint32_t fullWidth;
; 1379 :     uint32_t fullHeight;
; 1380 :     if (4 != sscanf(value, "%u!%u!%u!%u", &firstCTU_x,

	lea	rax, QWORD PTR fullHeight$3[rbp-80]
	mov	rcx, rdi
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR firstCTU_y$12[rbp-80]
	lea	rax, QWORD PTR fullWidth$1[rbp-80]
	lea	r8, QWORD PTR firstCTU_x$5[rbp-80]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, OFFSET FLAT:$SG4294957000
	call	sscanf
	cmp	eax, 4
	je	SHORT $LN274@kvz_config

; 1381 :       &firstCTU_y, &fullWidth, &fullHeight)) {
; 1382 :       fprintf(stderr, "invalid partial-coding options. Expected \"%%u!%%u!%%u!%%u\", but got \"%s\"\n", value);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294956999

; 1383 :       return 0;

	jmp	$LN1395@kvz_config
$LN274@kvz_config:

; 1384 :     }
; 1385 :     cfg->partial_coding.startCTU_x = firstCTU_x;

	movzx	eax, BYTE PTR firstCTU_x$5[rbp-80]
	mov	BYTE PTR [rsi+2476], al

; 1386 :     cfg->partial_coding.startCTU_y = firstCTU_y;

	movzx	eax, BYTE PTR firstCTU_y$12[rbp-80]
	mov	BYTE PTR [rsi+2477], al

; 1387 :     cfg->partial_coding.fullWidth = fullWidth;

	movzx	eax, WORD PTR fullWidth$1[rbp-80]
	mov	WORD PTR [rsi+2478], ax

; 1388 :     cfg->partial_coding.fullHeight = fullHeight;

	movzx	eax, WORD PTR fullHeight$3[rbp-80]
	mov	WORD PTR [rsi+2480], ax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN272@kvz_config:

; 1389 :   }
; 1390 :   else if OPT("zero-coeff-rdo") {

	lea	r8, OFFSET FLAT:$SG4294956998
	mov	rax, rbx
	sub	r8, rbx
	npad	2
$LL1065@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1066@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1065@kvz_config
$LN1066@kvz_config:
	test	edx, edx
	jne	SHORT $LN275@kvz_config

; 1391 :   cfg->zero_coeff_rdo = (bool)atobool(value);

	mov	rcx, rdi
	call	atobool
	test	eax, eax
	setne	al
	mov	BYTE PTR [rsi+2482], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN275@kvz_config:

; 1392 :   }
; 1393 :   else if OPT("rc-algorithm") {

	lea	r8, OFFSET FLAT:$SG4294956997
	mov	rax, rbx
	sub	r8, rbx
$LL1063@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1064@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1063@kvz_config
$LN1064@kvz_config:
	test	edx, edx
	jne	$LN277@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?rc_algorithm_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	3
$LL872@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN279@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?rc_algorithm_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL872@kvz_config

; 1394 :     int8_t rc_algorithm = 0;
; 1395 :     if (!parse_enum(value, rc_algorithm_names, &rc_algorithm)) {
; 1396 :       fprintf(stderr, "Invalid rate control algorithm %s. Valid values include %s, %s, and %s\n", value, 

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	lea	r9, OFFSET FLAT:$SG4294957641
	mov	r8, rdi
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956996
	lea	rax, OFFSET FLAT:$SG4294957639
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:$SG4294957640
	mov	QWORD PTR [rsp+32], rax
	call	fprintf

; 1397 :         rc_algorithm_names[0],
; 1398 :         rc_algorithm_names[1],
; 1399 :         rc_algorithm_names[2]);
; 1400 :       return 0;

	jmp	$LN287@kvz_config
$LN279@kvz_config:

; 1401 :     }
; 1402 :     cfg->rc_algorithm = rc_algorithm;

	mov	BYTE PTR [rsi+2484], r14b

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN277@kvz_config:

; 1403 :   }
; 1404 :   else if OPT("intra-bits") {

	lea	r8, OFFSET FLAT:$SG4294956995
	mov	rax, rbx
	sub	r8, rbx
	npad	9
$LL1061@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1062@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1061@kvz_config
$LN1062@kvz_config:
	test	edx, edx
	jne	SHORT $LN280@kvz_config

; 1405 :     cfg->intra_bit_allocation = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	BYTE PTR [rsi+2485], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN280@kvz_config:

; 1406 :   }
; 1407 :   else if OPT("clip-neighbour") {

	lea	r8, OFFSET FLAT:$SG4294956994
	mov	rax, rbx
	sub	r8, rbx
	npad	4
$LL1059@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1060@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1059@kvz_config
$LN1060@kvz_config:
	test	edx, edx
	jne	SHORT $LN282@kvz_config

; 1408 :     cfg->clip_neighbour = atobool(value);

	mov	rcx, rdi
	call	atobool
	mov	BYTE PTR [rsi+2486], al

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN282@kvz_config:

; 1409 :   }
; 1410 :   else if OPT("input-file-format") {

	lea	r8, OFFSET FLAT:$SG4294956993
	mov	rax, rbx
	sub	r8, rbx
	npad	4
$LL1057@kvz_config:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN1058@kvz_config
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL1057@kvz_config
$LN1058@kvz_config:
	test	edx, edx
	jne	$LN284@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR ?file_format_names@?1??kvz_config_parse@@9@9
	lea	rbx, OFFSET FLAT:__ImageBase
	xor	r14b, r14b
	npad	4
$LL880@kvz_config:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rdi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN286@kvz_config

; 222  :   for (i = 0; names[i]; i++) {

	inc	r14b
	movsx	rax, r14b
	mov	rax, QWORD PTR ?file_format_names@?1??kvz_config_parse@@9@9[rbx+rax*8]
	test	rax, rax
	jne	SHORT $LL880@kvz_config

; 1411 :     int8_t file_format = 0;
; 1412 :     if (!parse_enum(value, file_format_names, &file_format)) {
; 1413 :       fprintf(stderr, "Invalid input file format %s. Valid values include %s, %s, and %s\n", value,

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	lea	r9, OFFSET FLAT:$SG4294957638
	mov	r8, rdi
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956992
	lea	rax, OFFSET FLAT:$SG4294957636
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:$SG4294957637
	mov	QWORD PTR [rsp+32], rax
	call	fprintf

; 1414 :         file_format_names[0],
; 1415 :         file_format_names[1], 
; 1416 :         file_format_names[2]);
; 1417 :       return 0;

	jmp	$LN287@kvz_config
$LN286@kvz_config:

; 1418 :     }
; 1419 :     cfg->file_format = file_format;

	movsx	eax, r14b
	mov	DWORD PTR [rsi+2488], eax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN284@kvz_config:

; 1420 :   }
; 1421 :   else if OPT("stats-file-prefix") {

	lea	rdx, OFFSET FLAT:$SG4294956991
	sub	rdx, rbx
	npad	9
$LL1055@kvz_config:
	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx+rdx]
	sub	ecx, eax
	jne	SHORT $LN1056@kvz_config
	inc	rbx
	test	eax, eax
	jne	SHORT $LL1055@kvz_config
$LN1056@kvz_config:
	test	ecx, ecx
	jne	$LN287@kvz_config

; 1422 :     cfg->stats_file_prefix = strdup(value);

	mov	rcx, rdi
	call	QWORD PTR __imp_strdup
	mov	QWORD PTR [rsi+2496], rax

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	$LN1@kvz_config
$LN242@kvz_config:

; 1306 :     if OPT("force-level") {

	lea	rdx, OFFSET FLAT:$SG4294957015
	sub	rdx, rbx
	npad	2
$LL1053@kvz_config:
	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx+rdx]
	sub	ecx, eax
	jne	SHORT $LN1054@kvz_config
	inc	rbx
	test	eax, eax
	jne	SHORT $LL1053@kvz_config
$LN1054@kvz_config:

; 1307 :       cfg->force_level = true;
; 1308 :     } else {
; 1309 :       cfg->force_level = false;
; 1310 :     }
; 1311 : 
; 1312 :     unsigned int num_first, num_second, level;
; 1313 :     int matched_amount = sscanf(value, "%u.%u", &num_first, &num_second);

	test	ecx, ecx
	lea	r9, QWORD PTR num_second$13[rbp-80]
	lea	r8, QWORD PTR num_first$7[rbp-80]
	mov	rcx, rdi
	sete	al
	lea	rdx, OFFSET FLAT:$SG4294957014
	mov	BYTE PTR [rsi+2449], al
	call	sscanf

; 1314 : 
; 1315 :     if (matched_amount == 2) {

	cmp	eax, 2
	jne	SHORT $LN245@kvz_config

; 1316 :       // of form x.y
; 1317 :       level = num_first * 10 + num_second;

	mov	eax, DWORD PTR num_first$7[rbp-80]
	lea	ecx, DWORD PTR [rax+rax*4]
	mov	eax, DWORD PTR num_second$13[rbp-80]
	lea	edx, DWORD PTR [rax+rcx*2]
	jmp	SHORT $LN249@kvz_config
$LN245@kvz_config:

; 1318 :     } else if (matched_amount == 1) {

	cmp	eax, 1
	jne	SHORT $LN247@kvz_config

; 1319 :       // no dot
; 1320 :       if (num_first < 10) {

	mov	edx, DWORD PTR num_first$7[rbp-80]
	cmp	edx, 10
	jae	SHORT $LN249@kvz_config

; 1321 :         // of form x
; 1322 :         level = num_first * 10;

	lea	edx, DWORD PTR [rdx+rdx*4]
	add	edx, edx
$LN249@kvz_config:

; 1329 :       return 0;
; 1330 :     }
; 1331 :     if (level < 10 || level > 62) {

	lea	eax, DWORD PTR [rdx-10]
	cmp	eax, 52					; 00000034H
	ja	SHORT $LN252@kvz_config

; 1334 :     }
; 1335 : 
; 1336 :     cfg->level = level;

	mov	BYTE PTR [rsi+2448], dl
$LN288@kvz_config:

; 1423 :   }
; 1424 :   else {
; 1425 :     return 0;
; 1426 :   }
; 1427 : #undef OPT
; 1428 : 
; 1429 :   return 1;

	mov	eax, 1
	jmp	SHORT $LN1@kvz_config
$LN252@kvz_config:

; 1332 :       fprintf(stderr, "Level value of %s is out of bounds\n", value);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294957012

; 1333 :       return 0;

	jmp	SHORT $LN1395@kvz_config
$LN247@kvz_config:

; 1323 :       } else {
; 1324 :         // of form xx
; 1325 :         level = num_first;
; 1326 :       }
; 1327 :     } else {
; 1328 :       fprintf(stderr, "Invalid level value: \"%s\"\n", value);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294957013
$LN1395@kvz_config:

; 1430 : }

	mov	r8, rdi
	mov	rcx, rax
	call	fprintf
$LN287@kvz_config:
	xor	eax, eax
$LN1@kvz_config:
	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
kvz_config_parse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
cfg$ = 48
kvz_config_destroy PROC

; 190  : {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 191  :   if (cfg) {

	test	rcx, rcx
	je	$LN2@kvz_config

; 192  :     FREE_POINTER(cfg->cqmfile);

	mov	rcx, QWORD PTR [rcx+136]
	mov	QWORD PTR [rsp+48], rdi
	call	QWORD PTR __imp_free

; 193  :     FREE_POINTER(cfg->fast_coeff_table_fn);

	mov	rcx, QWORD PTR [rbx+2504]
	xor	edi, edi
	mov	QWORD PTR [rbx+136], rdi
	call	QWORD PTR __imp_free

; 194  :     FREE_POINTER(cfg->tiles_width_split);

	mov	rcx, QWORD PTR [rbx+152]
	mov	QWORD PTR [rbx+2504], rdi
	call	QWORD PTR __imp_free

; 195  :     FREE_POINTER(cfg->tiles_height_split);

	mov	rcx, QWORD PTR [rbx+160]
	mov	QWORD PTR [rbx+152], rdi
	call	QWORD PTR __imp_free

; 196  :     FREE_POINTER(cfg->slice_addresses_in_ts);

	mov	rcx, QWORD PTR [rbx+184]
	mov	QWORD PTR [rbx+160], rdi
	call	QWORD PTR __imp_free

; 197  :     FREE_POINTER(cfg->roi.dqps);

	mov	rcx, QWORD PTR [rbx+2432]
	mov	QWORD PTR [rbx+184], rdi
	call	QWORD PTR __imp_free

; 198  :     FREE_POINTER(cfg->optional_key);

	mov	rcx, QWORD PTR [rbx+2376]
	mov	QWORD PTR [rbx+2432], rdi
	call	QWORD PTR __imp_free

; 199  :     FREE_POINTER(cfg->fastrd_learning_outdir_fn);

	mov	rcx, QWORD PTR [rbx+2520]
	mov	QWORD PTR [rbx+2376], rdi
	call	QWORD PTR __imp_free
	mov	QWORD PTR [rbx+2520], rdi
	mov	rdi, QWORD PTR [rsp+48]
$LN2@kvz_config:

; 200  :   }
; 201  :   free(cfg);

	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 202  : 
; 203  :   return 1;

	mov	eax, 1

; 204  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
kvz_config_destroy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
gop$ = 0
depth_modulos$ = 16
cfg$ = 96
kvz_config_process_lp_gop PROC

; 1433 : {

$LN73:
	push	r12
	sub	rsp, 80					; 00000050H

; 1434 :   struct {
; 1435 :     unsigned g;
; 1436 :     unsigned d;
; 1437 :     unsigned t;
; 1438 :   } gop;
; 1439 : 
; 1440 :   gop.g = cfg->gop_len;

	movsx	r10d, BYTE PTR [rcx+300]
	xor	r12d, r12d
	mov	QWORD PTR [rsp+104], rbp
	xorps	xmm0, xmm0

; 1441 :   gop.d = cfg->gop_lp_definition.d;

	mov	ebp, DWORD PTR [rcx+2412]
	mov	r9, rcx
	mov	QWORD PTR [rsp+72], rdi
	mov	edx, r12d
	mov	QWORD PTR [rsp+56], r14

; 1442 :   gop.t = cfg->gop_lp_definition.t;

	mov	r14d, DWORD PTR [rcx+2416]
	mov	DWORD PTR gop$[rsp+8], r14d
	mov	DWORD PTR gop$[rsp], r10d

; 1443 : 
; 1444 :   // Initialize modulos for testing depth.
; 1445 :   // The picture belong to the lowest depth in which (poc % modulo) == 0.
; 1446 :   unsigned depth_modulos[8] = { 0 };

	movups	XMMWORD PTR depth_modulos$[rsp], xmm0
	movups	XMMWORD PTR depth_modulos$[rsp+16], xmm0
	test	ebp, ebp

; 1447 :   for (int d = 0; d < gop.d; ++d) {

	je	SHORT $LN3@kvz_config
	mov	ecx, 1
$LL4@kvz_config:

; 1448 :     depth_modulos[gop.d - 1 - d] = 1 << d;

	mov	eax, ebp
	sub	eax, edx
	inc	edx
	dec	eax
	mov	DWORD PTR depth_modulos$[rsp+rax*4], ecx
	rol	ecx, 1
	cmp	edx, ebp
	jb	SHORT $LL4@kvz_config
$LN3@kvz_config:

; 1449 :   }
; 1450 :   depth_modulos[0] = gop.g;
; 1451 : 
; 1452 :   cfg->gop_lowdelay = 1;
; 1453 :   cfg->gop_len = gop.g;

	movzx	eax, BYTE PTR gop$[rsp]

; 1454 :   for (int g = 1; g <= gop.g; ++g) {

	mov	edi, 1
	mov	DWORD PTR depth_modulos$[rsp], r10d
	mov	BYTE PTR [r9+301], 1
	mov	BYTE PTR [r9+300], al
	cmp	r10d, edi
	jb	$LN6@kvz_config
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+64], r13
	mov	r13, 4602001477788690389		; 3fdd97f62b6ae7d5H
	mov	QWORD PTR [rsp+48], r15
	movzx	r15d, BYTE PTR gop$[rsp+8]
	mov	QWORD PTR [rsp+112], rsi
	npad	2
$LL7@kvz_config:

; 1455 :     kvz_gop_config *gop_pic = &cfg->gop[g - 1];

	movsxd	r11, edi

; 1456 : 
; 1457 :     // Find gop depth for picture.
; 1458 :     int gop_layer = 1;

	mov	r8d, 1
	shl	r11, 6

; 1459 :     while (gop_layer < gop.d && (g % depth_modulos[gop_layer - 1])) {

	cmp	ebp, r8d
	jbe	SHORT $LN70@kvz_config
$LL8@kvz_config:
	xor	edx, edx
	movsxd	rcx, r8d
	mov	eax, edi
	div	DWORD PTR depth_modulos$[rsp+rcx*4-4]
	test	edx, edx
	je	SHORT $LN70@kvz_config

; 1460 :       ++gop_layer;

	inc	r8d
	cmp	r8d, ebp
	jb	SHORT $LL8@kvz_config
$LN70@kvz_config:

; 1461 :     }
; 1462 : 
; 1463 :     gop_pic->poc_offset = g;

	mov	BYTE PTR [r11+r9+249], dil

; 1464 :     gop_pic->layer = gop_layer;

	mov	BYTE PTR [r11+r9+250], r8b

; 1465 :     gop_pic->qp_offset = gop_layer;

	mov	BYTE PTR [r11+r9+248], r8b

; 1466 :     gop_pic->ref_pos_count = 0;

	mov	BYTE PTR [r11+r9+252], r12b

; 1467 :     gop_pic->ref_neg_count = cfg->ref_frames;

	movzx	eax, BYTE PTR [r9+128]
	mov	BYTE PTR [r11+r9+269], al

; 1468 :     gop_pic->is_ref = 0;

	mov	BYTE PTR [r11+r9+251], r12b

; 1469 : 
; 1470 :     // Set first ref to point to previous frame, and the rest to previous
; 1471 :     // key-frames.
; 1472 :     // If gop.t > 1, have (poc % gop.t) == 0 point gop.t frames away,
; 1473 :     // instead of the previous frame. Set the frames in between to
; 1474 :     // point to the nearest frame with a lower gop-depth.
; 1475 :     if (gop.t > 1) {

	cmp	r14d, 1
	jbe	$LN20@kvz_config

; 1476 :       if (gop_pic->poc_offset % gop.t == 0) {

	xor	edx, edx
	movsx	esi, dil
	mov	eax, esi
	div	r14d
	test	edx, edx
	jne	SHORT $LN22@kvz_config

; 1477 :         gop_pic->ref_neg[0] = gop.t;

	mov	BYTE PTR [r11+r9+270], r15b

; 1478 :       } else {

	jmp	$LN27@kvz_config
$LN22@kvz_config:

; 1479 :         int r = gop_pic->poc_offset - 1;

	lea	ebx, DWORD PTR [rsi-1]

; 1480 :         while (r > 0) {

	test	ebx, ebx
	jle	SHORT $LN71@kvz_config

; 1481 :           if (cfg->gop[r].layer < gop_pic->layer) break;

	movsxd	rdx, ebx
	lea	rcx, QWORD PTR [r9+314]
	mov	rax, rdx
	shl	rax, 6
	add	rcx, rax
$LL10@kvz_config:
	cmp	BYTE PTR [rcx], r8b
	jl	SHORT $LN71@kvz_config

; 1482 :           --r;

	dec	ebx
	dec	rdx
	sub	rcx, 64					; 00000040H
	test	rdx, rdx
	jg	SHORT $LL10@kvz_config
$LN71@kvz_config:

; 1483 :         }
; 1484 :         // Var r is now 0 or index of the pic with layer < depth.
; 1485 :         if (cfg->gop[r].layer < gop_pic->layer) {

	movsxd	rcx, ebx
	shl	rcx, 6
	cmp	BYTE PTR [rcx+r9+314], r8b
	jge	SHORT $LN25@kvz_config

; 1486 :           gop_pic->ref_neg[0] = gop_pic->poc_offset - cfg->gop[r].poc_offset;

	movzx	eax, dil
	sub	al, BYTE PTR [rcx+r9+313]
	mov	BYTE PTR [r11+r9+270], al

; 1487 :           cfg->gop[r].is_ref = 1;

	mov	BYTE PTR [rcx+r9+315], 1

; 1488 :         } else {

	jmp	SHORT $LN27@kvz_config
$LN25@kvz_config:

; 1489 :           // No ref was found, just refer to the previous key-frame.
; 1490 :           gop_pic->ref_neg[0] = gop_pic->poc_offset % gop.g;

	xor	edx, edx
	mov	eax, esi
	div	r10d
	mov	BYTE PTR [r11+r9+270], dl

; 1491 :         }
; 1492 :       }
; 1493 :     } else {

	jmp	SHORT $LN27@kvz_config
$LN20@kvz_config:

; 1494 :       gop_pic->ref_neg[0] = 1;

	mov	BYTE PTR [r11+r9+270], 1

; 1495 :       if (gop_pic->poc_offset >= 2) {

	cmp	dil, 2
	jl	SHORT $LN27@kvz_config

; 1496 :         cfg->gop[gop_pic->poc_offset - 2].is_ref = 1;

	movsx	rax, dil
	shl	rax, 6
	mov	BYTE PTR [rax+r9+187], 1
$LN27@kvz_config:

; 1497 :       }
; 1498 :     }
; 1499 : 
; 1500 :     int keyframe = gop_pic->poc_offset;

	movsx	ecx, BYTE PTR [r11+r9+249]

; 1501 :     for (int i = 1; i < gop_pic->ref_neg_count; ++i) {

	mov	r8d, 1
	cmp	BYTE PTR [r11+r9+269], r8b
	jle	SHORT $LN13@kvz_config

; 1497 :       }
; 1498 :     }
; 1499 : 
; 1500 :     int keyframe = gop_pic->poc_offset;

	lea	rdx, QWORD PTR [r9+271]
	add	rdx, r11
	npad	7
$LL14@kvz_config:

; 1502 :       while (keyframe == gop_pic->ref_neg[i - 1]) {

	movsx	eax, BYTE PTR [rdx-1]
	cmp	ecx, eax
	jne	SHORT $LN60@kvz_config
$LL15@kvz_config:

; 1503 :         keyframe += gop.g;

	add	ecx, r10d
	cmp	ecx, eax
	je	SHORT $LL15@kvz_config
$LN60@kvz_config:

; 1504 :       }
; 1505 :       gop_pic->ref_neg[i] = keyframe;

	mov	BYTE PTR [rdx], cl
	inc	r8d
	movsx	eax, BYTE PTR [r11+r9+269]
	inc	rdx
	cmp	r8d, eax
	jl	SHORT $LL14@kvz_config
$LN13@kvz_config:

; 1454 :   for (int g = 1; g <= gop.g; ++g) {

	inc	edi

; 1506 :     }
; 1507 : 
; 1508 :     gop_pic->qp_factor = 0.4624;  // from HM

	mov	QWORD PTR [r11+r9+240], r13
	cmp	edi, r10d
	jbe	$LL7@kvz_config

; 1454 :   for (int g = 1; g <= gop.g; ++g) {

	mov	r15, QWORD PTR [rsp+48]
	mov	r13, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+112]
	mov	rbx, QWORD PTR [rsp+96]
$LN6@kvz_config:

; 1509 :   }
; 1510 : 
; 1511 :   for (int g = 0; g < gop.g; ++g) {

	mov	r14, QWORD PTR [rsp+56]
	mov	r8, 4606198832641399693			; 3fec816f0068db8dH
	mov	rdi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+104]
	cmp	r10d, 4
	jb	SHORT $LC53@kvz_config
	lea	eax, DWORD PTR [r10-4]
	shr	eax, 2
	lea	rcx, QWORD PTR [r9+379]
	inc	eax
	mov	edx, eax
	lea	r12d, DWORD PTR [rax*4]
	lea	rax, QWORD PTR [rax*4]
	npad	3
$LL58@kvz_config:

; 1512 :     kvz_gop_config *gop_pic = &cfg->gop[g];
; 1513 :     if (!gop_pic->is_ref) {

	cmp	BYTE PTR [rcx-64], 0
	jne	SHORT $LN54@kvz_config

; 1514 :       gop_pic->qp_factor = 0.68 * 1.31;  // derived from HM

	mov	QWORD PTR [rcx-75], r8
$LN54@kvz_config:

; 1512 :     kvz_gop_config *gop_pic = &cfg->gop[g];
; 1513 :     if (!gop_pic->is_ref) {

	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LN55@kvz_config

; 1514 :       gop_pic->qp_factor = 0.68 * 1.31;  // derived from HM

	mov	QWORD PTR [rcx-11], r8
$LN55@kvz_config:

; 1512 :     kvz_gop_config *gop_pic = &cfg->gop[g];
; 1513 :     if (!gop_pic->is_ref) {

	cmp	BYTE PTR [rcx+64], 0
	jne	SHORT $LN56@kvz_config

; 1514 :       gop_pic->qp_factor = 0.68 * 1.31;  // derived from HM

	mov	QWORD PTR [rcx+53], r8
$LN56@kvz_config:

; 1512 :     kvz_gop_config *gop_pic = &cfg->gop[g];
; 1513 :     if (!gop_pic->is_ref) {

	cmp	BYTE PTR [rcx+128], 0
	jne	SHORT $LN57@kvz_config

; 1514 :       gop_pic->qp_factor = 0.68 * 1.31;  // derived from HM

	mov	QWORD PTR [rcx+117], r8
$LN57@kvz_config:
	add	rcx, 256				; 00000100H
	sub	rdx, 1
	jne	SHORT $LL58@kvz_config

; 1509 :   }
; 1510 : 
; 1511 :   for (int g = 0; g < gop.g; ++g) {

	cmp	r12d, r10d
	jb	SHORT $LN69@kvz_config
	jmp	SHORT $LN52@kvz_config
$LC53@kvz_config:
	test	r10d, r10d
	je	SHORT $LN52@kvz_config
	mov	rax, r12
$LN69@kvz_config:
	shl	rax, 6
	lea	rcx, QWORD PTR [r9+304]
	add	rcx, rax
	mov	edx, r10d
	sub	edx, r12d
$LC59@kvz_config:

; 1512 :     kvz_gop_config *gop_pic = &cfg->gop[g];
; 1513 :     if (!gop_pic->is_ref) {

	cmp	BYTE PTR [rcx+11], 0
	jne	SHORT $LN17@kvz_config

; 1514 :       gop_pic->qp_factor = 0.68 * 1.31;  // derived from HM

	mov	QWORD PTR [rcx], r8
$LN17@kvz_config:

; 1509 :   }
; 1510 : 
; 1511 :   for (int g = 0; g < gop.g; ++g) {

	add	rcx, 64					; 00000040H
	sub	rdx, 1
	jne	SHORT $LC59@kvz_config
$LN52@kvz_config:

; 1515 :     }
; 1516 :   }
; 1517 : 
; 1518 :   // Key-frame is always a reference.
; 1519 :   cfg->gop[gop.g - 1].is_ref = 1;

	lea	ecx, DWORD PTR [r10-1]

; 1520 :   cfg->gop[gop.g - 1].qp_factor = 0.578;  // from HM

	mov	rax, 4603381380714516709		; 3fe27ef9db22d0e5H
	shl	rcx, 6
	mov	BYTE PTR [rcx+r9+315], 1
	mov	QWORD PTR [rcx+r9+304], rax

; 1521 : }

	add	rsp, 80					; 00000050H
	pop	r12
	ret	0
kvz_config_process_lp_gop ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
cfg$ = 96
kvz_config_validate PROC

; 1533 : {

$LN108:
	push	rbx
	push	rdi
	push	r12
	push	r13
	sub	rsp, 56					; 00000038H

; 1534 :   int error = 0;

	xor	r12d, r12d
	mov	QWORD PTR [rsp+104], rsi
	mov	ebx, r12d
	mov	QWORD PTR [rsp+112], r14
	mov	rdi, rcx
	mov	QWORD PTR [rsp+48], r15

; 1535 : 
; 1536 :   if (cfg->vaq < 0) {

	lea	r13d, QWORD PTR [r12+1]
	cmp	DWORD PTR [rcx+2468], ebx
	jge	SHORT $LN11@kvz_config

; 1537 :     fprintf(stderr, "vaq strength must be positive\n");

	lea	ecx, QWORD PTR [r12+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956990
	call	fprintf

; 1538 :     error = 1;

	mov	ebx, r13d
$LN11@kvz_config:

; 1539 :   }
; 1540 : 
; 1541 :   if (cfg->width <= 0) {

	cmp	DWORD PTR [rdi+12], r12d
	jg	SHORT $LN12@kvz_config

; 1542 :     fprintf(stderr, "Input error: width must be positive\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956989
	call	fprintf

; 1543 :     error = 1;

	mov	ebx, r13d
$LN12@kvz_config:

; 1544 :   }
; 1545 : 
; 1546 :   if (cfg->height <= 0) {

	cmp	DWORD PTR [rdi+16], r12d
	jg	SHORT $LN13@kvz_config

; 1547 :     fprintf(stderr, "Input error: height must be positive\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956988
	call	fprintf

; 1548 :     error = 1;

	mov	ebx, r13d
$LN13@kvz_config:

; 1549 :   }
; 1550 : 
; 1551 :   if (cfg->width % 2 != 0) {

	test	BYTE PTR [rdi+12], r13b
	je	SHORT $LN14@kvz_config

; 1552 :     fprintf(stderr, "Input error: width must be a multiple of two\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956987
	call	fprintf

; 1553 :     error = 1;

	mov	ebx, r13d
$LN14@kvz_config:

; 1554 :   }
; 1555 : 
; 1556 :   if (cfg->height % 2 != 0) {

	test	BYTE PTR [rdi+16], r13b
	je	SHORT $LN15@kvz_config

; 1557 :     fprintf(stderr, "Input error: height must be a multiple of two\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956986
	call	fprintf

; 1558 :     error = 1;

	mov	ebx, r13d
$LN15@kvz_config:

; 1559 :   }
; 1560 : 
; 1561 :   if (cfg->width > 0 && cfg->height > 0) {

	movsxd	rsi, DWORD PTR [rdi+12]
	mov	QWORD PTR [rsp+96], rbp
	test	esi, esi
	jle	SHORT $LN17@kvz_config
	movsxd	rbp, DWORD PTR [rdi+16]
	test	ebp, ebp
	jle	SHORT $LN17@kvz_config

; 1562 :     // We must be able to store the total number of luma and chroma pixels
; 1563 :     // in an int32_t. For 4:4:4 chroma mode, the number of pixels is
; 1564 :     // 3 * width * height. Width and height are rounded up to a multiple of
; 1565 :     // LCU size.
; 1566 :     const uint32_t max_lcus = INT_MAX / (3 * LCU_WIDTH * LCU_WIDTH);
; 1567 :     const uint64_t num_lcus = CEILDIV((uint64_t)cfg->width,  LCU_WIDTH) *

	lea	rcx, QWORD PTR [rbp+63]
	shr	rcx, 6
	lea	rax, QWORD PTR [rsi+63]
	shr	rax, 6
	imul	rcx, rax

; 1568 :                               CEILDIV((uint64_t)cfg->height, LCU_WIDTH);
; 1569 :     if (num_lcus > max_lcus) {

	cmp	rcx, 174762				; 0002aaaaH
	jbe	SHORT $LN17@kvz_config

; 1570 :       fprintf(stderr, "Input error: resolution %dx%d too large (max %u CTUs)\n",

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, ebp
	mov	DWORD PTR [rsp+32], 174762		; 0002aaaaH
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956985
	mov	r8d, esi
	call	fprintf

; 1571 :               cfg->width, cfg->height, max_lcus);
; 1572 :       error = 1;

	mov	ebx, r13d
$LN17@kvz_config:

; 1573 :     }
; 1574 :   }
; 1575 : 
; 1576 :   if (cfg->framerate < 0.0) {

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR [rdi+24]
	jbe	SHORT $LN18@kvz_config

; 1577 :     fprintf(stderr, "Input error: --input-fps must be positive\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956984
	call	fprintf

; 1578 :     error = 1;

	mov	ebx, r13d
$LN18@kvz_config:

; 1579 :   }
; 1580 :   if (cfg->framerate_num < 0) {

	cmp	DWORD PTR [rdi+32], r12d
	jge	SHORT $LN19@kvz_config

; 1581 :     fprintf(stderr, "Input error: --input-fps must >=0\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956983
	call	fprintf

; 1582 :     error = 1;

	mov	ebx, r13d
$LN19@kvz_config:

; 1583 :   }
; 1584 :   if (cfg->framerate_denom <= 0) {

	cmp	DWORD PTR [rdi+36], r12d
	jg	SHORT $LN20@kvz_config

; 1585 :     fprintf(stderr, "Input error: --input-fps denominator must be >0\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956982
	call	fprintf

; 1586 :     error = 1;

	mov	ebx, r13d
$LN20@kvz_config:

; 1587 :   }
; 1588 : 
; 1589 :   if (cfg->gop_len &&
; 1590 :       cfg->intra_period > 1 &&
; 1591 :       !cfg->gop_lowdelay &&

	movsx	eax, BYTE PTR [rdi+300]
	test	al, al
	je	SHORT $LN21@kvz_config
	mov	esi, DWORD PTR [rdi+4]
	cmp	esi, r13d
	jle	SHORT $LN21@kvz_config
	cmp	BYTE PTR [rdi+301], r12b
	jne	SHORT $LN21@kvz_config
	mov	ebp, eax
	mov	eax, esi
	cdq
	idiv	ebp
	test	edx, edx
	je	SHORT $LN21@kvz_config

; 1592 :       cfg->intra_period % cfg->gop_len != 0)
; 1593 :   {
; 1594 :     fprintf(stderr,

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, ebp
	lea	rdx, OFFSET FLAT:$SG4294956981
	mov	rcx, rax
	mov	r8d, esi
	call	fprintf

; 1595 :             "Input error: intra period (%d) not a multiple of B-gop length (%d)\n",
; 1596 :             cfg->intra_period,
; 1597 :             cfg->gop_len);
; 1598 :     error = 1;

	mov	ebx, r13d
$LN21@kvz_config:

; 1599 :   }
; 1600 : 
; 1601 :   if (cfg->ref_frames  < 1 || cfg->ref_frames >= MAX_REF_PIC_COUNT) {

	mov	eax, DWORD PTR [rdi+128]
	dec	eax
	cmp	eax, 14
	jbe	SHORT $LN22@kvz_config

; 1602 :     fprintf(stderr, "Input error: --ref out of range [1..%d]\n", MAX_REF_PIC_COUNT - 1);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, 15
	lea	rdx, OFFSET FLAT:$SG4294956980
	mov	rcx, rax
	call	fprintf

; 1603 :     error = 1;

	mov	ebx, r13d
$LN22@kvz_config:

; 1604 :   }
; 1605 : 
; 1606 :   if (cfg->deblock_beta  < -6 || cfg->deblock_beta  > 6) {

	mov	eax, DWORD PTR [rdi+96]
	add	eax, 6
	cmp	eax, 12
	jbe	SHORT $LN24@kvz_config

; 1607 :     fprintf(stderr, "Input error: deblock beta parameter out of range [-6..6]\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956979
	call	fprintf

; 1608 :     error = 1;

	mov	ebx, r13d
$LN24@kvz_config:

; 1609 :   }
; 1610 :   if (cfg->deblock_tc < -6 || cfg->deblock_tc > 6) {

	mov	eax, DWORD PTR [rdi+100]
	add	eax, 6
	cmp	eax, 12
	jbe	SHORT $LN26@kvz_config

; 1611 :     fprintf(stderr, "Input error: deblock tc parameter out of range [-6..6]\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956978
	call	fprintf

; 1612 :     error = 1;

	mov	ebx, r13d
$LN26@kvz_config:

; 1613 :   }
; 1614 : 
; 1615 :   if (cfg->rdo < 0 || cfg->rdo > 3) {

	cmp	DWORD PTR [rdi+64], 3
	jbe	SHORT $LN28@kvz_config

; 1616 :     fprintf(stderr, "Input error: --rd parameter out of range [0..3]\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956977
	call	fprintf

; 1617 :     error = 1;

	mov	ebx, r13d
$LN28@kvz_config:

; 1618 :   }
; 1619 : 
; 1620 :   if (cfg->tr_depth_intra < 0 || cfg->tr_depth_intra > 4) {

	cmp	DWORD PTR [rdi+76], 4
	jbe	SHORT $LN30@kvz_config

; 1621 :     // range is 0 .. CtbLog2SizeY - Log2MinTrafoSize
; 1622 :     fprintf(stderr, "Input error: --tr-depth-intra is out of range [0..4]\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956976
	call	fprintf

; 1623 :     error = 1;

	mov	ebx, r13d
$LN30@kvz_config:

; 1624 :   }
; 1625 : 
; 1626 :   if (cfg->fme_level != 0 && cfg->fme_level > 4) {

	cmp	DWORD PTR [rdi+84], 5
	jl	SHORT $LN32@kvz_config

; 1627 :     fprintf(stderr, "Input error: invalid --subme parameter (must be in range 0-4)\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956975
	call	fprintf

; 1628 :     error = 1;

	mov	ebx, r13d
$LN32@kvz_config:

; 1629 :   }
; 1630 : 
; 1631 :   if (cfg->vui.chroma_loc < 0 || cfg->vui.chroma_loc > 5) {

	cmp	DWORD PTR [rdi+120], 5
	jbe	SHORT $LN33@kvz_config

; 1632 :     fprintf(stderr, "Input error: --chromaloc parameter out of range [0..5]\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956974
	call	fprintf

; 1633 :     error = 1;

	mov	ebx, r13d
$LN33@kvz_config:

; 1634 :   }
; 1635 : 
; 1636 :   if (cfg->owf < -1) {

	cmp	DWORD PTR [rdi+172], -1
	jge	SHORT $LN35@kvz_config

; 1637 :     fprintf(stderr, "Input error: --owf must be nonnegative or -1\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956973
	call	fprintf

; 1638 :     error = 1;

	mov	ebx, r13d
$LN35@kvz_config:

; 1639 :   }
; 1640 : 
; 1641 :   if (cfg->qp != CLIP_TO_QP(cfg->qp)) {

	cmp	DWORD PTR [rdi], 51			; 00000033H
	jbe	SHORT $LN36@kvz_config

; 1642 :       fprintf(stderr, "Input error: --qp parameter out of range [0..51]\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956972
	call	fprintf

; 1643 :       error = 1;

	mov	ebx, r13d
$LN36@kvz_config:

; 1644 :   }
; 1645 : 
; 1646 :   if (abs(cfg->intra_qp_offset) > 51) {

	movsx	eax, BYTE PTR [rdi+2460]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 51					; 00000033H
	jle	SHORT $LN37@kvz_config

; 1647 :     fprintf(stderr, "Input error: --intra-qp-offset out of range [-51..51]\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956971
	call	fprintf

; 1648 :     error = 1;

	mov	ebx, r13d
$LN37@kvz_config:

; 1649 :   }
; 1650 : 
; 1651 :   if (cfg->target_bitrate < 0) {

	cmp	DWORD PTR [rdi+2352], r12d
	jge	SHORT $LN38@kvz_config

; 1652 :       fprintf(stderr, "Input error: --bitrate must be nonnegative\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956970
	call	fprintf

; 1653 :       error = 1;

	mov	ebx, r13d
$LN38@kvz_config:

; 1654 :   }
; 1655 : 
; 1656 :   for( size_t i = 0; i < KVZ_MAX_GOP_LAYERS; i++ )

	lea	r14, QWORD PTR [rdi+224]
	mov	r15d, 6
$LL4@kvz_config:

; 1657 :   {
; 1658 :       if( cfg->pu_depth_inter.min[i] < 0 || cfg->pu_depth_inter.max[i] < 0 ) continue;

	mov	esi, DWORD PTR [r14-24]
	test	esi, esi
	js	$LN2@kvz_config
	mov	ebp, DWORD PTR [r14]
	test	ebp, ebp
	js	$LN2@kvz_config

; 1659 : 
; 1660 :       if( !WITHIN( cfg->pu_depth_inter.min[i], PU_DEPTH_INTER_MIN, PU_DEPTH_INTER_MAX ) ||

	cmp	esi, 3
	ja	SHORT $LN44@kvz_config
	cmp	ebp, 3
	ja	SHORT $LN44@kvz_config

; 1664 :                    cfg->pu_depth_inter.min[i], cfg->pu_depth_inter.max[i] );
; 1665 :           error = 1;
; 1666 :       }
; 1667 :       else if( cfg->pu_depth_inter.min[i] > cfg->pu_depth_inter.max[i] )

	cmp	esi, ebp
	jle	SHORT $LN45@kvz_config

; 1668 :       {
; 1669 :           fprintf( stderr, "Input error: Inter PU depth min (%d) > max (%d)\n",

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294956968

; 1670 :                    cfg->pu_depth_inter.min[i], cfg->pu_depth_inter.max[i] );
; 1671 :           error = 1;

	jmp	SHORT $LN102@kvz_config
$LN44@kvz_config:

; 1661 :           !WITHIN( cfg->pu_depth_inter.max[i], PU_DEPTH_INTER_MIN, PU_DEPTH_INTER_MAX ) )
; 1662 :       {
; 1663 :           fprintf( stderr, "Input error: illegal value for --pu-depth-inter (%d-%d)\n",

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294956969
$LN102@kvz_config:

; 1672 :       }
; 1673 : 
; 1674 :       if( cfg->pu_depth_intra.min[i] < 0 || cfg->pu_depth_intra.max[i] < 0 ) continue;

	mov	r9d, ebp
	mov	r8d, esi
	mov	rcx, rax
	call	fprintf
	mov	ebx, r13d
$LN45@kvz_config:
	mov	esi, DWORD PTR [r14+24]
	test	esi, esi
	js	SHORT $LN2@kvz_config
	mov	ebp, DWORD PTR [r14+48]
	test	ebp, ebp
	js	SHORT $LN2@kvz_config

; 1675 : 
; 1676 :       if( !WITHIN( cfg->pu_depth_intra.min[i], PU_DEPTH_INTRA_MIN, PU_DEPTH_INTRA_MAX ) ||

	cmp	esi, 4
	ja	SHORT $LN51@kvz_config
	cmp	ebp, 4
	ja	SHORT $LN51@kvz_config

; 1680 :                    cfg->pu_depth_intra.min[i], cfg->pu_depth_intra.max[i] );
; 1681 :           error = 1;
; 1682 :       }
; 1683 :       else if( cfg->pu_depth_intra.min[i] > cfg->pu_depth_intra.max[i] )

	cmp	esi, ebp
	jle	SHORT $LN2@kvz_config

; 1684 :       {
; 1685 :           fprintf( stderr, "Input error: Intra PU depth min (%d) > max (%d)\n",

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294956966

; 1686 :                    cfg->pu_depth_intra.min[i], cfg->pu_depth_intra.max[i] );
; 1687 :           error = 1;

	jmp	SHORT $LN103@kvz_config
$LN51@kvz_config:

; 1677 :           !WITHIN( cfg->pu_depth_intra.max[i], PU_DEPTH_INTRA_MIN, PU_DEPTH_INTRA_MAX ) )
; 1678 :       {
; 1679 :           fprintf( stderr, "Input error: illegal value for --pu-depth-intra (%d-%d)\n",

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294956967
$LN103@kvz_config:

; 1654 :   }
; 1655 : 
; 1656 :   for( size_t i = 0; i < KVZ_MAX_GOP_LAYERS; i++ )

	mov	r9d, ebp
	mov	r8d, esi
	mov	rcx, rax
	call	fprintf
	mov	ebx, r13d
$LN2@kvz_config:
	add	r14, 4
	sub	r15, r13
	jne	$LL4@kvz_config

; 1688 :       }
; 1689 :   }
; 1690 : 
; 1691 :   // Tile separation should be at round position in terms of LCU, should be monotonic, and should not start by 0
; 1692 :   if (cfg->tiles_width_split) {

	mov	r14, QWORD PTR [rdi+152]
	mov	r15, QWORD PTR [rsp+48]
	test	r14, r14
	je	$LN56@kvz_config

; 1693 :     int i;
; 1694 :     int32_t prev_tile_split = 0;
; 1695 :     for (i=0; i < cfg->tiles_width_count - 1; ++i) {

	mov	eax, DWORD PTR [rdi+144]
	mov	esi, r12d
	dec	eax
	mov	ebp, r12d
	test	eax, eax
	jle	$LN6@kvz_config
	movsxd	r8, eax
	mov	rcx, r12
$LL7@kvz_config:

; 1696 :       if (cfg->tiles_width_split[i] <= prev_tile_split) {

	mov	edx, DWORD PTR [r14+rcx*4]
	cmp	edx, esi
	jle	SHORT $LN77@kvz_config

; 1698 :         error = 1;
; 1699 :         break;
; 1700 :       }
; 1701 :       if ((cfg->tiles_width_split[i] % LCU_WIDTH) != 0) {

	mov	eax, edx
	and	eax, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN101@kvz_config
	dec	eax
	or	eax, -64				; ffffffffffffffc0H
	inc	eax
$LN101@kvz_config:
	test	eax, eax
	jne	SHORT $LN78@kvz_config

; 1693 :     int i;
; 1694 :     int32_t prev_tile_split = 0;
; 1695 :     for (i=0; i < cfg->tiles_width_count - 1; ++i) {

	inc	ebp
	inc	rcx

; 1704 :         break;
; 1705 :       }
; 1706 :       prev_tile_split = cfg->tiles_width_split[i];

	mov	esi, edx
	cmp	rcx, r8
	jl	SHORT $LL7@kvz_config

; 1720 :         error = 1;
; 1721 :         break;
; 1722 :       }
; 1723 :       if ((cfg->tiles_height_split[i] % LCU_WIDTH) != 0) {

	jmp	SHORT $LN6@kvz_config
$LN78@kvz_config:

; 1702 :         fprintf(stderr, "Input error: tile separation in width %d (at %d) is not at a multiple of LCU_WIDTH (%d)\n", i, cfg->tiles_width_split[i], LCU_WIDTH);

	mov	ecx, 2
	mov	ebx, ebp
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [r14+rbx*4]
	lea	rdx, OFFSET FLAT:$SG4294956964
	mov	rcx, rax
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	mov	r8d, ebp
	call	fprintf

; 1703 :         error = 1;

	jmp	SHORT $LN104@kvz_config
$LN77@kvz_config:

; 1697 :         fprintf(stderr, "Input error: tile separations in width should be strictly monotonic (%d <= %d)\n", cfg->tiles_width_split[i], prev_tile_split);

	mov	ecx, 2
	mov	ebx, ebp
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, DWORD PTR [r14+rbx*4]
	lea	rdx, OFFSET FLAT:$SG4294956965
	mov	rcx, rax
	mov	r9d, esi
	call	fprintf
$LN104@kvz_config:

; 1707 :     }
; 1708 :     if (cfg->tiles_width_split[cfg->tiles_width_count - 2] >= cfg->width) {

	mov	ebx, r13d
$LN6@kvz_config:
	movsxd	rcx, DWORD PTR [rdi+144]
	mov	rax, QWORD PTR [rdi+152]
	mov	ebp, DWORD PTR [rdi+12]
	mov	esi, DWORD PTR [rax+rcx*4-8]
	cmp	esi, ebp
	jl	SHORT $LN56@kvz_config

; 1709 :       fprintf(stderr, "Input error: last x tile separation in width (%d) should smaller than image width (%d)\n", cfg->tiles_width_split[cfg->tiles_width_count - 2], cfg->width);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, ebp
	lea	rdx, OFFSET FLAT:$SG4294956963
	mov	rcx, rax
	mov	r8d, esi
	call	fprintf

; 1710 :       error = 1;

	mov	ebx, r13d
$LN56@kvz_config:

; 1711 :     }
; 1712 :   }
; 1713 : 
; 1714 :   if (cfg->tiles_height_split) {

	mov	r14, QWORD PTR [rdi+160]
	test	r14, r14
	je	$LN60@kvz_config

; 1715 :     int i;
; 1716 :     int32_t prev_tile_split = 0;
; 1717 :     for (i=0; i < cfg->tiles_height_count - 1; ++i) {

	mov	eax, DWORD PTR [rdi+148]
	mov	esi, r12d
	dec	eax
	mov	ebp, r12d
	test	eax, eax
	jle	$LN9@kvz_config
	movsxd	r8, eax
	mov	rcx, r12
$LL10@kvz_config:

; 1718 :       if (cfg->tiles_height_split[i] <= prev_tile_split) {

	mov	edx, DWORD PTR [r14+rcx*4]
	cmp	edx, esi
	jle	SHORT $LN79@kvz_config

; 1720 :         error = 1;
; 1721 :         break;
; 1722 :       }
; 1723 :       if ((cfg->tiles_height_split[i] % LCU_WIDTH) != 0) {

	mov	eax, edx
	and	eax, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN100@kvz_config
	dec	eax
	or	eax, -64				; ffffffffffffffc0H
	inc	eax
$LN100@kvz_config:
	test	eax, eax
	jne	SHORT $LN80@kvz_config

; 1715 :     int i;
; 1716 :     int32_t prev_tile_split = 0;
; 1717 :     for (i=0; i < cfg->tiles_height_count - 1; ++i) {

	inc	ebp
	inc	rcx

; 1726 :         break;
; 1727 :       }
; 1728 :       prev_tile_split = cfg->tiles_height_split[i];

	mov	esi, edx
	cmp	rcx, r8
	jl	SHORT $LL10@kvz_config

; 1720 :         error = 1;
; 1721 :         break;
; 1722 :       }
; 1723 :       if ((cfg->tiles_height_split[i] % LCU_WIDTH) != 0) {

	jmp	SHORT $LN9@kvz_config
$LN80@kvz_config:

; 1724 :         fprintf(stderr, "Input error: tile separation in height %d (at %d) is not at a multiple of LCU_WIDTH (%d)\n", i, cfg->tiles_height_split[i], LCU_WIDTH);

	mov	ecx, 2
	mov	ebx, ebp
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [r14+rbx*4]
	lea	rdx, OFFSET FLAT:$SG4294956961
	mov	rcx, rax
	mov	DWORD PTR [rsp+32], 64			; 00000040H
	mov	r8d, ebp
	call	fprintf

; 1725 :         error = 1;

	jmp	SHORT $LN105@kvz_config
$LN79@kvz_config:

; 1719 :         fprintf(stderr, "Input error: tile separations in height should be strictly monotonic (%d <= %d)\n", cfg->tiles_height_split[i], prev_tile_split);

	mov	ecx, 2
	mov	ebx, ebp
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8d, DWORD PTR [r14+rbx*4]
	lea	rdx, OFFSET FLAT:$SG4294956962
	mov	rcx, rax
	mov	r9d, esi
	call	fprintf
$LN105@kvz_config:

; 1729 :     }
; 1730 : 
; 1731 :     if (cfg->tiles_height_split[cfg->tiles_height_count - 2] >= cfg->height) {

	mov	ebx, r13d
$LN9@kvz_config:
	movsxd	rcx, DWORD PTR [rdi+148]
	mov	rax, QWORD PTR [rdi+160]
	mov	ebp, DWORD PTR [rdi+16]
	mov	esi, DWORD PTR [rax+rcx*4-8]
	cmp	esi, ebp
	jl	SHORT $LN60@kvz_config

; 1732 :       fprintf(stderr, "Input error: last tile separation in height (%d) should smaller than image height (%d)\n", cfg->tiles_height_split[cfg->tiles_height_count - 2], cfg->height);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, ebp
	lea	rdx, OFFSET FLAT:$SG4294956960
	mov	rcx, rax
	mov	r8d, esi
	call	fprintf

; 1733 :       error = 1;

	mov	ebx, r13d
$LN60@kvz_config:

; 1734 :     }
; 1735 :   }
; 1736 : 
; 1737 :   if (cfg->implicit_rdpcm && !cfg->lossless) {

	mov	r14, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+96]
	cmp	DWORD PTR [rdi+2420], r12d
	je	SHORT $LN61@kvz_config
	cmp	DWORD PTR [rdi+2392], r12d
	jne	SHORT $LN61@kvz_config

; 1738 :     fprintf(stderr, "Input error: --implicit-rdpcm is not suppoted without --lossless\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956959
	call	fprintf

; 1739 :     error = 1;

	mov	ebx, r13d
$LN61@kvz_config:

; 1740 :   }
; 1741 : 
; 1742 :   if ((cfg->slices & KVZ_SLICES_WPP) && !cfg->wpp) {

	test	BYTE PTR [rdi+2440], 2
	je	SHORT $LN62@kvz_config
	cmp	DWORD PTR [rdi+168], r12d
	jne	SHORT $LN62@kvz_config

; 1743 :     fprintf(stderr, "Input error: --slices=wpp does not work without --wpp.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956958
	call	fprintf

; 1744 :     error = 1;

	mov	ebx, r13d
$LN62@kvz_config:

; 1745 :   }
; 1746 : 
; 1747 :   if ((cfg->scaling_list == KVZ_SCALING_LIST_CUSTOM) && !cfg->cqmfile) {

	cmp	BYTE PTR [rdi+2472], r13b
	jne	SHORT $LN63@kvz_config
	cmp	QWORD PTR [rdi+136], r12
	jne	SHORT $LN63@kvz_config

; 1748 :     fprintf(stderr, "Input error: --scaling-list=custom does not work without --cqmfile=<FILE>.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956957
	call	fprintf

; 1749 :     error = 1;

	mov	ebx, r13d
$LN63@kvz_config:

; 1750 :   }
; 1751 : 
; 1752 :   if (validate_hevc_level((kvz_config *const) cfg)) {

	mov	rcx, rdi
	call	validate_hevc_level
	test	eax, eax

; 1753 :     // a level error found and it's not okay
; 1754 :     error = 1;
; 1755 :   }
; 1756 : 
; 1757 :   if(cfg->target_bitrate > 0 && cfg->rc_algorithm == KVZ_NO_RC) {

	mov	eax, DWORD PTR [rdi+2352]
	cmovne	ebx, r13d
	test	eax, eax
	jle	SHORT $LN106@kvz_config
	cmp	BYTE PTR [rdi+2484], r12b
	jne	SHORT $LN66@kvz_config

; 1758 :     fprintf(stderr, "Bitrate set but rc-algorithm is turned off.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956956
	call	fprintf

; 1759 :     error = 1;

	mov	eax, DWORD PTR [rdi+2352]
	mov	ebx, r13d

; 1760 :   }
; 1761 : 
; 1762 :   if(cfg->target_bitrate == 0 && cfg->rc_algorithm != KVZ_NO_RC) {

	test	eax, eax
$LN106@kvz_config:
	jne	SHORT $LN66@kvz_config
	cmp	BYTE PTR [rdi+2484], r12b
	je	SHORT $LN66@kvz_config

; 1763 :     fprintf(stderr, "Rate control algorithm set but bitrate not set.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956955
	call	fprintf

; 1764 :     error = 1;

	mov	ebx, r13d
$LN66@kvz_config:

; 1765 :   }
; 1766 : 
; 1767 :   return !error;

	test	ebx, ebx
	sete	r12b
	mov	eax, r12d

; 1768 : }

	add	rsp, 56					; 00000038H
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx
	ret	0
kvz_config_validate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfscanf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfscanf_l PROC						; COMDAT

; 1062 :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 1063 :         return __stdio_common_vfscanf(

	call	__local_stdio_scanf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfscanf

; 1064 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 1065 :             _Stream, _Format, _Locale, _ArgList);
; 1066 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT fscanf
_TEXT	SEGMENT
_Stream$ = 80
_Format$ = 88
fscanf	PROC						; COMDAT

; 1204 :     {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx

; 1205 :         int _Result;
; 1206 :         va_list _ArgList;
; 1207 :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rbx, rcx

; 1063 :         return __stdio_common_vfscanf(

	call	__local_stdio_scanf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfscanf

; 1208 :         _Result = _vfscanf_l(_Stream, _Format, NULL, _ArgList);
; 1209 :         __crt_va_end(_ArgList);
; 1210 :         return _Result;
; 1211 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
fscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
str$ = 8
atobool	PROC

; 208  :   if (!strcmp(str, "1")    ||
; 209  :       !strcmp(str, "true") ||

	lea	r9, OFFSET FLAT:$SG4294957751
	mov	rax, rcx
	sub	r9, rcx
	npad	3
$LL17@atobool:
	movzx	r8d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r9]
	sub	r8d, edx
	jne	SHORT $LN18@atobool
	inc	rax
	test	edx, edx
	jne	SHORT $LL17@atobool
$LN18@atobool:
	test	r8d, r8d
	je	$LN3@atobool
	lea	r9, OFFSET FLAT:$SG4294957750
	mov	rax, rcx
	sub	r9, rcx
	npad	5
$LL15@atobool:
	movzx	r8d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r9]
	sub	r8d, edx
	jne	SHORT $LN16@atobool
	inc	rax
	test	edx, edx
	jne	SHORT $LL15@atobool
$LN16@atobool:
	test	r8d, r8d
	je	$LN3@atobool
	lea	r9, OFFSET FLAT:$SG4294957749
	mov	rax, rcx
	sub	r9, rcx
	npad	5
$LL13@atobool:
	movzx	r8d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r9]
	sub	r8d, edx
	jne	SHORT $LN14@atobool
	inc	rax
	test	edx, edx
	jne	SHORT $LL13@atobool
$LN14@atobool:
	test	r8d, r8d
	je	$LN3@atobool

; 212  :   if (!strcmp(str, "0")     ||
; 213  :       !strcmp(str, "false") ||

	lea	r9, OFFSET FLAT:$SG4294957748
	mov	rax, rcx
	sub	r9, rcx
	npad	5
$LL11@atobool:
	movzx	r8d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r9]
	sub	r8d, edx
	jne	SHORT $LN12@atobool
	inc	rax
	test	edx, edx
	jne	SHORT $LL11@atobool
$LN12@atobool:
	test	r8d, r8d
	je	SHORT $LN5@atobool
	lea	r9, OFFSET FLAT:$SG4294957747
	mov	rax, rcx
	sub	r9, rcx
	npad	9
$LL9@atobool:
	movzx	r8d, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+r9]
	sub	r8d, edx
	jne	SHORT $LN10@atobool
	inc	rax
	test	edx, edx
	jne	SHORT $LL9@atobool
$LN10@atobool:
	test	r8d, r8d
	je	SHORT $LN5@atobool
	lea	r8, OFFSET FLAT:$SG4294957746
	sub	r8, rcx
$LL7@atobool:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN5@atobool
	inc	rcx
	test	eax, eax
	jne	SHORT $LL7@atobool
$LN5@atobool:

; 214  :       !strcmp(str, "no"))
; 215  :     return 0;
; 216  :   return 0;
; 217  : }

	xor	eax, eax
	ret	0
$LN3@atobool:

; 210  :       !strcmp(str, "yes"))
; 211  :     return 1;

	mov	eax, 1

; 214  :       !strcmp(str, "no"))
; 215  :     return 0;
; 216  :   return 0;
; 217  : }

	ret	0
atobool	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
arg$ = 48
num_chars$ = 56
names$ = 64
dst$ = 72
parse_enum_n PROC

; 220  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 221  :   int8_t i;
; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR [r8]
	xor	bl, bl
	mov	r14, r9
	mov	rdi, r8
	mov	rbp, rcx
	test	rax, rax
	je	SHORT $LN3@parse_enum
	mov	esi, edx
	npad	1
$LL4@parse_enum:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8, rsi
	mov	rdx, rax
	mov	rcx, rbp
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN8@parse_enum

; 221  :   int8_t i;
; 222  :   for (i = 0; names[i]; i++) {

	inc	bl
	movsx	rax, bl
	mov	rax, QWORD PTR [rdi+rax*8]
	test	rax, rax
	jne	SHORT $LL4@parse_enum
$LN3@parse_enum:

; 226  :     }
; 227  :   }
; 228  : 
; 229  :   return 0;

	xor	eax, eax
$LN1@parse_enum:

; 230  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN8@parse_enum:

; 224  :       *dst = i;

	mov	BYTE PTR [r14], bl

; 225  :       return 1;

	mov	eax, 1
	jmp	SHORT $LN1@parse_enum
parse_enum_n ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
arg$ = 48
names$ = 56
dst$ = 64
parse_enum PROC

; 233  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 222  :   for (i = 0; names[i]; i++) {

	mov	rax, QWORD PTR [rdx]
	xor	bl, bl

; 233  : {

	mov	r14, r8
	mov	rdi, rdx
	mov	rsi, rcx

; 222  :   for (i = 0; names[i]; i++) {

	test	rax, rax
	je	SHORT $LN5@parse_enum
	npad	8
$LL6@parse_enum:

; 223  :     if (!strncmp(arg, names[i], num_chars)) {

	mov	r8d, 255				; 000000ffH
	mov	rdx, rax
	mov	rcx, rsi
	call	QWORD PTR __imp_strncmp
	test	eax, eax
	je	SHORT $LN10@parse_enum

; 222  :   for (i = 0; names[i]; i++) {

	inc	bl
	movsx	rax, bl
	mov	rax, QWORD PTR [rdi+rax*8]
	test	rax, rax
	jne	SHORT $LL6@parse_enum
$LN5@parse_enum:

; 234  :   return parse_enum_n(arg, 255, names, dst);

	xor	eax, eax
$LN3@parse_enum:

; 235  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN10@parse_enum:

; 224  :       *dst = i;

	mov	BYTE PTR [r14], bl

; 234  :   return parse_enum_n(arg, 255, names, dst);

	mov	eax, 1

; 225  :       return 1;

	jmp	SHORT $LN3@parse_enum
parse_enum ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
values$ = 32
current_value$ = 256
arg$ = 256
ntiles$ = 264
array$ = 272
parse_tiles_specification PROC

; 237  : static int parse_tiles_specification(const char* const arg, int32_t * const ntiles, int32_t** const array) {

	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 224				; 000000e0H
	mov	rbx, rcx

; 238  :   const char* current_arg = NULL;
; 239  :   int32_t current_value;
; 240  :   int32_t values[MAX_TILES_PER_DIM];
; 241  : 
; 242  :   int i;
; 243  : 
; 244  :   //Free pointer in any case
; 245  :   if (*array) {

	xor	edi, edi
	mov	rcx, QWORD PTR [r8]
	mov	r14, r8
	mov	rsi, rdx
	test	rcx, rcx
	je	SHORT $LN8@parse_tile

; 246  :     FREE_POINTER(*array);

	call	QWORD PTR __imp_free
	mov	QWORD PTR [r14], rdi
$LN8@parse_tile:

; 247  :   }
; 248  : 
; 249  :   //If the arg starts with u, we want an uniform split
; 250  :   if (arg[0]=='u') {

	cmp	BYTE PTR [rbx], 117			; 00000075H
	jne	SHORT $LN9@parse_tile

; 251  :     *ntiles = atoi(arg + 1);

	lea	rcx, QWORD PTR [rbx+1]
	call	QWORD PTR __imp_atoi
	mov	ebx, eax
	mov	DWORD PTR [rsi], eax

; 252  :     if (MAX_TILES_PER_DIM <= *ntiles || 1 >= *ntiles) {

	lea	ecx, DWORD PTR [rax-2]
	cmp	ecx, 45					; 0000002dH
	ja	SHORT $LN11@parse_tile

; 255  :     }
; 256  :     //Done with parsing
; 257  :     return 1;

	mov	eax, 1
	jmp	$LN1@parse_tile
$LN11@parse_tile:

; 253  :       fprintf(stderr, "Invalid number of tiles (1 <= %d <= %d = MAX_TILES_PER_DIM)!\n", *ntiles, MAX_TILES_PER_DIM);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, 48					; 00000030H
	lea	rdx, OFFSET FLAT:$SG4294957745
	mov	rcx, rax
	mov	r8d, ebx
	call	fprintf

; 254  :       return 0;

	xor	eax, eax
	jmp	$LN1@parse_tile
$LN9@parse_tile:

; 258  :   }
; 259  : 
; 260  :   //We have a comma-separated list of int for the split...
; 261  :   current_arg = arg;
; 262  :   *ntiles = 1;

	mov	DWORD PTR [rsi], 1
	mov	QWORD PTR [rsp+264], rbp
	npad	7
$LL4@parse_tile:

; 263  :   do {
; 264  :     int ret = sscanf(current_arg, "%d", &current_value);

	lea	r8, QWORD PTR current_value$[rsp]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG4294957744
	call	sscanf

; 265  :     if (ret != 1) {

	cmp	eax, 1
	jne	$LN21@parse_tile

; 268  :     }
; 269  :     current_arg = strchr(current_arg, ',');

	lea	edx, QWORD PTR [rax+43]
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rbx, rax

; 270  :     //Skip the , if we found one
; 271  :     if (current_arg) ++current_arg;

	test	rax, rax
	je	SHORT $LN13@parse_tile
	inc	rbx
$LN13@parse_tile:

; 272  :     values[*ntiles - 1] = current_value;

	movsxd	rdx, DWORD PTR [rsi]
	mov	eax, DWORD PTR current_value$[rsp]

; 273  :     ++(*ntiles);

	lea	ebp, DWORD PTR [rdx+1]
	mov	DWORD PTR values$[rsp+rdx*4-4], eax
	mov	DWORD PTR [rsi], ebp

; 274  :     if (MAX_TILES_PER_DIM <= *ntiles) break;

	cmp	ebp, 48					; 00000030H
	jge	SHORT $LN3@parse_tile

; 275  :   } while (current_arg);

	test	rbx, rbx
	jne	SHORT $LL4@parse_tile
$LN3@parse_tile:

; 276  : 
; 277  :   if (MAX_TILES_PER_DIM <= *ntiles || 1 >= *ntiles) {

	lea	eax, DWORD PTR [rbp-2]
	cmp	eax, 45					; 0000002dH
	ja	SHORT $LN16@parse_tile

; 280  :   }
; 281  : 
; 282  :   *array = MALLOC(int32_t, *ntiles - 1);

	mov	rcx, rdx
	shl	rcx, 2
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14], rax

; 283  :   if (!*array) {

	test	rax, rax
	jne	SHORT $LN17@parse_tile

; 284  :     fprintf(stderr, "Could not allocate array for tiles\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957741
	call	fprintf

; 285  :     return 0;

	jmp	SHORT $LN29@parse_tile
$LN17@parse_tile:

; 286  :   }
; 287  : 
; 288  :   //TODO: memcpy?
; 289  :   for (i = 0; i < *ntiles - 1; ++i) {

	mov	eax, DWORD PTR [rsi]
	dec	eax
	test	eax, eax
	jle	SHORT $LN6@parse_tile
	mov	rdx, rdi
	npad	10
$LL7@parse_tile:

; 290  :     (*array)[i] = values[i];

	mov	eax, DWORD PTR values$[rsp+rdx]
	lea	rdx, QWORD PTR [rdx+4]
	mov	rcx, QWORD PTR [r14]
	inc	edi
	mov	DWORD PTR [rdx+rcx-4], eax
	mov	eax, DWORD PTR [rsi]
	dec	eax
	cmp	edi, eax
	jl	SHORT $LL7@parse_tile
$LN6@parse_tile:

; 291  :   }
; 292  : 
; 293  :   return 1;

	mov	eax, 1
	jmp	SHORT $LN28@parse_tile
$LN16@parse_tile:

; 278  :     fprintf(stderr, "Invalid number of tiles (1 <= %d <= %d = MAX_TILES_PER_DIM)!\n", *ntiles, MAX_TILES_PER_DIM);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, 48					; 00000030H
	lea	rdx, OFFSET FLAT:$SG4294957742
	mov	rcx, rax
	mov	r8d, ebp
	call	fprintf

; 279  :     return 0;

	jmp	SHORT $LN29@parse_tile
$LN21@parse_tile:

; 266  :       fprintf(stderr, "Could not parse integer \"%s\"!\n", current_arg);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8, rbx
	lea	rdx, OFFSET FLAT:$SG4294957743
	mov	rcx, rax
	call	fprintf
$LN29@parse_tile:

; 267  :       return 0;

	xor	eax, eax
$LN28@parse_tile:
	mov	rbp, QWORD PTR [rsp+264]
$LN1@parse_tile:

; 294  : }

	mov	rbx, QWORD PTR [rsp+272]
	add	rsp, 224				; 000000e0H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
parse_tiles_specification ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
tail$ = 32
numstr$ = 64
number$ = 72
min$dead$ = 80
max$dead$ = 88
parse_uint8 PROC

; 297  : {

	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 298  :   char *tail;
; 299  :   int d = strtol(numstr, &tail, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR tail$[rsp]
	call	QWORD PTR __imp_strtol

; 300  :   if (*tail || d < min || d > max){

	mov	rcx, QWORD PTR tail$[rsp]
	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LN4@parse_uint
	cmp	eax, 255				; 000000ffH
	ja	SHORT $LN4@parse_uint

; 305  :   } else{
; 306  :     if (number)

	test	rbx, rbx
	je	SHORT $LN6@parse_uint

; 307  :       *number = (uint8_t) d;

	mov	BYTE PTR [rbx], al
$LN6@parse_uint:

; 308  :     return 1;

	mov	eax, 1

; 309  :   }
; 310  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN4@parse_uint:

; 301  :     fprintf(stderr, "Expected number between %d and %d\n", min, max);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, 255				; 000000ffH
	lea	rdx, OFFSET FLAT:$SG4294957740
	mov	rcx, rax
	xor	r8d, r8d
	call	fprintf

; 302  :     if(number)

	test	rbx, rbx
	je	SHORT $LN5@parse_uint

; 303  :       *number = 0;

	mov	BYTE PTR [rbx], 0
$LN5@parse_uint:

; 304  :     return 0;

	xor	eax, eax

; 309  :   }
; 310  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
parse_uint8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
tail$1 = 32
array$ = 64
coeff_key$ = 72
size$dead$ = 80
min$dead$ = 88
delim$ = 88
max$dead$ = 96
parse_array PROC

; 314  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	DWORD PTR [rsp+32], r9d
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rsi, rdx

; 315  :   char *key = strdup(array);

	call	QWORD PTR __imp_strdup

; 316  :   const char delim[] = ",;:";
; 317  :   char *token;
; 318  :   int i = 0;
; 319  : 
; 320  :   token = strtok(key, delim);

	lea	rdx, QWORD PTR delim$[rsp]
	mov	DWORD PTR delim$[rsp], 3816236		; 003a3b2cH
	mov	rcx, rax
	mov	rbp, rax
	xor	edi, edi
	call	QWORD PTR __imp_strtok

; 321  :   while(token!=NULL&&i<size){

	test	rax, rax
	je	$LN21@parse_arra
	mov	rbx, rsi
	npad	7
$LL2@parse_arra:
	mov	rcx, rbx
	sub	rcx, rsi
	cmp	rcx, 16
	jge	SHORT $LN3@parse_arra

; 299  :   int d = strtol(numstr, &tail, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR tail$1[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_strtol

; 300  :   if (*tail || d < min || d > max){

	mov	rcx, QWORD PTR tail$1[rsp]
	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LN12@parse_arra
	cmp	eax, 255				; 000000ffH
	ja	SHORT $LN12@parse_arra

; 304  :     return 0;
; 305  :   } else{
; 306  :     if (number)

	test	rbx, rbx
	je	SHORT $LN14@parse_arra

; 307  :       *number = (uint8_t) d;

	mov	BYTE PTR [rbx], al
$LN14@parse_arra:

; 326  :     }
; 327  :     i++;
; 328  :     token = strtok(NULL, delim);

	lea	rdx, QWORD PTR delim$[rsp]
	xor	ecx, ecx
	inc	edi
	inc	rbx
	call	QWORD PTR __imp_strtok
	test	rax, rax
	jne	SHORT $LL2@parse_arra
$LN3@parse_arra:

; 329  :   }
; 330  :   if(i>=size && (token != NULL)){

	cmp	edi, 16
	jl	SHORT $LN21@parse_arra
	test	rax, rax
	je	SHORT $LN7@parse_arra

; 331  :     fprintf(stderr, "parsing failed : too many members.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294957738

; 332  :     free(key);
; 333  :     return 0;

	jmp	SHORT $LN24@parse_arra
$LN12@parse_arra:

; 301  :     fprintf(stderr, "Expected number between %d and %d\n", min, max);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, 255				; 000000ffH
	lea	rdx, OFFSET FLAT:$SG4294957740
	mov	rcx, rax
	xor	r8d, r8d
	call	fprintf

; 302  :     if(number)

	test	rbx, rbx
	je	SHORT $LN17@parse_arra

; 303  :       *number = 0;

	mov	BYTE PTR [rbx], 0

; 322  :     if (!parse_uint8(token, &coeff_key[i], min, max))
; 323  :     {
; 324  :       free(key);
; 325  :       return 0;

	jmp	SHORT $LN17@parse_arra
$LN7@parse_arra:

; 337  :     free(key);
; 338  :     return 0;
; 339  :   }
; 340  :   free(key);

	mov	rcx, rbp
	call	QWORD PTR __imp_free

; 341  :   return 1;

	mov	eax, 1
	jmp	SHORT $LN1@parse_arra
$LN21@parse_arra:

; 334  :   }
; 335  :   else if (i<size){
; 336  :     fprintf(stderr, "parsing failed : too few members.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG4294957737
$LN24@parse_arra:

; 342  : }

	mov	rcx, rax
	call	fprintf
$LN17@parse_arra:
	mov	rcx, rbp
	call	QWORD PTR __imp_free
	xor	eax, eax
$LN1@parse_arra:
	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
parse_array ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
array$ = 64
depths_min$ = 72
depths_max$ = 80
size$dead$ = 88
parse_pu_depth_list PROC

; 345  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r15, r8
	mov	r12, rdx

; 346  :     char *list = strdup( array );

	call	QWORD PTR __imp_strdup

; 347  :     char *token;
; 348  :     int i = 0;
; 349  :     int ptr = -1;

	mov	rdi, -1
	xor	ebx, ebx
	mov	r14, rax

; 350  :     int len = strlen( list );

	mov	rsi, rdi
	npad	7
$LL31@parse_pu_d:
	inc	rsi
	cmp	BYTE PTR [rax+rsi], bl
	jne	SHORT $LL31@parse_pu_d

; 351  :     int retval = 1;
; 352  : 
; 353  :     //Reset depths in case multiple pu depth parameters are given
; 354  :     if(size > 1) memset( depths_max + 1, -1, (size - 1) * sizeof( *depths_max ) );

	movdqa	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff

; 355  :     if(size > 1) memset( depths_min + 1, -1, (size - 1) * sizeof( *depths_min ) );
; 356  : 
; 357  :     token = strtok( list, "," );

	lea	rdx, OFFSET FLAT:$SG4294957736
	movups	XMMWORD PTR [r15+4], xmm0
	mov	rcx, r14
	mov	ebp, 1
	movd	DWORD PTR [r15+20], xmm0
	movups	XMMWORD PTR [r12+4], xmm0
	movd	DWORD PTR [r12+20], xmm0
	call	QWORD PTR __imp_strtok

; 358  :     while( ptr < len && list[ptr + 1] == ',' )

	movsxd	rsi, esi
	mov	r10, rax
	cmp	rsi, rdi
	jle	SHORT $LL4@parse_pu_d
	mov	rcx, rdi
	npad	5
$LL2@parse_pu_d:
	cmp	BYTE PTR [r14+rcx+1], 44		; 0000002cH
	jne	SHORT $LL4@parse_pu_d

; 359  :     {
; 360  :         i++;

	inc	ebx

; 361  :         ptr++;

	inc	edi
	inc	rcx
	cmp	rcx, rsi
	jl	SHORT $LL2@parse_pu_d
$LL4@parse_pu_d:

; 362  :     }
; 363  :     while( retval && token != NULL && i < size ) {

	test	r10, r10
	je	SHORT $LN5@parse_pu_d
	cmp	ebx, 6
	jge	SHORT $LN26@parse_pu_d

; 364  :         retval &= (sscanf( token, "%d-%d", &depths_min[i], &depths_max[i] ) == 2);

	movsxd	rax, ebx
	lea	rdx, OFFSET FLAT:$SG4294957735
	mov	rcx, r10
	lea	r9, QWORD PTR [r15+rax*4]
	lea	r8, QWORD PTR [r12+rax*4]
	call	sscanf
	xor	ecx, ecx

; 365  :         ptr += (retval ? 4 : 0);
; 366  :         i++;
; 367  :         token = strtok( NULL, "," );

	lea	rdx, OFFSET FLAT:$SG4294957734
	cmp	eax, 2
	cmove	ecx, ebp
	mov	eax, ecx
	mov	ebp, ecx
	neg	eax
	sbb	ecx, ecx
	inc	ebx
	and	ecx, 4
	add	edi, ecx
	xor	ecx, ecx
	call	QWORD PTR __imp_strtok
	mov	r10, rax
	movsxd	rax, edi

; 368  :         while(ptr < len && list[ptr + 1] == ',' ){

	cmp	rax, rsi
	jge	SHORT $LN37@parse_pu_d
	npad	7
$LL6@parse_pu_d:
	cmp	BYTE PTR [r14+rax+1], 44		; 0000002cH
	jne	SHORT $LN37@parse_pu_d

; 369  :           i++;

	inc	ebx

; 370  :           ptr++;

	inc	edi
	inc	rax
	cmp	rax, rsi
	jl	SHORT $LL6@parse_pu_d
$LN37@parse_pu_d:

; 362  :     }
; 363  :     while( retval && token != NULL && i < size ) {

	test	ebp, ebp
	jne	SHORT $LL4@parse_pu_d
$LN5@parse_pu_d:

; 371  :         }
; 372  :     }
; 373  : 
; 374  :     if( i >= size && ( token != NULL ) ) {

	cmp	ebx, 6
	jl	SHORT $LN10@parse_pu_d
	test	r10, r10
	je	SHORT $LN10@parse_pu_d
$LN26@parse_pu_d:

; 375  :         fprintf( stderr, "parsing failed : too many values.\n" );

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957733
	call	fprintf

; 376  :         retval = 0;

	xor	ebp, ebp
$LN10@parse_pu_d:

; 377  :     }
; 378  :     
; 379  :     free( list );

	mov	rcx, r14
	call	QWORD PTR __imp_free

; 380  :     return retval;
; 381  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	eax, ebp
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
parse_pu_depth_list ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
values$ = 32
current_value$ = 128
arg$ = 128
nslices$ = 136
array$ = 144
parse_slice_specification PROC

; 383  : static int parse_slice_specification(const char* const arg, int32_t * const nslices, int32_t** const array) {

	mov	QWORD PTR [rsp+24], rbx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 96					; 00000060H
	mov	rbx, rcx

; 384  :   const char* current_arg = NULL;
; 385  :   int32_t current_value;
; 386  :   int32_t values[MAX_SLICES];
; 387  : 
; 388  :   int i;
; 389  : 
; 390  :   //Free pointer in any case
; 391  :   if (*array) {

	xor	edi, edi
	mov	rcx, QWORD PTR [r8]
	mov	r14, r8
	mov	rsi, rdx
	test	rcx, rcx
	je	SHORT $LN8@parse_slic

; 392  :     FREE_POINTER(*array);

	call	QWORD PTR __imp_free
	mov	QWORD PTR [r14], rdi
$LN8@parse_slic:

; 393  :   }
; 394  : 
; 395  :   //If the arg starts with u, we want an uniform split
; 396  :   if (arg[0]=='u') {

	cmp	BYTE PTR [rbx], 117			; 00000075H
	jne	SHORT $LN9@parse_slic

; 397  :     *nslices = atoi(arg+1);

	lea	rcx, QWORD PTR [rbx+1]
	call	QWORD PTR __imp_atoi
	mov	DWORD PTR [rsi], eax

; 398  :     if (MAX_SLICES <= *nslices || 0 >= *nslices) {

	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, 14
	ja	SHORT $LN11@parse_slic

; 401  :     }
; 402  :     //Done with parsing
; 403  :     return 1;

	mov	eax, 1

; 442  : }

	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 96					; 00000060H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN11@parse_slic:

; 399  :       fprintf(stderr, "Invalid number of tiles (0 < %d <= %d = MAX_SLICES)!\n", *nslices + 1, MAX_SLICES);

	mov	ecx, 2
	lea	ebx, DWORD PTR [rax+1]
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, 16
	lea	rdx, OFFSET FLAT:$SG4294957732
	mov	rcx, rax
	mov	r8d, ebx
	call	fprintf

; 400  :       return 0;

	xor	eax, eax

; 442  : }

	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 96					; 00000060H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN9@parse_slic:

; 404  :   }
; 405  : 
; 406  :   //We have a comma-separated list of int for the split...
; 407  :   current_arg = arg;
; 408  :   //We always have a slice starting at 0
; 409  :   values[0] = 0;

	mov	DWORD PTR values$[rsp], edi

; 410  :   *nslices = 1;

	mov	DWORD PTR [rsi], 1
	mov	QWORD PTR [rsp+136], rbp
$LL4@parse_slic:

; 411  :   do {
; 412  :     int ret = sscanf(current_arg, "%d", &current_value);

	lea	r8, QWORD PTR current_value$[rsp]
	mov	rcx, rbx
	lea	rdx, OFFSET FLAT:$SG4294957731
	call	sscanf

; 413  :     if (ret != 1) {

	cmp	eax, 1
	jne	$LN21@parse_slic

; 416  :     }
; 417  :     current_arg = strchr(current_arg, ',');

	lea	edx, QWORD PTR [rax+43]
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rbx, rax

; 418  :     //Skip the , if we found one
; 419  :     if (current_arg) ++current_arg;

	test	rax, rax
	je	SHORT $LN13@parse_slic
	inc	rbx
$LN13@parse_slic:

; 420  :     values[*nslices] = current_value;

	movsxd	rdx, DWORD PTR [rsi]
	mov	eax, DWORD PTR current_value$[rsp]

; 421  :     ++(*nslices);

	lea	ebp, DWORD PTR [rdx+1]
	mov	DWORD PTR values$[rsp+rdx*4], eax
	mov	DWORD PTR [rsi], ebp

; 422  :     if (MAX_SLICES <= *nslices) break;

	cmp	ebp, 16
	jge	SHORT $LN3@parse_slic

; 423  :   } while (current_arg);

	test	rbx, rbx
	jne	SHORT $LL4@parse_slic
$LN3@parse_slic:

; 424  : 
; 425  :   if (MAX_SLICES <= *nslices || 0 >= *nslices) {

	cmp	edx, 14
	ja	SHORT $LN16@parse_slic

; 428  :   }
; 429  : 
; 430  :   *array = MALLOC(int32_t, *nslices);

	movsxd	rcx, ebp
	shl	rcx, 2
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r14], rax

; 431  :   if (!*array) {

	test	rax, rax
	jne	SHORT $LN17@parse_slic

; 432  :     fprintf(stderr, "Could not allocate array for slices\n");

	lea	ecx, QWORD PTR [rax+2]
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294957728
	call	fprintf

; 433  :     return 0;

	jmp	SHORT $LN29@parse_slic
$LN17@parse_slic:

; 434  :   }
; 435  : 
; 436  :   //TODO: memcpy?
; 437  :   for (i = 0; i < *nslices; ++i) {

	cmp	DWORD PTR [rsi], edi
	jle	SHORT $LN6@parse_slic
	mov	rdx, rdi
$LL7@parse_slic:

; 438  :     (*array)[i] = values[i];

	mov	eax, DWORD PTR values$[rsp+rdx]
	lea	rdx, QWORD PTR [rdx+4]
	mov	rcx, QWORD PTR [r14]
	inc	edi
	mov	DWORD PTR [rdx+rcx-4], eax
	cmp	edi, DWORD PTR [rsi]
	jl	SHORT $LL7@parse_slic
$LN6@parse_slic:

; 439  :   }
; 440  : 
; 441  :   return 1;

	mov	eax, 1
	jmp	SHORT $LN28@parse_slic
$LN16@parse_slic:

; 426  :     fprintf(stderr, "Invalid number of slices (0 < %d <= %d = MAX_SLICES)!\n", *nslices, MAX_SLICES);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, 16
	lea	rdx, OFFSET FLAT:$SG4294957729
	mov	rcx, rax
	mov	r8d, ebp
	call	fprintf

; 427  :     return 0;

	jmp	SHORT $LN29@parse_slic
$LN21@parse_slic:

; 414  :       fprintf(stderr, "Could not parse integer \"%s\"!\n", current_arg);

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r8, rbx
	lea	rdx, OFFSET FLAT:$SG4294957730
	mov	rcx, rax
	call	fprintf
$LN29@parse_slic:

; 415  :       return 0;

	xor	eax, eax
$LN28@parse_slic:
	mov	rbp, QWORD PTR [rsp+136]

; 442  : }

	mov	rbx, QWORD PTR [rsp+144]
	add	rsp, 96					; 00000060H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
parse_slice_specification ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cfg.c
_TEXT	SEGMENT
max_lps$1$ = 176
cfg$ = 176
max_lsr$1$ = 184
validate_hevc_level PROC

; 1770 : static int validate_hevc_level(kvz_config *const cfg) {

	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 144				; 00000090H

; 1771 :   static const struct { uint32_t lsr; uint32_t lps; uint32_t main_bitrate; } LEVEL_CONSTRAINTS[13] = {
; 1772 :     { 552960, 36864, 128 }, // 1
; 1773 : 
; 1774 :     { 3686400, 122880, 1500 }, // 2
; 1775 :     { 7372800, 245760, 3000 }, // 2.1
; 1776 : 
; 1777 :     { 16588800, 552960, 6000 },  // 3
; 1778 :     { 33177600, 983040, 10000 }, // 3.1
; 1779 : 
; 1780 :     { 66846720, 2228224, 12000 },  // 4
; 1781 :     { 133693440, 2228224, 20000 }, // 4.1
; 1782 : 
; 1783 :     { 267386880, 8912896, 25000 },  // 5
; 1784 :     { 534773760, 8912896, 40000 },  // 5.1
; 1785 :     { 1069547520, 8912896, 60000 }, // 5.2
; 1786 : 
; 1787 :     { 1069547520, 35651584, 60000 },  // 6
; 1788 :     { 2139095040, 35651584, 120000 }, // 6.1
; 1789 :     { 4278190080, 35651584, 240000 }, // 6.2
; 1790 :   };
; 1791 : 
; 1792 :   // bit rates for the high-tiers of the levels from 4 to 6.2
; 1793 :   static const uint32_t HIGH_TIER_BITRATES[8] = {
; 1794 :     30000, 50000, 100000, 160000, 240000, 240000, 480000, 800000
; 1795 :   };
; 1796 : 
; 1797 :   int level_error = 0;
; 1798 : 
; 1799 :   const char* level_err_prefix;
; 1800 :   if (cfg->force_level) {
; 1801 :     level_err_prefix = "Level warning";
; 1802 :   } else {
; 1803 :     level_err_prefix = "Level error";
; 1804 :   }
; 1805 : 
; 1806 :   uint8_t lvl_idx;
; 1807 : 
; 1808 :   // for nicer error print
; 1809 :   float lvl = ((float)cfg->level) / 10.0f;

	movzx	r11d, BYTE PTR [rcx+2448]
	lea	rax, OFFSET FLAT:$SG4294956953
	xor	edx, edx
	movaps	XMMWORD PTR [rsp+96], xmm6
	cmp	BYTE PTR [rcx+2449], dl
	lea	rbp, OFFSET FLAT:$SG4294956954
	mov	rdi, rcx
	mov	r9d, edx
	cmove	rbp, rax
	movd	xmm0, r11d
	cvtdq2ps xmm0, xmm0

; 1810 : 
; 1811 :   // check if the level is valid and get it's lsr and lps values
; 1812 :   switch (cfg->level) {

	lea	eax, DWORD PTR [r11-10]
	mulss	xmm0, DWORD PTR __real@3dcccccd
	cmp	eax, 52					; 00000034H
	ja	$LN19@validate_h
	lea	rbx, OFFSET FLAT:__ImageBase
	cdqe
	movzx	eax, BYTE PTR $LN34@validate_h[rbx+rax]
	mov	ecx, DWORD PTR $LN35@validate_h[rbx+rax*4]
	add	rcx, rbx
	jmp	rcx
$LN6@validate_h:

; 1813 :   case 10:
; 1814 :     lvl_idx = 0;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9
	mov	rdx, -20
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+4
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+8

; 1815 :     break;

	jmp	$LN2@validate_h
$LN7@validate_h:

; 1816 :   case 20:
; 1817 :     lvl_idx = 1;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+12
	mov	rdx, -16
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+16
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+20

; 1818 :     break;

	jmp	$LN2@validate_h
$LN8@validate_h:

; 1819 :   case 21:
; 1820 :     lvl_idx = 2;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+24
	mov	rdx, -12
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+28
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+32

; 1821 :     break;

	jmp	$LN2@validate_h
$LN9@validate_h:

; 1822 :   case 30:
; 1823 :     lvl_idx = 3;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+36
	mov	rdx, -8
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+40
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+44

; 1824 :     break;

	jmp	$LN2@validate_h
$LN10@validate_h:

; 1825 :   case 31:
; 1826 :     lvl_idx = 4;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+48
	mov	rdx, -4
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+52
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+56

; 1827 :     break;

	jmp	$LN2@validate_h
$LN11@validate_h:

; 1828 :   case 40:
; 1829 :     lvl_idx = 5;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+60
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+64
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+68

; 1830 :     break;

	jmp	$LN2@validate_h
$LN12@validate_h:

; 1831 :   case 41:
; 1832 :     lvl_idx = 6;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+72
	mov	edx, 4
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+76
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+80

; 1833 :     break;

	jmp	$LN2@validate_h
$LN13@validate_h:

; 1834 :   case 50:
; 1835 :     lvl_idx = 7;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+84
	mov	edx, 8
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+88
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+92

; 1836 :     break;

	jmp	$LN2@validate_h
$LN14@validate_h:

; 1837 :   case 51:
; 1838 :     lvl_idx = 8;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+96
	mov	edx, 12
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+100
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+104

; 1839 :     break;

	jmp	SHORT $LN2@validate_h
$LN15@validate_h:

; 1840 :   case 52:
; 1841 :     lvl_idx = 9;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+108
	mov	edx, 16
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+112
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+116

; 1842 :     break;

	jmp	SHORT $LN2@validate_h
$LN16@validate_h:

; 1843 :   case 60:
; 1844 :     lvl_idx = 10;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+120
	mov	edx, 20
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+124
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+128

; 1845 :     break;

	jmp	SHORT $LN2@validate_h
$LN17@validate_h:

; 1846 :   case 61:
; 1847 :     lvl_idx = 11;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+132
	mov	edx, 24
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+136
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+140

; 1848 :     break;

	jmp	SHORT $LN2@validate_h
$LN18@validate_h:

; 1849 :   case 62:
; 1850 :     lvl_idx = 12;

	lea	rax, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+144
	mov	edx, 28
	lea	rcx, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+148
	lea	r8, OFFSET FLAT:?LEVEL_CONSTRAINTS@?1??validate_hevc_level@@9@9+152
$LN2@validate_h:

; 1855 :     return 1;
; 1856 :   }
; 1857 : 
; 1858 :   if (cfg->high_tier && cfg->level < 40) {

	movzx	r10d, BYTE PTR [rdi+2450]
	test	r10b, r10b
	je	SHORT $LN20@validate_h
	cmp	r11b, 40				; 00000028H
	jae	SHORT $LN20@validate_h

; 1859 :     fprintf(stderr, "Input error: high tier requires at least level 4\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294956951
	call	fprintf

; 1860 :     return 1;

	jmp	$LN36@validate_h
$LN20@validate_h:

; 1861 :   }
; 1862 : 
; 1863 :   // max luma sample rate
; 1864 :   uint32_t max_lsr = LEVEL_CONSTRAINTS[lvl_idx].lsr;

	mov	eax, DWORD PTR [rax]

; 1865 : 
; 1866 :   // max luma picture size
; 1867 :   uint32_t max_lps = LEVEL_CONSTRAINTS[lvl_idx].lps;

	mov	r11d, DWORD PTR [rcx]
	mov	QWORD PTR [rsp+192], rsi
	mov	QWORD PTR [rsp+136], r12
	mov	QWORD PTR [rsp+128], r13
	mov	QWORD PTR [rsp+120], r14
	mov	QWORD PTR [rsp+112], r15
	mov	DWORD PTR max_lsr$1$[rsp], eax

; 1868 : 
; 1869 :   if (cfg->high_tier) {
; 1870 :     cfg->max_bitrate = HIGH_TIER_BITRATES[lvl_idx - 5] * 1000;
; 1871 :   } else {
; 1872 :     cfg->max_bitrate = LEVEL_CONSTRAINTS[lvl_idx].main_bitrate * 1000;
; 1873 :   }
; 1874 : 
; 1875 :   if (cfg->target_bitrate > cfg->max_bitrate) {

	lea	rax, QWORD PTR ?HIGH_TIER_BITRATES@?1??validate_hevc_level@@9@9[rbx]
	add	rax, rdx
	movaps	XMMWORD PTR [rsp+80], xmm7
	test	r10b, r10b
	movaps	XMMWORD PTR [rsp+64], xmm8
	mov	DWORD PTR max_lps$1$[rsp], r11d
	cmove	rax, r8
	cvtps2pd xmm6, xmm0
	imul	ecx, DWORD PTR [rax], 1000		; 000003e8H
	mov	DWORD PTR [rdi+2452], ecx
	cmp	DWORD PTR [rdi+2352], ecx
	jbe	SHORT $LN31@validate_h

; 1876 :     fprintf(stderr, "%s: target bitrate exceeds %i, which is the maximum %s tier level %g bitrate\n",

	test	r10b, r10b
	lea	rax, OFFSET FLAT:$SG4294956950
	lea	rbx, OFFSET FLAT:$SG4294956949
	mov	ecx, 2
	cmovne	rbx, rax
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [rdi+2452]
	lea	rdx, OFFSET FLAT:$SG4294956948
	mov	rcx, rax
	movsd	QWORD PTR [rsp+40], xmm6
	mov	r8, rbp
	mov	QWORD PTR [rsp+32], rbx
	call	fprintf
	mov	r11d, DWORD PTR max_lps$1$[rsp]

; 1877 :       level_err_prefix, cfg->max_bitrate, cfg->high_tier?"high":"main", lvl);
; 1878 :     level_error = 1;

	mov	r9d, 1
$LN31@validate_h:

; 1879 :   }
; 1880 : 
; 1881 :   // check the conformance to the level limits
; 1882 : 
; 1883 :   // luma samples
; 1884 :   uint64_t cfg_samples = cfg->width * cfg->height;

	movd	xmm7, DWORD PTR [rdi+32]
	movd	xmm0, DWORD PTR [rdi+36]
	mov	r12d, DWORD PTR [rdi+12]
	mov	eax, r12d
	mov	r14d, DWORD PTR [rdi+16]

; 1885 : 
; 1886 :   // luma sample rate
; 1887 :   double framerate = ((double)cfg->framerate_num) / ((double)cfg->framerate_denom);
; 1888 :   uint64_t cfg_sample_rate = cfg_samples * (uint64_t) framerate;

	movsd	xmm1, QWORD PTR __real@43e0000000000000
	cvtdq2pd xmm7, xmm7
	cvtdq2pd xmm0, xmm0
	imul	eax, r14d
	divsd	xmm7, xmm0
	movsxd	r13, eax
	xor	eax, eax
	comisd	xmm7, xmm1
	movaps	xmm0, xmm7
	jb	SHORT $LN33@validate_h
	subsd	xmm0, xmm1
	comisd	xmm0, xmm1
	jae	SHORT $LN33@validate_h
	mov	rcx, -9223372036854775808		; 8000000000000000H
	mov	rax, rcx
$LN33@validate_h:

; 1889 : 
; 1890 :   // square of the maximum allowed dimension
; 1891 :   uint32_t max_dimension_squared = 8 * max_lps;

	lea	r15d, DWORD PTR [r11*8]
	xorps	xmm8, xmm8
	cvttsd2si rsi, xmm0
	add	rsi, rax

; 1892 : 
; 1893 :   // check maximum dimensions
; 1894 :   if (cfg->width * cfg->width > max_dimension_squared) {

	mov	eax, r15d
	imul	rsi, r13
	cvtsi2ss xmm8, rax
	mov	eax, r12d
	imul	eax, r12d
	cmp	eax, r15d
	jbe	SHORT $LN32@validate_h

; 1895 :     uint32_t max_dim = sqrtf(max_dimension_squared);

	xorps	xmm0, xmm0

; 1896 :     fprintf(stderr, "%s: picture width of %i is too large for this level (%g), maximum dimension is %i\n",

	mov	ecx, 2
	sqrtss	xmm0, xmm8
	cvttss2si rbx, xmm0
	call	QWORD PTR __imp___acrt_iob_func
	mov	DWORD PTR [rsp+40], ebx
	lea	rdx, OFFSET FLAT:$SG4294956947
	mov	rcx, rax
	movsd	QWORD PTR [rsp+32], xmm6
	mov	r9d, r12d
	mov	r8, rbp
	call	fprintf

; 1897 :       level_err_prefix, cfg->width, lvl, max_dim);
; 1898 :     level_error = 1;

	mov	r14d, DWORD PTR [rdi+16]
	mov	r9d, 1
$LN32@validate_h:

; 1899 :   }
; 1900 :   if (cfg->height * cfg->height > max_dimension_squared) {

	mov	r12, QWORD PTR [rsp+136]
	mov	eax, r14d
	imul	eax, r14d
	cmp	eax, r15d
	mov	r15, QWORD PTR [rsp+112]
	jbe	SHORT $LN25@validate_h

; 1901 :     uint32_t max_dim = sqrtf(max_dimension_squared);

	xorps	xmm0, xmm0

; 1902 :     fprintf(stderr, "%s: picture height of %i is too large for this level (%g), maximum dimension is %i\n",

	mov	ecx, 2
	sqrtss	xmm0, xmm8
	cvttss2si rbx, xmm0
	call	QWORD PTR __imp___acrt_iob_func
	mov	DWORD PTR [rsp+40], ebx
	lea	rdx, OFFSET FLAT:$SG4294956946
	mov	rcx, rax
	movsd	QWORD PTR [rsp+32], xmm6
	mov	r9d, r14d
	mov	r8, rbp
	call	fprintf

; 1903 :       level_err_prefix, cfg->height, lvl, max_dim);
; 1904 :     level_error = 1;

	mov	r9d, 1
$LN25@validate_h:

; 1905 :   }
; 1906 : 
; 1907 :   // check luma picture size
; 1908 :   if (cfg_samples > max_lps) {

	mov	ebx, DWORD PTR max_lps$1$[rsp]
	movaps	xmm8, XMMWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+120]
	cmp	r13, rbx
	jbe	SHORT $LN26@validate_h

; 1909 :     fprintf(stderr, "%s: picture resolution of %ix%i is too large for this level (%g) (it has %llu samples, maximum is %u samples)\n",

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9d, DWORD PTR [rdi+12]
	lea	rdx, OFFSET FLAT:$SG4294956945
	mov	DWORD PTR [rsp+56], ebx
	mov	rcx, rax
	mov	eax, DWORD PTR [rdi+16]
	mov	r8, rbp
	mov	QWORD PTR [rsp+48], r13
	movsd	QWORD PTR [rsp+40], xmm6
	mov	DWORD PTR [rsp+32], eax
	call	fprintf

; 1910 :       level_err_prefix, cfg->width, cfg->height, lvl, (unsigned long long) cfg_samples, max_lps);
; 1911 :     level_error = 1;

	mov	r9d, 1
$LN26@validate_h:

; 1912 :   }
; 1913 : 
; 1914 :   // check luma sample rate
; 1915 :   if (cfg_sample_rate > max_lsr) {

	mov	ebx, DWORD PTR max_lsr$1$[rsp]
	mov	r13, QWORD PTR [rsp+128]
	cmp	rsi, rbx
	jbe	SHORT $LN27@validate_h

; 1916 :     fprintf(stderr, "%s: framerate of %g is too big for this level (%g) and picture resolution (it has the sample rate of %llu, maximum is %u\n",

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	DWORD PTR [rsp+48], ebx
	lea	rdx, OFFSET FLAT:$SG4294956944
	mov	rcx, rax
	mov	QWORD PTR [rsp+40], rsi
	movaps	xmm3, xmm7
	movsd	QWORD PTR [rsp+32], xmm6
	movq	r9, xmm7
	mov	r8, rbp
	call	fprintf

; 1917 :       level_err_prefix, framerate, lvl, (unsigned long long) cfg_sample_rate, max_lsr);
; 1918 :     level_error = 1;

	mov	r9d, 1
$LN27@validate_h:

; 1919 :   }
; 1920 : 
; 1921 :   if (cfg->force_level) {

	cmp	BYTE PTR [rdi+2449], 0
	mov	eax, 0
	movaps	xmm7, XMMWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+192]
	cmovne	r9d, eax
	mov	eax, r9d

; 1922 :     // we wanted to print warnings, not get errors
; 1923 :     return 0;
; 1924 :   } else {
; 1925 :     return level_error;
; 1926 :   }
; 1927 : }

	movaps	xmm6, XMMWORD PTR [rsp+96]
	add	rsp, 144				; 00000090H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN19@validate_h:

; 1851 :     break;
; 1852 : 
; 1853 :   default:
; 1854 :     fprintf(stderr, "Input error: %g is an invalid level value\n", lvl);

	mov	ecx, 2
	cvtps2pd xmm6, xmm0
	call	QWORD PTR __imp___acrt_iob_func
	movaps	xmm2, xmm6
	lea	rdx, OFFSET FLAT:$SG4294956952
	mov	rcx, rax
	movq	r8, xmm6
	call	fprintf
$LN36@validate_h:

; 1922 :     // we wanted to print warnings, not get errors
; 1923 :     return 0;
; 1924 :   } else {
; 1925 :     return level_error;
; 1926 :   }
; 1927 : }

	movaps	xmm6, XMMWORD PTR [rsp+96]
	mov	eax, 1
	add	rsp, 144				; 00000090H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
	npad	1
$LN35@validate_h:
	DD	$LN6@validate_h
	DD	$LN7@validate_h
	DD	$LN8@validate_h
	DD	$LN9@validate_h
	DD	$LN10@validate_h
	DD	$LN11@validate_h
	DD	$LN12@validate_h
	DD	$LN13@validate_h
	DD	$LN14@validate_h
	DD	$LN15@validate_h
	DD	$LN16@validate_h
	DD	$LN17@validate_h
	DD	$LN18@validate_h
	DD	$LN19@validate_h
$LN34@validate_h:
	DB	0
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	1
	DB	2
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	3
	DB	4
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	5
	DB	6
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	7
	DB	8
	DB	9
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	10
	DB	11
	DB	12
validate_hevc_level ENDP
_TEXT	ENDS
END
