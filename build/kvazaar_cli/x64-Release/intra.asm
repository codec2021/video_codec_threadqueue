; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
?kvz_intra_hor_ver_dist_thres@?4??kvz_intra_predict@@9@9 DD 00H ; `kvz_intra_predict'::`5'::kvz_intra_hor_ver_dist_thres
	DD	07H
	DD	01H
	DD	00H
	DD	00H
	ORG $+4
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	ORG $+8
num_ref_pixels_left DB 040H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	020H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	03cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	01cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	038H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	018H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	034H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	014H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	030H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	02cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	028H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	024H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	020H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	020H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	01cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	01cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	018H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	018H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	014H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	014H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	04H
	DB	08H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	0cH
	DB	04H
	DB	04H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
num_ref_pixels_top DB 040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	040H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	020H
	DB	01cH
	DB	018H
	DB	014H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	020H
	DB	01cH
	DB	018H
	DB	014H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	040H
	DB	03cH
	DB	038H
	DB	034H
	DB	030H
	DB	02cH
	DB	028H
	DB	024H
	DB	020H
	DB	01cH
	DB	018H
	DB	014H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	020H
	DB	01cH
	DB	018H
	DB	014H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	020H
	DB	01cH
	DB	018H
	DB	014H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	010H
	DB	0cH
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
	DB	08H
	DB	04H
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
PUBLIC	kvz_intra_build_reference
PUBLIC	kvz_intra_build_reference_inner
PUBLIC	kvz_intra_build_reference_any
PUBLIC	kvz_intra_predict
PUBLIC	kvz_intra_recon_cu
PUBLIC	kvz_intra_get_dir_luma_predictor
pdata	SEGMENT
$pdata$intra_recon_tb_leaf DD imagerel intra_recon_tb_leaf
	DD	imagerel intra_recon_tb_leaf+21
	DD	imagerel $unwind$intra_recon_tb_leaf
$pdata$4$intra_recon_tb_leaf DD imagerel intra_recon_tb_leaf+21
	DD	imagerel intra_recon_tb_leaf+391
	DD	imagerel $chain$4$intra_recon_tb_leaf
$pdata$5$intra_recon_tb_leaf DD imagerel intra_recon_tb_leaf+391
	DD	imagerel intra_recon_tb_leaf+483
	DD	imagerel $chain$5$intra_recon_tb_leaf
$pdata$kvz_intra_build_reference_inner DD imagerel $LN65
	DD	imagerel $LN65+829
	DD	imagerel $unwind$kvz_intra_build_reference_inner
$pdata$kvz_intra_build_reference_any DD imagerel $LN95
	DD	imagerel $LN95+874
	DD	imagerel $unwind$kvz_intra_build_reference_any
$pdata$kvz_intra_predict DD imagerel $LN75
	DD	imagerel $LN75+36
	DD	imagerel $unwind$kvz_intra_predict
$pdata$0$kvz_intra_predict DD imagerel $LN75+36
	DD	imagerel $LN75+578
	DD	imagerel $chain$0$kvz_intra_predict
$pdata$1$kvz_intra_predict DD imagerel $LN75+578
	DD	imagerel $LN75+903
	DD	imagerel $chain$1$kvz_intra_predict
$pdata$intra_pred_dc DD imagerel intra_pred_dc
	DD	imagerel intra_pred_dc+138
	DD	imagerel $unwind$intra_pred_dc
$pdata$intra_post_process_angular DD imagerel intra_post_process_angular
	DD	imagerel intra_post_process_angular+12
	DD	imagerel $unwind$intra_post_process_angular
$pdata$0$intra_post_process_angular DD imagerel intra_post_process_angular+12
	DD	imagerel intra_post_process_angular+100
	DD	imagerel $chain$0$intra_post_process_angular
$pdata$1$intra_post_process_angular DD imagerel intra_post_process_angular+100
	DD	imagerel intra_post_process_angular+101
	DD	imagerel $chain$1$intra_post_process_angular
$pdata$intra_filter_reference DD imagerel intra_filter_reference
	DD	imagerel intra_filter_reference+38
	DD	imagerel $unwind$intra_filter_reference
$pdata$1$intra_filter_reference DD imagerel intra_filter_reference+38
	DD	imagerel intra_filter_reference+266
	DD	imagerel $chain$1$intra_filter_reference
$pdata$3$intra_filter_reference DD imagerel intra_filter_reference+266
	DD	imagerel intra_filter_reference+307
	DD	imagerel $chain$3$intra_filter_reference
$pdata$4$intra_filter_reference DD imagerel intra_filter_reference+307
	DD	imagerel intra_filter_reference+312
	DD	imagerel $chain$4$intra_filter_reference
$pdata$kvz_math_floor_log2 DD imagerel kvz_math_floor_log2
	DD	imagerel kvz_math_floor_log2+142
	DD	imagerel $unwind$kvz_math_floor_log2
$pdata$kvz_intra_recon_cu DD imagerel $LN329
	DD	imagerel $LN329+1782
	DD	imagerel $unwind$kvz_intra_recon_cu
xdata	SEGMENT
$unwind$intra_recon_tb_leaf DD 050e01H
	DD	0ac010eH
	DD	05005c007H
	DD	03004H
$chain$4$intra_recon_tb_leaf DD 0a3d21H
	DD	0b1643dH
	DD	0aaf418H
	DD	0abe414H
	DD	0b3d40dH
	DD	0b27404H
	DD	imagerel intra_recon_tb_leaf
	DD	imagerel intra_recon_tb_leaf+21
	DD	imagerel $unwind$intra_recon_tb_leaf
$chain$5$intra_recon_tb_leaf DD 020021H
	DD	0b16400H
	DD	imagerel intra_recon_tb_leaf
	DD	imagerel intra_recon_tb_leaf+21
	DD	imagerel $unwind$intra_recon_tb_leaf
$unwind$kvz_intra_build_reference_inner DD 0a1e01H
	DD	0d341eH
	DD	0f01a321eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
$unwind$kvz_intra_build_reference_any DD 091a01H
	DD	0f016621aH
	DD	0d012e014H
	DD	0700ec010H
	DD	0500c600dH
	DD	0300bH
$unwind$kvz_intra_predict DD 081701H
	DD	0f0135217H
	DD	0c00fe011H
	DD	0600c700dH
	DD	0300a500bH
$chain$0$kvz_intra_predict DD 020521H
	DD	0ed405H
	DD	imagerel $LN75
	DD	imagerel $LN75+36
	DD	imagerel $unwind$kvz_intra_predict
$chain$1$kvz_intra_predict DD 021H
	DD	imagerel $LN75
	DD	imagerel $LN75+36
	DD	imagerel $unwind$kvz_intra_predict
$unwind$intra_pred_dc DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$intra_post_process_angular DD 030a01H
	DD	03640aH
	DD	0700aH
$chain$0$intra_post_process_angular DD 020521H
	DD	023405H
	DD	imagerel intra_post_process_angular
	DD	imagerel intra_post_process_angular+12
	DD	imagerel $unwind$intra_post_process_angular
$chain$1$intra_post_process_angular DD 021H
	DD	imagerel intra_post_process_angular
	DD	imagerel intra_post_process_angular+12
	DD	imagerel $unwind$intra_post_process_angular
$unwind$intra_filter_reference DD 010401H
	DD	0204H
$chain$1$intra_filter_reference DD 041121H
	DD	07411H
	DD	023405H
	DD	imagerel intra_filter_reference
	DD	imagerel intra_filter_reference+38
	DD	imagerel $unwind$intra_filter_reference
$chain$3$intra_filter_reference DD 040021H
	DD	07400H
	DD	023400H
	DD	imagerel intra_filter_reference
	DD	imagerel intra_filter_reference+38
	DD	imagerel $unwind$intra_filter_reference
$chain$4$intra_filter_reference DD 021H
	DD	imagerel intra_filter_reference
	DD	imagerel intra_filter_reference+38
	DD	imagerel $unwind$intra_filter_reference
$unwind$kvz_math_floor_log2 DD 020601H
	DD	030023206H
$unwind$kvz_intra_recon_cu DD 0bfc01H
	DD	0b164fcH
	DD	0b20128H
	DD	0e017f019H
	DD	0c013d015H
	DD	030107011H
	DD	0500fH
	ORG $+8
$SG4294942889 DB 'l', 00H, 'o', 00H, 'g', 00H, '2', 00H, '_', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '2', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, '2', 00H, '_', 00H, 'w', 00H, 'i'
	DB	00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '5', 00H, 00H, 00H
	ORG $+10
$SG4294942890 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'r', 00H, 'a', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+8
$SG4294942891 DB 'l', 00H, 'o', 00H, 'g', 00H, '2', 00H, '_', 00H, 'w', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '2', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, '2', 00H, '_', 00H, 'w', 00H, 'i'
	DB	00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '5', 00H, 00H, 00H
	ORG $+10
$SG4294942892 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'r', 00H, 'a', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H
$SG4294942895 DB 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H
	ORG $+4
$SG4294942896 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'k', 00H
	DB	'v', 00H, 'z', 00H, '_', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'h'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
x$dead$ = 8
y$ = 16
preds$ = 24
cur_pu$dead$ = 32
left_pu$ = 40
above_pu$ = 48
kvz_intra_get_dir_luma_predictor PROC

; 92   :   // The default mode if block is not coded yet is INTRA_DC.
; 93   :   int8_t left_intra_dir  = 1;
; 94   :   if (left_pu && left_pu->type == CU_INTRA) {

	mov	rcx, QWORD PTR left_pu$[rsp]
	mov	r10d, edx
	mov	r9b, 1
	test	rcx, rcx
	je	SHORT $LN2@kvz_intra_
	movzx	eax, BYTE PTR [rcx]
	and	al, 3
	cmp	al, r9b
	jne	SHORT $LN2@kvz_intra_

; 95   :     left_intra_dir = left_pu->intra.mode;

	movzx	r9d, BYTE PTR [rcx+8]
$LN2@kvz_intra_:

; 96   :   }
; 97   : 
; 98   :   int8_t above_intra_dir = 1;
; 99   :   if (above_pu && above_pu->type == CU_INTRA && y % LCU_WIDTH != 0) {

	mov	rdx, QWORD PTR above_pu$[rsp]
	mov	cl, 1
	test	rdx, rdx
	je	SHORT $LN3@kvz_intra_
	movzx	eax, BYTE PTR [rdx]
	and	al, 3
	cmp	al, cl
	jne	SHORT $LN3@kvz_intra_
	test	r10b, 63				; 0000003fH
	je	SHORT $LN3@kvz_intra_

; 100  :     above_intra_dir = above_pu->intra.mode;

	movzx	ecx, BYTE PTR [rdx+8]
$LN3@kvz_intra_:

; 101  :   }
; 102  : 
; 103  :   // If the predictions are the same, add new predictions
; 104  :   if (left_intra_dir == above_intra_dir) {

	cmp	r9b, cl
	jne	SHORT $LN4@kvz_intra_

; 105  :     if (left_intra_dir > 1) { // angular modes

	cmp	r9b, 1
	jle	SHORT $LN6@kvz_intra_

; 106  :       preds[0] = left_intra_dir;
; 107  :       preds[1] = ((left_intra_dir + 29) % 32) + 2;

	movsx	eax, r9b

; 108  :       preds[2] = ((left_intra_dir - 1 ) % 32) + 2;

	lea	ecx, DWORD PTR [rax-1]
	and	ecx, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN12@kvz_intra_
	dec	ecx
	or	ecx, -32				; ffffffffffffffe0H
	inc	ecx
$LN12@kvz_intra_:
	add	cl, 2
	add	eax, 29
	and	eax, -2147483617			; ffffffff8000001fH
	jge	SHORT $LN11@kvz_intra_

; 106  :       preds[0] = left_intra_dir;
; 107  :       preds[1] = ((left_intra_dir + 29) % 32) + 2;

	dec	eax
	or	eax, -32				; ffffffffffffffe0H
	inc	eax
$LN11@kvz_intra_:
	add	al, 2

; 113  :     }
; 114  :   } else { // If we have two distinct predictions

	mov	BYTE PTR [r8], r9b
	mov	BYTE PTR [r8+1], al

; 127  : }

	mov	al, 1
	mov	BYTE PTR [r8+2], cl
	ret	0
$LN6@kvz_intra_:

; 109  :     } else { //non-angular
; 110  :       preds[0] = 0;//PLANAR_IDX;
; 111  :       preds[1] = 1;//DC_IDX;
; 112  :       preds[2] = 26;//VER_IDX;

	xor	r9b, r9b
	mov	al, 1

; 113  :     }
; 114  :   } else { // If we have two distinct predictions

	mov	BYTE PTR [r8], r9b
	mov	cl, 26
	mov	BYTE PTR [r8+1], al

; 123  :     }
; 124  :   }
; 125  : 
; 126  :   return 1;

	mov	BYTE PTR [r8+2], cl

; 127  : }

	ret	0
$LN4@kvz_intra_:

; 115  :     preds[0] = left_intra_dir;

	mov	BYTE PTR [r8], r9b

; 116  :     preds[1] = above_intra_dir;

	mov	BYTE PTR [r8+1], cl

; 117  : 
; 118  :     // add planar mode if it's not yet present
; 119  :     if (left_intra_dir && above_intra_dir ) {

	test	r9b, r9b
	je	SHORT $LN8@kvz_intra_
	test	cl, cl
	je	SHORT $LN8@kvz_intra_

; 123  :     }
; 124  :   }
; 125  : 
; 126  :   return 1;

	mov	BYTE PTR [r8+2], 0

; 127  : }

	mov	al, 1
	ret	0
$LN8@kvz_intra_:

; 120  :       preds[2] = 0; // PLANAR_IDX;
; 121  :     } else {  // Add DC mode if it's not present, otherwise 26.
; 122  :       preds[2] =  (left_intra_dir+above_intra_dir)<2? 26 : 1;

	movsx	eax, r9b
	mov	edx, 26
	movsx	ecx, cl
	add	ecx, eax
	mov	eax, 1
	cmp	ecx, 2
	cmovl	eax, edx

; 123  :     }
; 124  :   }
; 125  : 
; 126  :   return 1;

	mov	BYTE PTR [r8+2], al

; 127  : }

	mov	al, 1
	ret	0
kvz_intra_get_dir_luma_predictor ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
lcu_px$1$sroa$1078$1$ = 80
luma_px$3 = 88
pic_px$4 = 88
luma_px$5 = 88
luma_px$6 = 96
pic_px$7 = 96
cfg$1$ = 104
refs$8 = 112
refs$9 = 112
refs$10 = 112
pred$11 = 384
pred$12 = 384
pred$13 = 384
state$ = 1488
x$ = 1496
$T14 = 1504
y$ = 1504
$T15 = 1512
has_luma$1$ = 1512
depth$ = 1512
width$1$ = 1520
mode_luma$ = 1520
mode_chroma$ = 1528
tv1789 = 1536
width$1$ = 1536
pic_px$16 = 1536
cur_cu$ = 1536
lcu$ = 1544
kvz_intra_recon_cu PROC

; 632  : {

$LN329:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-1168]
	sub	rsp, 1424				; 00000590H

; 633  :   const vector2d_t lcu_px = { SUB_SCU(x), SUB_SCU(y) };
; 634  :   const int8_t width = LCU_WIDTH >> depth;
; 635  :   if (cur_cu == NULL) {

	mov	r13, QWORD PTR cur_cu$[rbp-256]
	mov	r14d, r8d
	mov	r12, QWORD PTR lcu$[rbp-256]
	mov	r10d, edx
	movsxd	r15, r9d
	mov	rdx, rcx
	mov	r8d, r10d
	mov	ebx, r14d
	and	r8d, 63					; 0000003fH
	mov	ecx, r15d
	mov	edi, 64					; 00000040H
	mov	DWORD PTR lcu_px$1$sroa$1078$1$[rsp], r8d
	and	ebx, 63					; 0000003fH
	sar	edi, cl
	test	r13, r13
	jne	SHORT $LN322@kvz_intra_

; 636  :     cur_cu = LCU_GET_CU_AT_PX(lcu, lcu_px.x, lcu_px.y);

	mov	ecx, r8d
	mov	edx, ebx
	shr	edx, 2
	shr	ecx, 2
	add	ecx, 18
	imul	eax, edx, 17
	mov	DWORD PTR $T15[rbp-256], edx
	mov	rdx, QWORD PTR state$[rbp-256]
	add	ecx, eax
	lea	r13, QWORD PTR [rcx+1561]
	lea	r13, QWORD PTR [rcx+r13*4]
	lea	r13, QWORD PTR [r12+r13*4]
	jmp	SHORT $LN2@kvz_intra_
$LN322@kvz_intra_:
	mov	eax, ebx
	shr	eax, 2
	mov	DWORD PTR $T15[rbp-256], eax
$LN2@kvz_intra_:

; 637  :   }
; 638  : 
; 639  :   // Reset CBFs because CBFs might have been set
; 640  :   // for depth earlier
; 641  :   if (mode_luma >= 0) {

	movzx	r11d, BYTE PTR mode_luma$[rbp-256]
	lea	rax, OFFSET FLAT:cbf_masks
	mov	rcx, r15
	test	r11b, r11b
	js	SHORT $LN313@kvz_intra_
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	movzx	eax, WORD PTR [rax+r15*2]
	not	ax
	and	WORD PTR [r13+4], ax
	lea	rax, OFFSET FLAT:cbf_masks
$LN313@kvz_intra_:
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 644  :   if (mode_chroma >= 0) {

	movzx	r9d, BYTE PTR mode_chroma$[rbp-256]
	test	r9b, r9b
	js	SHORT $LN323@kvz_intra_
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	movzx	eax, WORD PTR [rax+rcx*2]
	movzx	ecx, ax
	shl	ax, 5
	shl	cx, 10
	not	ax
	not	cx
	and	cx, ax
	and	WORD PTR [r13+4], cx
$LN323@kvz_intra_:
	mov	QWORD PTR [rsp+1416], rsi
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 649  :   if (depth == 0 || cur_cu->tr_depth > depth) {

	test	r15d, r15d
	je	$LN7@kvz_intra_
	movzx	eax, BYTE PTR [r13+1]
	and	eax, 7
	cmp	eax, r15d
	jg	$LN7@kvz_intra_

; 671  :       cbf_set_conditionally(&cur_cu->cbf, child_cbfs, depth, COLOR_U);
; 672  :       cbf_set_conditionally(&cur_cu->cbf, child_cbfs, depth, COLOR_V);
; 673  :     }
; 674  :   } else {
; 675  :     const bool has_luma = mode_luma != -1;

	cmp	r11b, -1
	setne	BYTE PTR has_luma$1$[rbp-256]

; 676  :     const bool has_chroma = mode_chroma != -1 && x % 8 == 0 && y % 8 == 0;

	cmp	r9b, -1
	je	SHORT $LN13@kvz_intra_
	mov	eax, r10d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN325@kvz_intra_
	dec	eax
	or	eax, -8
	inc	eax
$LN325@kvz_intra_:
	test	eax, eax
	jne	SHORT $LN13@kvz_intra_
	mov	eax, r14d
	and	eax, -2147483641			; ffffffff80000007H
	jge	SHORT $LN324@kvz_intra_
	dec	eax
	or	eax, -8
	inc	eax
$LN324@kvz_intra_:
	mov	BYTE PTR $T14[rbp-256], 1
	test	eax, eax
	je	SHORT $LN14@kvz_intra_
$LN13@kvz_intra_:
	mov	BYTE PTR $T14[rbp-256], 0
$LN14@kvz_intra_:

; 677  :     // Process a leaf TU.
; 678  :     if (has_luma) {

	mov	eax, 6
	lea	edi, QWORD PTR [rax-5]
	cmp	r11b, -1
	je	$LN268@kvz_intra_

; 570  :   const kvz_config *cfg = &state->encoder_control->cfg;

	mov	rcx, QWORD PTR [rdx]

; 571  :   const int shift = color == COLOR_Y ? 0 : 1;
; 572  : 
; 573  :   int log2width = LOG2_LCU_WIDTH - depth;

	mov	esi, eax
	sub	esi, r15d
	mov	QWORD PTR cfg$1$[rsp], rcx

; 577  :   }
; 578  :   const int width = 1 << log2width;

	mov	ecx, esi

; 579  :   const int lcu_width = LCU_WIDTH >> shift;
; 580  : 
; 581  :   const vector2d_t luma_px = { x, y };

	mov	DWORD PTR luma_px$5[rsp], r10d
	mov	eax, edi
	mov	DWORD PTR luma_px$5[rsp+4], r14d
	shl	eax, cl
	mov	DWORD PTR width$1$[rbp-256], eax

; 582  :   const vector2d_t pic_px = {

	mov	rax, QWORD PTR [rdx+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR pic_px$7[rsp], eax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR pic_px$7[rsp+4], eax

; 583  :     state->tile->frame->width,
; 584  :     state->tile->frame->height,
; 585  :   };
; 586  :   const vector2d_t lcu_px = { SUB_SCU(x) >> shift, SUB_SCU(y) >> shift};

	test	r10d, r10d

; 554  :   if (luma_px->x > 0 && luma_px->y > 0) {

	jle	SHORT $LN280@kvz_intra_
	test	r14d, r14d
	jle	SHORT $LN280@kvz_intra_

; 555  :     kvz_intra_build_reference_inner(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs$10[rsp]
	xor	edx, edx
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$7[rsp]
	lea	r8, QWORD PTR luma_px$5[rsp]
	mov	QWORD PTR [rsp+32], r12
	movzx	ecx, sil
	call	kvz_intra_build_reference_inner

; 556  :   } else {

	jmp	SHORT $LN281@kvz_intra_
$LN280@kvz_intra_:

; 557  :     kvz_intra_build_reference_any(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs$10[rsp]
	xor	edx, edx
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$7[rsp]
	lea	r8, QWORD PTR luma_px$5[rsp]
	mov	QWORD PTR [rsp+32], r12
	movzx	ecx, sil
	call	kvz_intra_build_reference_any
$LN281@kvz_intra_:

; 592  :   const bool filter_boundary = color == COLOR_Y && !(cfg->lossless && cfg->implicit_rdpcm);

	mov	rax, QWORD PTR cfg$1$[rsp]
	cmp	DWORD PTR [rax+2392], 0
	je	SHORT $LN276@kvz_intra_
	cmp	DWORD PTR [rax+2420], 0
	je	SHORT $LN276@kvz_intra_
	xor	al, al
	jmp	SHORT $LN278@kvz_intra_
$LN276@kvz_intra_:
	movzx	eax, dil
$LN278@kvz_intra_:

; 593  :   kvz_intra_predict(&refs, log2width, intra_mode, color, pred, filter_boundary);

	movzx	r8d, BYTE PTR mode_luma$[rbp-256]
	lea	rcx, QWORD PTR refs$10[rsp]
	mov	BYTE PTR [rsp+40], al
	xor	r9d, r9d
	lea	rax, QWORD PTR pred$13[rbp-256]
	movzx	edx, sil
	mov	QWORD PTR [rsp+32], rax
	call	kvz_intra_predict

; 606  :       break;
; 607  :   }
; 608  :   kvz_pixels_blit(pred, block , width, width, width, lcu_width);

	mov	r8d, DWORD PTR width$1$[rbp-256]
	lea	rdx, QWORD PTR [r12+6540]
	mov	eax, ebx
	mov	DWORD PTR [rsp+40], 64			; 00000040H
	shl	eax, 6
	lea	rcx, QWORD PTR pred$13[rbp-256]
	add	eax, DWORD PTR lcu_px$1$sroa$1078$1$[rsp]
	mov	r9d, r8d
	add	rdx, rax
	mov	DWORD PTR [rsp+32], r8d
	call	kvz_pixels_blit
	mov	r10d, DWORD PTR x$[rbp-256]
	mov	eax, 6
	mov	r8d, DWORD PTR lcu_px$1$sroa$1078$1$[rsp]
$LN268@kvz_intra_:

; 679  :       intra_recon_tb_leaf(state, x, y, depth, mode_luma, lcu, COLOR_Y);
; 680  :     }
; 681  :     if (has_chroma) {

	cmp	BYTE PTR $T14[rbp-256], 0
	je	$LN298@kvz_intra_

; 573  :   int log2width = LOG2_LCU_WIDTH - depth;

	sub	eax, r15d
	mov	DWORD PTR tv1789[rbp-256], eax
	mov	esi, eax

; 574  :   if (color != COLOR_Y && depth < MAX_PU_DEPTH) {

	cmp	r15d, 4
	jge	SHORT $LN321@kvz_intra_

; 575  :     // Chroma width is half of luma width, when not at maximum depth.
; 576  :     log2width -= 1;

	dec	esi
$LN321@kvz_intra_:

; 577  :   }
; 578  :   const int width = 1 << log2width;

	mov	ecx, esi

; 583  :     state->tile->frame->width,
; 584  :     state->tile->frame->height,
; 585  :   };
; 586  :   const vector2d_t lcu_px = { SUB_SCU(x) >> shift, SUB_SCU(y) >> shift};

	shr	r8d, 1
	mov	eax, edi
	shr	ebx, 1
	shl	eax, cl
	mov	DWORD PTR width$1$[rbp-256], eax
	mov	rax, QWORD PTR state$[rbp-256]
	mov	DWORD PTR luma_px$6[rsp], r10d
	mov	DWORD PTR luma_px$6[rsp+4], r14d
	mov	DWORD PTR lcu_px$1$sroa$1078$1$[rsp], r8d
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR pic_px$4[rsp], eax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR pic_px$4[rsp+4], eax
	test	r10d, r10d

; 554  :   if (luma_px->x > 0 && luma_px->y > 0) {

	jle	SHORT $LN295@kvz_intra_
	test	r14d, r14d
	jle	SHORT $LN295@kvz_intra_

; 555  :     kvz_intra_build_reference_inner(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs$9[rsp]
	mov	edx, edi
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$4[rsp]
	lea	r8, QWORD PTR luma_px$6[rsp]
	mov	QWORD PTR [rsp+32], r12
	movzx	ecx, sil
	call	kvz_intra_build_reference_inner

; 556  :   } else {

	jmp	SHORT $LN296@kvz_intra_
$LN295@kvz_intra_:

; 557  :     kvz_intra_build_reference_any(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs$9[rsp]
	mov	edx, edi
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$4[rsp]
	lea	r8, QWORD PTR luma_px$6[rsp]
	mov	QWORD PTR [rsp+32], r12
	movzx	ecx, sil
	call	kvz_intra_build_reference_any
$LN296@kvz_intra_:

; 593  :   kvz_intra_predict(&refs, log2width, intra_mode, color, pred, filter_boundary);

	movzx	r8d, BYTE PTR mode_chroma$[rbp-256]
	lea	rax, QWORD PTR pred$12[rbp-256]
	mov	BYTE PTR [rsp+40], 0
	lea	rcx, QWORD PTR refs$9[rsp]
	mov	r9d, edi
	mov	QWORD PTR [rsp+32], rax
	movzx	edx, sil
	call	kvz_intra_predict

; 606  :       break;
; 607  :   }
; 608  :   kvz_pixels_blit(pred, block , width, width, width, lcu_width);

	mov	r8d, DWORD PTR width$1$[rbp-256]
	lea	rdx, QWORD PTR [r12+10636]
	mov	esi, DWORD PTR lcu_px$1$sroa$1078$1$[rsp]
	lea	rcx, QWORD PTR pred$12[rbp-256]
	shl	ebx, 5
	mov	r9d, r8d
	add	esi, ebx
	mov	DWORD PTR [rsp+40], 32			; 00000020H
	add	rdx, rsi
	mov	DWORD PTR [rsp+32], r8d
	call	kvz_pixels_blit

; 578  :   const int width = 1 << log2width;

	mov	eax, DWORD PTR tv1789[rbp-256]
	cmp	r15d, 4

; 579  :   const int lcu_width = LCU_WIDTH >> shift;
; 580  : 
; 581  :   const vector2d_t luma_px = { x, y };

	mov	edx, DWORD PTR x$[rbp-256]
	mov	DWORD PTR luma_px$3[rsp], edx
	mov	DWORD PTR luma_px$3[rsp+4], r14d
	lea	ebx, DWORD PTR [rax-1]
	cmovge	ebx, eax

; 582  :   const vector2d_t pic_px = {

	mov	rax, QWORD PTR state$[rbp-256]
	mov	ecx, ebx
	shl	edi, cl
	mov	rax, QWORD PTR [rax+48]
	mov	rcx, QWORD PTR [rax]
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR pic_px$16[rbp-256], eax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR pic_px$16[rbp-252], eax

; 583  :     state->tile->frame->width,
; 584  :     state->tile->frame->height,
; 585  :   };
; 586  :   const vector2d_t lcu_px = { SUB_SCU(x) >> shift, SUB_SCU(y) >> shift};

	test	edx, edx

; 554  :   if (luma_px->x > 0 && luma_px->y > 0) {

	jle	SHORT $LN310@kvz_intra_
	test	r14d, r14d
	jle	SHORT $LN310@kvz_intra_

; 555  :     kvz_intra_build_reference_inner(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs$8[rsp]
	mov	edx, 2
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$16[rbp-256]
	lea	r8, QWORD PTR luma_px$3[rsp]
	mov	QWORD PTR [rsp+32], r12
	movzx	ecx, bl
	call	kvz_intra_build_reference_inner

; 556  :   } else {

	jmp	SHORT $LN311@kvz_intra_
$LN310@kvz_intra_:

; 557  :     kvz_intra_build_reference_any(log2_width, color, luma_px, pic_px, lcu, refs);

	lea	rax, QWORD PTR refs$8[rsp]
	mov	edx, 2
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$16[rbp-256]
	lea	r8, QWORD PTR luma_px$3[rsp]
	mov	QWORD PTR [rsp+32], r12
	movzx	ecx, bl
	call	kvz_intra_build_reference_any
$LN311@kvz_intra_:

; 593  :   kvz_intra_predict(&refs, log2width, intra_mode, color, pred, filter_boundary);

	movzx	r8d, BYTE PTR mode_chroma$[rbp-256]
	lea	rax, QWORD PTR pred$11[rbp-256]
	mov	BYTE PTR [rsp+40], 0
	lea	rcx, QWORD PTR refs$8[rsp]
	mov	r9d, 2
	mov	QWORD PTR [rsp+32], rax
	movzx	edx, bl
	call	kvz_intra_predict

; 594  : 
; 595  :   const int index = lcu_px.x + lcu_px.y * lcu_width;
; 596  :   kvz_pixel *block = NULL;
; 597  :   switch (color) {
; 598  :     case COLOR_Y:
; 599  :       block = &lcu->rec.y[index];
; 600  :       break;
; 601  :     case COLOR_U:
; 602  :       block = &lcu->rec.u[index];
; 603  :       break;
; 604  :     case COLOR_V:
; 605  :       block = &lcu->rec.v[index];

	lea	rdx, QWORD PTR [r12+11660]

; 606  :       break;
; 607  :   }
; 608  :   kvz_pixels_blit(pred, block , width, width, width, lcu_width);

	mov	DWORD PTR [rsp+40], 32			; 00000020H
	add	rdx, rsi
	mov	DWORD PTR [rsp+32], edi
	mov	r9d, edi
	lea	rcx, QWORD PTR pred$11[rbp-256]
	mov	r8d, edi
	call	kvz_pixels_blit
$LN298@kvz_intra_:

; 682  :       intra_recon_tb_leaf(state, x, y, depth, mode_chroma, lcu, COLOR_U);
; 683  :       intra_recon_tb_leaf(state, x, y, depth, mode_chroma, lcu, COLOR_V);
; 684  :     }
; 685  : 
; 686  :     kvz_quantize_lcu_residual(state, has_luma, has_chroma, x, y, depth, cur_cu, lcu, false);

	mov	r9d, DWORD PTR x$[rbp-256]
	movzx	r8d, BYTE PTR $T14[rbp-256]
	movzx	edx, BYTE PTR has_luma$1$[rbp-256]
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	BYTE PTR [rsp+64], 0
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], r13
	mov	BYTE PTR [rsp+40], r15b
	mov	DWORD PTR [rsp+32], r14d
	call	kvz_quantize_lcu_residual
	jmp	$LN266@kvz_intra_
$LN7@kvz_intra_:

; 650  : 
; 651  :     const int offset = width / 2;
; 652  :     const int32_t x2 = x + offset;
; 653  :     const int32_t y2 = y + offset;
; 654  : 
; 655  :     kvz_intra_recon_cu(state, x,  y,  depth + 1, mode_luma, mode_chroma, NULL, lcu);

	mov	rcx, QWORD PTR state$[rbp-256]
	movsx	eax, dil
	cdq
	mov	QWORD PTR [rsp+56], r12
	sub	eax, edx
	mov	QWORD PTR [rsp+48], 0
	sar	eax, 1
	mov	edx, r10d
	mov	r14d, eax
	mov	BYTE PTR [rsp+40], r9b
	lea	r9d, DWORD PTR [r15+1]
	mov	BYTE PTR [rsp+32], r11b
	lea	esi, DWORD PTR [rax+r10]
	mov	eax, DWORD PTR y$[rbp-256]
	mov	r8d, eax
	lea	edi, DWORD PTR [r14+rax]
	call	kvz_intra_recon_cu

; 656  :     kvz_intra_recon_cu(state, x2, y,  depth + 1, mode_luma, mode_chroma, NULL, lcu);

	movzx	eax, BYTE PTR mode_chroma$[rbp-256]
	lea	r9d, DWORD PTR [r15+1]
	mov	r8d, DWORD PTR y$[rbp-256]
	mov	edx, esi
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], 0
	mov	BYTE PTR [rsp+40], al
	movzx	eax, BYTE PTR mode_luma$[rbp-256]
	mov	BYTE PTR [rsp+32], al
	call	kvz_intra_recon_cu

; 657  :     kvz_intra_recon_cu(state, x,  y2, depth + 1, mode_luma, mode_chroma, NULL, lcu);

	movzx	eax, BYTE PTR mode_chroma$[rbp-256]
	lea	r9d, DWORD PTR [r15+1]
	mov	edx, DWORD PTR x$[rbp-256]
	mov	r8d, edi
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], 0
	mov	BYTE PTR [rsp+40], al
	movzx	eax, BYTE PTR mode_luma$[rbp-256]
	mov	BYTE PTR [rsp+32], al
	call	kvz_intra_recon_cu

; 658  :     kvz_intra_recon_cu(state, x2, y2, depth + 1, mode_luma, mode_chroma, NULL, lcu);

	movzx	eax, BYTE PTR mode_chroma$[rbp-256]
	lea	r9d, DWORD PTR [r15+1]
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	r8d, edi
	mov	QWORD PTR [rsp+56], r12
	mov	edx, esi
	mov	QWORD PTR [rsp+48], 0
	mov	BYTE PTR [rsp+40], al
	movzx	eax, BYTE PTR mode_luma$[rbp-256]
	mov	BYTE PTR [rsp+32], al
	call	kvz_intra_recon_cu

; 659  : 
; 660  :     // Propagate coded block flags from child CUs to parent CU.
; 661  :     uint16_t child_cbfs[3] = {

	mov	r9d, DWORD PTR lcu_px$1$sroa$1078$1$[rsp]

; 662  :       LCU_GET_CU_AT_PX(lcu, lcu_px.x + offset, lcu_px.y         )->cbf,
; 663  :       LCU_GET_CU_AT_PX(lcu, lcu_px.x,          lcu_px.y + offset)->cbf,
; 664  :       LCU_GET_CU_AT_PX(lcu, lcu_px.x + offset, lcu_px.y + offset)->cbf,
; 665  :     };
; 666  : 
; 667  :     if (mode_luma != -1 && depth <= MAX_DEPTH) {

	mov	r8, r15
	imul	eax, DWORD PTR $T15[rbp-256], 17
	lea	edx, DWORD PTR [r9+r14]
	shr	r9d, 2
	sar	edx, 2
	add	eax, edx
	movsxd	rcx, eax
	add	rcx, 1267				; 000004f3H
	lea	rax, QWORD PTR [rcx+rcx*4]
	movzx	r10d, WORD PTR [r12+rax*4]
	mov	eax, ebx
	add	eax, r14d
	sar	eax, 2
	imul	ecx, eax, 17
	lea	eax, DWORD PTR [rcx+r9]
	cdqe
	lea	r9, OFFSET FLAT:cbf_masks
	add	rax, 1267				; 000004f3H
	lea	rax, QWORD PTR [rax+rax*4]
	movzx	ebx, WORD PTR [r12+rax*4]
	lea	eax, DWORD PTR [rcx+rdx]
	movsxd	rcx, eax
	mov	edx, 16
	add	rcx, 1267				; 000004f3H
	cmp	BYTE PTR mode_luma$[rbp-256], -1
	lea	rax, QWORD PTR [rcx+rcx*4]
	movzx	r11d, WORD PTR [r12+rax*4]
	je	SHORT $LN240@kvz_intra_
	cmp	r15d, 3
	jg	SHORT $LN240@kvz_intra_
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR [r9+r15*2+2]
	test	ax, r10w

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN232@kvz_intra_

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	test	ax, bx

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN232@kvz_intra_

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	test	ax, r11w

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	je	SHORT $LN240@kvz_intra_
$LN232@kvz_intra_:

; 537  :   *cbf |= (0x10 >> depth) << (NUM_CBF_DEPTHS * plane);

	mov	eax, edx
	mov	ecx, r15d
	sar	eax, cl
	or	WORD PTR [r13+4], ax
$LN240@kvz_intra_:
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 670  :     if (mode_chroma != -1 && depth <= MAX_DEPTH) {

	cmp	BYTE PTR mode_chroma$[rbp-256], -1
	je	SHORT $LN266@kvz_intra_
	cmp	r15d, 3
	jg	SHORT $LN266@kvz_intra_
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	r8d, WORD PTR [r9+r8*2+2]
	mov	edi, r10d
	mov	eax, r8d
	shl	eax, 5
	test	eax, r10d

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN245@kvz_intra_

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	r10d, ebx
	test	eax, ebx

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN245@kvz_intra_

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	mov	r9d, r11d
	test	eax, r11d

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN245@kvz_intra_
	mov	ecx, r15d
	sar	edx, cl
	jmp	SHORT $LN316@kvz_intra_
$LN245@kvz_intra_:

; 537  :   *cbf |= (0x10 >> depth) << (NUM_CBF_DEPTHS * plane);

	mov	ecx, r15d
	mov	r10d, ebx
	sar	edx, cl
	mov	r9d, r11d
	movzx	eax, dx
	shl	ax, 5
	or	WORD PTR [r13+4], ax
$LN316@kvz_intra_:

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	shl	r8d, 10
	test	r8d, edi

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN258@kvz_intra_

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	test	r8d, r10d

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN258@kvz_intra_

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	test	r8d, r9d

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	je	SHORT $LN266@kvz_intra_
$LN258@kvz_intra_:

; 537  :   *cbf |= (0x10 >> depth) << (NUM_CBF_DEPTHS * plane);

	shl	dx, 10
	or	WORD PTR [r13+4], dx
$LN266@kvz_intra_:
	mov	rsi, QWORD PTR [rsp+1416]
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 688  : }

	add	rsp, 1424				; 00000590H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
kvz_intra_recon_cu ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_is_set PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movsxd	rax, edx
	movzx	r9d, cx
	lea	rcx, OFFSET FLAT:cbf_masks
	movzx	edx, WORD PTR [rcx+rax*2]
	lea	ecx, DWORD PTR [r8+r8*4]
	shl	edx, cl
	mov	eax, 0
	test	edx, r9d
	setne	al

; 519  : }

	ret	0
cbf_is_set ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_set	PROC

; 535  : {

	mov	r9, rcx

; 536  :   // Return value of the bit corresponding to the level.
; 537  :   *cbf |= (0x10 >> depth) << (NUM_CBF_DEPTHS * plane);

	mov	eax, 16
	mov	ecx, edx
	sar	eax, cl
	lea	ecx, DWORD PTR [r8+r8*4]
	shl	ax, cl
	or	WORD PTR [r9], ax

; 538  : }

	ret	0
cbf_set	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
child_cbfs$ = 16
depth$ = 24
plane$ = 32
cbf_set_conditionally PROC

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	r11d, DWORD PTR [r9+r9*4]
	movsxd	rax, r8d

; 545  : {

	mov	r10, rcx

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	lea	rcx, OFFSET FLAT:cbf_masks+2
	movzx	r9d, WORD PTR [rcx+rax*2]
	mov	ecx, r11d
	movzx	eax, WORD PTR [rdx]
	shl	r9d, cl
	test	eax, r9d

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN4@cbf_set_co

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR [rdx+2]
	test	eax, r9d

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	jne	SHORT $LN4@cbf_set_co

; 518  :   return (cbf & (cbf_masks[depth] << (NUM_CBF_DEPTHS * plane))) != 0;

	movzx	eax, WORD PTR [rdx+4]
	test	eax, r9d

; 546  :   bool child_cbf_set = cbf_is_set(child_cbfs[0], depth + 1, plane) ||

	je	SHORT $LN12@cbf_set_co
$LN4@cbf_set_co:

; 537  :   *cbf |= (0x10 >> depth) << (NUM_CBF_DEPTHS * plane);

	mov	ecx, r8d
	mov	eax, 16
	sar	eax, cl
	mov	ecx, r11d
	shl	ax, cl
	or	WORD PTR [r10], ax
$LN12@cbf_set_co:

; 547  :                        cbf_is_set(child_cbfs[1], depth + 1, plane) ||
; 548  :                        cbf_is_set(child_cbfs[2], depth + 1, plane);
; 549  :   if (child_cbf_set) {
; 550  :     cbf_set(cbf, depth, plane);
; 551  :   }
; 552  : }

	ret	0
cbf_set_conditionally ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\cu.h
_TEXT	SEGMENT
cbf$ = 8
depth$ = 16
plane$ = 24
cbf_clear PROC

; 559  :   *cbf &= ~(cbf_masks[depth] << (NUM_CBF_DEPTHS * plane));

	movsxd	rax, edx
	mov	r9, rcx
	lea	rdx, OFFSET FLAT:cbf_masks
	lea	ecx, DWORD PTR [r8+r8*4]
	movzx	edx, WORD PTR [rdx+rax*2]
	shl	dx, cl
	not	dx
	and	WORD PTR [r9], dx

; 560  : }

	ret	0
cbf_clear ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
_TEXT	SEGMENT
value$ = 48
kvz_math_floor_log2 PROC

; 44   : {

	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, ecx

; 45   :   assert(value > 0);

	test	ecx, ecx
	jne	SHORT $LN6@kvz_math_f
	lea	r8d, QWORD PTR [rcx+45]
	lea	rcx, OFFSET FLAT:$SG4294942895
	lea	rdx, OFFSET FLAT:$SG4294942896
	call	QWORD PTR __imp__wassert
$LN6@kvz_math_f:

; 46   : 
; 47   :   unsigned result = 0;
; 48   : 
; 49   :   for (int i = 4; i >= 0; --i) {
; 50   :     unsigned bits = 1ull << i;
; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	xor	r9d, r9d
	mov	eax, 1
	mov	edx, eax
	mov	r8d, r9d
	rol	rdx, 4
	mov	ecx, edx
	shl	eax, cl
	cmp	ebx, eax
	mov	eax, 8
	cmovae	r8d, edx
	mov	edx, 4

; 52   :     result += shift;
; 53   :     value >>= shift;

	mov	ecx, r8d
	shr	ebx, cl
	mov	ecx, r9d
	cmp	ebx, 256				; 00000100H
	cmovae	ecx, eax
	shr	ebx, cl
	cmp	ebx, 16
	lea	eax, DWORD PTR [r8+rcx]
	mov	ecx, r9d
	cmovae	ecx, edx
	mov	edx, 2
	add	eax, ecx
	shr	ebx, cl
	cmp	ebx, 4
	mov	ecx, r9d
	cmovae	ecx, edx
	add	eax, ecx
	shr	ebx, cl
	cmp	ebx, edx
	setae	r9b
	add	eax, r9d

; 54   :   }
; 55   : 
; 56   :   return result;
; 57   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
kvz_math_floor_log2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
log2_width$ = 16
refs$ = 24
intra_filter_reference PROC

; 179  : {

	sub	rsp, 8

; 180  :   if (refs->filtered_initialized) {

	cmp	BYTE PTR [rdx+260], 0
	mov	r10, rdx
	jne	$LN1@intra_filt

; 181  :     return;
; 182  :   } else {
; 183  :     refs->filtered_initialized = true;

	mov	BYTE PTR [rdx+260], 1
	mov	r9b, 1

; 184  :   }
; 185  : 
; 186  :   const int_fast8_t ref_width = 2 * (1 << log2_width) + 1;
; 187  :   kvz_intra_ref *ref = &refs->ref;
; 188  :   kvz_intra_ref *filtered_ref = &refs->filtered_ref;
; 189  : 
; 190  :   filtered_ref->left[0] = (ref->left[1] + 2 * ref->left[0] + ref->top[1] + 2) / 4;

	movzx	edx, BYTE PTR [rdx]
	movzx	eax, BYTE PTR [r10+66]
	mov	QWORD PTR [rsp+16], rbx
	add	eax, 2
	mov	ebx, 1
	mov	QWORD PTR [rsp], rdi
	shl	bl, cl
	add	bl, bl
	lea	edx, DWORD PTR [rax+rdx*2]

; 191  :   filtered_ref->top[0] = filtered_ref->left[0];
; 192  : 
; 193  :   for (int_fast8_t y = 1; y < ref_width - 1; ++y) {

	movsx	r11d, bl
	movzx	eax, BYTE PTR [r10+1]
	add	edx, eax
	shr	edx, 2
	mov	BYTE PTR [r10+130], dl
	mov	BYTE PTR [r10+195], dl
	cmp	r11d, 1
	jle	$LN3@intra_filt
	npad	12
$LL4@intra_filt:

; 194  :     kvz_pixel *p = &ref->left[y];

	movsx	r8, r9b
	inc	r9b

; 195  :     filtered_ref->left[y] = (p[-1] + 2 * p[0] + p[1] + 2) / 4;

	movzx	eax, BYTE PTR [r8+r10-1]
	movzx	edx, BYTE PTR [r8+r10]
	add	eax, 2
	lea	edx, DWORD PTR [rax+rdx*2]
	movzx	eax, BYTE PTR [r8+r10+1]
	add	edx, eax
	movsx	eax, r9b
	shr	edx, 2
	mov	BYTE PTR [r8+r10+130], dl
	cmp	eax, r11d
	jl	SHORT $LL4@intra_filt
	movsx	rax, bl
	lea	rdi, QWORD PTR [r10+130]
	add	rdi, rax
	mov	r9b, 1
	lea	rbx, QWORD PTR [rax+r10]
	movzx	eax, BYTE PTR [rax+r10]
	mov	BYTE PTR [rdi], al
$LL7@intra_filt:

; 198  : 
; 199  :   for (int_fast8_t x = 1; x < ref_width - 1; ++x) {
; 200  :     kvz_pixel *p = &ref->top[x];

	movsx	r8, r9b
	inc	r9b

; 201  :     filtered_ref->top[x] = (p[-1] + 2 * p[0] + p[1] + 2) / 4;

	movzx	eax, BYTE PTR [r8+r10+64]
	movzx	edx, BYTE PTR [r8+r10+65]
	add	eax, 2
	lea	edx, DWORD PTR [rax+rdx*2]
	movzx	eax, BYTE PTR [r8+r10+66]
	add	edx, eax
	movsx	eax, r9b
	shr	edx, 2
	mov	BYTE PTR [r8+r10+195], dl
	cmp	eax, r11d
	jl	SHORT $LL7@intra_filt

; 202  :   }
; 203  :   filtered_ref->top[ref_width - 1] = ref->top[ref_width - 1];

	movzx	eax, BYTE PTR [rbx+65]
	mov	rbx, QWORD PTR [rsp+16]
	mov	BYTE PTR [rdi+65], al
	mov	rdi, QWORD PTR [rsp]

; 204  : }

	add	rsp, 8
	ret	0
$LN3@intra_filt:

; 196  :   }
; 197  :   filtered_ref->left[ref_width - 1] = ref->left[ref_width - 1];

	movsx	rax, bl
	lea	rdi, QWORD PTR [r10+130]
	add	rdi, rax
	lea	rbx, QWORD PTR [rax+r10]
	movzx	eax, BYTE PTR [rax+r10]
	mov	BYTE PTR [rdi], al

; 202  :   }
; 203  :   filtered_ref->top[ref_width - 1] = ref->top[ref_width - 1];

	movzx	eax, BYTE PTR [rbx+65]
	mov	rbx, QWORD PTR [rsp+16]
	mov	BYTE PTR [rdi+65], al
	mov	rdi, QWORD PTR [rsp]
$LN1@intra_filt:

; 204  : }

	add	rsp, 8
	ret	0
intra_filter_reference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
width$ = 16
stride$ = 24
ref$ = 32
block$ = 40
intra_post_process_angular PROC

; 214  :   for (unsigned i = 0; i < width; i++) {

	test	ecx, ecx
	je	SHORT $LN17@intra_post
	mov	QWORD PTR [rsp+16], rsi
	push	rdi

; 213  :   kvz_pixel ref2 = ref[0];

	xor	esi, esi
	mov	QWORD PTR [rsp+16], rbx
	movzx	ebx, BYTE PTR [r8]
	mov	r10d, esi
	inc	r8
	mov	edi, edx
	mov	r11d, ecx
$LL4@intra_post:

; 215  :     kvz_pixel val = block[i * stride];
; 216  :     kvz_pixel ref1 = ref[i + 1];
; 217  :     block[i * stride] = CLIP_TO_PIXEL(val + ((ref1 - ref2) >> 1));

	movzx	ecx, BYTE PTR [r8]
	mov	eax, r10d
	imul	eax, edi
	sub	ecx, ebx
	sar	ecx, 1
	mov	edx, eax
	movzx	eax, BYTE PTR [rax+r9]
	add	eax, ecx
	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN6@intra_post
	mov	eax, 255				; 000000ffH
	jmp	SHORT $LN8@intra_post
$LN6@intra_post:
	test	eax, eax
	cmovs	eax, esi
$LN8@intra_post:
	inc	r10d
	mov	BYTE PTR [rdx+r9], al
	inc	r8
	cmp	r10d, r11d
	jb	SHORT $LL4@intra_post

; 218  :   }
; 219  : }

	mov	rbx, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+24]
	pop	rdi
$LN17@intra_post:
	ret	0
intra_post_process_angular ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
log2_width$ = 48
ref_top$ = 56
ref_left$ = 64
out_block$ = 72
intra_pred_dc PROC

; 234  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 235  :   int_fast8_t width = 1 << log2_width;

	movsx	esi, cl
	mov	ebx, 1
	mov	ecx, esi
	mov	edi, ebx
	shl	dil, cl

; 236  : 
; 237  :   int_fast16_t sum = 0;

	xor	r10d, r10d
	mov	r11, rdx

; 238  :   for (int_fast8_t i = 0; i < width; ++i) {

	test	dil, dil
	jle	SHORT $LN3@intra_pred

; 235  :   int_fast8_t width = 1 << log2_width;

	lea	rax, QWORD PTR [r8+1]
	sub	r11, r8
	movzx	r8d, dil
	npad	12
$LL4@intra_pred:

; 239  :     sum += ref_top[i + 1];
; 240  :     sum += ref_left[i + 1];

	movzx	ecx, BYTE PTR [rax]
	movzx	edx, BYTE PTR [r11+rax]
	lea	rax, QWORD PTR [rax+1]
	add	r10d, ecx
	add	r10d, edx
	sub	r8, rbx
	jne	SHORT $LL4@intra_pred
$LN3@intra_pred:

; 241  :   }
; 242  : 
; 243  :   const kvz_pixel dc_val = (sum + width) >> (log2_width + 1);

	lea	ecx, DWORD PTR [rsi+1]
	movsx	eax, dil
	add	eax, r10d
	sar	eax, cl

; 244  :   const int_fast16_t block_size = 1 << (log2_width * 2);

	lea	ecx, DWORD PTR [rsi+rsi]
	shl	ebx, cl

; 245  : 
; 246  :   for (int_fast16_t i = 0; i < block_size; ++i) {

	test	ebx, ebx
	jle	SHORT $LN6@intra_pred

; 241  :   }
; 242  : 
; 243  :   const kvz_pixel dc_val = (sum + width) >> (log2_width + 1);

	movsxd	r8, ebx
	movzx	edx, al
	mov	rcx, r9
	call	memset
$LN6@intra_pred:

; 247  :     out_block[i] = dc_val;
; 248  :   }
; 249  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
intra_pred_dc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
refs$ = 112
log2_width$ = 120
mode$ = 128
color$ = 136
dst$ = 144
filter_boundary$ = 152
kvz_intra_predict PROC

; 259  : {

$LN75:
	mov	DWORD PTR [rsp+32], r9d
	mov	BYTE PTR [rsp+16], dl
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	movsx	r12d, dl

; 260  :   const int_fast8_t width = 1 << log2_width;

	mov	r15d, 1
	mov	QWORD PTR [rsp+112], r13
	mov	ecx, r12d
	movsx	r14d, r8b
	mov	edi, r15d

; 261  : 
; 262  :   const kvz_intra_ref *used_ref = &refs->ref;
; 263  :   if (color != COLOR_Y || mode == 1 || width == 4) {

	xor	ebp, ebp
	shl	dil, cl
	mov	rsi, rbx
	test	r9d, r9d
	jne	$LN4@kvz_intra_
	cmp	r14b, r15b
	je	$LN4@kvz_intra_
	cmp	dil, 4
	je	$LN4@kvz_intra_

; 264  :     // For chroma, DC and 4x4 blocks, always use unfiltered reference.
; 265  :   } else if (mode == 0) {

	test	r8b, r8b
	je	$LN72@kvz_intra_

; 266  :     // Otherwise, use filtered for planar.
; 267  :     used_ref = &refs->filtered_ref;
; 268  :   } else {
; 269  :     // Angular modes use smoothed reference pixels, unless the mode is close
; 270  :     // to being either vertical or horizontal.
; 271  :     static const int kvz_intra_hor_ver_dist_thres[5] = { 0, 7, 1, 0, 0 };
; 272  :     int filter_threshold = kvz_intra_hor_ver_dist_thres[kvz_math_floor_log2(width) - 2];

	movsx	r13d, dil
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h

; 45   :   assert(value > 0);

	test	dil, dil
	jne	SHORT $LN27@kvz_intra_
	lea	r8d, QWORD PTR [r15+44]
	lea	rdx, OFFSET FLAT:$SG4294942896
	lea	rcx, OFFSET FLAT:$SG4294942895
	call	QWORD PTR __imp__wassert
$LN27@kvz_intra_:
	mov	rdx, r15

; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	mov	eax, r15d
	rol	rdx, 4
	mov	r8d, ebp
	mov	ecx, edx
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 273  :     int dist_from_vert_or_hor = MIN(abs(mode - 26), abs(mode - 10));

	mov	r9d, r14d
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h

; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	shl	eax, cl
	cmp	r13d, eax
	mov	eax, 8
	cmovae	r8d, edx

; 53   :     value >>= shift;

	mov	ecx, r8d
	shr	r13d, cl
	mov	ecx, ebp
	cmp	r13d, 256				; 00000100H
	cmovae	ecx, eax
	mov	eax, 4
	shr	r13d, cl
	cmp	r13d, 16
	lea	r10d, DWORD PTR [r8+rcx]
	mov	ecx, ebp
	cmovae	ecx, eax
	mov	eax, 2
	add	r10d, ecx
	shr	r13d, cl
	cmp	r13d, 4
	mov	ecx, ebp
	cmovae	ecx, eax
	mov	eax, ebp
	add	r10d, ecx
	shr	r13d, cl
	cmp	r13d, 2
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 274  :     if (dist_from_vert_or_hor > filter_threshold) {

	mov	ecx, 26
; File F:\open_codec_learn_2021\kvazaar-master\src\kvz_math.h

; 51   :     unsigned shift = value >= (1 << bits) ? bits : 0;

	setae	al

; 52   :     result += shift;

	add	r10d, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c

; 273  :     int dist_from_vert_or_hor = MIN(abs(mode - 26), abs(mode - 10));

	lea	eax, DWORD PTR [r14-26]
	cdq
	mov	r8d, eax
	lea	eax, DWORD PTR [r14-10]
	xor	r8d, edx
	sub	r8d, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 274  :     if (dist_from_vert_or_hor > filter_threshold) {

	mov	edx, 10
	cmp	r8d, eax
	cmovge	ecx, edx
	sub	r9d, ecx
	lea	rcx, OFFSET FLAT:?kvz_intra_hor_ver_dist_thres@?4??kvz_intra_predict@@9@9
	mov	eax, r9d
	cdq
	xor	eax, edx
	sub	eax, edx
	lea	edx, DWORD PTR [r10-2]
	cmp	eax, DWORD PTR [rcx+rdx*4]
	jle	SHORT $LN4@kvz_intra_
$LN72@kvz_intra_:

; 275  :       used_ref = &refs->filtered_ref;
; 276  :     }
; 277  :   }
; 278  : 
; 279  :   if (used_ref == &refs->filtered_ref && !refs->filtered_initialized) {

	lea	rsi, QWORD PTR [rbx+130]
$LN4@kvz_intra_:
	lea	r10, QWORD PTR [rbx+130]
	cmp	rsi, r10
	jne	$LN28@kvz_intra_
	cmp	BYTE PTR [rbx+260], bpl
	jne	$LN28@kvz_intra_

; 183  :     refs->filtered_initialized = true;

	mov	BYTE PTR [rbx+260], r15b

; 184  :   }
; 185  : 
; 186  :   const int_fast8_t ref_width = 2 * (1 << log2_width) + 1;

	movzx	r12d, dil

; 187  :   kvz_intra_ref *ref = &refs->ref;
; 188  :   kvz_intra_ref *filtered_ref = &refs->filtered_ref;
; 189  : 
; 190  :   filtered_ref->left[0] = (ref->left[1] + 2 * ref->left[0] + ref->top[1] + 2) / 4;

	movzx	eax, BYTE PTR [rbx+66]
	add	r12b, r12b
	movzx	edx, BYTE PTR [rbx]
	add	eax, 2

; 191  :   filtered_ref->top[0] = filtered_ref->left[0];
; 192  : 
; 193  :   for (int_fast8_t y = 1; y < ref_width - 1; ++y) {

	movsx	r11d, r12b
	movzx	r9d, r15b
	lea	edx, DWORD PTR [rax+rdx*2]
	movzx	eax, BYTE PTR [rbx+1]
	add	edx, eax
	shr	edx, 2
	mov	BYTE PTR [r10], dl
	mov	BYTE PTR [r10+65], dl
	cmp	r11d, r15d
	jle	$LN30@kvz_intra_
$LL31@kvz_intra_:

; 194  :     kvz_pixel *p = &ref->left[y];

	movsx	r8, r9b
	inc	r9b

; 195  :     filtered_ref->left[y] = (p[-1] + 2 * p[0] + p[1] + 2) / 4;

	movzx	eax, BYTE PTR [r8+rbx-1]
	movzx	edx, BYTE PTR [r8+rbx]
	add	eax, 2
	lea	edx, DWORD PTR [rax+rdx*2]
	movzx	eax, BYTE PTR [r8+rbx+1]
	add	edx, eax
	movsx	eax, r9b
	shr	edx, 2
	mov	BYTE PTR [r8+r10], dl
	cmp	eax, r11d
	jl	SHORT $LL31@kvz_intra_
	movsx	rax, r12b
	movzx	r9d, r15b
	lea	r13, QWORD PTR [rax+r10]
	lea	r12, QWORD PTR [rax+rbx]
	movzx	eax, BYTE PTR [rax+rbx]
	mov	BYTE PTR [r13], al
	npad	8
$LL34@kvz_intra_:

; 200  :     kvz_pixel *p = &ref->top[x];

	movsx	r8, r9b
	inc	r9b

; 201  :     filtered_ref->top[x] = (p[-1] + 2 * p[0] + p[1] + 2) / 4;

	movzx	eax, BYTE PTR [r8+rbx+64]
	movzx	edx, BYTE PTR [r8+rbx+65]
	add	eax, 2
	lea	edx, DWORD PTR [rax+rdx*2]
	movzx	eax, BYTE PTR [r8+rbx+66]
	add	edx, eax
	movsx	eax, r9b
	shr	edx, 2
	mov	BYTE PTR [r8+r10+65], dl
	cmp	eax, r11d
	jl	SHORT $LL34@kvz_intra_

; 198  : 
; 199  :   for (int_fast8_t x = 1; x < ref_width - 1; ++x) {

	jmp	SHORT $LN33@kvz_intra_
$LN30@kvz_intra_:

; 196  :   }
; 197  :   filtered_ref->left[ref_width - 1] = ref->left[ref_width - 1];

	movsx	rax, r12b
	lea	r13, QWORD PTR [rax+r10]
	lea	r12, QWORD PTR [rax+rbx]
	movzx	eax, BYTE PTR [rax+rbx]
	mov	BYTE PTR [r13], al
$LN33@kvz_intra_:

; 202  :   }
; 203  :   filtered_ref->top[ref_width - 1] = ref->top[ref_width - 1];

	movzx	eax, BYTE PTR [r12+65]
	movzx	r12d, BYTE PTR log2_width$[rsp]
	mov	BYTE PTR [r13+65], al
$LN28@kvz_intra_:
	mov	r13, QWORD PTR [rsp+112]

; 280  :     intra_filter_reference(log2_width, refs);
; 281  :   }
; 282  : 
; 283  :   if (mode == 0) {

	test	r14b, r14b
	jne	SHORT $LN9@kvz_intra_

; 284  :     kvz_intra_pred_planar(log2_width, used_ref->top, used_ref->left, dst);

	mov	r9, QWORD PTR dst$[rsp]
	lea	rdx, QWORD PTR [rsi+65]
	mov	r8, rsi
	movzx	ecx, r12b

; 299  :       }
; 300  :     }
; 301  :   }
; 302  : }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx

; 284  :     kvz_intra_pred_planar(log2_width, used_ref->top, used_ref->left, dst);

	rex_jmp	QWORD PTR kvz_intra_pred_planar
$LN9@kvz_intra_:

; 285  :   } else if (mode == 1) {

	cmp	r14b, r15b
	jne	$LN11@kvz_intra_

; 286  :     // Do extra post filtering for edge pixels of luma DC mode.
; 287  :     if (color == COLOR_Y && width < 32) {

	cmp	DWORD PTR color$[rsp], ebp
	jne	SHORT $LN13@kvz_intra_
	cmp	dil, 32					; 00000020H
	jge	SHORT $LN13@kvz_intra_

; 288  :       kvz_intra_pred_filtered_dc(log2_width, used_ref->top, used_ref->left, dst);

	mov	r9, QWORD PTR dst$[rsp]
	lea	rdx, QWORD PTR [rsi+65]
	mov	r8, rsi
	movzx	ecx, r12b

; 299  :       }
; 300  :     }
; 301  :   }
; 302  : }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx

; 288  :       kvz_intra_pred_filtered_dc(log2_width, used_ref->top, used_ref->left, dst);

	rex_jmp	QWORD PTR kvz_intra_pred_filtered_dc
$LN13@kvz_intra_:

; 238  :   for (int_fast8_t i = 0; i < width; ++i) {

	test	dil, dil
	jle	SHORT $LN40@kvz_intra_

; 204  : }
; 205  : 
; 206  : 
; 207  : static void intra_post_process_angular(
; 208  :   unsigned width,
; 209  :   unsigned stride,
; 210  :   const kvz_pixel *ref,
; 211  :   kvz_pixel *block)
; 212  : {
; 213  :   kvz_pixel ref2 = ref[0];
; 214  :   for (unsigned i = 0; i < width; i++) {
; 215  :     kvz_pixel val = block[i * stride];
; 216  :     kvz_pixel ref1 = ref[i + 1];
; 217  :     block[i * stride] = CLIP_TO_PIXEL(val + ((ref1 - ref2) >> 1));
; 218  :   }
; 219  : }
; 220  : 
; 221  : 
; 222  : /**
; 223  : * \brief Generage planar prediction.
; 224  : * \param log2_width    Log2 of width, range 2..5.
; 225  : * \param in_ref_above  Pointer to -1 index of above reference, length=width*2+1.
; 226  : * \param in_ref_left   Pointer to -1 index of left reference, length=width*2+1.
; 227  : * \param dst           Buffer of size width*width.
; 228  : */
; 229  : static void intra_pred_dc(
; 230  :   const int_fast8_t log2_width,
; 231  :   const kvz_pixel *const ref_top,
; 232  :   const kvz_pixel *const ref_left,
; 233  :   kvz_pixel *const out_block)
; 234  : {
; 235  :   int_fast8_t width = 1 << log2_width;

	lea	rax, QWORD PTR [rsi+1]
	movzx	r8d, dil
	npad	9
$LL41@kvz_intra_:

; 239  :     sum += ref_top[i + 1];
; 240  :     sum += ref_left[i + 1];

	movzx	ecx, BYTE PTR [rax]
	movzx	edx, BYTE PTR [rax+65]
	lea	rax, QWORD PTR [rax+1]
	add	ebp, ecx
	add	ebp, edx
	sub	r8, r15
	jne	SHORT $LL41@kvz_intra_
$LN40@kvz_intra_:

; 241  :   }
; 242  : 
; 243  :   const kvz_pixel dc_val = (sum + width) >> (log2_width + 1);

	movsx	edx, r12b
	movsx	eax, dil
	add	eax, ebp
	lea	ecx, DWORD PTR [rdx+1]
	sar	eax, cl

; 244  :   const int_fast16_t block_size = 1 << (log2_width * 2);

	lea	ecx, DWORD PTR [rdx+rdx]
	shl	r15d, cl

; 245  : 
; 246  :   for (int_fast16_t i = 0; i < block_size; ++i) {

	test	r15d, r15d
	jle	$LN18@kvz_intra_

; 241  :   }
; 242  : 
; 243  :   const kvz_pixel dc_val = (sum + width) >> (log2_width + 1);

	mov	rcx, QWORD PTR dst$[rsp]
	movzx	edx, al
	movsxd	r8, r15d

; 299  :       }
; 300  :     }
; 301  :   }
; 302  : }

	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx

; 243  :   const kvz_pixel dc_val = (sum + width) >> (log2_width + 1);

	jmp	memset
$LN11@kvz_intra_:

; 289  :     } else {
; 290  :       intra_pred_dc(log2_width, used_ref->top, used_ref->left, dst);
; 291  :     }
; 292  :   } else {
; 293  :     kvz_angular_pred(log2_width, mode, used_ref->top, used_ref->left, dst);

	mov	rbx, QWORD PTR dst$[rsp]
	lea	r8, QWORD PTR [rsi+65]
	mov	r9, rsi
	mov	QWORD PTR [rsp+32], rbx
	movzx	edx, r14b
	movzx	ecx, r12b
	call	QWORD PTR kvz_angular_pred

; 294  :     if (color == COLOR_Y && width < 32 && filter_boundary) {

	cmp	DWORD PTR color$[rsp], ebp
	jne	SHORT $LN18@kvz_intra_
	cmp	dil, 32					; 00000020H
	jge	SHORT $LN18@kvz_intra_
	cmp	BYTE PTR filter_boundary$[rsp], bpl
	je	SHORT $LN18@kvz_intra_

; 295  :       if (mode == 10) {

	cmp	r14b, 10
	jne	SHORT $LN16@kvz_intra_

; 296  :         intra_post_process_angular(width, 1, used_ref->top, dst);

	movsx	ecx, dil
	lea	r8, QWORD PTR [rsi+65]
	mov	edx, r15d
	jmp	SHORT $LN73@kvz_intra_
$LN16@kvz_intra_:

; 297  :       } else if (mode == 26) {

	cmp	r14b, 26
	jne	SHORT $LN18@kvz_intra_

; 298  :         intra_post_process_angular(width, width, used_ref->left, dst);

	movsx	ecx, dil
	mov	r8, rsi
	mov	edx, ecx
$LN73@kvz_intra_:

; 299  :       }
; 300  :     }
; 301  :   }
; 302  : }

	mov	r9, rbx
	call	intra_post_process_angular
$LN18@kvz_intra_:
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
kvz_intra_predict ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
out_top_ref$1$ = 32
tv1165 = 128
log2_width$ = 128
tv1167 = 136
color$ = 136
luma_px$ = 144
pic_px$ = 152
lcu$ = 160
is_chroma$1$ = 168
refs$ = 168
kvz_intra_build_reference_any PROC

; 312  : {

$LN95:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H
	mov	r14, QWORD PTR lcu$[rsp]
	movzx	edi, cl
	mov	rsi, r8
	mov	ebx, edx

; 313  :   assert(log2_width >= 2 && log2_width <= 5);

	lea	eax, DWORD PTR [rdi-2]
	cmp	al, 3
	jbe	SHORT $LN34@kvz_intra_
	mov	r8d, 313				; 00000139H
	lea	rdx, OFFSET FLAT:$SG4294942892
	lea	rcx, OFFSET FLAT:$SG4294942891
	call	QWORD PTR __imp__wassert
$LN34@kvz_intra_:

; 314  : 
; 315  :   refs->filtered_initialized = false;

	mov	r15, QWORD PTR refs$[rsp]

; 316  :   kvz_pixel *out_left_ref = &refs->ref.left[0];
; 317  :   kvz_pixel *out_top_ref = &refs->ref.top[0];
; 318  : 
; 319  :   const kvz_pixel dc_val = 1 << (KVZ_BIT_DEPTH - 1);
; 320  :   const int is_chroma = color != COLOR_Y ? 1 : 0;

	xor	r9d, r9d
	test	ebx, ebx
	mov	r10d, r9d

; 321  :   const int_fast8_t width = 1 << log2_width;

	movzx	ecx, dil
	mov	r11d, 1
	setne	r10b
	shl	r11b, cl
	lea	rax, QWORD PTR [r15+65]
	mov	BYTE PTR [r15+260], 0
	mov	QWORD PTR out_top_ref$1$[rsp], rax

; 322  : 
; 323  :   // Convert luma coordinates to chroma coordinates for chroma.
; 324  :   const vector2d_t lcu_px = {

	mov	eax, DWORD PTR [rsi]
	mov	ebp, eax
	mov	DWORD PTR is_chroma$1$[rsp], r10d
	mov	DWORD PTR tv1167[rsp], eax
	and	ebp, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN92@kvz_intra_
	dec	ebp
	or	ebp, -64				; ffffffffffffffc0H
	inc	ebp
$LN92@kvz_intra_:
	mov	eax, DWORD PTR [rsi+4]
	mov	r12d, eax
	mov	DWORD PTR tv1165[rsp], eax
	and	r12d, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN91@kvz_intra_
	dec	r12d
	or	r12d, -64				; ffffffffffffffc0H
	inc	r12d
$LN91@kvz_intra_:

; 325  :     luma_px->x % LCU_WIDTH,
; 326  :     luma_px->y % LCU_WIDTH
; 327  :   };
; 328  :   const vector2d_t px = {

	mov	ecx, r10d
	mov	r13d, ebp
	mov	edx, r12d
	sar	r13d, cl
	sar	edx, cl

; 329  :     lcu_px.x >> is_chroma,
; 330  :     lcu_px.y >> is_chroma,
; 331  :   };
; 332  : 
; 333  :   // Init pointers to LCUs reconstruction buffers, such that index 0 refers to block coordinate 0.
; 334  :   const kvz_pixel *left_ref = !color ? &lcu->left_ref.y[1] : (color == 1) ? &lcu->left_ref.u[1] : &lcu->left_ref.v[1];

	test	ebx, ebx
	je	SHORT $LN87@kvz_intra_
	cmp	ebx, 1
	jne	SHORT $LN43@kvz_intra_

; 335  :   const kvz_pixel *top_ref = !color ? &lcu->top_ref.y[1] : (color == 1) ? &lcu->top_ref.u[1] : &lcu->top_ref.v[1];
; 336  :   const kvz_pixel *rec_ref = !color ? lcu->rec.y : (color == 1) ? lcu->rec.u : lcu->rec.v;

	mov	eax, 10636				; 0000298cH
	lea	ecx, QWORD PTR [rbx+97]
	mov	r8d, 293				; 00000125H
	jmp	SHORT $LN44@kvz_intra_
$LN43@kvz_intra_:
	mov	eax, 11660				; 00002d8cH
	mov	ecx, 147				; 00000093H
	mov	r8d, 342				; 00000156H
	jmp	SHORT $LN44@kvz_intra_
$LN87@kvz_intra_:
	mov	eax, 6540				; 0000198cH
	mov	ecx, 1
	mov	r8d, 196				; 000000c4H
$LN44@kvz_intra_:

; 337  : 
; 338  :   // Init top borders pointer to point to the correct place in the correct reference array.
; 339  :   const kvz_pixel *top_border;
; 340  :   if (px.y) {

	add	rcx, r14
	lea	rbx, QWORD PTR [r8+r14]
	lea	r8, QWORD PTR [rax+r14]
	mov	edi, 64					; 00000040H
	test	edx, edx
	je	SHORT $LN20@kvz_intra_

; 341  :     top_border = &rec_ref[px.x + (px.y - 1) * (LCU_WIDTH >> is_chroma)];

	mov	ecx, r10d
	lea	eax, DWORD PTR [rdx-1]
	sar	edi, cl
	imul	eax, edi
	add	eax, r13d
	movsxd	r14, eax
	add	r14, r8

; 342  :   } else {

	jmp	SHORT $LN21@kvz_intra_
$LN20@kvz_intra_:

; 343  :     top_border = &top_ref[px.x];

	movsxd	r14, r13d
	add	r14, rcx
	mov	ecx, r10d
	sar	edi, cl
$LN21@kvz_intra_:

; 344  :   }
; 345  : 
; 346  :   // Init left borders pointer to point to the correct place in the correct reference array.
; 347  :   const kvz_pixel *left_border;
; 348  :   int left_stride; // Distance between reference samples.
; 349  :   if (px.x) {

	test	r13d, r13d
	je	SHORT $LN22@kvz_intra_

; 350  :     left_border = &rec_ref[px.x - 1 + px.y * (LCU_WIDTH >> is_chroma)];

	imul	edx, edi
	lea	eax, DWORD PTR [r13-1]
	add	eax, edx
	movsxd	rsi, eax
	add	rsi, r8

; 351  :     left_stride = LCU_WIDTH >> is_chroma;
; 352  :   } else {

	jmp	SHORT $LN23@kvz_intra_
$LN22@kvz_intra_:

; 353  :     left_border = &left_ref[px.y];

	movsxd	rsi, edx

; 354  :     left_stride = 1;

	mov	edi, 1
	add	rsi, rbx
$LN23@kvz_intra_:

; 355  :   }
; 356  : 
; 357  :   // Generate left reference.
; 358  :   if (luma_px->x > 0) {

	lea	rbx, OFFSET FLAT:__ImageBase
	cmp	DWORD PTR tv1167[rsp], r9d
	jle	$LN24@kvz_intra_

; 359  :     // Get the number of reference pixels based on the PU coordinate within the LCU.
; 360  :     int px_available_left = num_ref_pixels_left[lcu_px.y / 4][lcu_px.x / 4] >> is_chroma;

	mov	eax, r12d
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	movsxd	r8, eax
	mov	eax, ebp
	cdq
	shl	r8, 4
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	movsxd	rcx, eax
	add	r8, rcx
	movzx	ecx, r10b
	movzx	eax, BYTE PTR num_ref_pixels_left[r8+rbx]
	shr	eax, cl

; 361  : 
; 362  :     // Limit the number of available pixels based on block size and dimensions
; 363  :     // of the picture.
; 364  :     px_available_left = MIN(px_available_left, width * 2);
; 365  :     px_available_left = MIN(px_available_left, (pic_px->y - luma_px->y) >> is_chroma);

	mov	rcx, QWORD PTR pic_px$[rsp]
	movsx	ebx, r11b
	add	ebx, ebx
	cmp	eax, ebx
	mov	r11d, DWORD PTR [rcx+4]
	mov	ecx, r10d
	cmovge	eax, ebx
	sub	r11d, DWORD PTR tv1165[rsp]
	sar	r11d, cl

; 366  : 
; 367  :     // Copy pixels from coded CUs.
; 368  :     for (int i = 0; i < px_available_left; ++i) {

	cmp	eax, r11d
	cmovl	r11d, eax
	movsxd	r8, r11d
	test	r11d, r11d
	jle	SHORT $LN3@kvz_intra_
	mov	edx, r9d
	npad	3
$LL4@kvz_intra_:

; 369  :       out_left_ref[i + 1] = left_border[i * left_stride];

	movsxd	rax, edx
	add	edx, edi
	movzx	ecx, BYTE PTR [rax+rsi]
	mov	BYTE PTR [r9+r15+1], cl
	inc	r9
	cmp	r9, r8
	jl	SHORT $LL4@kvz_intra_
$LN3@kvz_intra_:

; 370  :     }
; 371  :     // Extend the last pixel for the rest of the reference values.
; 372  :     kvz_pixel nearest_pixel = out_left_ref[px_available_left];

	movzx	edx, BYTE PTR [r8+r15]

; 373  :     for (int i = px_available_left; i < width * 2; ++i) {

	cmp	r11d, ebx
	jge	SHORT $LN89@kvz_intra_

; 374  :       out_left_ref[i + 1] = nearest_pixel;

	mov	eax, ebx
	sub	eax, r11d
	movsxd	r8, eax
	lea	eax, DWORD PTR [r11+1]
	movsxd	rcx, eax
	add	rcx, r15
	call	memset
$LN89@kvz_intra_:

; 381  :     }
; 382  :   }
; 383  : 
; 384  :   // Generate top-left reference.
; 385  :   if (luma_px->x > 0 && luma_px->y > 0) {

	cmp	DWORD PTR tv1165[rsp], 0
	jle	SHORT $LN26@kvz_intra_

; 386  :     // If the block is at an LCU border, the top-left must be copied from
; 387  :     // the border that points to the LCUs 1D reference buffer.
; 388  :     if (px.x == 0) {

	test	r13d, r13d
	jne	SHORT $LN28@kvz_intra_

; 389  :       out_left_ref[0] = left_border[-1 * left_stride];

	movsxd	rax, edi
	mov	rcx, rsi
	sub	rcx, rax
	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r15], al

; 390  :       out_top_ref[0] = left_border[-1 * left_stride];

	movzx	eax, BYTE PTR [rcx]

; 391  :     } else {

	jmp	SHORT $LN27@kvz_intra_
$LN28@kvz_intra_:

; 392  :       out_left_ref[0] = top_border[-1];

	movzx	eax, BYTE PTR [r14-1]
	mov	BYTE PTR [r15], al

; 393  :       out_top_ref[0] = top_border[-1];

	movzx	eax, BYTE PTR [r14-1]

; 394  :     }
; 395  :   } else {

	jmp	SHORT $LN27@kvz_intra_
$LN24@kvz_intra_:

; 375  :     }
; 376  :   } else {
; 377  :     // If we are on the left edge, extend the first pixel of the top row.
; 378  :     kvz_pixel nearest_pixel = luma_px->y > 0 ? top_border[0] : dc_val;

	cmp	DWORD PTR tv1165[rsp], r9d
	jle	SHORT $LN51@kvz_intra_
	movzx	edx, BYTE PTR [r14]
	jmp	SHORT $LN52@kvz_intra_
$LN51@kvz_intra_:
	mov	dl, 128					; 00000080H
$LN52@kvz_intra_:

; 379  :     for (int i = 0; i < width * 2; i++) {

	movsx	ebx, r11b
	add	ebx, ebx
	test	ebx, ebx
	jle	SHORT $LN26@kvz_intra_
	movsxd	r8, ebx

; 380  :       out_left_ref[i + 1] = nearest_pixel;

	lea	rcx, QWORD PTR [r15+1]
	call	memset
$LN26@kvz_intra_:

; 396  :     // Copy reference clockwise.
; 397  :     out_left_ref[0] = out_left_ref[1];

	movzx	eax, BYTE PTR [r15+1]
	mov	BYTE PTR [r15], al
$LN27@kvz_intra_:

; 398  :     out_top_ref[0] = out_left_ref[1];
; 399  :   }
; 400  : 
; 401  :   // Generate top reference.
; 402  :   if (luma_px->y > 0) {

	mov	r11, QWORD PTR out_top_ref$1$[rsp]
	mov	BYTE PTR [r11], al
	mov	r10, QWORD PTR luma_px$[rsp]
	cmp	DWORD PTR [r10+4], 0
	jle	$LN30@kvz_intra_

; 403  :     // Get the number of reference pixels based on the PU coordinate within the LCU.
; 404  :     int px_available_top = num_ref_pixels_top[lcu_px.y / 4][lcu_px.x / 4] >> is_chroma;

	mov	eax, r12d
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	movsxd	r8, eax
	mov	eax, ebp
	cdq
	shl	r8, 4
	and	edx, 3
	add	eax, edx
	mov	edx, DWORD PTR is_chroma$1$[rsp]
	sar	eax, 2
	movsxd	rcx, eax
	lea	rax, OFFSET FLAT:__ImageBase
	add	r8, rcx
	movzx	ecx, dl
	movzx	eax, BYTE PTR num_ref_pixels_top[r8+rax]
	shr	eax, cl

; 405  : 
; 406  :     // Limit the number of available pixels based on block size and dimensions
; 407  :     // of the picture.
; 408  :     px_available_top = MIN(px_available_top, width * 2);
; 409  :     px_available_top = MIN(px_available_top, (pic_px->x - luma_px->x) >> is_chroma);

	mov	rcx, QWORD PTR pic_px$[rsp]
	cmp	eax, ebx
	cmovge	eax, ebx
	mov	r9d, DWORD PTR [rcx]
	mov	ecx, edx
	sub	r9d, DWORD PTR [r10]
	sar	r9d, cl

; 410  : 
; 411  :     // Copy all the pixels we can.
; 412  :     for (int i = 0; i < px_available_top; ++i) {

	cmp	eax, r9d
	cmovl	r9d, eax
	movsxd	r10, r9d
	test	r9d, r9d
	jle	SHORT $LN12@kvz_intra_
	mov	r8, r11
	mov	rcx, r14
	sub	r8, r14
	mov	rdx, r10
	npad	9
$LL71@kvz_intra_:

; 413  :       out_top_ref[i + 1] = top_border[i];

	movzx	eax, BYTE PTR [rcx]
	mov	BYTE PTR [r8+rcx+1], al
	lea	rcx, QWORD PTR [rcx+1]
	sub	rdx, 1
	jne	SHORT $LL71@kvz_intra_
$LN12@kvz_intra_:

; 414  :     }
; 415  :     // Extend the last pixel for the rest of the reference values.
; 416  :     kvz_pixel nearest_pixel = top_border[px_available_top - 1];
; 417  :     for (int i = px_available_top; i < width * 2; ++i) {

	cmp	r9d, ebx
	jge	SHORT $LN18@kvz_intra_

; 418  :       out_top_ref[i + 1] = nearest_pixel;

	movzx	edx, BYTE PTR [r10+r14-1]
	lea	eax, DWORD PTR [r9+1]
	movsxd	rcx, eax
	sub	ebx, r9d
	add	rcx, r11

; 419  :     }
; 420  :   } else {

	jmp	SHORT $LN93@kvz_intra_
$LN30@kvz_intra_:

; 421  :     // Extend nearest pixel.
; 422  :     kvz_pixel nearest_pixel = luma_px->x > 0 ? left_border[0] : dc_val;

	cmp	DWORD PTR [r10], 0
	jle	SHORT $LN57@kvz_intra_
	movzx	edx, BYTE PTR [rsi]
	jmp	SHORT $LN58@kvz_intra_
$LN57@kvz_intra_:
	mov	dl, 128					; 00000080H
$LN58@kvz_intra_:

; 423  :     for (int i = 0; i < width * 2; i++) {

	test	ebx, ebx
	jle	SHORT $LN18@kvz_intra_

; 424  :       out_top_ref[i + 1] = nearest_pixel;

	lea	rcx, QWORD PTR [r11+1]
$LN93@kvz_intra_:

; 425  :     }
; 426  :   }
; 427  : }

	movsxd	r8, ebx
	call	memset
$LN18@kvz_intra_:
	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
kvz_intra_build_reference_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
tv1602 = 96
log2_width$ = 96
color$ = 104
luma_px$ = 112
pic_px$ = 120
lcu$ = 128
tv1489 = 136
tv1473 = 136
refs$ = 136
kvz_intra_build_reference_inner PROC

; 436  : {

$LN65:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r15, QWORD PTR lcu$[rsp]
	movzx	edi, cl
	mov	r12, r8
	mov	esi, edx

; 437  :   assert(log2_width >= 2 && log2_width <= 5);

	lea	eax, DWORD PTR [rdi-2]
	cmp	al, 3
	jbe	SHORT $LN20@kvz_intra_
	mov	r8d, 437				; 000001b5H
	lea	rdx, OFFSET FLAT:$SG4294942890
	lea	rcx, OFFSET FLAT:$SG4294942889
	call	QWORD PTR __imp__wassert
$LN20@kvz_intra_:

; 438  : 
; 439  :   refs->filtered_initialized = false;

	mov	r14, QWORD PTR refs$[rsp]

; 440  :   kvz_pixel * __restrict out_left_ref = &refs->ref.left[0];
; 441  :   kvz_pixel * __restrict out_top_ref = &refs->ref.top[0];
; 442  : 
; 443  :   const int is_chroma = color != COLOR_Y ? 1 : 0;

	xor	ebx, ebx

; 444  :   const int_fast8_t width = 1 << log2_width;

	movzx	ecx, dil
	test	esi, esi

; 445  : 
; 446  :   // Convert luma coordinates to chroma coordinates for chroma.
; 447  :   const vector2d_t lcu_px = {

	mov	edi, DWORD PTR [r12]
	mov	ebp, ebx
	setne	bpl
	mov	r13d, 1
	shl	r13b, cl
	mov	BYTE PTR [r14+260], 0
	and	edi, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN63@kvz_intra_
	dec	edi
	or	edi, -64				; ffffffffffffffc0H
	inc	edi
$LN63@kvz_intra_:
	mov	edx, DWORD PTR [r12+4]
	and	edx, -2147483585			; ffffffff8000003fH
	jge	SHORT $LN62@kvz_intra_
	dec	edx
	or	edx, -64				; ffffffffffffffc0H
	inc	edx
$LN62@kvz_intra_:

; 448  :     luma_px->x % LCU_WIDTH,
; 449  :     luma_px->y % LCU_WIDTH
; 450  :   };
; 451  :   const vector2d_t px = {

	mov	ecx, ebp
	mov	r8d, edi
	mov	r10d, edx
	sar	r8d, cl
	sar	r10d, cl

; 452  :     lcu_px.x >> is_chroma,
; 453  :     lcu_px.y >> is_chroma,
; 454  :   };
; 455  : 
; 456  :   // Init pointers to LCUs reconstruction buffers, such that index 0 refers to block coordinate 0.
; 457  :   const kvz_pixel * __restrict left_ref = !color ? &lcu->left_ref.y[1] : (color == 1) ? &lcu->left_ref.u[1] : &lcu->left_ref.v[1];

	test	esi, esi
	je	SHORT $LN59@kvz_intra_
	cmp	esi, 1
	jne	SHORT $LN29@kvz_intra_

; 458  :   const kvz_pixel * __restrict top_ref = !color ? &lcu->top_ref.y[1] : (color == 1) ? &lcu->top_ref.u[1] : &lcu->top_ref.v[1];
; 459  :   const kvz_pixel * __restrict rec_ref = !color ? lcu->rec.y : (color == 1) ? lcu->rec.u : lcu->rec.v;

	mov	eax, 10636				; 0000298cH
	lea	ecx, QWORD PTR [rsi+97]
	mov	r9d, 293				; 00000125H
	jmp	SHORT $LN30@kvz_intra_
$LN29@kvz_intra_:
	mov	eax, 11660				; 00002d8cH
	mov	ecx, 147				; 00000093H
	mov	r9d, 342				; 00000156H
	jmp	SHORT $LN30@kvz_intra_
$LN59@kvz_intra_:
	mov	eax, 6540				; 0000198cH
	mov	ecx, 1
	mov	r9d, 196				; 000000c4H
$LN30@kvz_intra_:

; 460  : 
; 461  :   // Init top borders pointer to point to the correct place in the correct reference array.
; 462  :   const kvz_pixel * __restrict top_border;
; 463  :   if (px.y) {

	add	r9, r15
	lea	r11, QWORD PTR [rcx+r15]
	mov	QWORD PTR tv1473[rsp], r9
	lea	rsi, QWORD PTR [rax+r15]
	mov	ecx, ebp
	test	r10d, r10d
	je	SHORT $LN14@kvz_intra_

; 464  :     top_border = &rec_ref[px.x + (px.y - 1) * (LCU_WIDTH >> is_chroma)];

	mov	r11d, 64				; 00000040H
	lea	eax, DWORD PTR [r10-1]
	sar	r11d, cl
	imul	eax, r11d
	add	eax, r8d
	movsxd	r9, eax
	add	r9, rsi

; 465  :   } else {

	jmp	SHORT $LN15@kvz_intra_
$LN14@kvz_intra_:

; 466  :     top_border = &top_ref[px.x];

	movsxd	r9, r8d
	add	r9, r11
	mov	r11d, 64				; 00000040H
	sar	r11d, cl
$LN15@kvz_intra_:

; 467  : 
; 468  :   }
; 469  : 
; 470  :   // Init left borders pointer to point to the correct place in the correct reference array.
; 471  :   const kvz_pixel * __restrict left_border;
; 472  :   int left_stride; // Distance between reference samples.
; 473  : 
; 474  :   // Generate top-left reference.
; 475  :   // If the block is at an LCU border, the top-left must be copied from
; 476  :   // the border that points to the LCUs 1D reference buffer.
; 477  :   if (px.x) {

	test	r8d, r8d
	je	SHORT $LN16@kvz_intra_

; 478  :     left_border = &rec_ref[px.x - 1 + px.y * (LCU_WIDTH >> is_chroma)];

	mov	eax, r11d
	imul	eax, r10d
	dec	eax
	add	eax, r8d
	movsxd	r10, eax

; 479  :     left_stride = LCU_WIDTH >> is_chroma;
; 480  :     out_left_ref[0] = top_border[-1];

	movzx	eax, BYTE PTR [r9-1]
	add	r10, rsi
	mov	BYTE PTR [r14], al

; 481  :     out_top_ref[0] = top_border[-1];

	movzx	eax, BYTE PTR [r9-1]

; 482  :   } else {

	jmp	SHORT $LN17@kvz_intra_
$LN16@kvz_intra_:

; 483  :     left_border = &left_ref[px.y];

	movsxd	r10, r10d

; 484  :     left_stride = 1;

	mov	r11d, 1
	add	r10, QWORD PTR tv1473[rsp]

; 485  :     out_left_ref[0] = left_border[-1 * left_stride];

	movzx	ecx, BYTE PTR [r10-1]
	mov	BYTE PTR [r14], cl

; 486  :     out_top_ref[0] = left_border[-1 * left_stride];

	movzx	eax, BYTE PTR [r10-1]
$LN17@kvz_intra_:

; 487  :   }
; 488  : 
; 489  :   // Generate left reference.
; 490  : 
; 491  :   // Get the number of reference pixels based on the PU coordinate within the LCU.
; 492  :   int px_available_left = num_ref_pixels_left[lcu_px.y / 4][lcu_px.x / 4] >> is_chroma;

	mov	BYTE PTR [r14+65], al
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, edx

; 493  : 
; 494  :   // Limit the number of available pixels based on block size and dimensions
; 495  :   // of the picture.
; 496  :   px_available_left = MIN(px_available_left, width * 2);
; 497  :   px_available_left = MIN(px_available_left, (pic_px->y - luma_px->y) >> is_chroma);
; 498  : 
; 499  :   // Copy pixels from coded CUs.
; 500  :   int i = 0;

	mov	esi, ebx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	movsxd	r8, eax
	mov	eax, edi
	cdq
	shl	r8, 4
	and	edx, 3

; 507  :   } while (i < px_available_left);

	mov	rdi, rbx
	add	eax, edx
	sar	eax, 2
	cdqe
	add	rax, r8
	lea	r8, QWORD PTR [r14+2]
	mov	QWORD PTR tv1489[rsp], rax
	movzx	edx, BYTE PTR num_ref_pixels_left[rax+rcx]
	movzx	ecx, bpl
	shr	edx, cl
	mov	ecx, ebp
	movsx	eax, r13b
	add	eax, eax
	cmp	edx, eax
	mov	DWORD PTR tv1602[rsp], eax
	cmovge	edx, eax
	mov	rax, QWORD PTR pic_px$[rsp]
	mov	eax, DWORD PTR [rax+4]
	sub	eax, DWORD PTR [r12+4]
	lea	r12d, DWORD PTR [r11*4]
	sar	eax, cl
	cmp	edx, eax
	cmovl	eax, edx
	lea	edx, DWORD PTR [r11+r11]
	movsxd	r15, eax
	mov	eax, r11d
	neg	eax
	lea	r13d, DWORD PTR [rax+rax]
	npad	8
$LL4@kvz_intra_:

; 501  :   do {
; 502  :     out_left_ref[i + 1] = left_border[(i + 0) * left_stride];
; 503  :     out_left_ref[i + 2] = left_border[(i + 1) * left_stride];
; 504  :     out_left_ref[i + 3] = left_border[(i + 2) * left_stride];
; 505  :     out_left_ref[i + 4] = left_border[(i + 3) * left_stride];
; 506  :     i += 4;

	lea	eax, DWORD PTR [rdx+r13]
	add	esi, 4
	movsxd	rcx, eax
	lea	r8, QWORD PTR [r8+4]
	add	rdi, 4
	movzx	eax, BYTE PTR [rcx+r10]
	mov	BYTE PTR [r8-5], al
	mov	eax, edx
	sub	eax, r11d
	cdqe
	movzx	ecx, BYTE PTR [rax+r10]
	mov	BYTE PTR [r8-4], cl
	movsxd	rax, edx
	movzx	ecx, BYTE PTR [rax+r10]
	lea	eax, DWORD PTR [rdx+r11]
	mov	BYTE PTR [r8-3], cl
	add	edx, r12d
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rcx+r10]
	mov	BYTE PTR [r8-2], al

; 507  :   } while (i < px_available_left);

	cmp	rdi, r15
	jl	SHORT $LL4@kvz_intra_

; 511  :   for (; i < width * 2; i += 4) {

	movsxd	r10, DWORD PTR tv1602[rsp]
	movsxd	rax, esi
	mov	r8, r10
	movzx	ecx, BYTE PTR [rax+r14]
	cmp	rdi, r10
	jge	SHORT $LN6@kvz_intra_

; 508  : 
; 509  :   // Extend the last pixel for the rest of the reference values.
; 510  :   kvz_pixel nearest_pixel = out_left_ref[i];

	mov	rdx, r10
	lea	rax, QWORD PTR [r14+2]
	sub	rdx, rdi
	add	rax, rdi
	dec	rdx
	shr	rdx, 2
	inc	rdx
	npad	5
$LL7@kvz_intra_:

; 512  :     out_left_ref[i + 1] = nearest_pixel;

	mov	BYTE PTR [rax-1], cl

; 513  :     out_left_ref[i + 2] = nearest_pixel;

	mov	BYTE PTR [rax], cl

; 514  :     out_left_ref[i + 3] = nearest_pixel;

	mov	BYTE PTR [rax+1], cl

; 515  :     out_left_ref[i + 4] = nearest_pixel;

	mov	BYTE PTR [rax+2], cl
	lea	rax, QWORD PTR [rax+4]
	sub	rdx, 1
	jne	SHORT $LL7@kvz_intra_
$LN6@kvz_intra_:

; 516  :   }
; 517  : 
; 518  :   // Generate top reference.
; 519  : 
; 520  :   // Get the number of reference pixels based on the PU coordinate within the LCU.
; 521  :   int px_available_top = num_ref_pixels_top[lcu_px.y / 4][lcu_px.x / 4] >> is_chroma;

	mov	rax, QWORD PTR tv1489[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	edx, BYTE PTR num_ref_pixels_top[rax+rcx]
	movzx	ecx, bpl

; 522  : 
; 523  :   // Limit the number of available pixels based on block size and dimensions
; 524  :   // of the picture.
; 525  :   px_available_top = MIN(px_available_top, width * 2);
; 526  :   px_available_top = MIN(px_available_top, (pic_px->x - luma_px->x) >> is_chroma);

	mov	rax, QWORD PTR pic_px$[rsp]
	shr	edx, cl
	mov	rcx, QWORD PTR luma_px$[rsp]
	cmp	edx, r10d
	mov	eax, DWORD PTR [rax]
	cmovge	edx, r10d
	lea	r10, QWORD PTR [r14+65]
	sub	eax, DWORD PTR [rcx]
	mov	ecx, ebp
	sar	eax, cl

; 527  : 
; 528  :   // Copy all the pixels we can.
; 529  :   i = 0;

	cmp	edx, eax
	cmovl	eax, edx
	sub	r10, r9

; 533  :   } while (i < px_available_top);

	movsxd	rdx, eax
	mov	rax, rbx
	npad	3
$LL10@kvz_intra_:

; 530  :   do {
; 531  :     memcpy(out_top_ref + i + 1, top_border + i, 4 * sizeof(kvz_pixel));
; 532  :     i += 4;

	mov	ecx, DWORD PTR [r9]
	add	ebx, 4
	mov	DWORD PTR [r10+r9+1], ecx
	lea	r9, QWORD PTR [r9+4]
	add	rax, 4

; 533  :   } while (i < px_available_top);

	cmp	rax, rdx
	jl	SHORT $LL10@kvz_intra_

; 534  : 
; 535  :   // Extend the last pixel for the rest of the reference values.
; 536  :   nearest_pixel = out_top_ref[i];

	movsxd	rcx, ebx
	movzx	edx, BYTE PTR [rcx+r14+65]

; 537  :   for (; i < width * 2; i += 4) {

	cmp	rax, r8
	jge	SHORT $LN12@kvz_intra_

; 534  : 
; 535  :   // Extend the last pixel for the rest of the reference values.
; 536  :   nearest_pixel = out_top_ref[i];

	lea	rcx, QWORD PTR [r14+67]
	add	rcx, rax
	npad	3
$LL13@kvz_intra_:

; 537  :   for (; i < width * 2; i += 4) {

	add	rax, 4

; 538  :     out_top_ref[i + 1] = nearest_pixel;

	mov	BYTE PTR [rcx-1], dl

; 539  :     out_top_ref[i + 2] = nearest_pixel;

	mov	BYTE PTR [rcx], dl

; 540  :     out_top_ref[i + 3] = nearest_pixel;

	mov	BYTE PTR [rcx+1], dl

; 541  :     out_top_ref[i + 4] = nearest_pixel;

	mov	BYTE PTR [rcx+2], dl
	lea	rcx, QWORD PTR [rcx+4]
	cmp	rax, r8
	jl	SHORT $LL13@kvz_intra_
$LN12@kvz_intra_:

; 542  :   }
; 543  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
kvz_intra_build_reference_inner ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
log2_width$ = 8
color$ = 16
luma_px$ = 24
pic_px$ = 32
lcu$ = 40
refs$ = 48
kvz_intra_build_reference PROC

; 553  :   // Much logic can be discarded if not on the edge
; 554  :   if (luma_px->x > 0 && luma_px->y > 0) {

	cmp	DWORD PTR [r8], 0
	jle	SHORT $LN2@kvz_intra_
	cmp	DWORD PTR [r8+4], 0
	jg	kvz_intra_build_reference_inner
$LN2@kvz_intra_:

; 555  :     kvz_intra_build_reference_inner(log2_width, color, luma_px, pic_px, lcu, refs);
; 556  :   } else {
; 557  :     kvz_intra_build_reference_any(log2_width, color, luma_px, pic_px, lcu, refs);

	jmp	kvz_intra_build_reference_any
kvz_intra_build_reference ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\intra.c
_TEXT	SEGMENT
luma_px$ = 48
refs$ = 64
pred$ = 336
pic_px$ = 1408
state$ = 1408
x$ = 1416
y$ = 1424
depth$ = 1432
intra_mode$ = 1440
lcu$ = 1448
color$ = 1456
intra_recon_tb_leaf PROC

; 569  : {

	mov	rax, rsp
	push	rbx
	push	rbp
	push	r12
	sub	rsp, 1376				; 00000560H

; 570  :   const kvz_config *cfg = &state->encoder_control->cfg;
; 571  :   const int shift = color == COLOR_Y ? 0 : 1;
; 572  : 
; 573  :   int log2width = LOG2_LCU_WIDTH - depth;
; 574  :   if (color != COLOR_Y && depth < MAX_PU_DEPTH) {

	mov	ebx, DWORD PTR color$[rsp]
	mov	QWORD PTR [rax+24], rdi
	mov	edi, 6
	mov	QWORD PTR [rax+32], r13
	sub	edi, r9d
	mov	QWORD PTR [rax-32], r14
	mov	QWORD PTR [rax-40], r15
	mov	rax, rcx
	mov	r15, QWORD PTR [rcx]
	test	ebx, ebx
	je	SHORT $LN4@intra_reco
	cmp	r9d, 4
	jge	SHORT $LN4@intra_reco

; 575  :     // Chroma width is half of luma width, when not at maximum depth.
; 576  :     log2width -= 1;

	dec	edi
$LN4@intra_reco:

; 577  :   }
; 578  :   const int width = 1 << log2width;
; 579  :   const int lcu_width = LCU_WIDTH >> shift;
; 580  : 
; 581  :   const vector2d_t luma_px = { x, y };
; 582  :   const vector2d_t pic_px = {

	mov	rax, QWORD PTR [rax+48]
	mov	ecx, edi
	mov	ebp, 1
	mov	QWORD PTR [rsp+1416], rsi
	shl	ebp, cl
	mov	r12d, 64				; 00000040H
	test	ebx, ebx
	mov	DWORD PTR luma_px$[rsp], edx
	mov	ecx, 32					; 00000020H
	mov	DWORD PTR luma_px$[rsp+4], r8d
	cmovne	r12d, ecx

; 583  :     state->tile->frame->width,
; 584  :     state->tile->frame->height,
; 585  :   };
; 586  :   const vector2d_t lcu_px = { SUB_SCU(x) >> shift, SUB_SCU(y) >> shift};

	mov	r13d, edx
	mov	rcx, QWORD PTR [rax]
	and	r13d, 63				; 0000003fH
	mov	r14d, r8d
	mov	eax, DWORD PTR [rcx+16]
	mov	DWORD PTR pic_px$[rsp], eax
	mov	eax, DWORD PTR [rcx+20]
	mov	DWORD PTR pic_px$[rsp+4], eax
	mov	eax, r13d
	shr	eax, 1
	test	ebx, ebx
	cmovne	r13d, eax
	and	r14d, 63				; 0000003fH
	mov	eax, r14d
	shr	eax, 1
	test	ebx, ebx
	cmovne	r14d, eax
	test	edx, edx

; 554  :   if (luma_px->x > 0 && luma_px->y > 0) {

	jle	SHORT $LN13@intra_reco
	test	r8d, r8d
	jle	SHORT $LN13@intra_reco

; 555  :     kvz_intra_build_reference_inner(log2_width, color, luma_px, pic_px, lcu, refs);

	mov	rsi, QWORD PTR lcu$[rsp]
	lea	rax, QWORD PTR refs$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$[rsp]
	lea	r8, QWORD PTR luma_px$[rsp]
	mov	QWORD PTR [rsp+32], rsi
	mov	edx, ebx
	movzx	ecx, dil
	call	kvz_intra_build_reference_inner

; 556  :   } else {

	jmp	SHORT $LN14@intra_reco
$LN13@intra_reco:

; 557  :     kvz_intra_build_reference_any(log2_width, color, luma_px, pic_px, lcu, refs);

	mov	rsi, QWORD PTR lcu$[rsp]
	lea	rax, QWORD PTR refs$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	r9, QWORD PTR pic_px$[rsp]
	lea	r8, QWORD PTR luma_px$[rsp]
	mov	QWORD PTR [rsp+32], rsi
	mov	edx, ebx
	movzx	ecx, dil
	call	kvz_intra_build_reference_any
$LN14@intra_reco:

; 587  : 
; 588  :   kvz_intra_references refs;
; 589  :   kvz_intra_build_reference(log2width, color, &luma_px, &pic_px, lcu, &refs);
; 590  : 
; 591  :   kvz_pixel pred[32 * 32];
; 592  :   const bool filter_boundary = color == COLOR_Y && !(cfg->lossless && cfg->implicit_rdpcm);

	test	ebx, ebx
	jne	SHORT $LN10@intra_reco
	cmp	DWORD PTR [r15+2392], ebx
	je	SHORT $LN9@intra_reco
	cmp	DWORD PTR [r15+2420], ebx
	jne	SHORT $LN10@intra_reco
$LN9@intra_reco:
	mov	al, 1
	jmp	SHORT $LN11@intra_reco
$LN10@intra_reco:
	xor	al, al
$LN11@intra_reco:

; 593  :   kvz_intra_predict(&refs, log2width, intra_mode, color, pred, filter_boundary);

	movzx	r8d, BYTE PTR intra_mode$[rsp]
	lea	rcx, QWORD PTR refs$[rsp]
	mov	BYTE PTR [rsp+40], al
	mov	r9d, ebx
	lea	rax, QWORD PTR pred$[rsp]
	movzx	edx, dil
	mov	QWORD PTR [rsp+32], rax
	call	kvz_intra_predict

; 594  : 
; 595  :   const int index = lcu_px.x + lcu_px.y * lcu_width;
; 596  :   kvz_pixel *block = NULL;

	mov	r15, QWORD PTR [rsp+1360]
	xor	edx, edx
	mov	rdi, QWORD PTR [rsp+1424]
	imul	r14d, r12d
	lea	ecx, DWORD PTR [r14+r13]
	mov	r14, QWORD PTR [rsp+1368]
	mov	r13, QWORD PTR [rsp+1432]

; 597  :   switch (color) {

	test	ebx, ebx
	je	SHORT $LN5@intra_reco
	sub	ebx, 1
	je	SHORT $LN6@intra_reco
	cmp	ebx, 1
	jne	SHORT $LN2@intra_reco

; 604  :     case COLOR_V:
; 605  :       block = &lcu->rec.v[index];

	mov	edx, ecx
	add	rdx, 11660				; 00002d8cH
	jmp	SHORT $LN16@intra_reco
$LN6@intra_reco:

; 600  :       break;
; 601  :     case COLOR_U:
; 602  :       block = &lcu->rec.u[index];

	mov	edx, ecx
	add	rdx, 10636				; 0000298cH

; 603  :       break;

	jmp	SHORT $LN16@intra_reco
$LN5@intra_reco:

; 598  :     case COLOR_Y:
; 599  :       block = &lcu->rec.y[index];

	mov	edx, ecx
	add	rdx, 6540				; 0000198cH
$LN16@intra_reco:

; 606  :       break;
; 607  :   }
; 608  :   kvz_pixels_blit(pred, block , width, width, width, lcu_width);

	add	rdx, rsi
$LN2@intra_reco:
	mov	DWORD PTR [rsp+40], r12d
	lea	rcx, QWORD PTR pred$[rsp]
	mov	r9d, ebp
	mov	DWORD PTR [rsp+32], ebp
	mov	r8d, ebp
	call	kvz_pixels_blit
	mov	rsi, QWORD PTR [rsp+1416]

; 609  : }

	add	rsp, 1376				; 00000560H
	pop	r12
	pop	rbp
	pop	rbx
	ret	0
intra_recon_tb_leaf ENDP
_TEXT	ENDS
END
