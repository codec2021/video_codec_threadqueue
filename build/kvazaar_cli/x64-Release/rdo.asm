; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	kvz_g_go_rice_range
PUBLIC	kvz_g_go_rice_prefix_len
PUBLIC	kvz_entropy_bits
PUBLIC	kvz_f_entropy_bits
EXTRN	__imp_strerror:PROC
EXTRN	__imp_strncat:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_strncpy:PROC
kvz_g_go_rice_range DD 07H
	DD	0eH
	DD	01aH
	DD	02eH
	DD	04eH
?basename_tmpl@?1??kvz_init_rdcost_outfiles@@9@9 DQ FLAT:$SG4294949253 ; `kvz_init_rdcost_outfiles'::`2'::basename_tmpl
kvz_g_go_rice_prefix_len DD 08H
	DD	07H
	DD	06H
	DD	05H
	DD	04H
cbf_masks DW	01fH
	DW	0fH
	DW	07H
	DW	03H
	DW	01H
	ORG $+6
g_sig_last_scan_16x16 DD 00H
	DD	04H
	DD	01H
	DD	08H
	DD	05H
	DD	02H
	DD	0cH
	DD	09H
	DD	06H
	DD	03H
	DD	0dH
	DD	0aH
	DD	07H
	DD	0eH
	DD	0bH
	DD	0fH
g_group_idx DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
strategies_to_select DQ FLAT:$SG4294949316
	DQ	FLAT:kvz_array_checksum
	DQ	FLAT:$SG4294949315
	DQ	FLAT:kvz_array_md5
	DQ	FLAT:$SG4294949314
	DQ	FLAT:kvz_reg_sad
	DQ	FLAT:$SG4294949313
	DQ	FLAT:kvz_sad_4x4
	DQ	FLAT:$SG4294949312
	DQ	FLAT:kvz_sad_8x8
	DQ	FLAT:$SG4294949311
	DQ	FLAT:kvz_sad_16x16
	DQ	FLAT:$SG4294949310
	DQ	FLAT:kvz_sad_32x32
	DQ	FLAT:$SG4294949309
	DQ	FLAT:kvz_sad_64x64
	DQ	FLAT:$SG4294949308
	DQ	FLAT:kvz_satd_4x4
	DQ	FLAT:$SG4294949307
	DQ	FLAT:kvz_satd_8x8
	DQ	FLAT:$SG4294949306
	DQ	FLAT:kvz_satd_16x16
	DQ	FLAT:$SG4294949305
	DQ	FLAT:kvz_satd_32x32
	DQ	FLAT:$SG4294949304
	DQ	FLAT:kvz_satd_64x64
	DQ	FLAT:$SG4294949303
	DQ	FLAT:kvz_satd_any_size
	DQ	FLAT:$SG4294949302
	DQ	FLAT:kvz_sad_4x4_dual
	DQ	FLAT:$SG4294949301
	DQ	FLAT:kvz_sad_8x8_dual
	DQ	FLAT:$SG4294949300
	DQ	FLAT:kvz_sad_16x16_dual
	DQ	FLAT:$SG4294949299
	DQ	FLAT:kvz_sad_32x32_dual
	DQ	FLAT:$SG4294949298
	DQ	FLAT:kvz_sad_64x64_dual
	DQ	FLAT:$SG4294949297
	DQ	FLAT:kvz_satd_4x4_dual
	DQ	FLAT:$SG4294949296
	DQ	FLAT:kvz_satd_8x8_dual
	DQ	FLAT:$SG4294949295
	DQ	FLAT:kvz_satd_16x16_dual
	DQ	FLAT:$SG4294949294
	DQ	FLAT:kvz_satd_32x32_dual
	DQ	FLAT:$SG4294949293
	DQ	FLAT:kvz_satd_64x64_dual
	DQ	FLAT:$SG4294949292
	DQ	FLAT:kvz_satd_any_size_quad
	DQ	FLAT:$SG4294949291
	DQ	FLAT:kvz_pixels_calc_ssd
	DQ	FLAT:$SG4294949290
	DQ	FLAT:kvz_bipred_average
	DQ	FLAT:$SG4294949289
	DQ	FLAT:kvz_get_optimized_sad
	DQ	FLAT:$SG4294949288
	DQ	FLAT:kvz_ver_sad
	DQ	FLAT:$SG4294949287
	DQ	FLAT:kvz_hor_sad
	DQ	FLAT:$SG4294949286
	DQ	FLAT:kvz_pixel_var
	DQ	FLAT:$SG4294949285
	DQ	FLAT:kvz_fast_forward_dst_4x4
	DQ	FLAT:$SG4294949284
	DQ	FLAT:kvz_dct_4x4
	DQ	FLAT:$SG4294949283
	DQ	FLAT:kvz_dct_8x8
	DQ	FLAT:$SG4294949282
	DQ	FLAT:kvz_dct_16x16
	DQ	FLAT:$SG4294949281
	DQ	FLAT:kvz_dct_32x32
	DQ	FLAT:$SG4294949280
	DQ	FLAT:kvz_fast_inverse_dst_4x4
	DQ	FLAT:$SG4294949279
	DQ	FLAT:kvz_idct_4x4
	DQ	FLAT:$SG4294949278
	DQ	FLAT:kvz_idct_8x8
	DQ	FLAT:$SG4294949277
	DQ	FLAT:kvz_idct_16x16
	DQ	FLAT:$SG4294949276
	DQ	FLAT:kvz_idct_32x32
	DQ	FLAT:$SG4294949275
	DQ	FLAT:kvz_filter_hpel_blocks_hor_ver_luma
	DQ	FLAT:$SG4294949274
	DQ	FLAT:kvz_filter_hpel_blocks_diag_luma
	DQ	FLAT:$SG4294949273
	DQ	FLAT:kvz_filter_qpel_blocks_hor_ver_luma
	DQ	FLAT:$SG4294949272
	DQ	FLAT:kvz_filter_qpel_blocks_diag_luma
	DQ	FLAT:$SG4294949271
	DQ	FLAT:kvz_sample_quarterpel_luma
	DQ	FLAT:$SG4294949270
	DQ	FLAT:kvz_sample_octpel_chroma
	DQ	FLAT:$SG4294949269
	DQ	FLAT:kvz_sample_quarterpel_luma_hi
	DQ	FLAT:$SG4294949268
	DQ	FLAT:kvz_sample_octpel_chroma_hi
	DQ	FLAT:$SG4294949267
	DQ	FLAT:kvz_get_extended_block
	DQ	FLAT:$SG4294949266
	DQ	FLAT:kvz_quant
	DQ	FLAT:$SG4294949265
	DQ	FLAT:kvz_quantize_residual
	DQ	FLAT:$SG4294949264
	DQ	FLAT:kvz_dequant
	DQ	FLAT:$SG4294949263
	DQ	FLAT:kvz_coeff_abs_sum
	DQ	FLAT:$SG4294949262
	DQ	FLAT:kvz_fast_coeff_cost
	DQ	FLAT:$SG4294949261
	DQ	FLAT:kvz_angular_pred
	DQ	FLAT:$SG4294949260
	DQ	FLAT:kvz_intra_pred_planar
	DQ	FLAT:$SG4294949259
	DQ	FLAT:kvz_intra_pred_filtered_dc
	DQ	FLAT:$SG4294949258
	DQ	FLAT:kvz_sao_edge_ddistortion
	DQ	FLAT:$SG4294949257
	DQ	FLAT:kvz_calc_sao_edge_dir
	DQ	FLAT:$SG4294949256
	DQ	FLAT:kvz_sao_reconstruct_color
	DQ	FLAT:$SG4294949255
	DQ	FLAT:kvz_sao_band_ddistortion
	DQ	FLAT:$SG4294949254
	DQ	FLAT:kvz_encode_coeff_nxn
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_32x32 DD 00H
	DD	08H
	DD	01H
	DD	010H
	DD	09H
	DD	02H
	DD	018H
	DD	011H
	DD	0aH
	DD	03H
	DD	020H
	DD	019H
	DD	012H
	DD	0bH
	DD	04H
	DD	028H
	DD	021H
	DD	01aH
	DD	013H
	DD	0cH
	DD	05H
	DD	030H
	DD	029H
	DD	022H
	DD	01bH
	DD	014H
	DD	0dH
	DD	06H
	DD	038H
	DD	031H
	DD	02aH
	DD	023H
	DD	01cH
	DD	015H
	DD	0eH
	DD	07H
	DD	039H
	DD	032H
	DD	02bH
	DD	024H
	DD	01dH
	DD	016H
	DD	0fH
	DD	03aH
	DD	033H
	DD	02cH
	DD	025H
	DD	01eH
	DD	017H
	DD	03bH
	DD	034H
	DD	02dH
	DD	026H
	DD	01fH
	DD	03cH
	DD	035H
	DD	02eH
	DD	027H
	DD	03dH
	DD	036H
	DD	02fH
	DD	03eH
	DD	037H
	DD	03fH
kvz_entropy_bits DD 08000H
	DD	08000H
	DD	076daH
	DD	089a0H
	DD	06e92H
	DD	09340H
	DD	0670aH
	DD	09cdfH
	DD	06029H
	DD	0a67fH
	DD	059ddH
	DD	0b01fH
	DD	05413H
	DD	0b9bfH
	DD	04ebfH
	DD	0c35fH
	DD	049d3H
	DD	0ccffH
	DD	04546H
	DD	0d69eH
	DD	0410dH
	DD	0e03eH
	DD	03d22H
	DD	0e9deH
	DD	0397dH
	DD	0f37eH
	DD	03619H
	DD	0fd1eH
	DD	032eeH
	DD	0106beH
	DD	02ffaH
	DD	01105dH
	DD	02d37H
	DD	0119fdH
	DD	02aa2H
	DD	01239dH
	DD	02836H
	DD	012d3dH
	DD	025f2H
	DD	0136ddH
	DD	023d1H
	DD	01407cH
	DD	021d2H
	DD	014a1cH
	DD	01ff2H
	DD	0153bcH
	DD	01e2fH
	DD	015d5cH
	DD	01c87H
	DD	0166fcH
	DD	01af7H
	DD	01709bH
	DD	0197fH
	DD	017a3bH
	DD	0181dH
	DD	0183dbH
	DD	016d0H
	DD	018d7bH
	DD	01595H
	DD	01971bH
	DD	0146cH
	DD	01a0bbH
	DD	01354H
	DD	01aa5aH
	DD	0124cH
	DD	01b3faH
	DD	01153H
	DD	01bd9aH
	DD	01067H
	DD	01c73aH
	DD	0f89H
	DD	01d0daH
	DD	0eb7H
	DD	01da79H
	DD	0df0H
	DD	01e419H
	DD	0d34H
	DD	01edb9H
	DD	0c82H
	DD	01f759H
	DD	0bdaH
	DD	0200f9H
	DD	0b3cH
	DD	020a99H
	DD	0aa5H
	DD	021438H
	DD	0a17H
	DD	021dd8H
	DD	0990H
	DD	022778H
	DD	0911H
	DD	023118H
	DD	0898H
	DD	023ab8H
	DD	0826H
	DD	024458H
	DD	07baH
	DD	024df7H
	DD	0753H
	DD	025797H
	DD	06f2H
	DD	026137H
	DD	0696H
	DD	026ad7H
	DD	063fH
	DD	027477H
	DD	05edH
	DD	027e17H
	DD	059fH
	DD	0287b6H
	DD	0554H
	DD	029156H
	DD	050eH
	DD	029af6H
	DD	04ccH
	DD	02a497H
	DD	048dH
	DD	02ae35H
	DD	0451H
	DD	02b7d6H
	DD	0418H
	DD	02c176H
	DD	03e2H
	DD	02cb15H
	DD	03afH
	DD	02d4b5H
	DD	037fH
	DD	02de55H
g_min_in_group DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	06H
	DB	08H
	DB	0cH
	DB	010H
	DB	018H
	ORG $+6
kvz_f_entropy_bits DD 03f800000r		; 1
	DD	03f800000r			; 1
	DD	03f6db400r			; 0.928528
	DD	03f89a000r			; 1.0752
	DD	03f5d2400r			; 0.863831
	DD	03f934000r			; 1.15039
	DD	03f4e1400r			; 0.804993
	DD	03f9cdf00r			; 1.22556
	DD	03f405200r			; 0.751251
	DD	03fa67f00r			; 1.30075
	DD	03f33ba00r			; 0.702057
	DD	03fb01f00r			; 1.37595
	DD	03f282600r			; 0.65683
	DD	03fb9bf00r			; 1.45114
	DD	03f1d7e00r			; 0.615204
	DD	03fc35f00r			; 1.52634
	DD	03f13a600r			; 0.576752
	DD	03fccff00r			; 1.60153
	DD	03f0a8c00r			; 0.541199
	DD	03fd69e00r			; 1.6767
	DD	03f021a00r			; 0.508209
	DD	03fe03e00r			; 1.75189
	DD	03ef48800r			; 0.4776
	DD	03fe9de00r			; 1.82709
	DD	03ee5f400r			; 0.449127
	DD	03ff37e00r			; 1.90228
	DD	03ed86400r			; 0.422638
	DD	03ffd1e00r			; 1.97748
	DD	03ecbb800r			; 0.397888
	DD	040035f00r			; 2.05267
	DD	03ebfe800r			; 0.374817
	DD	040082e80r			; 2.12784
	DD	03eb4dc00r			; 0.353241
	DD	0400cfe80r			; 2.20303
	DD	03eaa8800r			; 0.333069
	DD	04011ce80r			; 2.27823
	DD	03ea0d800r			; 0.314148
	DD	040169e80r			; 2.35342
	DD	03e97c800r			; 0.296448
	DD	0401b6e80r			; 2.42862
	DD	03e8f4400r			; 0.279816
	DD	040203e00r			; 2.50378
	DD	03e874800r			; 0.264221
	DD	040250e00r			; 2.57898
	DD	03e7f9000r			; 0.249573
	DD	04029de00r			; 2.65417
	DD	03e717800r			; 0.235809
	DD	0402eae00r			; 2.72937
	DD	03e643800r			; 0.22287
	DD	040337e00r			; 2.80457
	DD	03e57b800r			; 0.210663
	DD	040384d80r			; 2.87973
	DD	03e4bf800r			; 0.199188
	DD	0403d1d80r			; 2.95493
	DD	03e40e800r			; 0.188385
	DD	04041ed80r			; 3.03012
	DD	03e368000r			; 0.178223
	DD	04046bd80r			; 3.10532
	DD	03e2ca800r			; 0.16861
	DD	0404b8d80r			; 3.18051
	DD	03e236000r			; 0.159546
	DD	040505d80r			; 3.25571
	DD	03e1aa000r			; 0.151001
	DD	040552d00r			; 3.33087
	DD	03e126000r			; 0.142944
	DD	04059fd00r			; 3.40607
	DD	03e0a9800r			; 0.135345
	DD	0405ecd00r			; 3.48126
	DD	03e033800r			; 0.128143
	DD	040639d00r			; 3.55646
	DD	03df89000r			; 0.121368
	DD	040686d00r			; 3.63165
	DD	03deb7000r			; 0.11496
	DD	0406d3c80r			; 3.70682
	DD	03ddf0000r			; 0.108887
	DD	040720c80r			; 3.78201
	DD	03dd34000r			; 0.103149
	DD	04076dc80r			; 3.85721
	DD	03dc82000r			; 0.0977173
	DD	0407bac80r			; 3.9324
	DD	03dbda000r			; 0.0925903
	DD	040803e40r			; 4.0076
	DD	03db3c000r			; 0.0877686
	DD	04082a640r			; 4.08279
	DD	03daa5000r			; 0.0831604
	DD	040850e00r			; 4.15796
	DD	03da17000r			; 0.0788269
	DD	040877600r			; 4.23315
	DD	03d990000r			; 0.074707
	DD	04089de00r			; 4.30835
	DD	03d911000r			; 0.0708313
	DD	0408c4600r			; 4.38354
	DD	03d898000r			; 0.0671387
	DD	0408eae00r			; 4.45874
	DD	03d826000r			; 0.0636597
	DD	040911600r			; 4.53394
	DD	03d774000r			; 0.0603638
	DD	040937dc0r			; 4.6091
	DD	03d6a6000r			; 0.0572205
	DD	04095e5c0r			; 4.6843
	DD	03d5e4000r			; 0.0542603
	DD	040984dc0r			; 4.75949
	DD	03d52c000r			; 0.0514526
	DD	0409ab5c0r			; 4.83469
	DD	03d47e000r			; 0.0487976
	DD	0409d1dc0r			; 4.90988
	DD	03d3da000r			; 0.0462952
	DD	0409f85c0r			; 4.98508
	DD	03d33e000r			; 0.0439148
	DD	040a1ed80r			; 5.06024
	DD	03d2a8000r			; 0.041626
	DD	040a45580r			; 5.13544
	DD	03d21c000r			; 0.0394897
	DD	040a6bd80r			; 5.21063
	DD	03d198000r			; 0.0374756
	DD	040a925c0r			; 5.28586
	DD	03d11a000r			; 0.035553
	DD	040ab8d40r			; 5.36099
	DD	03d0a2000r			; 0.0337219
	DD	040adf580r			; 5.43622
	DD	03d030000r			; 0.0319824
	DD	040b05d80r			; 5.51141
	DD	03cf88000r			; 0.0303345
	DD	040b2c540r			; 5.58658
	DD	03cebc000r			; 0.0287781
	DD	040b52d40r			; 5.66177
	DD	03cdfc000r			; 0.0273132
	DD	040b79540r			; 5.73697
default_fast_coeff_cost_wts DD 03e282e88r	; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e282e88r			; 0.16424
	DD	040852b41r			; 4.16153
	DD	0406093ffr			; 3.50903
	DD	040ddb290r			; 6.92805
	DD	03e26c094r			; 0.162844
	DD	04081ca43r			; 4.05594
	DD	04064203ar			; 3.56447
	DD	040db915ar			; 6.86149
	DD	03e03d189r			; 0.128729
	DD	04089fbafr			; 4.31197
	DD	0407c5771r			; 3.94284
	DD	040ddeed2r			; 6.9354
	DD	03de33ce6r			; 0.110956
	DD	0408ddcb1r			; 4.43319
	DD	0407c8738r			; 3.94575
	DD	040dc1618r			; 6.8777
	DD	03dc29cfer			; 0.095026
	DD	0408f7938r			; 4.48355
	DD	0408636aar			; 4.19417
	DD	040d90260r			; 6.78154
	DD	03d99b1b8r			; 0.075046
	DD	04094474cr			; 4.6337
	DD	04082b1b6r			; 4.08419
	DD	040d65aeer			; 6.6986
	DD	03d56bca5r			; 0.052426
	DD	0409ef37er			; 4.96722
	DD	04080dee8r			; 4.02721
	DD	040d19306r			; 6.5492
	DD	03d24bcaer			; 0.040219
	DD	040a489car			; 5.14182
	DD	0407ee3bdr			; 3.98265
	DD	040cec513r			; 6.46156
	DD	03d0fba88r			; 0.03509
	DD	040a628e7r			; 5.19249
	DD	040752e49r			; 3.83095
	DD	040cd642ar			; 6.41848
	DD	03cf47d80r			; 0.029845
	DD	040a6c5d0r			; 5.21165
	DD	040743073r			; 3.81546
	DD	040cb0dd8r			; 6.34544
	DD	03cc0b136r			; 0.023522
	DD	040aa4f92r			; 5.32221
	DD	040744224r			; 3.81654
	DD	040cb8aaar			; 6.36068
	DD	03cae87d3r			; 0.021305
	DD	040a73ac3r			; 5.22592
	DD	04075eeccr			; 3.8427
	DD	040ca6cd9r			; 6.32579
	DD	03c821294r			; 0.015878
	DD	040a5dbe0r			; 5.18309
	DD	0407d2f27r			; 3.956
	DD	040ca8cbdr			; 6.32968
	DD	03c2ae297r			; 0.01043
	DD	040a32ce4r			; 5.09923
	DD	04085a85fr			; 4.1768
	DD	040c9c5d6r			; 6.3054
	DD	03c0a2a91r			; 0.008433
	DD	040a0f7der			; 5.03026
	DD	040879a50r			; 4.23759
	DD	040c8a4eer			; 6.27013
	DD	03bd4fdf4r			; 0.0065
	DD	0409f0412r			; 4.96925
	DD	0408adc57r			; 4.3394
	DD	040c6f870r			; 6.21783
	DD	03ba18373r			; 0.004929
	DD	0409d8d50r			; 4.9235
	DD	0408e283fr			; 4.44241
	DD	040c5df6cr			; 6.18352
	DD	03b73775cr			; 0.003715
	DD	0409d4c75r			; 4.91558
	DD	0408dbb1br			; 4.42909
	DD	040c4029fr			; 6.12532
	DD	03b4a70d2r			; 0.003089
	DD	0409c48f7r			; 4.88391
	DD	040920260r			; 4.56279
	DD	040c5019dr			; 6.15645
	DD	03b219c9dr			; 0.002466
	DD	0409c31abr			; 4.88106
	DD	040942800r			; 4.62988
	DD	040c49088r			; 6.14264
	DD	03b0e25c8r			; 0.002169
	DD	0409c3d62r			; 4.88249
	DD	04094ae99r			; 4.64631
	DD	040c415d1r			; 6.12766
	DD	03b26dacbr			; 0.002546
	DD	040996304r			; 4.79334
	DD	0409acc16r			; 4.83741
	DD	040c6606br			; 6.19927
	DD	03aac3a86r			; 0.001314
	DD	04099e220r			; 4.80885
	DD	0409a81bdr			; 4.82834
	DD	040c7ca3cr			; 6.24344
	DD	03a9741d1r			; 0.001154
	DD	0409b9a72r			; 4.8626
	DD	0409b19aar			; 4.84688
	DD	040c693a5r			; 6.20552
	DD	03a80f990r			; 0.000984
	DD	0409bb993r			; 4.8664
	DD	0409b7fa2r			; 4.85933
	DD	040c7b565r			; 6.24089
	DD	03a551f82r			; 0.000813
	DD	0409b698ar			; 4.85663
	DD	0409d95bar			; 4.92453
	DD	040c963a4r			; 6.29341
	DD	03a91c087r			; 0.001112
	DD	04099419er			; 4.78926
	DD	040a050f0r			; 5.00988
	DD	040cddf8fr			; 6.43354
	DD	03a10b418r			; 0.000552
	DD	04098580ar			; 4.76075
	DD	040a2e4f1r			; 5.09045
	DD	040d32e1fr			; 6.59938
	DD	039ccff22r			; 0.000391
	DD	0409ec42cr			; 4.96145
	DD	040a38d95r			; 5.11103
	DD	040d8342fr			; 6.75637
	DD	039ae1049r			; 0.000332
	DD	0409f63f8r			; 4.98095
	DD	040a46b89r			; 5.13813
	DD	040dbc1e8r			; 6.86742
	DD	03952c387r			; 0.000201
	DD	040a5d297r			; 5.18196
	DD	04097af64r			; 4.74016
	DD	040cec07dr			; 6.461
	DD	0397ba882r			; 0.00024
	DD	040a5eeb7r			; 5.18539
	DD	0409bfeb0r			; 4.87484
	DD	040da3603r			; 6.81909
	DD	03908509cr			; 0.00013
	DD	040a8a6b5r			; 5.27035
	DD	040977eacr			; 4.73421
	DD	040da708fr			; 6.82624
	DD	038da1a93r			; 0.000104
	DD	040abe6e8r			; 5.37194
	DD	040930af4r			; 4.59509
	DD	040d5189ar			; 6.65925
	DD	038ae1049r			; 8.3e-05
	DD	040ab9581r			; 5.362
	DD	04093c250r			; 4.61747
	DD	040dacf03r			; 6.83777
	DD	03890b418r			; 6.9e-05
	DD	040a926e3r			; 5.286
	DD	0409828e7r			; 4.75499
	DD	040e516e1r			; 7.15904
	DD	0384d8559r			; 4.9e-05
	DD	040afa18cr			; 5.48847
	DD	0408cace9r			; 4.39611
	DD	040d74682r			; 6.72736
	DD	038734507r			; 5.8e-05
	DD	0409eafa3r			; 4.95894
	DD	040929321r			; 4.58046
	DD	040cf49a5r			; 6.47774
	DD	037eae18br			; 2.8e-05
	DD	040b0ae1br			; 5.52125
	DD	0408e1885r			; 4.44049
	DD	040e68f80r			; 7.20502
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	0379f6230r			; 1.9e-05
	DD	040b9f5d8r			; 5.81126
	DD	0408cc582r			; 4.39911
	DD	040eac30dr			; 7.33631
g_sao_edge_offsets DD 0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
	DD	01H
	DD	01H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	01H
g_sig_last_scan_cg DQ FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_8x8
	DQ	FLAT:g_sig_last_scan_8x8+16
	DQ	FLAT:g_sig_last_scan_8x8+32
	DQ	FLAT:g_sig_last_scan_16x16
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:g_sig_last_scan_32x32
	DQ	0000000000000000H
	DQ	0000000000000000H
g_sig_last_scan_8x8 DD 00H
	DD	02H
	DD	01H
	DD	03H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	00H
	DD	02H
	DD	01H
	DD	03H
	ORG $+3
$SG4294949266 DB 'quant', 00H
	ORG $+7
$SG4294949316 DB 'array_checksum', 00H
	ORG $+1
$SG4294949315 DB 'array_md5', 00H
	ORG $+6
$SG4294949314 DB 'reg_sad', 00H
$SG4294949313 DB 'sad_4x4', 00H
$SG4294949312 DB 'sad_8x8', 00H
$SG4294949311 DB 'sad_16x16', 00H
	ORG $+6
$SG4294949310 DB 'sad_32x32', 00H
	ORG $+6
$SG4294949309 DB 'sad_64x64', 00H
	ORG $+6
$SG4294949308 DB 'satd_4x4', 00H
	ORG $+7
$SG4294949307 DB 'satd_8x8', 00H
	ORG $+7
$SG4294949306 DB 'satd_16x16', 00H
	ORG $+5
$SG4294949305 DB 'satd_32x32', 00H
	ORG $+5
$SG4294949304 DB 'satd_64x64', 00H
	ORG $+5
$SG4294949303 DB 'satd_any_size', 00H
	ORG $+2
$SG4294949302 DB 'sad_4x4_dual', 00H
	ORG $+3
$SG4294949301 DB 'sad_8x8_dual', 00H
	ORG $+3
$SG4294949300 DB 'sad_16x16_dual', 00H
	ORG $+1
$SG4294949299 DB 'sad_32x32_dual', 00H
	ORG $+1
$SG4294949298 DB 'sad_64x64_dual', 00H
	ORG $+1
$SG4294949297 DB 'satd_4x4_dual', 00H
	ORG $+2
$SG4294949296 DB 'satd_8x8_dual', 00H
	ORG $+2
$SG4294949295 DB 'satd_16x16_dual', 00H
$SG4294949294 DB 'satd_32x32_dual', 00H
$SG4294949293 DB 'satd_64x64_dual', 00H
$SG4294949292 DB 'satd_any_size_quad', 00H
	ORG $+5
$SG4294949291 DB 'pixels_calc_ssd', 00H
$SG4294949290 DB 'bipred_average', 00H
	ORG $+1
$SG4294949289 DB 'get_optimized_sad', 00H
	ORG $+6
$SG4294949288 DB 'ver_sad', 00H
$SG4294949287 DB 'hor_sad', 00H
$SG4294949286 DB 'pixel_var', 00H
	ORG $+6
$SG4294949285 DB 'fast_forward_dst_4x4', 00H
	ORG $+3
$SG4294949284 DB 'dct_4x4', 00H
$SG4294949283 DB 'dct_8x8', 00H
$SG4294949282 DB 'dct_16x16', 00H
	ORG $+6
$SG4294949281 DB 'dct_32x32', 00H
	ORG $+6
$SG4294949280 DB 'fast_inverse_dst_4x4', 00H
	ORG $+3
$SG4294949279 DB 'idct_4x4', 00H
	ORG $+7
$SG4294949278 DB 'idct_8x8', 00H
	ORG $+7
$SG4294949277 DB 'idct_16x16', 00H
	ORG $+5
$SG4294949276 DB 'idct_32x32', 00H
	ORG $+5
$SG4294949275 DB 'filter_hpel_blocks_hor_ver_luma', 00H
$SG4294949274 DB 'filter_hpel_blocks_diag_luma', 00H
	ORG $+3
$SG4294949273 DB 'filter_qpel_blocks_hor_ver_luma', 00H
$SG4294949272 DB 'filter_qpel_blocks_diag_luma', 00H
	ORG $+3
$SG4294949271 DB 'sample_quarterpel_luma', 00H
	ORG $+1
$SG4294949270 DB 'sample_octpel_chroma', 00H
	ORG $+3
$SG4294949269 DB 'sample_quarterpel_luma_hi', 00H
	ORG $+6
$SG4294949268 DB 'sample_octpel_chroma_hi', 00H
$SG4294949267 DB 'get_extended_block', 00H
	ORG $+5
$SG4294949265 DB 'quantize_residual', 00H
	ORG $+6
$SG4294949264 DB 'dequant', 00H
$SG4294949263 DB 'coeff_abs_sum', 00H
	ORG $+2
$SG4294949262 DB 'fast_coeff_cost', 00H
$SG4294949261 DB 'angular_pred', 00H
	ORG $+3
$SG4294949260 DB 'intra_pred_planar', 00H
	ORG $+6
$SG4294949259 DB 'intra_pred_filtered_dc', 00H
	ORG $+1
$SG4294949258 DB 'sao_edge_ddistortion', 00H
	ORG $+3
$SG4294949257 DB 'calc_sao_edge_dir', 00H
	ORG $+6
$SG4294949256 DB 'sao_reconstruct_color', 00H
	ORG $+2
$SG4294949255 DB 'sao_band_ddistortion', 00H
	ORG $+3
$SG4294949254 DB 'encode_coeff_nxn', 00H
	ORG $+7
$SG4294949253 DB '/%02i.txt', 00H
PUBLIC	kvz_calc_mvd_cost_cabac
PUBLIC	kvz_get_mvd_coding_cost_cabac
PUBLIC	kvz_rdoq_sign_hiding
PUBLIC	kvz_get_coded_level
PUBLIC	kvz_get_ic_rate
PUBLIC	kvz_get_coeff_cost
PUBLIC	snprintf
PUBLIC	vsnprintf
PUBLIC	kvz_rdoq
PUBLIC	kvz_close_rdcost_outfiles
PUBLIC	kvz_init_rdcost_outfiles
fastrd_learning_outfile DQ 033H DUP (?)
outfile_mutex DQ 033H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$kvz_calc_mvd_cost_cabac DD imagerel $LN77
	DD	imagerel $LN77+1034
	DD	imagerel $unwind$kvz_calc_mvd_cost_cabac
$pdata$kvz_get_mvd_coding_cost_cabac DD imagerel $LN4
	DD	imagerel $LN4+203
	DD	imagerel $unwind$kvz_get_mvd_coding_cost_cabac
$pdata$kvz_rdoq_sign_hiding DD imagerel $LN67
	DD	imagerel $LN67+185
	DD	imagerel $unwind$kvz_rdoq_sign_hiding
$pdata$5$kvz_rdoq_sign_hiding DD imagerel $LN67+185
	DD	imagerel $LN67+1100
	DD	imagerel $chain$5$kvz_rdoq_sign_hiding
$pdata$6$kvz_rdoq_sign_hiding DD imagerel $LN67+1100
	DD	imagerel $LN67+1109
	DD	imagerel $chain$6$kvz_rdoq_sign_hiding
$pdata$calc_last_bits DD imagerel calc_last_bits
	DD	imagerel calc_last_bits+11
	DD	imagerel $unwind$calc_last_bits
$pdata$2$calc_last_bits DD imagerel calc_last_bits+11
	DD	imagerel calc_last_bits+311
	DD	imagerel $chain$2$calc_last_bits
$pdata$3$calc_last_bits DD imagerel calc_last_bits+311
	DD	imagerel calc_last_bits+409
	DD	imagerel $chain$3$calc_last_bits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_get_coded_level DD imagerel $LN46
	DD	imagerel $LN46+246
	DD	imagerel $unwind$kvz_get_coded_level
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$kvz_get_coded_level DD imagerel $LN46+246
	DD	imagerel $LN46+683
	DD	imagerel $chain$3$kvz_get_coded_level
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$kvz_get_coded_level DD imagerel $LN46+683
	DD	imagerel $LN46+696
	DD	imagerel $chain$4$kvz_get_coded_level
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kvz_get_ic_rate DD imagerel $LN29
	DD	imagerel $LN29+352
	DD	imagerel $unwind$kvz_get_ic_rate
pdata	ENDS
pdata	SEGMENT
$pdata$kvz_get_coeff_cost DD imagerel $LN85
	DD	imagerel $LN85+1046
	DD	imagerel $unwind$kvz_get_coeff_cost
$pdata$save_accuracy DD imagerel save_accuracy
	DD	imagerel save_accuracy+175
	DD	imagerel $unwind$save_accuracy
$pdata$save_ccc DD imagerel save_ccc
	DD	imagerel save_ccc+230
	DD	imagerel $unwind$save_ccc
$pdata$get_coeff_cabac_cost DD imagerel get_coeff_cabac_cost
	DD	imagerel get_coeff_cabac_cost+281
	DD	imagerel $unwind$get_coeff_cabac_cost
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$snprintf DD imagerel $LN6
	DD	imagerel $LN6+92
	DD	imagerel $unwind$snprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsnprintf DD imagerel $LN4
	DD	imagerel $LN4+104
	DD	imagerel $unwind$vsnprintf
pdata	ENDS
pdata	SEGMENT
$pdata$kvz_rdoq DD imagerel $LN500
	DD	imagerel $LN500+1080
	DD	imagerel $unwind$kvz_rdoq
$pdata$5$kvz_rdoq DD imagerel $LN500+1080
	DD	imagerel $LN500+5558
	DD	imagerel $chain$5$kvz_rdoq
$pdata$6$kvz_rdoq DD imagerel $LN500+5558
	DD	imagerel $LN500+6335
	DD	imagerel $chain$6$kvz_rdoq
$pdata$kvz_close_rdcost_outfiles DD imagerel $LN26
	DD	imagerel $LN26+152
	DD	imagerel $unwind$kvz_close_rdcost_outfiles
$pdata$kvz_init_rdcost_outfiles DD imagerel $LN58
	DD	imagerel $LN58+418
	DD	imagerel $unwind$kvz_init_rdcost_outfiles
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsnprintf DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$snprintf DD 051201H
	DD	0700e6212H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_get_ic_rate DD 040a01H
	DD	02640aH
	DD	015405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$kvz_get_coded_level DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+246
	DD	imagerel $unwind$kvz_get_coded_level
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$kvz_get_coded_level DD 084321H
	DD	0e443H
	DD	08d424H
	DD	07c419H
	DD	065405H
	DD	imagerel $LN46
	DD	imagerel $LN46+246
	DD	imagerel $unwind$kvz_get_coded_level
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kvz_get_coded_level DD 050e01H
	DD	0f00a020eH
	DD	060077008H
	DD	03006H
xdata	ENDS
xdata	SEGMENT
$unwind$kvz_calc_mvd_cost_cabac DD 0b2101H
	DD	02f3421H
	DD	0240121H
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
$unwind$kvz_get_mvd_coding_cost_cabac DD 030901H
	DD	0200109H
	DD	03002H
$unwind$kvz_rdoq_sign_hiding DD 030d01H
	DD	0d009a20dH
	DD	0c007H
$chain$5$kvz_rdoq_sign_hiding DD 0c2e21H
	DD	06f42eH
	DD	07e421H
	DD	08741cH
	DD	096417H
	DD	0a5412H
	DD	0113408H
	DD	imagerel $LN67
	DD	imagerel $LN67+185
	DD	imagerel $unwind$kvz_rdoq_sign_hiding
$chain$6$kvz_rdoq_sign_hiding DD 021H
	DD	imagerel $LN67
	DD	imagerel $LN67+185
	DD	imagerel $unwind$kvz_rdoq_sign_hiding
$unwind$calc_last_bits DD 050801H
	DD	0c006e008H
	DD	060037004H
	DD	03002H
$chain$2$calc_last_bits DD 061721H
	DD	09f417H
	DD	08d40dH
	DD	075405H
	DD	imagerel calc_last_bits
	DD	imagerel calc_last_bits+11
	DD	imagerel $unwind$calc_last_bits
$chain$3$calc_last_bits DD 021H
	DD	imagerel calc_last_bits
	DD	imagerel calc_last_bits+11
	DD	imagerel $unwind$calc_last_bits
$unwind$kvz_get_coeff_cost DD 0b1901H
	DD	02e5419H
	DD	02d3419H
	DD	0260119H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0600bH
$unwind$save_accuracy DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$save_ccc DD 061901H
	DD	076419H
	DD	063419H
	DD	070153219H
$unwind$get_coeff_cabac_cost DD 020701H
	DD	0250107H
$unwind$kvz_rdoq DD 0e8b01H
	DD	0a54d88bH
	DD	0a56b871H
	DD	014b90135H
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
$chain$5$kvz_rdoq DD 0c3621H
	DD	0a55c836H
	DD	0a57a82dH
	DD	0a589824H
	DD	0a59881bH
	DD	0a5a7812H
	DD	0a5b6808H
	DD	imagerel $LN500
	DD	imagerel $LN500+1080
	DD	imagerel $unwind$kvz_rdoq
$chain$6$kvz_rdoq DD 021H
	DD	imagerel $LN500
	DD	imagerel $LN500+1080
	DD	imagerel $unwind$kvz_rdoq
$unwind$kvz_close_rdcost_outfiles DD 0a1d01H
	DD	06641dH
	DD	097415H
	DD	085415H
	DD	073415H
	DD	0e0113215H
$unwind$kvz_init_rdcost_outfiles DD 091d01H
	DD	0408641dH
	DD	0407541dH
	DD	0406341dH
	DD	0404011dH
	DD	07010H
	ORG $+1
$SG4294949249 DB 'w', 00H
	ORG $+2
$SG4294949243 DB '%u %u', 0aH, 00H
	ORG $+3
$SG4294949240 DB 00H, 03H, 01H, 02H, 00H
	ORG $+3
$SG4294949238 DB '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H
	DB	'T', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 's'
	DB	00H, 'h', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'b', 00H, 'e', 00H, ' ', 00H, '1', 00H, ',', 00H, ' ', 00H, '4'
	DB	00H, ',', 00H, ' ', 00H, '1', 00H, '6', 00H, ' ', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '6', 00H, '4', 00H, ' ', 00H, 'c', 00H, 'o'
	DB	00H, 'e', 00H, 'f', 00H, 'f', 00H, 'i', 00H, 'c', 00H, 'i', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'g', 00H, 'r', 00H, 'o'
	DB	00H, 'u', 00H, 'p', 00H, 's', 00H, '"', 00H, 00H, 00H
	ORG $+6
$SG4294949244 DB 'q', 00H, 'p', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'R', 00H, 'D', 00H, '_', 00H, 'S', 00H, 'A', 00H, 'M', 00H, 'P'
	DB	00H, 'L', 00H, 'I', 00H, 'N', 00H, 'G', 00H, '_', 00H, 'M', 00H
	DB	'A', 00H, 'X', 00H, '_', 00H, 'L', 00H, 'A', 00H, 'S', 00H, 'T'
	DB	00H, '_', 00H, 'Q', 00H, 'P', 00H, 00H, 00H
	ORG $+7
$SG4294949239 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'r', 00H
	DB	'd', 00H, 'o', 00H, '.', 00H, 'c', 00H, 00H, 00H
	ORG $+7
$SG4294949241 DB '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H
	DB	'F', 00H, 'a', 00H, 's', 00H, 't', 00H, ' ', 00H, 'R', 00H, 'D'
	DB	00H, ' ', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'o', 00H, 'e'
	DB	00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'w', 00H, 'o', 00H, 'r', 00H, 'k', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 't', 00H, 'h', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 's', 00H
	DB	't', 00H, '-', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'i', 00H, 'd'
	DB	00H, 'u', 00H, 'a', 00H, 'l', 00H, '-', 00H, 'c', 00H, 'o', 00H
	DB	's', 00H, 't', 00H, '"', 00H, 00H, 00H
	ORG $+4
$SG4294949242 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'r', 00H
	DB	'd', 00H, 'o', 00H, '.', 00H, 'c', 00H, 00H, 00H
	ORG $+7
$SG4294949245 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'r', 00H
	DB	'd', 00H, 'o', 00H, '.', 00H, 'c', 00H, 00H, 00H
	ORG $+4
$SG4294949246 DB 'q', 00H, 'p', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'R', 00H, 'D', 00H, '_', 00H, 'S', 00H, 'A', 00H, 'M', 00H, 'P'
	DB	00H, 'L', 00H, 'I', 00H, 'N', 00H, 'G', 00H, '_', 00H, 'M', 00H
	DB	'A', 00H, 'X', 00H, '_', 00H, 'L', 00H, 'A', 00H, 'S', 00H, 'T'
	DB	00H, '_', 00H, 'Q', 00H, 'P', 00H, 00H, 00H
	ORG $+7
$SG4294949247 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'r', 00H
	DB	'd', 00H, 'o', 00H, '.', 00H, 'c', 00H, 00H, 00H
	ORG $+4
$SG4294949248 DB 'Failed to open %s: %s', 0aH, 00H
	ORG $+1
$SG4294949251 DB 's', 00H, 't', 00H, 'r', 00H, 'l', 00H, 'e', 00H, 'n', 00H
	DB	'(', 00H, 'f', 00H, 'n', 00H, '_', 00H, 't', 00H, 'e', 00H, 'm'
	DB	00H, 'p', 00H, 'l', 00H, 'a', 00H, 't', 00H, 'e', 00H, ')', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'R', 00H, 'D', 00H, '_'
	DB	00H, 'S', 00H, 'A', 00H, 'M', 00H, 'P', 00H, 'L', 00H, 'I', 00H
	DB	'N', 00H, 'G', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'X', 00H, '_'
	DB	00H, 'F', 00H, 'N', 00H, '_', 00H, 'L', 00H, 'E', 00H, 'N', 00H
	DB	'G', 00H, 'T', 00H, 'H', 00H, 00H, 00H
$SG4294949252 DB 'F', 00H, ':', 00H, '\', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'_', 00H, '2', 00H, '0', 00H, '2', 00H, '1', 00H, '\', 00H, 'k'
	DB	00H, 'v', 00H, 'a', 00H, 'z', 00H, 'a', 00H, 'a', 00H, 'r', 00H
	DB	'-', 00H, 'm', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'r', 00H
	DB	'd', 00H, 'o', 00H, '.', 00H, 'c', 00H, 00H, 00H
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
fn_template$ = 32
fn$ = 4128
dir_path$ = 8240
kvz_init_rdcost_outfiles PROC

; 165  : {

$LN58:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	mov	eax, 8224				; 00002020H
	call	__chkstk
	sub	rsp, rax
	mov	rbx, rcx

; 166  : #define RD_SAMPLING_MAX_FN_LENGTH 4095
; 167  :   static const char *basename_tmpl = "/%02i.txt";
; 168  :   char fn_template[RD_SAMPLING_MAX_FN_LENGTH + 1];
; 169  :   char fn[RD_SAMPLING_MAX_FN_LENGTH + 1];
; 170  :   int rv = 0, qp;

	xor	ebp, ebp

; 171  : 
; 172  :   // As long as QP is a two-digit number, template and produced string should
; 173  :   // be equal in length ("%i" -> "22")
; 174  :   assert(RD_SAMPLING_MAX_LAST_QP <= 99);
; 175  :   assert(strlen(fn_template) <= RD_SAMPLING_MAX_FN_LENGTH);

	lea	rcx, QWORD PTR fn_template$[rsp]
	mov	rax, -1
	npad	2
$LL53@kvz_init_r:
	inc	rax
	cmp	BYTE PTR [rcx+rax], bpl
	jne	SHORT $LL53@kvz_init_r
	cmp	rax, 4095				; 00000fffH
	jbe	SHORT $LN17@kvz_init_r
	mov	r8d, 175				; 000000afH
	lea	rdx, OFFSET FLAT:$SG4294949252
	lea	rcx, OFFSET FLAT:$SG4294949251
	call	QWORD PTR __imp__wassert
$LN17@kvz_init_r:

; 176  : 
; 177  :   strncpy(fn_template, dir_path, RD_SAMPLING_MAX_FN_LENGTH);

	mov	r8d, 4095				; 00000fffH
	lea	rcx, QWORD PTR fn_template$[rsp]
	mov	rdx, rbx
	call	QWORD PTR __imp_strncpy

; 178  :   strncat(fn_template, basename_tmpl, RD_SAMPLING_MAX_FN_LENGTH - strlen(dir_path));

	mov	rax, -1
$LL52@kvz_init_r:
	inc	rax
	cmp	BYTE PTR [rbx+rax], bpl
	jne	SHORT $LL52@kvz_init_r
	mov	r8d, 4095				; 00000fffH
	lea	rdx, OFFSET FLAT:$SG4294949253
	sub	r8, rax
	lea	rcx, QWORD PTR fn_template$[rsp]
	call	QWORD PTR __imp_strncat
	lea	rdi, OFFSET FLAT:outfile_mutex
	lea	rsi, OFFSET FLAT:outfile_mutex+400
	npad	8
$LL4@kvz_init_r:
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	ecx, 80					; 00000050H
	call	??2@YAPEAX_K@Z				; operator new
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	mov	edx, 2
	mov	rcx, rax
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	rbx, rax
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 40   :         _Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);

	call	QWORD PTR __imp__Mtx_init_in_situ
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 81   :     *mutex = new std::mutex();

	mov	QWORD PTR [rdi], rbx
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 180  :   for (qp = 0; qp <= RD_SAMPLING_MAX_LAST_QP; qp++) {

	add	rdi, 8
	cmp	rdi, rsi
	jle	SHORT $LL4@kvz_init_r

; 181  :     pthread_mutex_t *curr = outfile_mutex + qp;
; 182  : 
; 183  :     if (pthread_mutex_init(curr, NULL) != 0) {
; 184  :       fprintf(stderr, "Failed to create mutex\n");
; 185  :       rv = -1;
; 186  :       qp--;
; 187  :       goto out_destroy_mutexes;
; 188  :     }
; 189  :   }
; 190  : 
; 191  :   for (qp = 0; qp <= RD_SAMPLING_MAX_LAST_QP; qp++) {

	lea	rsi, OFFSET FLAT:fastrd_learning_outfile
	mov	edi, ebp
	mov	rbx, rsi
$LL7@kvz_init_r:

; 192  :     FILE *curr;
; 193  : 
; 194  :     snprintf(fn, RD_SAMPLING_MAX_FN_LENGTH, fn_template, qp);

	mov	r9d, edi
	lea	r8, QWORD PTR fn_template$[rsp]
	mov	edx, 4095				; 00000fffH
	lea	rcx, QWORD PTR fn$[rsp]
	call	snprintf

; 195  :     fn[RD_SAMPLING_MAX_FN_LENGTH] = 0;
; 196  :     curr = fopen(fn, "w");

	lea	rdx, OFFSET FLAT:$SG4294949249
	mov	BYTE PTR fn$[rsp+4095], bpl
	lea	rcx, QWORD PTR fn$[rsp]
	call	QWORD PTR __imp_fopen

; 197  :     if (curr == NULL) {

	test	rax, rax
	je	SHORT $LN42@kvz_init_r

; 199  :       rv = -1;
; 200  :       qp--;
; 201  :       goto out_close_files;
; 202  :     }
; 203  :     fastrd_learning_outfile[qp] = curr;

	mov	QWORD PTR [rbx], rax
	inc	edi
	add	rbx, 8
	cmp	edi, 50					; 00000032H
	jle	SHORT $LL7@kvz_init_r
$out_destroy_mutexes$59:

; 211  :   }
; 212  :   goto out;
; 213  : 
; 214  : out_destroy_mutexes:
; 215  :   for (; qp >= 0; qp--) {
; 216  :     pthread_mutex_destroy(outfile_mutex + qp);
; 217  :   }
; 218  :   goto out;
; 219  : 
; 220  : out:
; 221  :   return rv;

	mov	eax, ebp
	jmp	SHORT $out$60
$LN42@kvz_init_r:

; 198  :       fprintf(stderr, "Failed to open %s: %s\n", fn, strerror(errno));

	call	QWORD PTR __imp__errno
	mov	ecx, DWORD PTR [rax]
	call	QWORD PTR __imp_strerror
	mov	ecx, 2
	mov	rbx, rax
	call	QWORD PTR __imp___acrt_iob_func
	mov	r9, rbx
	lea	r8, QWORD PTR fn$[rsp]
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:$SG4294949248
	call	fprintf
$out_close_files$61:
	mov	ebx, edi
	sub	rbx, 1

; 204  :   }
; 205  :   goto out;
; 206  : 
; 207  : out_close_files:
; 208  :   for (; qp >= 0; qp--) {

	js	SHORT $LN54@kvz_init_r
	npad	1
$LL10@kvz_init_r:

; 209  :     fclose(fastrd_learning_outfile[qp]);

	mov	rcx, QWORD PTR [rsi+rbx*8]
	call	QWORD PTR __imp_fclose

; 210  :     fastrd_learning_outfile[qp] = NULL;

	mov	QWORD PTR [rsi+rbx*8], rbp
	sub	rbx, 1
	jns	SHORT $LL10@kvz_init_r
$out_destroy_mutexes_1$62:
$LN54@kvz_init_r:
$out_destroy_mutexes_2$63:

; 222  : #undef RD_SAMPLING_MAX_FN_LENGTH
; 223  : }

	mov	eax, -1
$out$60:
	lea	r11, QWORD PTR [rsp+8224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
kvz_init_rdcost_outfiles ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
kvz_close_rdcost_outfiles PROC

; 1181 : {

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	xor	r14d, r14d
	mov	QWORD PTR [rsp+48], rsi
	mov	ebx, r14d
	lea	rbp, OFFSET FLAT:__ImageBase
	npad	9
$LL4@kvz_close_:

; 1185 :     FILE *curr = fastrd_learning_outfile[i];

	mov	rcx, QWORD PTR fastrd_learning_outfile[rbx+rbp]

; 1186 :     pthread_mutex_t *curr_mtx = outfile_mutex + i;
; 1187 :     if (curr != NULL) {

	test	rcx, rcx
	je	SHORT $LN5@kvz_close_

; 1188 :       fclose(curr);

	call	QWORD PTR __imp_fclose
$LN5@kvz_close_:

; 1189 :     }
; 1190 :     if (curr_mtx != NULL) {

	lea	rdi, QWORD PTR outfile_mutex[rbp]
	add	rdi, rbx
	je	SHORT $LN2@kvz_close_
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 75   :     delete static_cast<std::mutex*>(*mutex);

	mov	rsi, QWORD PTR [rdi]
	test	rsi, rsi
	je	SHORT $LN13@kvz_close_
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 44   :         _Mtx_destroy_in_situ(_Mymtx());

	mov	rcx, rsi
	call	QWORD PTR __imp__Mtx_destroy_in_situ
	mov	edx, 80					; 00000050H
	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@kvz_close_:
; File F:\open_codec_learn_2021\kvazaar-master\src\threadwrapper\src\pthread.cpp

; 76   :     *mutex = nullptr;

	mov	QWORD PTR [rdi], r14
$LN2@kvz_close_:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 1184 :   for (i = 0; i < RD_SAMPLING_MAX_LAST_QP; i++) {

	add	rbx, 8
	cmp	rbx, 400				; 00000190H
	jl	SHORT $LL4@kvz_close_

; 1191 :       pthread_mutex_destroy(curr_mtx);
; 1192 :     }
; 1193 :   }
; 1194 : }

	mov	rsi, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
kvz_close_rdcost_outfiles ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\transform.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
tv9198 = 64
c2_idx$1$ = 68
q_bits$1$ = 72
width$1$ = 76
tv9210 = 80
scanpos$1$ = 84
tv9196 = 88
$T1 = 96
cabac$1$ = 96
tv9194 = 104
rd_stats$5$ = 108
cg_scanpos$1$ = 112
tv8097 = 120
scanpos_in_cg$1$ = 128
qp_scaled$1$ = 132
base_coeff_group_ctx$2$ = 136
scan$1$ = 144
pattern_sig_ctx$1$ = 152
cg_blkpos$1$ = 156
cg_pos_x$1$ = 160
cg_pos_y$1$ = 164
log2_block_size$1$ = 168
tv8059 = 176
tv8057 = 184
tv8096 = 192
encoder$1$ = 200
tv8099 = 208
tv8101 = 212
tv8098 = 216
$T2 = 220
quant_coeff$1$ = 224
$T3 = 232
tv8147 = 240
scan_cg$1$ = 248
err_scale$1$ = 256
tv8128 = 264
rd_stats$ = 272
sig_coeffgroup_flag$ = 320
last_y_bits$ = 576
last_x_bits$ = 704
cost_coeffgroup_sig$ = 832
cost_coeff$ = 1344
cost_sig$ = 9536
cost_coeff0$ = 17728
sh_rates$ = 25920
state$ = 42512
coef$ = 42520
dest_coeff$ = 42528
width$ = 42536
cg_scanpos$1$ = 42544
height$ = 42544
type$ = 42552
scan_mode$ = 42560
block_type$ = 42568
tr_depth$ = 42576
kvz_rdoq PROC

; 674  : {

$LN500:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-42184]
	mov	eax, 42440				; 0000a5c8H
	call	__chkstk
	sub	rsp, rax

; 675  :   const encoder_control_t * const encoder = state->encoder_control;
; 676  :   cabac_data_t * const cabac = &state->cabac;
; 677  :   uint32_t log2_tr_size      = kvz_g_convert_to_bit[ width ] + 2;
; 678  :   int32_t  transform_shift   = MAX_TR_DYNAMIC_RANGE - encoder->bitdepth - log2_tr_size;  // Represents scaling through forward transform
; 679  :   uint16_t go_rice_param     = 0;
; 680  :   uint32_t log2_block_size   = kvz_g_convert_to_bit[ width ] + 2;
; 681  :   int32_t  scalinglist_type= (block_type == CU_INTRA ? 0 : 3) + (int8_t)("\0\3\1\2"[type]);

	movsx	r15, BYTE PTR type$[rbp-256]
	lea	r10, OFFSET FLAT:__ImageBase
	mov	esi, DWORD PTR height$[rbp-256]
	mov	rdx, rcx
	mov	rcx, QWORD PTR [rcx]
	xor	r11d, r11d
	mov	QWORD PTR encoder$1$[rbp-256], rcx
	mov	r14, r8
	movsxd	r13, r9d
	mov	r8d, 15
	mov	eax, 3
	movaps	XMMWORD PTR [rsp+42336], xmm11
	movsx	ecx, BYTE PTR [rcx+2592]
	lea	r9, QWORD PTR [rdx+128]
	sub	r8d, ecx
	movaps	XMMWORD PTR [rsp+42304], xmm13
	movsx	ebx, BYTE PTR kvz_g_convert_to_bit[r13+r10]
	movsx	r10d, BYTE PTR $SG4294949240[r15+r10]
	add	ebx, 2
	sub	r8d, ebx
	mov	QWORD PTR cabac$1$[rsp], r9
	cmp	BYTE PTR block_type$[rbp-256], 1
	mov	DWORD PTR log2_block_size$1$[rbp-256], ebx
	cmove	eax, r11d
	mov	WORD PTR tv9198[rsp], r11w

; 682  : 
; 683  :   int32_t qp_scaled = kvz_get_scaled_qp(type, state->qp, (encoder->bitdepth - 8) * 6);

	sub	cl, 8
	add	r10d, eax
	movzx	eax, cl
	add	al, al
	add	cl, al
	movsx	eax, BYTE PTR [rdx+384]
	add	cl, cl
; File F:\open_codec_learn_2021\kvazaar-master\src\transform.c

; 144  :   if(type == 0) {

	test	r15b, r15b
	jne	SHORT $LN105@kvz_rdoq

; 145  :     qp_scaled = qp + qp_offset;

	mov	r12d, eax
	movsx	eax, cl
	add	r12d, eax

; 146  :   } else {

	jmp	SHORT $LN481@kvz_rdoq
$LN105@kvz_rdoq:

; 147  :     qp_scaled = CLIP(-qp_offset, 57, qp);

	mov	r9d, 57					; 00000039H
	cmp	al, 57					; 00000039H
	jg	SHORT $LN111@kvz_rdoq
	mov	r9d, eax
$LN111@kvz_rdoq:
	movsx	edx, cl
	mov	r12d, edx
	neg	r12d
	cmp	r12d, r9d
	jg	SHORT $LN113@kvz_rdoq
	cmp	al, 57					; 00000039H
	jle	SHORT $LN112@kvz_rdoq
	mov	r12d, 57				; 00000039H
	jmp	SHORT $LN107@kvz_rdoq
$LN112@kvz_rdoq:
	mov	r12d, eax
$LN113@kvz_rdoq:

; 148  :     if(qp_scaled < 0) {

	test	r12d, r12d
	js	SHORT $LN482@kvz_rdoq
$LN107@kvz_rdoq:

; 149  :       qp_scaled = qp_scaled + qp_offset;
; 150  :     } else {
; 151  :       qp_scaled = kvz_g_chroma_scale[qp_scaled] + qp_offset;

	mov	eax, r12d
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	r12d, BYTE PTR kvz_g_chroma_scale[rax+rcx]
$LN482@kvz_rdoq:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 685  :   int32_t q_bits = QUANT_SHIFT + qp_scaled/6 + transform_shift;

	mov	r9, QWORD PTR cabac$1$[rsp]
	add	r12d, edx
$LN481@kvz_rdoq:
	mov	eax, 715827883				; 2aaaaaabH
	mov	DWORD PTR qp_scaled$1$[rbp-256], r12d
	imul	r12d
	xorps	xmm13, xmm13
	xorps	xmm11, xmm11

; 686  : 
; 687  :   const int32_t *quant_coeff  = encoder->scaling_list.quant_coeff[log2_tr_size-2][scalinglist_type][qp_scaled%6];
; 688  :   const double *err_scale     = encoder->scaling_list.error_scale[log2_tr_size-2][scalinglist_type][qp_scaled%6];
; 689  : 
; 690  :   double block_uncoded_cost = 0;
; 691  :   
; 692  :   double cost_coeff [ 32 * 32 ];
; 693  :   double cost_sig   [ 32 * 32 ];
; 694  :   double cost_coeff0[ 32 * 32 ];
; 695  : 
; 696  :   struct sh_rates_t sh_rates;
; 697  : 
; 698  :   const uint32_t *scan_cg = g_sig_last_scan_cg[log2_block_size - 2][scan_mode];
; 699  :   const uint32_t cg_size = 16;
; 700  :   const int32_t  shift = 4 >> 1;
; 701  :   const uint32_t num_blk_side = width >> shift;
; 702  :   double   cost_coeffgroup_sig[ 64 ];
; 703  :   uint32_t sig_coeffgroup_flag[ 64 ];
; 704  : 
; 705  :   uint16_t    ctx_set    = 0;
; 706  :   int16_t     c1         = 1;
; 707  :   int16_t     c2         = 0;

	mov	WORD PTR tv9194[rsp], r11w
	mov	eax, edx

; 708  :   double      base_cost  = 0;
; 709  : 
; 710  :   uint32_t    c1_idx     = 0;
; 711  :   uint32_t    c2_idx     = 0;

	mov	DWORD PTR c2_idx$1$[rsp], r11d
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [r8+14]
	add	eax, edx
	lea	r8d, DWORD PTR [rbx-2]
	mov	DWORD PTR q_bits$1$[rsp], eax
	mov	eax, r12d
	lea	ecx, DWORD PTR [rdx+rdx*2]
	add	ecx, ecx
	sub	eax, ecx
	lea	rcx, QWORD PTR [r8+r8*2]
	movsxd	rdx, eax
	movsxd	rax, r10d
	lea	rcx, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [rcx+rcx*2]
	lea	rcx, QWORD PTR [rdx+rax*2]
	mov	rdx, QWORD PTR encoder$1$[rbp-256]
	mov	rax, QWORD PTR [rdx+rcx*8+2912]
	mov	QWORD PTR quant_coeff$1$[rbp-256], rax
	mov	rax, QWORD PTR [rdx+rcx*8+5216]
	movsx	rdx, BYTE PTR scan_mode$[rbp-256]
	mov	QWORD PTR err_scale$1$[rbp-256], rax
	lea	rcx, QWORD PTR [rdx+r8*2]
	add	rcx, r8
	lea	r8, OFFSET FLAT:__ImageBase
	mov	rax, QWORD PTR g_sig_last_scan_cg[r8+rcx*8]
	mov	ecx, r13d
	sar	ecx, 2
	mov	r13d, r11d
	mov	QWORD PTR scan_cg$1$[rbp-256], rax
	mov	eax, 1
	mov	WORD PTR tv9196[rsp], ax

; 712  :   int32_t     base_level;
; 713  : 
; 714  :   const uint32_t *scan = kvz_g_sig_last_scan[ scan_mode ][ log2_block_size - 1 ];

	lea	rax, QWORD PTR [rdx+rdx*4]
	mov	DWORD PTR width$1$[rsp], ecx
	lea	ecx, DWORD PTR [rbx-1]

; 715  : 
; 716  :   int32_t cg_last_scanpos = -1;
; 717  :   int32_t last_scanpos = -1;
; 718  : 
; 719  :   uint32_t cg_num = width * height >> 4;

	mov	ebx, DWORD PTR width$[rbp-256]
	add	rcx, rax
	imul	ebx, esi
	mov	r12, QWORD PTR kvz_g_sig_last_scan[r8+rcx*8]
	mov	QWORD PTR scan$1$[rbp-256], r12
	sar	ebx, 4

; 720  : 
; 721  :   // Explicitly tell the only possible numbers of elements to be zeroed.
; 722  :   // Hope the compiler is able to utilize this information.
; 723  :   switch (cg_num) {

	mov	eax, ebx
	sub	eax, 1
	je	$LN34@kvz_rdoq
	sub	eax, 3
	je	$LN35@kvz_rdoq
	sub	eax, 12
	je	$LN36@kvz_rdoq
	cmp	eax, 48					; 00000030H
	je	SHORT $LN37@kvz_rdoq

; 728  :     default: assert(0 && "There should be 1, 4, 16 or 64 coefficient groups");

	mov	r8d, 728				; 000002d8H
	lea	rdx, OFFSET FLAT:$SG4294949239
	lea	rcx, OFFSET FLAT:$SG4294949238
	call	QWORD PTR __imp__wassert

; 729  :   }
; 730  : 
; 731  :   cabac_ctx_t *base_coeff_group_ctx = &(cabac->ctx.cu_sig_coeff_group_model[type]);

	mov	rcx, QWORD PTR cabac$1$[rsp]

; 732  :   cabac_ctx_t *baseCtx              = (type == 0) ? &(cabac->ctx.cu_sig_model_luma[0]) : &(cabac->ctx.cu_sig_model_chroma[0]);
; 733  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);

	mov	r8d, 76					; 0000004cH

; 734  : 
; 735  :   struct {
; 736  :     double coded_level_and_dist;
; 737  :     double uncoded_dist;
; 738  :     double sig_cost;
; 739  :     double sig_cost_0;
; 740  :     int32_t nnz_before_pos0;
; 741  :   } rd_stats;
; 742  : 
; 743  :   //Find last cg and last scanpos
; 744  :   int32_t cg_scanpos;
; 745  :   for (cg_scanpos = (cg_num - 1); cg_scanpos >= 0; cg_scanpos--)

	mov	edx, 178				; 000000b2H
	lea	rax, QWORD PTR [rcx+72]
	add	rax, r15
	test	r15b, r15b
	mov	QWORD PTR base_coeff_group_ctx$2$[rbp-256], rax
	mov	eax, 103				; 00000067H
	cmovne	r8d, eax
	mov	eax, 194				; 000000c2H
	add	r8, rcx
	test	r15b, r15b
	mov	QWORD PTR tv8059[rbp-256], r8
	cmovne	edx, eax
	add	rdx, rcx
	mov	QWORD PTR tv8057[rbp-256], rdx
	lea	edx, DWORD PTR [rbx-1]
	mov	DWORD PTR cg_scanpos$1$[rbp-256], edx
	test	edx, edx
	js	$LN77@kvz_rdoq
	jmp	$LN378@kvz_rdoq
$LN37@kvz_rdoq:

; 727  :     case 64: FILL_ARRAY(sig_coeffgroup_flag, 0, 64); break;

	xor	edx, edx
	lea	rcx, QWORD PTR sig_coeffgroup_flag$[rbp-256]
	mov	r8d, 256				; 00000100H
	call	memset
	mov	rdx, QWORD PTR cabac$1$[rsp]
	mov	ecx, 76					; 0000004cH
	lea	rax, QWORD PTR [rdx+72]
	add	rax, r15
	test	r15b, r15b
	mov	QWORD PTR base_coeff_group_ctx$2$[rbp-256], rax
	mov	eax, 103				; 00000067H
	cmovne	ecx, eax
	mov	eax, 194				; 000000c2H
	add	rcx, rdx
	mov	QWORD PTR tv8059[rbp-256], rcx
	test	r15b, r15b
	mov	ecx, 178				; 000000b2H
	cmovne	ecx, eax
	add	rcx, rdx
	mov	QWORD PTR tv8057[rbp-256], rcx
	jmp	SHORT $LN483@kvz_rdoq
$LN36@kvz_rdoq:
	xorps	xmm0, xmm0

; 726  :     case 16: FILL_ARRAY(sig_coeffgroup_flag, 0, 16); break;

	movups	XMMWORD PTR sig_coeffgroup_flag$[rbp-256], xmm0
	movups	XMMWORD PTR sig_coeffgroup_flag$[rbp-240], xmm0
	movups	XMMWORD PTR sig_coeffgroup_flag$[rbp-224], xmm0
	movups	XMMWORD PTR sig_coeffgroup_flag$[rbp-208], xmm0
	jmp	SHORT $LN484@kvz_rdoq
$LN35@kvz_rdoq:
	xorps	xmm0, xmm0

; 725  :     case  4: FILL_ARRAY(sig_coeffgroup_flag, 0,  4); break;

	movups	XMMWORD PTR sig_coeffgroup_flag$[rbp-256], xmm0
	jmp	SHORT $LN484@kvz_rdoq
$LN34@kvz_rdoq:

; 724  :     case  1: FILL_ARRAY(sig_coeffgroup_flag, 0,  1); break;

	xor	eax, eax
	mov	DWORD PTR sig_coeffgroup_flag$[rbp-256], eax
$LN484@kvz_rdoq:

; 753  :       level_double            = MIN(abs(level_double) * q, MAX_INT - (1 << (q_bits - 1)));

	lea	rax, QWORD PTR [r15+72]
	mov	r8d, 76					; 0000004cH
	add	rax, r9
	mov	edx, 178				; 000000b2H
	test	r15b, r15b
	mov	QWORD PTR base_coeff_group_ctx$2$[rbp-256], rax
	mov	eax, 103				; 00000067H
	cmovne	r8d, eax
	mov	eax, 194				; 000000c2H
	add	r8, r9
	test	r15b, r15b
	mov	QWORD PTR tv8059[rbp-256], r8
	cmovne	edx, eax
	add	rdx, r9
	mov	QWORD PTR tv8057[rbp-256], rdx
$LN483@kvz_rdoq:
	lea	edx, DWORD PTR [rbx-1]
	mov	DWORD PTR cg_scanpos$1$[rbp-256], edx
$LN378@kvz_rdoq:
	mov	edi, DWORD PTR q_bits$1$[rsp]
	mov	r11d, 1
	mov	r9d, edx
	mov	r10d, 2147483647			; 7fffffffH
	neg	r9d
	mov	ebx, edx
	shl	r9d, 4
	lea	ecx, DWORD PTR [rdi-1]
	shl	ebx, 4
	shl	r11d, cl
	sub	r10d, r11d
	add	ebx, 15
	npad	4
$LL6@kvz_rdoq:

; 746  :   {
; 747  :     for (int32_t scanpos_in_cg = (cg_size - 1); scanpos_in_cg >= 0; scanpos_in_cg--)

	mov	r15d, ebx
	mov	DWORD PTR scanpos$1$[rsp], ebx
	mov	ecx, edi
	npad	7
$LL9@kvz_rdoq:

; 748  :     {
; 749  :       int32_t  scanpos        = cg_scanpos*cg_size + scanpos_in_cg;
; 750  :       uint32_t blkpos         = scan[scanpos];

	movsxd	rax, r15d

; 751  :       int32_t q               = quant_coeff[blkpos];

	mov	r8d, DWORD PTR [r12+rax*4]

; 752  :       int32_t level_double    = coef[blkpos];

	mov	rax, QWORD PTR coef$[rbp-256]
	movsx	eax, WORD PTR [rax+r8*2]

; 753  :       level_double            = MIN(abs(level_double) * q, MAX_INT - (1 << (q_bits - 1)));

	cdq
	xor	eax, edx
	sub	eax, edx
	mov	rdx, QWORD PTR quant_coeff$1$[rbp-256]
	imul	eax, DWORD PTR [rdx+r8*4]

; 754  :       uint32_t max_abs_level  = (level_double + (1 << (q_bits - 1))) >> q_bits;

	cmp	eax, r10d
	cmovge	eax, r10d
	add	eax, r11d
	sar	eax, cl

; 755  : 
; 756  :       if (max_abs_level > 0) {

	test	eax, eax
	jne	SHORT $LN281@kvz_rdoq

; 761  :         break;
; 762  :       }
; 763  :       dest_coeff[blkpos] = 0;

	dec	r15d
	xor	eax, eax
	mov	WORD PTR [r14+r8*2], ax
	mov	DWORD PTR scanpos$1$[rsp], r15d
	lea	eax, DWORD PTR [r15+r9]
	test	eax, eax
	jns	SHORT $LL9@kvz_rdoq

; 984  :         }
; 985  :       } //end for
; 986  :       if (found_last) break;

	jmp	SHORT $LN370@kvz_rdoq
$LN281@kvz_rdoq:

; 757  :         last_scanpos    = scanpos;
; 758  :         ctx_set         = (scanpos > 0 && type == 0) ? 2 : 0;

	movzx	ecx, BYTE PTR type$[rbp-256]
	mov	eax, 2
	test	r15d, r15d
	jle	SHORT $LN86@kvz_rdoq
	test	cl, cl
	je	SHORT $LN394@kvz_rdoq
$LN86@kvz_rdoq:

; 759  :         cg_last_scanpos = cg_scanpos;
; 760  :         sh_rates.sig_coeff_inc[blkpos] = 0;

	xor	edx, edx
	mov	DWORD PTR sh_rates$[rbp+r8*4+7936], edx
	movzx	eax, dx
	mov	DWORD PTR tv9210[rsp], eax

; 764  :     }
; 765  :     if (last_scanpos != -1) break;

	cmp	r15d, -1
	jne	SHORT $LN369@kvz_rdoq
$LN370@kvz_rdoq:

; 734  : 
; 735  :   struct {
; 736  :     double coded_level_and_dist;
; 737  :     double uncoded_dist;
; 738  :     double sig_cost;
; 739  :     double sig_cost_0;
; 740  :     int32_t nnz_before_pos0;
; 741  :   } rd_stats;
; 742  : 
; 743  :   //Find last cg and last scanpos
; 744  :   int32_t cg_scanpos;
; 745  :   for (cg_scanpos = (cg_num - 1); cg_scanpos >= 0; cg_scanpos--)

	mov	edx, DWORD PTR cg_scanpos$1$[rbp-256]
	sub	ebx, 16
	dec	edx
	add	r9d, 16
	mov	DWORD PTR cg_scanpos$1$[rbp-256], edx
	test	edx, edx
	jns	$LL6@kvz_rdoq
	jmp	$LN77@kvz_rdoq
$LN394@kvz_rdoq:

; 757  :         last_scanpos    = scanpos;
; 758  :         ctx_set         = (scanpos > 0 && type == 0) ? 2 : 0;

	mov	r14d, eax
	mov	DWORD PTR tv9210[rsp], eax
	xor	eax, eax
	mov	DWORD PTR sh_rates$[rbp+r8*4+7936], eax
	xor	edx, edx
	jmp	SHORT $LN485@kvz_rdoq
$LN369@kvz_rdoq:
	mov	r14d, DWORD PTR tv9210[rsp]
$LN485@kvz_rdoq:

; 766  :   }
; 767  : 
; 768  :   if (last_scanpos == -1) {
; 769  :     return;
; 770  :   }
; 771  : 
; 772  :   for (; cg_scanpos >= 0; cg_scanpos--) cost_coeffgroup_sig[cg_scanpos] = 0;

	mov	ebx, DWORD PTR cg_scanpos$1$[rbp-256]
	movaps	XMMWORD PTR [rsp+42416], xmm6
	mov	eax, ebx
	movaps	XMMWORD PTR [rsp+42400], xmm7
	movaps	XMMWORD PTR [rsp+42384], xmm8
	movaps	XMMWORD PTR [rsp+42368], xmm9
	movaps	XMMWORD PTR [rsp+42352], xmm10
	movaps	XMMWORD PTR [rsp+42320], xmm12
	mov	QWORD PTR $T1[rsp], rbx
	npad	13
$LL439@kvz_rdoq:
	mov	QWORD PTR cost_coeffgroup_sig$[rbp+rax*8-256], rdx
	sub	rax, 1
	jns	SHORT $LL439@kvz_rdoq
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 348  :   if (pos_y < (uint32_t)width - 1) sigLower = (sig_coeff_group_flag[(pos_y  + 1 ) * width + pos_x] != 0);

	mov	edx, DWORD PTR width$[rbp-256]
	lea	rax, QWORD PTR last_y_bits$[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	mov	r8d, esi
	mov	rsi, QWORD PTR state$[rbp-256]
	lea	rax, QWORD PTR last_x_bits$[rbp-256]
	movzx	r9d, cl
	mov	QWORD PTR [rsp+32], rax
	mov	rcx, rsi
	call	calc_last_bits
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 824  :         sh_rates.quant_delta[blkpos] = (level_double - level * (1 << q_bits)) >> (q_bits - 8);

	movsd	xmm12, QWORD PTR __real@7fee42d130773b76
	lea	eax, DWORD PTR [rdi-8]
	mov	DWORD PTR tv8101[rbp-256], eax
	lea	ecx, DWORD PTR [rdi-1]
	mov	r8d, 1
	mov	edx, ebx
	mov	eax, r8d
	mov	QWORD PTR tv8128[rbp-256], rdx
	rol	eax, cl
	mov	r10d, edi
	mov	DWORD PTR $T2[rbp-256], eax
	mov	ecx, edi
	mov	eax, r8d
	mov	DWORD PTR cg_scanpos$1$[rsp], ebx
	rol	eax, cl
	mov	DWORD PTR tv8099[rbp-256], eax
	mov	QWORD PTR tv8147[rbp-256], rdx
	npad	3
$LL15@kvz_rdoq:

; 778  :     uint32_t cg_blkpos  = scan_cg[cg_scanpos];
; 779  :     uint32_t cg_pos_y   = cg_blkpos / num_blk_side;

	mov	rax, QWORD PTR scan_cg$1$[rbp-256]
	mov	r9d, DWORD PTR width$1$[rsp]
	mov	r11d, DWORD PTR [rax+rdx*4]
	xor	edx, edx
	mov	eax, r11d
	mov	DWORD PTR cg_blkpos$1$[rbp-256], r11d
	div	r9d

; 780  :     uint32_t cg_pos_x   = cg_blkpos - (cg_pos_y * num_blk_side);

	mov	ebx, r11d
	mov	ecx, eax
	mov	DWORD PTR cg_pos_y$1$[rbp-256], eax
	imul	ecx, r9d
	mov	edi, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 341  :   uint32_t sigRight = 0;

	xor	eax, eax
	mov	edx, eax

; 342  :   uint32_t sigLower = 0;

	mov	r8d, eax
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 780  :     uint32_t cg_pos_x   = cg_blkpos - (cg_pos_y * num_blk_side);

	sub	ebx, ecx
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 344  :   if (width == 4) return -1;

	cmp	DWORD PTR width$[rbp-256], 4
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 780  :     uint32_t cg_pos_x   = cg_blkpos - (cg_pos_y * num_blk_side);

	mov	DWORD PTR cg_pos_x$1$[rbp-256], ebx
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 344  :   if (width == 4) return -1;

	jne	SHORT $LN117@kvz_rdoq
	mov	DWORD PTR pattern_sig_ctx$1$[rbp-256], -1
	jmp	SHORT $LN116@kvz_rdoq
$LN117@kvz_rdoq:

; 345  : 
; 346  :   width >>= 2;
; 347  :   if (pos_x < (uint32_t)width - 1) sigRight = (sig_coeff_group_flag[pos_y * width + pos_x + 1] != 0);

	dec	r9d
	cmp	ebx, r9d
	jae	SHORT $LN372@kvz_rdoq
	lea	ecx, DWORD PTR [r11+1]
	cmp	DWORD PTR sig_coeffgroup_flag$[rbp+rcx*4-256], eax
	setne	dl
$LN372@kvz_rdoq:

; 348  :   if (pos_y < (uint32_t)width - 1) sigLower = (sig_coeff_group_flag[(pos_y  + 1 ) * width + pos_x] != 0);

	cmp	edi, r9d
	jae	SHORT $LN373@kvz_rdoq
	lea	eax, DWORD PTR [rdi+1]
	imul	eax, DWORD PTR width$1$[rsp]
	add	eax, ebx
	cmp	DWORD PTR sig_coeffgroup_flag$[rbp+rax*4-256], r8d
	setne	r8b
$LN373@kvz_rdoq:

; 349  : 
; 350  :   return sigRight + (sigLower<<1);

	lea	eax, DWORD PTR [rdx+r8*2]
	mov	DWORD PTR pattern_sig_ctx$1$[rbp-256], eax
$LN116@kvz_rdoq:
	mov	edi, DWORD PTR cg_scanpos$1$[rsp]
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 785  :     FILL(rd_stats, 0);

	xor	eax, eax
	xorps	xmm0, xmm0
	shl	edi, 4
	movups	XMMWORD PTR rd_stats$[rbp-256], xmm0
	mov	r9d, 15
	mov	DWORD PTR tv8098[rbp-256], edi
	movsd	xmm9, QWORD PTR rd_stats$[rbp-248]
	movsd	xmm10, QWORD PTR rd_stats$[rbp-256]
	movups	XMMWORD PTR rd_stats$[rbp-240], xmm0
	mov	QWORD PTR rd_stats$[rbp-224], rax
	movsd	xmm8, QWORD PTR rd_stats$[rbp-232]
	movsd	xmm7, QWORD PTR rd_stats$[rbp-240]
	mov	DWORD PTR scanpos_in_cg$1$[rbp-256], r9d
	mov	DWORD PTR rd_stats$5$[rsp], eax
	npad	9
$LL18@kvz_rdoq:

; 787  :       int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;

	add	r9d, edi

; 788  :       if (scanpos > last_scanpos) continue;

	cmp	r9d, r15d
	jg	$LN459@kvz_rdoq

; 789  :       uint32_t blkpos         = scan[scanpos];
; 790  :       int32_t q               = quant_coeff[blkpos];
; 791  :       double temp             = err_scale[blkpos];

	mov	rax, QWORD PTR err_scale$1$[rbp-256]

; 792  :       int32_t level_double    = coef[blkpos];
; 793  :       level_double            = MIN(abs(level_double) * q , MAX_INT - (1 << (q_bits - 1)));

	mov	ecx, 2147483647				; 7fffffffH
	movsxd	rdi, r9d
	mov	QWORD PTR tv8097[rsp], rdi
	mov	r8d, DWORD PTR [r12+rdi*4]

; 794  :       uint32_t max_abs_level  = (level_double + (1 << (q_bits - 1))) >> q_bits;
; 795  : 
; 796  :       double err              = (double)level_double;
; 797  :       cost_coeff0[scanpos]    = err * err * temp; 
; 798  :       block_uncoded_cost      += cost_coeff0[ scanpos ];
; 799  :       //===== coefficient level estimation =====
; 800  :       int32_t  level;
; 801  :       uint16_t  one_ctx = 4 * ctx_set + c1;
; 802  :       uint16_t  abs_ctx = ctx_set + c2;

	movzx	r12d, WORD PTR tv9194[rsp]
	mov	QWORD PTR tv8096[rbp-256], r8
	movsd	xmm5, QWORD PTR [rax+r8*8]
	mov	rax, QWORD PTR coef$[rbp-256]
	movsx	eax, WORD PTR [rax+r8*2]
	cdq
	mov	esi, eax
	mov	rax, QWORD PTR quant_coeff$1$[rbp-256]
	xor	esi, edx
	sub	esi, edx
	imul	esi, DWORD PTR [rax+r8*4]
	mov	eax, DWORD PTR $T2[rbp-256]
	sub	ecx, eax
	cmp	esi, ecx
	cmovge	esi, ecx
	shl	r14w, 2
	add	r14w, WORD PTR tv9196[rsp]
	mov	ecx, r10d
	lea	ebx, DWORD PTR [rsi+rax]
	movd	xmm6, esi
	mov	eax, DWORD PTR tv9210[rsp]
	add	r12w, ax
	cvtdq2pd xmm6, xmm6
	sar	ebx, cl
	mulsd	xmm6, xmm6
	mulsd	xmm6, xmm5
	movsd	QWORD PTR cost_coeff0$[rbp+rdi*8-256], xmm6
	addsd	xmm13, xmm6

; 803  : 
; 804  :       if( scanpos == last_scanpos ) {

	cmp	r9d, r15d
	jne	$LN43@kvz_rdoq

; 430  :   uint32_t best_abs_level = 0;

	xor	eax, eax

; 445  :   }
; 446  : 
; 447  :   min_abs_level    = ( max_abs_level > 1 ? max_abs_level - 1 : 1 );
; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	lea	r11d, DWORD PTR [rbx-1]
	cmp	ebx, 1
	mov	r15d, eax
	mov	rax, 9218378953502702454		; 7fee42d130773b76H
	movaps	xmm4, xmm12
	mov	QWORD PTR cost_coeff$[rbp+rdi*8-256], rax
	mov	edi, 1
	cmovbe	r11d, edi
	cmp	ebx, r11d
	jl	$LN123@kvz_rdoq

; 450  :     double cur_cost  = err * err * temp + state->lambda *

	mov	rcx, QWORD PTR state$[rbp-256]

; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);

	mov	r9d, 322				; 00000142H
	movzx	edx, BYTE PTR type$[rbp-256]
	mov	eax, 306				; 00000132H

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	movzx	r8d, WORD PTR tv9198[rsp]
	test	dl, dl
	mov	r10d, 330				; 0000014aH

; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	mov	edx, 334				; 0000014eH

; 450  :     double cur_cost  = err * err * temp + state->lambda *

	movsd	xmm2, QWORD PTR [rcx+368]
	cmovne	eax, r9d
	cmovne	r10d, edx
	add	r10, rcx
	lea	r9, QWORD PTR [rax+rcx]

; 445  :   }
; 446  : 
; 447  :   min_abs_level    = ( max_abs_level > 1 ? max_abs_level - 1 : 1 );
; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	jmp	SHORT $LN124@kvz_rdoq
	npad	14
$LL464@kvz_rdoq:
	mov	edi, 1
$LN124@kvz_rdoq:

; 449  :     double err       = (double)(level_double - ( abs_level * (1 << q_bits) ) );

	mov	ecx, DWORD PTR q_bits$1$[rsp]
	mov	edx, ebx
	shl	edx, cl
	mov	eax, esi
	sub	eax, edx

; 367  :   int32_t rate = 1 << CTX_FRAC_BITS;

	mov	edx, 32768				; 00008000H
	movd	xmm1, eax

; 449  :     double err       = (double)(level_double - ( abs_level * (1 << q_bits) ) );

	cvtdq2pd xmm1, xmm1

; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	cmp	r13d, 8
	jae	SHORT $LN148@kvz_rdoq
	mov	edi, DWORD PTR c2_idx$1$[rsp]
	xor	eax, eax
	cmp	edi, 1
	mov	ecx, eax
	setb	cl
	add	ecx, 2
	jmp	SHORT $LN149@kvz_rdoq
$LN148@kvz_rdoq:
	mov	ecx, edi
	mov	edi, DWORD PTR c2_idx$1$[rsp]
$LN149@kvz_rdoq:

; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	cmp	ebx, ecx
	jb	$LN138@kvz_rdoq

; 373  :     int32_t symbol     = abs_level - base_level;

	mov	eax, ebx

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	mov	edx, 3
	sub	eax, ecx
	mov	ecx, r8d
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LN140@kvz_rdoq

; 376  :       length = symbol>>abs_go_rice;

	sar	eax, cl

; 377  :       rate += (length+1+abs_go_rice) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [r8+2]
	add	edx, eax

; 378  :     } else {

	jmp	SHORT $LN486@kvz_rdoq
$LN140@kvz_rdoq:

; 379  :       length = abs_go_rice;
; 380  :       symbol  = symbol - ( COEF_REMAIN_BIN_REDUCTION << abs_go_rice);

	sub	eax, edx

; 381  :       while (symbol >= (1<<length)) {

	mov	edx, 1
	shl	edx, cl
	cmp	eax, edx
	jl	SHORT $LN137@kvz_rdoq
	npad	2
$LL136@kvz_rdoq:

; 382  :         symbol -=  (1<<(length++));

	sub	eax, edx
	inc	ecx
	mov	edx, 1
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LL136@kvz_rdoq
$LN137@kvz_rdoq:

; 383  :       }
; 384  :       rate += (COEF_REMAIN_BIN_REDUCTION+length+1-abs_go_rice+length) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [rcx+rcx]
	sub	edx, r8d
	add	edx, 5
$LN486@kvz_rdoq:

; 385  :     }
; 386  :     if (c1_idx < C1FLAG_NUMBER) {

	shl	edx, 15
	cmp	r13d, 8
	jae	$LN146@kvz_rdoq

; 387  :       rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r9]
	lea	rax, OFFSET FLAT:__ImageBase
	xor	rcx, 1
	add	edx, DWORD PTR kvz_entropy_bits[rax+rcx*4]

; 388  : 
; 389  :       if (c2_idx < C2FLAG_NUMBER) {

	cmp	edi, 1
	jae	SHORT $LN146@kvz_rdoq

; 390  :         rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],1);

	movzx	eax, r12w
	movzx	ecx, BYTE PTR [rax+r10]
	lea	rax, OFFSET FLAT:__ImageBase
	xor	rcx, 1
	add	edx, DWORD PTR kvz_entropy_bits[rax+rcx*4]

; 391  :       }
; 392  :     }
; 393  :   }

	jmp	SHORT $LN146@kvz_rdoq
$LN138@kvz_rdoq:

; 394  :   else if( abs_level == 1 ) {

	cmp	ebx, 1
	jne	SHORT $LN144@kvz_rdoq

; 395  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],0);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r9]
	lea	rax, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR kvz_entropy_bits[rax+rcx*4]
	add	edx, 32768				; 00008000H
	jmp	SHORT $LN146@kvz_rdoq
$LN144@kvz_rdoq:

; 396  :   } else if( abs_level == 2 ) {

	cmp	ebx, 2
	jne	SHORT $LN146@kvz_rdoq

; 397  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r9]

; 398  :     rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],0);

	movzx	eax, r12w
	xor	rcx, 1
	movzx	edx, BYTE PTR [rax+r10]
	lea	rax, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR kvz_entropy_bits[rax+rcx*4]
	mov	edx, DWORD PTR kvz_entropy_bits[rax+rdx*4]
	add	edx, 32768				; 00008000H
	add	edx, ecx
$LN146@kvz_rdoq:

; 455  :     if( cur_cost < *coded_cost ) {

	mov	rdi, QWORD PTR tv8097[rsp]
	mulsd	xmm1, xmm1
	movd	xmm0, edx

; 450  :     double cur_cost  = err * err * temp + state->lambda *

	cvtdq2pd xmm0, xmm0
	mulsd	xmm1, xmm5
	mulsd	xmm0, xmm2
	addsd	xmm1, xmm0

; 454  : 
; 455  :     if( cur_cost < *coded_cost ) {

	comisd	xmm1, xmm4
	jae	SHORT $LN122@kvz_rdoq

; 456  :       best_abs_level  = abs_level;
; 457  :       *coded_cost     = cur_cost;
; 458  :       *coded_cost_sig = cur_cost_sig;

	xor	eax, eax
	mov	r15d, ebx
	mov	QWORD PTR cost_sig$[rbp+rdi*8-256], rax
	movaps	xmm4, xmm1
$LN122@kvz_rdoq:

; 445  :   }
; 446  : 
; 447  :   min_abs_level    = ( max_abs_level > 1 ? max_abs_level - 1 : 1 );
; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	dec	ebx
	cmp	ebx, r11d
	jge	$LL464@kvz_rdoq
	movsd	QWORD PTR cost_coeff$[rbp+rdi*8-256], xmm4
$LN123@kvz_rdoq:

; 805  :         level            = kvz_get_coded_level(state, &cost_coeff[ scanpos ], &cost_coeff0[ scanpos ], &cost_sig[ scanpos ],

	mov	rax, QWORD PTR encoder$1$[rbp-256]
	mov	eax, DWORD PTR [rax+52]

; 820  :         }
; 821  :       }
; 822  : 
; 823  :       if (encoder->cfg.signhide_enable) {

	test	eax, eax
	je	$LN453@kvz_rdoq
	mov	rdx, QWORD PTR tv8096[rbp-256]
	lea	r9, OFFSET FLAT:__ImageBase
$LN376@kvz_rdoq:

; 824  :         sh_rates.quant_delta[blkpos] = (level_double - level * (1 << q_bits)) >> (q_bits - 8);

	mov	ecx, DWORD PTR tv8101[rbp-256]
	mov	eax, r15d
	imul	eax, DWORD PTR tv8099[rbp-256]
	sub	esi, eax
	sar	esi, cl
	mov	DWORD PTR sh_rates$[rbp+rdx*4+12032], esi

; 825  :         if (level > 0) {

	test	r15d, r15d
	jle	$LN47@kvz_rdoq

; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	mov	edi, DWORD PTR c2_idx$1$[rsp]
	mov	r10d, 32768				; 00008000H
	cmp	r13d, 8
	jae	$LN200@kvz_rdoq
	xor	eax, eax
	cmp	edi, 1
	mov	ecx, eax
	setb	cl
	add	ecx, 2
	jmp	$LN201@kvz_rdoq
$LN43@kvz_rdoq:

; 806  :                                              level_double, max_abs_level, 0, one_ctx, abs_ctx, go_rice_param,
; 807  :                                              c1_idx, c2_idx, q_bits, temp, 1, type );
; 808  :       } else {
; 809  :         uint32_t  pos_y    = blkpos >> log2_block_size;

	mov	ecx, DWORD PTR log2_block_size$1$[rbp-256]
	mov	r9d, r8d

; 810  :         uint32_t  pos_x    = blkpos - ( pos_y << log2_block_size );
; 811  :         uint16_t  ctx_sig  = (uint16_t)kvz_context_get_sig_ctx_inc(pattern_sig_ctx, scan_mode, pos_x, pos_y,

	movsx	edx, BYTE PTR scan_mode$[rbp-256]
	shr	r9d, cl
	mov	eax, r9d
	shl	eax, cl
	sub	r8d, eax
	movzx	eax, BYTE PTR type$[rbp-256]
	mov	BYTE PTR [rsp+40], al
	mov	DWORD PTR [rsp+32], ecx
	mov	ecx, DWORD PTR pattern_sig_ctx$1$[rbp-256]
	call	kvz_context_get_sig_ctx_inc

; 435  :   if( !last && max_abs_level < 3 ) {

	mov	r10, QWORD PTR state$[rbp-256]
	lea	r9, OFFSET FLAT:__ImageBase
	xor	r8d, r8d
	mov	edx, 204				; 000000ccH
	cmp	BYTE PTR type$[rbp-256], r8b
	mov	ecx, 231				; 000000e7H
	mov	r15d, r8d
	movsd	xmm3, QWORD PTR [r10+368]
	cmove	ecx, edx
	lea	rdx, QWORD PTR [rcx+r10]
	cmp	ebx, 3
	jae	SHORT $LN158@kvz_rdoq

; 436  :     *coded_cost_sig = state->lambda * CTX_ENTROPY_BITS(&base_sig_model[ctx_num_sig], 0);

	mov	rcx, QWORD PTR tv8097[rsp]
	xorps	xmm4, xmm4
	movzx	edi, ax
	movzx	eax, BYTE PTR [rdi+rdx]
	mov	eax, DWORD PTR kvz_entropy_bits[r9+rax*4]
	cvtsi2sd xmm4, rax
	mulsd	xmm4, xmm3
	movsd	QWORD PTR cost_sig$[rbp+rcx*8-256], xmm4

; 437  :     *coded_cost     = *coded_cost0 + *coded_cost_sig;

	addsd	xmm4, xmm6
	movsd	QWORD PTR cost_coeff$[rbp+rcx*8-256], xmm4

; 438  :     if (max_abs_level == 0) return best_abs_level;

	test	ebx, ebx
	je	$LN156@kvz_rdoq

; 439  :   } else {

	movaps	xmm0, xmm4
	jmp	SHORT $LN487@kvz_rdoq
$LN158@kvz_rdoq:

; 440  :     *coded_cost = MAX_DOUBLE;

	mov	rcx, 9218378953502702454		; 7fee42d130773b76H
	movaps	xmm0, xmm12
	mov	QWORD PTR cost_coeff$[rbp+rdi*8-256], rcx
	movaps	xmm4, xmm12
	movzx	edi, ax
$LN487@kvz_rdoq:

; 441  :   }
; 442  : 
; 443  :   if( !last ) {
; 444  :     cur_cost_sig = state->lambda * CTX_ENTROPY_BITS(&base_sig_model[ctx_num_sig], 1);

	movzx	eax, BYTE PTR [rdx+rdi]

; 445  :   }
; 446  : 
; 447  :   min_abs_level    = ( max_abs_level > 1 ? max_abs_level - 1 : 1 );
; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	lea	r11d, DWORD PTR [rbx-1]
	xor	rax, 1
	mov	QWORD PTR $T3[rbp-256], rdi
	xorps	xmm2, xmm2
	cmp	ebx, 1
	mov	eax, DWORD PTR kvz_entropy_bits[r9+rax*4]
	cvtsi2sd xmm2, rax
	mov	eax, 1
	cmovbe	r11d, eax
	mulsd	xmm2, xmm3
	cmp	ebx, r11d
	jl	$LN156@kvz_rdoq

; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);

	movzx	ecx, BYTE PTR type$[rbp-256]
	mov	r9d, 306				; 00000132H

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	movzx	r8d, WORD PTR tv9198[rsp]
	test	cl, cl
	mov	edi, DWORD PTR c2_idx$1$[rsp]

; 369  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);
; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);

	mov	edx, 322				; 00000142H
	cmovne	r9d, edx
	mov	eax, 330				; 0000014aH
	add	r9, r10

; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	movaps	xmm4, xmm0

; 372  :   if ( abs_level >= base_level ) {

	test	cl, cl
	mov	ecx, 334				; 0000014eH
	cmovne	eax, ecx
	add	r10, rax
	npad	1
$LL157@kvz_rdoq:

; 449  :     double err       = (double)(level_double - ( abs_level * (1 << q_bits) ) );

	mov	ecx, DWORD PTR q_bits$1$[rsp]
	mov	edx, ebx
	shl	edx, cl
	mov	eax, esi
	sub	eax, edx

; 367  :   int32_t rate = 1 << CTX_FRAC_BITS;

	mov	edx, 32768				; 00008000H
	movd	xmm1, eax

; 449  :     double err       = (double)(level_double - ( abs_level * (1 << q_bits) ) );

	cvtdq2pd xmm1, xmm1

; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	cmp	r13d, 8
	jae	SHORT $LN181@kvz_rdoq
	xor	eax, eax
	cmp	edi, 1
	mov	ecx, eax
	setb	cl
	add	ecx, 2
	jmp	SHORT $LN182@kvz_rdoq
$LN181@kvz_rdoq:
	mov	ecx, 1
$LN182@kvz_rdoq:

; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	cmp	ebx, ecx
	jb	$LN171@kvz_rdoq

; 373  :     int32_t symbol     = abs_level - base_level;

	mov	eax, ebx

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	mov	edx, 3
	sub	eax, ecx
	mov	ecx, r8d
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LN173@kvz_rdoq

; 376  :       length = symbol>>abs_go_rice;

	sar	eax, cl

; 377  :       rate += (length+1+abs_go_rice) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [r8+2]
	add	edx, eax

; 378  :     } else {

	jmp	SHORT $LN488@kvz_rdoq
$LN173@kvz_rdoq:

; 379  :       length = abs_go_rice;
; 380  :       symbol  = symbol - ( COEF_REMAIN_BIN_REDUCTION << abs_go_rice);

	sub	eax, edx

; 381  :       while (symbol >= (1<<length)) {

	mov	edx, 1
	shl	edx, cl
	cmp	eax, edx
	jl	SHORT $LN170@kvz_rdoq
	mov	edi, 1
	npad	7
$LL169@kvz_rdoq:

; 382  :         symbol -=  (1<<(length++));

	sub	eax, edx
	inc	ecx
	mov	edx, edi
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LL169@kvz_rdoq
	mov	edi, DWORD PTR c2_idx$1$[rsp]
$LN170@kvz_rdoq:

; 383  :       }
; 384  :       rate += (COEF_REMAIN_BIN_REDUCTION+length+1-abs_go_rice+length) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [rcx+rcx]
	sub	edx, r8d
	add	edx, 5
$LN488@kvz_rdoq:

; 385  :     }
; 386  :     if (c1_idx < C1FLAG_NUMBER) {

	shl	edx, 15
	cmp	r13d, 8
	jae	$LN179@kvz_rdoq

; 387  :       rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r9]
	lea	rax, OFFSET FLAT:__ImageBase
	xor	rcx, 1
	add	edx, DWORD PTR kvz_entropy_bits[rax+rcx*4]

; 388  : 
; 389  :       if (c2_idx < C2FLAG_NUMBER) {

	cmp	edi, 1
	jae	SHORT $LN179@kvz_rdoq

; 390  :         rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],1);

	movzx	eax, r12w
	movzx	ecx, BYTE PTR [rax+r10]
	lea	rax, OFFSET FLAT:__ImageBase
	xor	rcx, 1
	add	edx, DWORD PTR kvz_entropy_bits[rax+rcx*4]

; 391  :       }
; 392  :     }
; 393  :   }

	jmp	SHORT $LN179@kvz_rdoq
$LN171@kvz_rdoq:

; 394  :   else if( abs_level == 1 ) {

	cmp	ebx, 1
	jne	SHORT $LN177@kvz_rdoq

; 395  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],0);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r9]
	lea	rax, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR kvz_entropy_bits[rax+rcx*4]
	add	edx, 32768				; 00008000H
	jmp	SHORT $LN179@kvz_rdoq
$LN177@kvz_rdoq:

; 396  :   } else if( abs_level == 2 ) {

	cmp	ebx, 2
	jne	SHORT $LN179@kvz_rdoq

; 397  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r9]

; 398  :     rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],0);

	movzx	eax, r12w
	xor	rcx, 1
	movzx	edx, BYTE PTR [rax+r10]
	lea	rax, OFFSET FLAT:__ImageBase
	mov	ecx, DWORD PTR kvz_entropy_bits[rax+rcx*4]
	mov	edx, DWORD PTR kvz_entropy_bits[rax+rdx*4]
	add	edx, 32768				; 00008000H
	add	edx, ecx
$LN179@kvz_rdoq:

; 455  :     if( cur_cost < *coded_cost ) {

	mov	rcx, QWORD PTR tv8097[rsp]
	mulsd	xmm1, xmm1
	movd	xmm0, edx

; 450  :     double cur_cost  = err * err * temp + state->lambda *

	cvtdq2pd xmm0, xmm0
	mulsd	xmm1, xmm5
	mulsd	xmm0, xmm3
	addsd	xmm1, xmm0

; 451  :                        kvz_get_ic_rate( state, abs_level, ctx_num_one, ctx_num_abs,
; 452  :                                     abs_go_rice, c1_idx, c2_idx, type);
; 453  :     cur_cost        += cur_cost_sig;

	addsd	xmm1, xmm2

; 454  : 
; 455  :     if( cur_cost < *coded_cost ) {

	comisd	xmm1, xmm4
	jae	SHORT $LN155@kvz_rdoq

; 456  :       best_abs_level  = abs_level;
; 457  :       *coded_cost     = cur_cost;
; 458  :       *coded_cost_sig = cur_cost_sig;

	movsd	QWORD PTR cost_sig$[rbp+rcx*8-256], xmm2
	mov	r15d, ebx
	movaps	xmm4, xmm1
$LN155@kvz_rdoq:

; 445  :   }
; 446  : 
; 447  :   min_abs_level    = ( max_abs_level > 1 ? max_abs_level - 1 : 1 );
; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	dec	ebx
	cmp	ebx, r11d
	jge	$LL157@kvz_rdoq
	mov	rdi, QWORD PTR $T3[rbp-256]
	lea	r9, OFFSET FLAT:__ImageBase
	movsd	QWORD PTR cost_coeff$[rbp+rcx*8-256], xmm4
$LN156@kvz_rdoq:

; 812  :                                                      log2_block_size, type);
; 813  :         level              = kvz_get_coded_level(state, &cost_coeff[ scanpos ], &cost_coeff0[ scanpos ], &cost_sig[ scanpos ],
; 814  :                                              level_double, max_abs_level, ctx_sig, one_ctx, abs_ctx, go_rice_param,
; 815  :                                              c1_idx, c2_idx, q_bits, temp, 0, type );
; 816  :         if (encoder->cfg.signhide_enable) {

	mov	rax, QWORD PTR encoder$1$[rbp-256]
	mov	eax, DWORD PTR [rax+52]
	test	eax, eax
	je	$LN453@kvz_rdoq

; 817  :           int greater_than_zero = CTX_ENTROPY_BITS(&baseCtx[ctx_sig], 1);

	mov	rax, QWORD PTR tv8059[rbp-256]

; 818  :           int zero = CTX_ENTROPY_BITS(&baseCtx[ctx_sig], 0);
; 819  :           sh_rates.sig_coeff_inc[blkpos] = greater_than_zero - zero;

	mov	rdx, QWORD PTR tv8096[rbp-256]
	movzx	ecx, BYTE PTR [rdi+rax]
	mov	eax, ecx
	xor	rax, 1
	mov	eax, DWORD PTR kvz_entropy_bits[r9+rax*4]
	sub	eax, DWORD PTR kvz_entropy_bits[r9+rcx*4]
	mov	DWORD PTR sh_rates$[rbp+rdx*4+7936], eax
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 348  :   if (pos_y < (uint32_t)width - 1) sigLower = (sig_coeff_group_flag[(pos_y  + 1 ) * width + pos_x] != 0);

	jmp	$LN376@kvz_rdoq
$LN200@kvz_rdoq:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	mov	ecx, 1
$LN201@kvz_rdoq:

; 369  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);
; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);

	movzx	edx, BYTE PTR type$[rbp-256]
	mov	r11d, 306				; 00000132H
	mov	rsi, QWORD PTR state$[rbp-256]
	test	dl, dl
	mov	r8d, 322				; 00000142H

; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	mov	ebx, 330				; 0000014aH
	cmovne	r11d, r8d
	add	r11, rsi
	test	dl, dl
	mov	edx, 334				; 0000014eH
	cmovne	ebx, edx
	add	rbx, rsi
	cmp	r15d, ecx
	jb	$LN190@kvz_rdoq

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	mov	r9d, DWORD PTR tv9198[rsp]
	mov	edx, r15d
	sub	edx, ecx
	movzx	r8d, r9w
	mov	ecx, r8d
	mov	eax, 3
	shl	eax, cl
	cmp	edx, eax
	jge	SHORT $LN192@kvz_rdoq

; 376  :       length = symbol>>abs_go_rice;

	sar	edx, cl

; 377  :       rate += (length+1+abs_go_rice) * (1 << CTX_FRAC_BITS);

	lea	r10d, DWORD PTR [r8+2]
	add	r10d, edx

; 378  :     } else {

	jmp	SHORT $LN490@kvz_rdoq
$LN192@kvz_rdoq:

; 379  :       length = abs_go_rice;
; 380  :       symbol  = symbol - ( COEF_REMAIN_BIN_REDUCTION << abs_go_rice);

	sub	edx, eax

; 381  :       while (symbol >= (1<<length)) {

	mov	r10d, 1
	mov	eax, r10d
	shl	eax, cl
	cmp	edx, eax
	jl	SHORT $LN189@kvz_rdoq
	npad	4
$LL188@kvz_rdoq:

; 382  :         symbol -=  (1<<(length++));

	sub	edx, eax
	inc	ecx
	mov	eax, r10d
	shl	eax, cl
	cmp	edx, eax
	jge	SHORT $LL188@kvz_rdoq
$LN189@kvz_rdoq:

; 383  :       }
; 384  :       rate += (COEF_REMAIN_BIN_REDUCTION+length+1-abs_go_rice+length) * (1 << CTX_FRAC_BITS);

	lea	r10d, DWORD PTR [rcx+rcx]
	sub	r10d, r8d
	add	r10d, 5
$LN490@kvz_rdoq:

; 385  :     }
; 386  :     if (c1_idx < C1FLAG_NUMBER) {

	shl	r10d, 15
	cmp	r13d, 8
	jae	$LN198@kvz_rdoq

; 387  :       rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	ecx, BYTE PTR [rax+r11]
	xor	rcx, 1
	add	r10d, DWORD PTR kvz_entropy_bits[rdx+rcx*4]

; 388  : 
; 389  :       if (c2_idx < C2FLAG_NUMBER) {

	cmp	edi, 1
	jae	SHORT $LN198@kvz_rdoq

; 390  :         rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],1);

	movzx	eax, r12w
	movzx	ecx, BYTE PTR [rax+rbx]
	xor	rcx, 1
	add	r10d, DWORD PTR kvz_entropy_bits[rdx+rcx*4]

; 391  :       }
; 392  :     }
; 393  :   }

	jmp	SHORT $LN198@kvz_rdoq
$LN190@kvz_rdoq:

; 394  :   else if( abs_level == 1 ) {

	cmp	r15d, 1
	jne	SHORT $LN196@kvz_rdoq

; 395  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],0);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r11]
	mov	r10d, DWORD PTR kvz_entropy_bits[r9+rcx*4]
	add	r10d, 32768				; 00008000H
	jmp	SHORT $LN461@kvz_rdoq
$LN196@kvz_rdoq:

; 396  :   } else if( abs_level == 2 ) {

	cmp	r15d, 2
	jne	SHORT $LN461@kvz_rdoq

; 397  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r11]
	xor	rcx, 1

; 398  :     rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],0);

	movzx	eax, r12w
	movzx	edx, BYTE PTR [rax+rbx]
	mov	ecx, DWORD PTR kvz_entropy_bits[r9+rcx*4]
	mov	r10d, DWORD PTR kvz_entropy_bits[r9+rdx*4]
	add	r10d, 32768				; 00008000H
	add	r10d, ecx
$LN461@kvz_rdoq:

; 826  :           int32_t rate_now  = kvz_get_ic_rate(state, level, one_ctx, abs_ctx, go_rice_param, c1_idx, c2_idx, type);
; 827  :           int32_t rate_up   = kvz_get_ic_rate(state, level + 1, one_ctx, abs_ctx, go_rice_param, c1_idx, c2_idx, type);

	mov	r9d, DWORD PTR tv9198[rsp]
$LN198@kvz_rdoq:
	lea	eax, DWORD PTR [r15+1]

; 367  :   int32_t rate = 1 << CTX_FRAC_BITS;

	mov	r8d, 32768				; 00008000H

; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	cmp	r13d, 8
	jae	SHORT $LN219@kvz_rdoq
	xor	ecx, ecx
	cmp	edi, 1
	setb	cl
	add	ecx, 2
	jmp	SHORT $LN220@kvz_rdoq
$LN219@kvz_rdoq:
	mov	ecx, 1
$LN220@kvz_rdoq:

; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	cmp	eax, ecx
	jb	$LN209@kvz_rdoq

; 373  :     int32_t symbol     = abs_level - base_level;

	sub	eax, ecx

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	movzx	r9d, r9w
	mov	ecx, r9d
	mov	edx, 3
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LN211@kvz_rdoq

; 376  :       length = symbol>>abs_go_rice;

	sar	eax, cl

; 377  :       rate += (length+1+abs_go_rice) * (1 << CTX_FRAC_BITS);

	lea	r8d, DWORD PTR [r9+2]
	add	r8d, eax

; 378  :     } else {

	jmp	SHORT $LN491@kvz_rdoq
$LN211@kvz_rdoq:

; 379  :       length = abs_go_rice;
; 380  :       symbol  = symbol - ( COEF_REMAIN_BIN_REDUCTION << abs_go_rice);

	sub	eax, edx

; 381  :       while (symbol >= (1<<length)) {

	mov	r8d, 1
	mov	edx, r8d
	shl	edx, cl
	cmp	eax, edx
	jl	SHORT $LN208@kvz_rdoq
$LL207@kvz_rdoq:

; 382  :         symbol -=  (1<<(length++));

	sub	eax, edx
	inc	ecx
	mov	edx, r8d
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LL207@kvz_rdoq
$LN208@kvz_rdoq:

; 383  :       }
; 384  :       rate += (COEF_REMAIN_BIN_REDUCTION+length+1-abs_go_rice+length) * (1 << CTX_FRAC_BITS);

	lea	r8d, DWORD PTR [rcx+rcx]
	sub	r8d, r9d
	add	r8d, 5
$LN491@kvz_rdoq:

; 385  :     }
; 386  :     if (c1_idx < C1FLAG_NUMBER) {

	shl	r8d, 15
	lea	r9, OFFSET FLAT:__ImageBase
	cmp	r13d, 8
	jae	$LN217@kvz_rdoq

; 387  :       rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r11]
	xor	rcx, 1
	add	r8d, DWORD PTR kvz_entropy_bits[r9+rcx*4]

; 388  : 
; 389  :       if (c2_idx < C2FLAG_NUMBER) {

	cmp	edi, 1
	jae	SHORT $LN217@kvz_rdoq

; 390  :         rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],1);

	movzx	eax, r12w
	movzx	ecx, BYTE PTR [rax+rbx]
	xor	rcx, 1
	add	r8d, DWORD PTR kvz_entropy_bits[r9+rcx*4]

; 391  :       }
; 392  :     }
; 393  :   }

	jmp	SHORT $LN217@kvz_rdoq
$LN209@kvz_rdoq:

; 394  :   else if( abs_level == 1 ) {

	lea	r9, OFFSET FLAT:__ImageBase
	cmp	eax, 1
	jne	SHORT $LN215@kvz_rdoq

; 395  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],0);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r11]
	mov	r8d, DWORD PTR kvz_entropy_bits[r9+rcx*4]
	add	r8d, 32768				; 00008000H
	jmp	SHORT $LN217@kvz_rdoq
$LN215@kvz_rdoq:

; 396  :   } else if( abs_level == 2 ) {

	cmp	eax, 2
	jne	SHORT $LN217@kvz_rdoq

; 397  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r11]
	xor	rcx, 1

; 398  :     rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],0);

	movzx	eax, r12w
	movzx	edx, BYTE PTR [rax+rbx]
	mov	ecx, DWORD PTR kvz_entropy_bits[r9+rcx*4]
	mov	r8d, DWORD PTR kvz_entropy_bits[r9+rdx*4]
	add	r8d, 32768				; 00008000H
	add	r8d, ecx
$LN217@kvz_rdoq:

; 828  :           int32_t rate_down = kvz_get_ic_rate(state, level - 1, one_ctx, abs_ctx, go_rice_param, c1_idx, c2_idx, type);

	lea	eax, DWORD PTR [r15-1]

; 367  :   int32_t rate = 1 << CTX_FRAC_BITS;

	mov	edx, 32768				; 00008000H

; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	cmp	r13d, 8
	jae	SHORT $LN238@kvz_rdoq
	xor	ecx, ecx
	cmp	edi, 1
	setb	cl
	add	ecx, 2
	jmp	SHORT $LN239@kvz_rdoq
$LN238@kvz_rdoq:
	mov	ecx, 1
$LN239@kvz_rdoq:

; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	cmp	eax, ecx
	jb	$LN228@kvz_rdoq

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	movzx	r9d, WORD PTR tv9198[rsp]
	sub	eax, ecx
	mov	ecx, r9d
	mov	edx, 3
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LN230@kvz_rdoq

; 376  :       length = symbol>>abs_go_rice;

	sar	eax, cl

; 377  :       rate += (length+1+abs_go_rice) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [r9+2]
	add	edx, eax

; 378  :     } else {

	jmp	SHORT $LN492@kvz_rdoq
$LN230@kvz_rdoq:

; 379  :       length = abs_go_rice;
; 380  :       symbol  = symbol - ( COEF_REMAIN_BIN_REDUCTION << abs_go_rice);

	sub	eax, edx

; 381  :       while (symbol >= (1<<length)) {

	mov	edx, 1
	shl	edx, cl
	cmp	eax, edx
	jl	SHORT $LN227@kvz_rdoq
	mov	esi, 1
$LL226@kvz_rdoq:

; 382  :         symbol -=  (1<<(length++));

	sub	eax, edx
	inc	ecx
	mov	edx, esi
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LL226@kvz_rdoq
	mov	rsi, QWORD PTR state$[rbp-256]
$LN227@kvz_rdoq:

; 383  :       }
; 384  :       rate += (COEF_REMAIN_BIN_REDUCTION+length+1-abs_go_rice+length) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [rcx+rcx]
	sub	edx, r9d
	add	edx, 5
$LN492@kvz_rdoq:

; 385  :     }
; 386  :     if (c1_idx < C1FLAG_NUMBER) {

	shl	edx, 15
	cmp	r13d, 8
	jae	$LN236@kvz_rdoq

; 387  :       rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	lea	r9, OFFSET FLAT:__ImageBase
	movzx	ecx, BYTE PTR [rax+r11]
	xor	rcx, 1
	add	edx, DWORD PTR kvz_entropy_bits[r9+rcx*4]

; 388  : 
; 389  :       if (c2_idx < C2FLAG_NUMBER) {

	cmp	edi, 1
	jae	SHORT $LN236@kvz_rdoq

; 390  :         rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],1);

	movzx	eax, r12w
	movzx	ecx, BYTE PTR [rax+rbx]
	xor	rcx, 1
	add	edx, DWORD PTR kvz_entropy_bits[r9+rcx*4]

; 391  :       }
; 392  :     }
; 393  :   }

	jmp	SHORT $LN236@kvz_rdoq
$LN228@kvz_rdoq:

; 394  :   else if( abs_level == 1 ) {

	cmp	eax, 1
	jne	SHORT $LN234@kvz_rdoq

; 395  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],0);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r11]
	mov	edx, DWORD PTR kvz_entropy_bits[r9+rcx*4]
	add	edx, 32768				; 00008000H
	jmp	SHORT $LN236@kvz_rdoq
$LN234@kvz_rdoq:

; 396  :   } else if( abs_level == 2 ) {

	cmp	eax, 2
	jne	SHORT $LN236@kvz_rdoq

; 397  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+r11]
	xor	rcx, 1

; 398  :     rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],0);

	movzx	eax, r12w
	movzx	edx, BYTE PTR [rax+rbx]
	mov	ecx, DWORD PTR kvz_entropy_bits[r9+rcx*4]
	mov	edx, DWORD PTR kvz_entropy_bits[r9+rdx*4]
	add	edx, 32768				; 00008000H
	add	edx, ecx
$LN236@kvz_rdoq:

; 829  :           sh_rates.inc[blkpos] = rate_up - rate_now;

	mov	rax, QWORD PTR tv8096[rbp-256]
	sub	r8d, r10d

; 830  :           sh_rates.dec[blkpos] = rate_down - rate_now;

	sub	edx, r10d
	mov	DWORD PTR sh_rates$[rbp+rax*4-256], r8d
	mov	DWORD PTR sh_rates$[rbp+rax*4+3840], edx
	mov	rdx, QWORD PTR tv8097[rsp]
	movsd	xmm4, QWORD PTR cost_coeff$[rbp+rdx*8-256]

; 831  :         } else { // level == 0

	jmp	SHORT $LN48@kvz_rdoq
$LN47@kvz_rdoq:

; 832  :           sh_rates.inc[blkpos]   = CTX_ENTROPY_BITS(&base_one_ctx[one_ctx], 0);

	mov	rcx, QWORD PTR tv8057[rbp-256]
	movzx	eax, r14w
	movzx	ecx, BYTE PTR [rax+rcx]
	mov	eax, DWORD PTR kvz_entropy_bits[r9+rcx*4]
	mov	DWORD PTR sh_rates$[rbp+rdx*4-256], eax
$LN453@kvz_rdoq:

; 833  :         }
; 834  :       }
; 835  :       dest_coeff[blkpos] = (coeff_t)level;

	mov	rsi, QWORD PTR state$[rbp-256]
	mov	rax, QWORD PTR tv8096[rbp-256]
	mov	rdx, QWORD PTR tv8097[rsp]
$LN48@kvz_rdoq:
	mov	rcx, QWORD PTR dest_coeff$[rbp-256]

; 836  :       base_cost         += cost_coeff[scanpos];

	addsd	xmm11, xmm4

; 837  : 
; 838  :       base_level = (c1_idx < C1FLAG_NUMBER) ? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	mov	r14d, DWORD PTR c2_idx$1$[rsp]
	xor	r11d, r11d
	mov	WORD PTR [rcx+rax*2], r15w
	lea	ebx, QWORD PTR [r11+1]
	cmp	r13d, 8
	jae	SHORT $LN90@kvz_rdoq
	cmp	r14d, ebx
	mov	eax, r11d
	setb	al
	add	eax, 2
	jmp	SHORT $LN91@kvz_rdoq
$LN90@kvz_rdoq:
	mov	eax, ebx
$LN91@kvz_rdoq:

; 839  :       if (level >= base_level) {

	cmp	r15d, eax
	jl	SHORT $LN93@kvz_rdoq

; 840  :         if(level  > 3*(1<<go_rice_param)) {

	mov	r8d, DWORD PTR tv9198[rsp]
	mov	eax, 3
	movzx	ecx, r8w
	shl	eax, cl
	cmp	r15d, eax
	jle	SHORT $LN93@kvz_rdoq

; 841  :           go_rice_param = MIN(go_rice_param + 1, 4);

	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, 4
	jae	SHORT $LN92@kvz_rdoq
	inc	r8w
	mov	DWORD PTR tv9198[rsp], r8d
	jmp	SHORT $LN93@kvz_rdoq
$LN92@kvz_rdoq:
	mov	DWORD PTR tv9198[rsp], 4
$LN93@kvz_rdoq:

; 842  :         }
; 843  :       }
; 844  :       if (level >= 1) c1_idx ++;
; 845  : 
; 846  :       //===== update bin model =====
; 847  :       if (level > 1) {

	lea	eax, DWORD PTR [r13+1]
	cmp	r15d, 1
	cmovl	eax, r13d
	mov	r13d, eax
	jle	SHORT $LN52@kvz_rdoq

; 848  :         c1 = 0;
; 849  :         c2 += (c2 < 2);

	mov	r10d, DWORD PTR tv9194[rsp]
	mov	eax, r11d
	cmp	r10w, 2
	mov	DWORD PTR tv9196[rsp], r11d
	mov	r8d, r11d
	setl	al
	add	r10w, ax

; 850  :         c2_idx ++;

	inc	r14d
	mov	DWORD PTR tv9194[rsp], r10d
	mov	DWORD PTR c2_idx$1$[rsp], r14d
	jmp	SHORT $LN54@kvz_rdoq
$LN52@kvz_rdoq:

; 851  :       } else if( (c1 < 3) && (c1 > 0) && level) {

	mov	r8d, DWORD PTR tv9196[rsp]
	lea	eax, DWORD PTR [r8-1]
	cmp	ax, 1
	ja	SHORT $LN54@kvz_rdoq
	test	r15d, r15d
	je	SHORT $LN54@kvz_rdoq

; 852  :         c1++;

	inc	r8w
	mov	DWORD PTR tv9196[rsp], r8d
$LN54@kvz_rdoq:

; 853  :       }
; 854  : 
; 855  :       //===== context set update =====
; 856  :       if ((scanpos % SCAN_SET_SIZE == 0) && scanpos > 0) {

	mov	r9d, DWORD PTR scanpos_in_cg$1$[rbp-256]
	mov	edi, DWORD PTR tv8098[rbp-256]
	lea	ecx, DWORD PTR [r9+rdi]
	mov	eax, ecx
	and	eax, -2147483633			; ffffffff8000000fH
	jge	SHORT $LN410@kvz_rdoq
	dec	eax
	or	eax, -16
	inc	eax
$LN410@kvz_rdoq:
	test	eax, eax
	jne	SHORT $LN55@kvz_rdoq
	test	ecx, ecx
	jle	SHORT $LN55@kvz_rdoq

; 857  :         c2                = 0;

	mov	DWORD PTR tv9194[rsp], r11d

; 858  :         go_rice_param     = 0;
; 859  : 
; 860  :         c1_idx   = 0;

	mov	r13d, r11d
	mov	WORD PTR tv9198[rsp], r11w

; 861  :         c2_idx   = 0;

	mov	DWORD PTR c2_idx$1$[rsp], r11d

; 862  :         ctx_set = (scanpos == SCAN_SET_SIZE || type != 0) ? 0 : 2;

	cmp	ecx, 16
	je	SHORT $LN94@kvz_rdoq
	cmp	BYTE PTR type$[rbp-256], al
	jne	SHORT $LN94@kvz_rdoq
	mov	eax, 2
	movzx	ecx, ax
	jmp	SHORT $LN95@kvz_rdoq
$LN94@kvz_rdoq:
	mov	ecx, r11d
$LN95@kvz_rdoq:

; 863  :         if( c1 == 0 ) {
; 864  :           ctx_set++;
; 865  :         }
; 866  :         c1 = 1;

	lea	eax, DWORD PTR [rcx+1]
	mov	WORD PTR tv9196[rsp], bx
	test	r8w, r8w
	cmovne	ax, cx
	mov	DWORD PTR tv9210[rsp], eax
$LN55@kvz_rdoq:

; 867  :       }
; 868  : 
; 869  :       rd_stats.sig_cost += cost_sig[scanpos];

	movsd	xmm0, QWORD PTR cost_sig$[rbp+rdx*8-256]
	addsd	xmm7, xmm0

; 870  :       if ( scanpos_in_cg == 0 ) {

	test	r9d, r9d
	jne	SHORT $LN57@kvz_rdoq

; 871  :         rd_stats.sig_cost_0 = cost_sig[scanpos];

	movaps	xmm8, xmm0
$LN57@kvz_rdoq:

; 872  :       }
; 873  :       if ( dest_coeff[blkpos] )  {

	mov	eax, DWORD PTR rd_stats$5$[rsp]
	test	r15w, r15w
	mov	r15d, DWORD PTR scanpos$1$[rsp]
	mov	r12, QWORD PTR scan$1$[rbp-256]
	mov	r10d, DWORD PTR q_bits$1$[rsp]
	je	SHORT $LN457@kvz_rdoq

; 874  :         sig_coeffgroup_flag[cg_blkpos] = 1;

	mov	r11d, DWORD PTR cg_blkpos$1$[rbp-256]

; 875  :         rd_stats.coded_level_and_dist   += cost_coeff[scanpos] - cost_sig[scanpos];

	subsd	xmm4, xmm0

; 876  :         rd_stats.uncoded_dist           += cost_coeff0[scanpos];

	addsd	xmm9, xmm6
	mov	DWORD PTR sig_coeffgroup_flag$[rbp+r11*4-256], ebx
	addsd	xmm10, xmm4

; 877  :         if ( scanpos_in_cg != 0 ) {

	test	r9d, r9d
	je	SHORT $LN16@kvz_rdoq

; 878  :           rd_stats.nnz_before_pos0++;

	inc	eax
	mov	DWORD PTR rd_stats$5$[rsp], eax
	jmp	SHORT $LN16@kvz_rdoq
$LN457@kvz_rdoq:

; 872  :       }
; 873  :       if ( dest_coeff[blkpos] )  {

	mov	r11d, DWORD PTR cg_blkpos$1$[rbp-256]
	jmp	SHORT $LN16@kvz_rdoq
$LN459@kvz_rdoq:

; 788  :       if (scanpos > last_scanpos) continue;

	mov	r9d, DWORD PTR scanpos_in_cg$1$[rbp-256]
$LN16@kvz_rdoq:

; 786  :     for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--)  {

	mov	r14d, DWORD PTR tv9210[rsp]
	sub	r9d, 1
	mov	DWORD PTR scanpos_in_cg$1$[rbp-256], r9d
	jns	$LL18@kvz_rdoq

; 879  :         }
; 880  :       }
; 881  :     } //end for (scanpos_in_cg)
; 882  : 
; 883  :     if( cg_scanpos ) {

	cmp	DWORD PTR cg_scanpos$1$[rsp], 0
	mov	r10d, r11d
	je	$LN60@kvz_rdoq

; 884  :       if (sig_coeffgroup_flag[cg_blkpos] == 0) {

	cmp	DWORD PTR sig_coeffgroup_flag$[rbp+r10*4-256], 0
	jne	$LN62@kvz_rdoq
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 323  :   if (pos_x < (uint32_t)width - 1) uiRight = (sig_coeff_group_flag[pos_y * width + pos_x + 1] != 0);

	mov	ecx, DWORD PTR width$1$[rsp]
	xor	r10d, r10d
	mov	ebx, DWORD PTR cg_pos_x$1$[rbp-256]
	mov	edx, r10d
	mov	r8d, r10d
	lea	r9d, DWORD PTR [rcx-1]
	cmp	ebx, r9d
	jae	SHORT $LN245@kvz_rdoq
	lea	eax, DWORD PTR [r11+1]
	cmp	DWORD PTR sig_coeffgroup_flag$[rbp+rax*4-256], edx
	setne	dl
$LN245@kvz_rdoq:

; 324  :   if (pos_y < (uint32_t)width - 1) uiLower = (sig_coeff_group_flag[(pos_y  + 1 ) * width + pos_x] != 0);

	mov	eax, DWORD PTR cg_pos_y$1$[rbp-256]
	cmp	eax, r9d
	jae	SHORT $LN246@kvz_rdoq
	inc	eax
	imul	eax, ecx
	add	eax, ebx
	cmp	DWORD PTR sig_coeffgroup_flag$[rbp+rax*4-256], r8d
	setne	r8b
$LN246@kvz_rdoq:

; 325  : 
; 326  :   return uiRight || uiLower;

	test	edx, edx
	jne	SHORT $LN248@kvz_rdoq
	mov	rax, r10
	test	r8d, r8d
	je	SHORT $LN249@kvz_rdoq
$LN248@kvz_rdoq:
	mov	eax, 1
$LN249@kvz_rdoq:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 887  :         cost_coeffgroup_sig[cg_scanpos] = state->lambda *CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig],0);

	mov	rcx, QWORD PTR base_coeff_group_ctx$2$[rbp-256]
	xorps	xmm0, xmm0
	mov	rdx, QWORD PTR $T1[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR kvz_entropy_bits[rcx+rax*4]
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR [rsi+368]
	movsd	QWORD PTR cost_coeffgroup_sig$[rbp+rdx*8-256], xmm0

; 888  :         base_cost += cost_coeffgroup_sig[cg_scanpos]  - rd_stats.sig_cost;

	subsd	xmm0, xmm7
	addsd	xmm11, xmm0

; 889  :       } else {

	jmp	$LN331@kvz_rdoq
$LN62@kvz_rdoq:

; 890  :         if (cg_scanpos < cg_last_scanpos){

	mov	rdx, QWORD PTR $T1[rsp]
	cmp	rdx, QWORD PTR tv8128[rbp-256]
	jge	$LN331@kvz_rdoq

; 891  :           double cost_zero_cg;
; 892  :           uint32_t ctx_sig;
; 893  :           if (rd_stats.nnz_before_pos0 == 0) {

	test	eax, eax
	jne	SHORT $LN65@kvz_rdoq

; 894  :             base_cost -= rd_stats.sig_cost_0;

	subsd	xmm11, xmm8

; 895  :             rd_stats.sig_cost -= rd_stats.sig_cost_0;

	subsd	xmm7, xmm8
$LN65@kvz_rdoq:
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 323  :   if (pos_x < (uint32_t)width - 1) uiRight = (sig_coeff_group_flag[pos_y * width + pos_x + 1] != 0);

	mov	ecx, DWORD PTR width$1$[rsp]
	xor	eax, eax
	mov	ebx, DWORD PTR cg_pos_x$1$[rbp-256]
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 898  :           cost_zero_cg = base_cost;

	movaps	xmm2, xmm11
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 320  :   uint32_t uiRight = 0;

	mov	edx, eax

; 321  :   uint32_t uiLower = 0;

	mov	r8d, eax

; 323  :   if (pos_x < (uint32_t)width - 1) uiRight = (sig_coeff_group_flag[pos_y * width + pos_x + 1] != 0);

	lea	r9d, DWORD PTR [rcx-1]
	cmp	ebx, r9d
	jae	SHORT $LN467@kvz_rdoq
	lea	eax, DWORD PTR [r11+1]
	xor	r11d, r11d
	cmp	DWORD PTR sig_coeffgroup_flag$[rbp+rax*4-256], edx
	setne	dl
	jmp	SHORT $LN251@kvz_rdoq
$LN467@kvz_rdoq:
	xor	r11d, r11d
$LN251@kvz_rdoq:

; 324  :   if (pos_y < (uint32_t)width - 1) uiLower = (sig_coeff_group_flag[(pos_y  + 1 ) * width + pos_x] != 0);

	mov	eax, DWORD PTR cg_pos_y$1$[rbp-256]
	cmp	eax, r9d
	jae	SHORT $LN371@kvz_rdoq
	inc	eax
	mov	r8d, r11d
	imul	eax, ecx
	add	eax, ebx
	cmp	DWORD PTR sig_coeffgroup_flag$[rbp+rax*4-256], 0
	setne	r8b
$LN371@kvz_rdoq:

; 325  : 
; 326  :   return uiRight || uiLower;

	test	edx, edx
	jne	SHORT $LN254@kvz_rdoq
	mov	rax, r11
	test	r8d, r8d
	je	SHORT $LN255@kvz_rdoq
$LN254@kvz_rdoq:
	mov	eax, 1
$LN255@kvz_rdoq:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 904  :           cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 1);

	movsd	xmm1, QWORD PTR [rsi+368]
	lea	r8, OFFSET FLAT:__ImageBase
	mov	rcx, QWORD PTR base_coeff_group_ctx$2$[rbp-256]
	xorps	xmm0, xmm0
	mov	rdx, QWORD PTR $T1[rsp]
	movzx	ecx, BYTE PTR [rax+rcx]
	mov	eax, ecx
	xor	rax, 1
	mov	eax, DWORD PTR kvz_entropy_bits[r8+rax*4]
	cvtsi2sd xmm0, rax

; 905  :           base_cost += cost_coeffgroup_sig[cg_scanpos];
; 906  :           cost_zero_cg += state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);

	mov	eax, DWORD PTR kvz_entropy_bits[r8+rcx*4]
	mulsd	xmm0, xmm1
	addsd	xmm11, xmm0
	movsd	QWORD PTR cost_coeffgroup_sig$[rbp+rdx*8-256], xmm0
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
	mulsd	xmm0, xmm1
	addsd	xmm2, xmm0

; 907  : 
; 908  :           // try to convert the current coeff group from non-zero to all-zero
; 909  :           cost_zero_cg += rd_stats.uncoded_dist;          // distortion for resetting non-zero levels to zero levels

	addsd	xmm2, xmm9

; 910  :           cost_zero_cg -= rd_stats.coded_level_and_dist;  // distortion and level cost for keeping all non-zero levels

	subsd	xmm2, xmm10

; 911  :           cost_zero_cg -= rd_stats.sig_cost;              // sig cost for all coeffs, including zero levels and non-zerl levels

	subsd	xmm2, xmm7

; 912  : 
; 913  :           // if we can save cost, change this block to all-zero block
; 914  :           if (cost_zero_cg < base_cost) {

	comisd	xmm2, xmm11
	jae	$LN331@kvz_rdoq

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	r14, QWORD PTR dest_coeff$[rbp-256]
	lea	eax, DWORD PTR [rdi+15]
	movsxd	rcx, eax
	movaps	xmm11, xmm2
	movsd	QWORD PTR cost_coeffgroup_sig$[rbp+rdx*8-256], xmm0
	mov	DWORD PTR sig_coeffgroup_flag$[rbp+r10*4-256], r11d
	mov	eax, DWORD PTR [r12+rcx*4]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN19@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-256]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-256], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-256], r11
$LN19@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-4]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN303@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-264]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-264], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-264], r11
$LN303@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-8]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN305@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-272]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-272], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-272], r11
$LN305@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-12]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN307@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-280]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-280], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-280], r11
$LN307@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-16]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN309@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-288]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-288], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-288], r11
$LN309@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-20]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN311@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-296]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-296], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-296], r11
$LN311@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-24]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN313@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-304]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-304], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-304], r11
$LN313@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-28]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN315@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-312]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-312], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-312], r11
$LN315@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-32]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN317@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-320]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-320], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-320], r11
$LN317@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-36]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN319@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-328]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-328], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-328], r11
$LN319@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-40]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN321@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-336]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-336], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-336], r11
$LN321@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-44]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN323@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-344]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-344], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-344], r11
$LN323@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-48]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN325@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-352]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-352], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-352], r11
$LN325@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-52]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN327@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-360]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-360], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-360], r11
$LN327@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-56]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN329@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-368]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-368], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-368], r11
$LN329@kvz_rdoq:

; 915  : 
; 916  :             sig_coeffgroup_flag[cg_blkpos] = 0;
; 917  :             base_cost = cost_zero_cg;
; 918  : 
; 919  :             cost_coeffgroup_sig[cg_scanpos] = state->lambda * CTX_ENTROPY_BITS(&base_coeff_group_ctx[ctx_sig], 0);
; 920  : 
; 921  :             // reset coeffs to 0 in this block
; 922  :             for (int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {
; 923  :               int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 924  :               uint32_t blkpos = scan[scanpos];
; 925  :               if (dest_coeff[blkpos]){

	mov	eax, DWORD PTR [r12+rcx*4-60]
	cmp	WORD PTR [r14+rax*2], 0
	je	SHORT $LN331@kvz_rdoq

; 926  :                 dest_coeff[blkpos] = 0;

	mov	WORD PTR [r14+rax*2], r11w

; 927  :                 cost_coeff[scanpos] = cost_coeff0[scanpos];

	mov	rax, QWORD PTR cost_coeff0$[rbp+rcx*8-376]
	mov	QWORD PTR cost_coeff$[rbp+rcx*8-376], rax

; 928  :                 cost_sig[scanpos] = 0;

	mov	QWORD PTR cost_sig$[rbp+rcx*8-376], r11
$LN331@kvz_rdoq:

; 773  : 
; 774  :   int32_t last_x_bits[32], last_y_bits[32];
; 775  :   calc_last_bits(state, width, height, type, last_x_bits, last_y_bits);
; 776  : 
; 777  :   for (int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	mov	eax, DWORD PTR cg_scanpos$1$[rsp]
	dec	rdx
	mov	r10d, DWORD PTR q_bits$1$[rsp]
	dec	eax
	mov	r14d, DWORD PTR tv9210[rsp]
	mov	DWORD PTR cg_scanpos$1$[rsp], eax
	mov	QWORD PTR $T1[rsp], rdx
	test	eax, eax
	jns	$LL15@kvz_rdoq
	jmp	SHORT $LN375@kvz_rdoq
$LN60@kvz_rdoq:

; 929  :               }
; 930  :             }
; 931  :           } // end if ( cost_all_zeros < base_cost )
; 932  :         }
; 933  :       } // end if if (sig_coeffgroup_flag[ cg_blkpos ] == 0)
; 934  :     } else {
; 935  :       sig_coeffgroup_flag[cg_blkpos] = 1;

	mov	eax, 1
	mov	DWORD PTR sig_coeffgroup_flag$[rbp+r10*4-256], eax
$LN375@kvz_rdoq:

; 936  :     }
; 937  :   } //end for (cg_scanpos)
; 938  : 
; 939  :   //===== estimate last position =====
; 940  :   double  best_cost        = 0;
; 941  :   int32_t ctx_cbf          = 0;
; 942  :   int8_t found_last        = 0;
; 943  :   int32_t best_last_idx_p1 = 0;

	movaps	xmm12, XMMWORD PTR [rsp+42320]
	xor	edx, edx

; 944  : 
; 945  :   if( block_type != CU_INTRA && !type/* && pcCU->getTransformIdx( uiAbsPartIdx ) == 0*/ ) {

	cmp	BYTE PTR block_type$[rbp-256], 1
	mov	edi, edx
	movaps	xmm10, XMMWORD PTR [rsp+42352]
	movaps	xmm9, XMMWORD PTR [rsp+42368]
	movaps	xmm8, XMMWORD PTR [rsp+42384]
	movaps	xmm7, XMMWORD PTR [rsp+42400]
	movaps	xmm6, XMMWORD PTR [rsp+42416]
	movzx	ebx, BYTE PTR type$[rbp-256]
	je	SHORT $LN68@kvz_rdoq
	test	bl, bl
	jne	SHORT $LN68@kvz_rdoq

; 946  :     best_cost  = block_uncoded_cost +   state->lambda * CTX_ENTROPY_BITS(&(cabac->ctx.cu_qt_root_cbf_model),0);

	movzx	ecx, BYTE PTR [rsi+349]

; 947  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&(cabac->ctx.cu_qt_root_cbf_model),1);
; 948  :   } else {

	jmp	SHORT $LN493@kvz_rdoq
$LN68@kvz_rdoq:

; 949  :     cabac_ctx_t* base_cbf_model = type?(cabac->ctx.qt_cbf_model_chroma):(cabac->ctx.qt_cbf_model_luma);
; 950  :     ctx_cbf    = ( type ? tr_depth : !tr_depth);

	mov	ecx, 56					; 00000038H
	test	bl, bl
	mov	eax, 60					; 0000003cH
	cmove	eax, ecx
	lea	rcx, QWORD PTR [rax+rsi]
	je	SHORT $LN98@kvz_rdoq
	movsx	eax, BYTE PTR tr_depth$[rbp-256]
	jmp	SHORT $LN99@kvz_rdoq
$LN98@kvz_rdoq:
	mov	eax, edx
	cmp	BYTE PTR tr_depth$[rbp-256], al
	sete	al
$LN99@kvz_rdoq:

; 951  :     best_cost  = block_uncoded_cost +  state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],0);

	cdqe
	movzx	ecx, BYTE PTR [rax+rcx+128]
$LN493@kvz_rdoq:

; 952  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],1);
; 953  :   }
; 954  : 
; 955  :   for ( int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	movsd	xmm0, QWORD PTR [rsi+368]
	lea	r11, OFFSET FLAT:__ImageBase

; 487  :   return state->lambda * uiCost;

	mov	rdx, QWORD PTR scan_cg$1$[rbp-256]
	lea	r12, QWORD PTR cost_coeffgroup_sig$[rbp-256]

; 952  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],1);
; 953  :   }
; 954  : 
; 955  :   for ( int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	mov	rax, rcx
	xorps	xmm2, xmm2
	xor	rax, 1
	xorps	xmm3, xmm3
	mov	eax, DWORD PTR kvz_entropy_bits[r11+rax*4]
	cvtsi2sd xmm2, rax
	mov	eax, DWORD PTR kvz_entropy_bits[r11+rcx*4]
	mov	ecx, DWORD PTR cg_scanpos$1$[rbp-256]
	mov	r14d, ecx

; 487  :   return state->lambda * uiCost;

	mov	esi, ecx
	shl	ecx, 4
	neg	esi

; 952  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],1);
; 953  :   }
; 954  : 
; 955  :   for ( int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	cvtsi2sd xmm3, rax
	mov	rax, QWORD PTR tv8147[rbp-256]

; 487  :   return state->lambda * uiCost;

	shl	esi, 4
	add	ecx, 15
	mov	DWORD PTR cg_scanpos$1$[rbp-256], ecx

; 952  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],1);
; 953  :   }
; 954  : 
; 955  :   for ( int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	mulsd	xmm2, xmm0

; 487  :   return state->lambda * uiCost;

	lea	r15, QWORD PTR [rdx+rax*4]
	lea	r12, QWORD PTR [r12+rax*8]

; 952  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],1);
; 953  :   }
; 954  : 
; 955  :   for ( int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	mulsd	xmm3, xmm0
	addsd	xmm2, xmm11
	addsd	xmm3, xmm13
$LL24@kvz_rdoq:

; 956  :     uint32_t cg_blkpos = scan_cg[cg_scanpos];
; 957  :     base_cost -= cost_coeffgroup_sig[cg_scanpos];
; 958  : 
; 959  :     if (sig_coeffgroup_flag[ cg_blkpos ]) {

	mov	eax, DWORD PTR [r15]
	subsd	xmm2, QWORD PTR [r12]
	cmp	DWORD PTR sig_coeffgroup_flag$[rbp+rax*4-256], 0
	je	$LN22@kvz_rdoq

; 960  :       for ( int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {

	mov	r8d, ecx
	npad	8
$LL27@kvz_rdoq:

; 961  :         int32_t  scanpos = cg_scanpos*cg_size + scanpos_in_cg;
; 962  :         if (scanpos > last_scanpos) continue;

	cmp	r8d, DWORD PTR scanpos$1$[rsp]
	jg	$LN25@kvz_rdoq

; 963  :         uint32_t blkpos  = scan[scanpos];

	mov	rax, QWORD PTR scan$1$[rbp-256]

; 964  : 
; 965  :         if( dest_coeff[ blkpos ] ) {

	mov	r13, QWORD PTR dest_coeff$[rbp-256]
	movsxd	r10, r8d
	mov	r9d, DWORD PTR [rax+r10*4]
	movzx	ebx, WORD PTR [r13+r9*2]
	test	bx, bx
	je	$LN72@kvz_rdoq

; 966  :           uint32_t   pos_y = blkpos >> log2_block_size;

	mov	ecx, DWORD PTR log2_block_size$1$[rbp-256]
	mov	edx, r9d
	shr	edx, cl

; 967  :           uint32_t   pos_x = blkpos - ( pos_y << log2_block_size );

	mov	eax, edx
	shl	eax, cl
	sub	r9d, eax

; 968  : 
; 969  :           double cost_last = (scan_mode == SCAN_VER) ? get_rate_last(state, pos_y, pos_x,last_x_bits,last_y_bits) : get_rate_last(state, pos_x, pos_y, last_x_bits,last_y_bits );

	cmp	BYTE PTR scan_mode$[rbp-256], 2
	jne	SHORT $LN100@kvz_rdoq

; 478  :   uint32_t ctx_x   = g_group_idx[pos_x];

	movzx	r11d, BYTE PTR g_group_idx[rdx+r11]

; 479  :   uint32_t ctx_y   = g_group_idx[pos_y];

	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	r9d, BYTE PTR g_group_idx[r9+rcx]

; 968  : 
; 969  :           double cost_last = (scan_mode == SCAN_VER) ? get_rate_last(state, pos_y, pos_x,last_x_bits,last_y_bits) : get_rate_last(state, pos_x, pos_y, last_x_bits,last_y_bits );

	jmp	SHORT $LN498@kvz_rdoq
$LN100@kvz_rdoq:

; 478  :   uint32_t ctx_x   = g_group_idx[pos_x];

	movzx	r11d, BYTE PTR g_group_idx[r9+r11]

; 479  :   uint32_t ctx_y   = g_group_idx[pos_y];

	lea	rax, OFFSET FLAT:__ImageBase
	movzx	r9d, BYTE PTR g_group_idx[rdx+rax]
$LN498@kvz_rdoq:

; 970  :           double totalCost = base_cost + cost_last - cost_sig[ scanpos ];

	mov	edx, DWORD PTR last_y_bits$[rbp+r9*4-256]
	add	edx, DWORD PTR last_x_bits$[rbp+r11*4-256]
	movd	xmm1, edx
	cvtdq2pd xmm1, xmm1
	cmp	r11d, 3
	jbe	SHORT $LN261@kvz_rdoq
	lea	eax, DWORD PTR [r11-2]
	xorps	xmm0, xmm0
	shr	eax, 1
	shl	eax, 15
	cvtsi2sd xmm0, rax
	addsd	xmm1, xmm0
$LN261@kvz_rdoq:
	cmp	r9d, 3
	jbe	SHORT $LN262@kvz_rdoq
	lea	eax, DWORD PTR [r9-2]
	xorps	xmm0, xmm0
	shr	eax, 1
	shl	eax, 15
	cvtsi2sd xmm0, rax
	addsd	xmm1, xmm0
$LN262@kvz_rdoq:
	mov	rax, QWORD PTR state$[rbp-256]
	mulsd	xmm1, QWORD PTR [rax+368]

; 971  : 
; 972  :           if( totalCost < best_cost ) {
; 973  :             best_last_idx_p1 = scanpos + 1;
; 974  :             best_cost        = totalCost;
; 975  :           }
; 976  :           if( dest_coeff[ blkpos ] > 1 ) {

	lea	eax, DWORD PTR [r8+1]
	addsd	xmm1, xmm2
	subsd	xmm1, QWORD PTR cost_sig$[rbp+r10*8-256]
	comisd	xmm3, xmm1
	minsd	xmm1, xmm3
	cmovbe	eax, edi
	mov	edi, eax
	movaps	xmm3, xmm1
	cmp	bx, 1
	jg	SHORT $LN284@kvz_rdoq

; 977  :             found_last = 1;
; 978  :             break;
; 979  :           }
; 980  :           base_cost -= cost_coeff[scanpos];

	subsd	xmm2, QWORD PTR cost_coeff$[rbp+r10*8-256]

; 981  :           base_cost += cost_coeff0[scanpos];

	addsd	xmm2, QWORD PTR cost_coeff0$[rbp+r10*8-256]

; 982  :         } else {

	jmp	SHORT $LN25@kvz_rdoq
$LN72@kvz_rdoq:

; 983  :           base_cost -= cost_sig[scanpos];

	subsd	xmm2, QWORD PTR cost_sig$[rbp+r10*8-256]
$LN25@kvz_rdoq:

; 960  :       for ( int32_t scanpos_in_cg = cg_size - 1; scanpos_in_cg >= 0; scanpos_in_cg--) {

	dec	r8d
	lea	r11, OFFSET FLAT:__ImageBase
	lea	eax, DWORD PTR [rsi+r8]
	test	eax, eax
	jns	$LL27@kvz_rdoq
	mov	ecx, DWORD PTR cg_scanpos$1$[rbp-256]
$LN22@kvz_rdoq:

; 952  :     base_cost +=   state->lambda * CTX_ENTROPY_BITS(&base_cbf_model[ctx_cbf],1);
; 953  :   }
; 954  : 
; 955  :   for ( int32_t cg_scanpos = cg_last_scanpos; cg_scanpos >= 0; cg_scanpos--) {

	sub	ecx, 16
	add	esi, 16
	sub	r12, 8
	mov	DWORD PTR cg_scanpos$1$[rbp-256], ecx
	sub	r15, 4
	sub	r14d, 1
	js	SHORT $LN456@kvz_rdoq
	lea	r11, OFFSET FLAT:__ImageBase
	jmp	$LL24@kvz_rdoq
$LN456@kvz_rdoq:
	mov	r13, QWORD PTR dest_coeff$[rbp-256]
$LN284@kvz_rdoq:

; 987  :     } // end if (sig_coeffgroup_flag[ cg_blkpos ])
; 988  :   } // end for
; 989  : 
; 990  :   uint32_t abs_sum = 0;
; 991  :   for ( int32_t scanpos = 0; scanpos < best_last_idx_p1; scanpos++) {

	mov	r11, QWORD PTR scan$1$[rbp-256]
	xor	edx, edx
	mov	rbx, QWORD PTR coef$[rbp-256]
	mov	r10d, edx
	movsxd	r8, edi
	test	edi, edi
	jle	SHORT $LN29@kvz_rdoq
; File F:\open_codec_learn_2021\kvazaar-master\src\context.c

; 348  :   if (pos_y < (uint32_t)width - 1) sigLower = (sig_coeff_group_flag[(pos_y  + 1 ) * width + pos_x] != 0);

	mov	r9d, edx
$LL30@kvz_rdoq:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 993  :     int32_t level      = dest_coeff[blkPos];

	movsxd	rdx, DWORD PTR [r11+r9*4]
	movsx	ecx, WORD PTR [r13+rdx*2]

; 994  :     abs_sum            += level;

	add	r10d, ecx

; 995  :     dest_coeff[blkPos] = (coeff_t)(( coef[blkPos] < 0 ) ? -level : level);

	movzx	eax, cx
	neg	ax
	cmp	WORD PTR [rbx+rdx*2], 0
	cmovge	ax, cx
	inc	r9
	mov	WORD PTR [r13+rdx*2], ax
	cmp	r9, r8
	jl	SHORT $LL30@kvz_rdoq

; 987  :     } // end if (sig_coeffgroup_flag[ cg_blkpos ])
; 988  :   } // end for
; 989  : 
; 990  :   uint32_t abs_sum = 0;
; 991  :   for ( int32_t scanpos = 0; scanpos < best_last_idx_p1; scanpos++) {

	xor	edx, edx
$LN29@kvz_rdoq:

; 996  :   }
; 997  :   //===== clean uncoded coefficients =====
; 998  :   for ( int32_t scanpos = best_last_idx_p1; scanpos <= last_scanpos; scanpos++) {

	movsxd	rcx, DWORD PTR scanpos$1$[rsp]
	cmp	r8, rcx
	jg	SHORT $LN32@kvz_rdoq
	npad	10
$LL33@kvz_rdoq:

; 999  :     dest_coeff[scan[scanpos]] = 0;

	mov	eax, DWORD PTR [r11+r8*4]
	inc	r8
	mov	WORD PTR [r13+rax*2], dx
	cmp	r8, rcx
	jle	SHORT $LL33@kvz_rdoq
$LN32@kvz_rdoq:

; 1000 :   }
; 1001 : 
; 1002 :   if (encoder->cfg.signhide_enable && abs_sum >= 2) {

	mov	rax, QWORD PTR encoder$1$[rbp-256]
	cmp	DWORD PTR [rax+52], 0
	je	SHORT $LN77@kvz_rdoq
	cmp	r10d, 2
	jb	SHORT $LN77@kvz_rdoq

; 1003 :     kvz_rdoq_sign_hiding(state, qp_scaled, scan, &sh_rates, best_last_idx_p1, coef, dest_coeff);

	mov	edx, DWORD PTR qp_scaled$1$[rbp-256]
	lea	r9, QWORD PTR sh_rates$[rbp-256]
	mov	rcx, QWORD PTR state$[rbp-256]
	mov	r8, r11
	mov	QWORD PTR [rsp+48], r13
	mov	QWORD PTR [rsp+40], rbx
	mov	DWORD PTR [rsp+32], edi
	call	kvz_rdoq_sign_hiding
$LN77@kvz_rdoq:

; 1004 :   }
; 1005 : }

	movaps	xmm11, XMMWORD PTR [rsp+42336]
	movaps	xmm13, XMMWORD PTR [rsp+42304]
	add	rsp, 42440				; 0000a5c8H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
kvz_rdoq ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT vsnprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
vsnprintf PROC						; COMDAT

; 1439 :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbx
	mov	r9, rdi
	mov	r8, rsi
	mov	QWORD PTR [rsp+32], 0
	mov	rdx, rbp
	mov	rcx, QWORD PTR [rax]
	or	rcx, 2
	call	QWORD PTR __imp___stdio_common_vsprintf

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;
; 1445 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	ecx, -1
	mov	rbp, QWORD PTR [rsp+72]
	test	eax, eax
	mov	rsi, QWORD PTR [rsp+80]
	cmovs	eax, ecx
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT snprintf
_TEXT	SEGMENT
_Buffer$ = 96
_BufferCount$ = 104
_Format$ = 112
snprintf PROC						; COMDAT

; 1948 :     {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H
	mov	rsi, r8

; 1949 :         int _Result;
; 1950 :         va_list _ArgList;
; 1951 :         __crt_va_start(_ArgList, _Format);

	lea	rbp, QWORD PTR _Format$[rsp+8]
	mov	rbx, rdx
	mov	rdi, rcx

; 1440 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	QWORD PTR [rsp+40], rbp
	mov	r9, rsi
	mov	r8, rbx
	mov	QWORD PTR [rsp+32], 0
	mov	rdx, rdi
	mov	rcx, QWORD PTR [rax]
	or	rcx, 2
	call	QWORD PTR __imp___stdio_common_vsprintf

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

	test	eax, eax
	mov	ecx, -1
	cmovs	eax, ecx

; 1952 :     #pragma warning(suppress:28719)    // 28719
; 1953 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1954 :         __crt_va_end(_ArgList);
; 1955 :         return _Result;
; 1956 :     }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
cabac_copy$ = 64
state$ = 304
coeff$ = 312
width$ = 320
type$ = 328
scan_mode$ = 336
get_coeff_cabac_cost PROC

; 242  : {

	sub	rsp, 296				; 00000128H

; 243  :   // Make sure there are coeffs present
; 244  :   bool found = false;
; 245  :   for (int i = 0; i < width*width; i++) {

	mov	eax, r8d
	mov	r11, rcx
	imul	eax, r8d
	movsxd	r10, eax
	test	eax, eax
	jle	SHORT $LN13@get_coeff_
	xor	eax, eax
	npad	6
$LL4@get_coeff_:

; 246  :     if (coeff[i] != 0) {

	cmp	WORD PTR [rdx+rax*2], 0
	jne	SHORT $LN6@get_coeff_

; 243  :   // Make sure there are coeffs present
; 244  :   bool found = false;
; 245  :   for (int i = 0; i < width*width; i++) {

	inc	rax
	cmp	rax, r10
	jl	SHORT $LL4@get_coeff_
$LN13@get_coeff_:

; 247  :       found = 1;
; 248  :       break;
; 249  :     }
; 250  :   }
; 251  :   if (!found) return 0;

	xor	eax, eax

; 275  : }

	add	rsp, 296				; 00000128H
	ret	0
$LN6@get_coeff_:

; 252  : 
; 253  :   // Take a copy of the CABAC so that we don't overwrite the contexts when
; 254  :   // counting the bits.
; 255  :   cabac_data_t cabac_copy;
; 256  :   memcpy(&cabac_copy, &state->cabac, sizeof(cabac_copy));

	lea	rax, QWORD PTR [rcx+128]

; 257  : 
; 258  :   // Clear bytes and bits and set mode to "count"
; 259  :   cabac_copy.only_count = 1;
; 260  :   cabac_copy.num_buffered_bytes = 0;
; 261  :   cabac_copy.bits_left = 23;
; 262  : 
; 263  :   // Execute the coding function.
; 264  :   // It is safe to drop the const modifier since state won't be modified
; 265  :   // when cabac.only_count is set.
; 266  :   kvz_encode_coeff_nxn((encoder_state_t*) state,

	mov	BYTE PTR [rsp+48], 0
	movups	xmm0, XMMWORD PTR [rax]
	lea	rcx, QWORD PTR cabac_copy$[rsp]
	movups	xmm1, XMMWORD PTR [rax+16]
	lea	rax, QWORD PTR [rax+128]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [rcx+80], xmm1
	movups	xmm1, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx+96], xmm0
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm0, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rcx-16], xmm0
	movups	xmm0, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx], xmm1
	movups	xmm1, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	xmm0, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx+32], xmm1
	movups	xmm1, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	xmm0, XMMWORD PTR [rax+80]
	movzx	eax, BYTE PTR scan_mode$[rsp]
	movups	XMMWORD PTR [rcx+64], xmm1
	mov	BYTE PTR [rsp+40], al
	movups	XMMWORD PTR [rcx+80], xmm0
	mov	BYTE PTR [rsp+32], r9b
	mov	rcx, r11
	movzx	r9d, r8b
	mov	BYTE PTR cabac_copy$[rsp+28], 1
	mov	r8, rdx
	mov	DWORD PTR cabac_copy$[rsp+20], 0
	lea	rdx, QWORD PTR cabac_copy$[rsp]
	mov	DWORD PTR cabac_copy$[rsp+24], 23
	call	QWORD PTR kvz_encode_coeff_nxn

; 267  :                        &cabac_copy,
; 268  :                        coeff,
; 269  :                        width,
; 270  :                        type,
; 271  :                        scan_mode,
; 272  :                        0);
; 273  : 
; 274  :   return (23 - cabac_copy.bits_left) + (cabac_copy.num_buffered_bytes << 3);

	mov	eax, DWORD PTR cabac_copy$[rsp+20]
	lea	eax, DWORD PTR [rax*8]
	sub	eax, DWORD PTR cabac_copy$[rsp+24]
	add	eax, 23

; 275  : }

	add	rsp, 296				; 00000128H
	ret	0
get_coeff_cabac_cost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
qp$ = 48
coeff$ = 56
size$ = 64
ccc$ = 72
save_ccc PROC

; 278  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	push	rdi
	sub	rsp, 32					; 00000020H

; 279  :   pthread_mutex_t *mtx = outfile_mutex + qp;

	movsxd	rax, ecx
	mov	rdi, rdx
	lea	rsi, OFFSET FLAT:__ImageBase
	lea	rbx, QWORD PTR [rax*8]

; 280  : 
; 281  :   assert(sizeof(coeff_t) == sizeof(int16_t));
; 282  :   assert(qp <= RD_SAMPLING_MAX_LAST_QP);

	cmp	ecx, 50					; 00000032H
	jle	SHORT $LN3@save_ccc
	mov	r8d, 282				; 0000011aH
	lea	rdx, OFFSET FLAT:$SG4294949247
	lea	rcx, OFFSET FLAT:$SG4294949246
	call	QWORD PTR __imp__wassert
$LN3@save_ccc:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	rcx, QWORD PTR outfile_mutex[rbx+rsi]
	call	QWORD PTR __imp__Mtx_lock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN9@save_ccc

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN9@save_ccc:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 286  :   fwrite(&size,  sizeof(size),     1,    fastrd_learning_outfile[qp]);

	mov	r9, QWORD PTR fastrd_learning_outfile[rbx+rsi]
	lea	rcx, QWORD PTR size$[rsp]
	mov	edx, 4
	lea	r8d, QWORD PTR [rdx-3]
	call	QWORD PTR __imp_fwrite

; 287  :   fwrite(&ccc,   sizeof(ccc),      1,    fastrd_learning_outfile[qp]);

	mov	r9, QWORD PTR fastrd_learning_outfile[rbx+rsi]
	lea	rcx, QWORD PTR ccc$[rsp]
	mov	edx, 4
	lea	r8d, QWORD PTR [rdx-3]
	call	QWORD PTR __imp_fwrite

; 288  :   fwrite( coeff, sizeof(coeff_t),  size, fastrd_learning_outfile[qp]);

	movsxd	r8, DWORD PTR size$[rsp]
	mov	edx, 2
	mov	r9, QWORD PTR fastrd_learning_outfile[rbx+rsi]
	mov	rcx, rdi
	call	QWORD PTR __imp_fwrite
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	rcx, QWORD PTR outfile_mutex[rbx+rsi]
	call	QWORD PTR __imp__Mtx_unlock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN19@save_ccc

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN19@save_ccc:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 291  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN23@save_ccc:
save_ccc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
qp$ = 48
ccc$ = 56
fast_cost$ = 64
save_accuracy PROC

; 294  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 295  :   pthread_mutex_t *mtx = outfile_mutex + qp;

	movsxd	rax, ecx
	mov	edi, r8d
	lea	rbp, OFFSET FLAT:__ImageBase
	mov	esi, edx
	lea	rbx, QWORD PTR [rax*8]

; 296  : 
; 297  :   assert(qp <= RD_SAMPLING_MAX_LAST_QP);

	cmp	ecx, 50					; 00000032H
	jle	SHORT $LN3@save_accur
	mov	r8d, 297				; 00000129H
	lea	rdx, OFFSET FLAT:$SG4294949245
	lea	rcx, OFFSET FLAT:$SG4294949244
	call	QWORD PTR __imp__wassert
$LN3@save_accur:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	rcx, QWORD PTR outfile_mutex[rbx+rbp]
	call	QWORD PTR __imp__Mtx_lock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN9@save_accur

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN9@save_accur:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 300  :   fprintf(fastrd_learning_outfile[qp], "%u %u\n", fast_cost, ccc);

	mov	rcx, QWORD PTR fastrd_learning_outfile[rbx+rbp]
	lea	rdx, OFFSET FLAT:$SG4294949243
	mov	r9d, esi
	mov	r8d, edi
	call	fprintf
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	rcx, QWORD PTR outfile_mutex[rbx+rbp]
	call	QWORD PTR __imp__Mtx_unlock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN19@save_accur

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN19@save_accur:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 302  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN23@save_accur:
save_accuracy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
ccc$ = 64
cabac_copy$1 = 80
cabac_copy$2 = 80
size$ = 352
state$ = 352
coeff$ = 360
width$ = 368
type$ = 376
scan_mode$ = 384
kvz_get_coeff_cost PROC

; 318  : {

$LN85:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 304				; 00000130H

; 319  :   uint8_t save_cccs = state->encoder_control->cfg.fastrd_sampling_on;
; 320  :   uint8_t check_accuracy = state->encoder_control->cfg.fastrd_accuracy_check_on;
; 321  : 
; 322  :   if (state->qp < state->encoder_control->cfg.fast_residual_cost_limit &&

	movsx	rax, BYTE PTR [rcx+384]
	mov	esi, r8d
	mov	r8, QWORD PTR [rcx]
	mov	r12d, r9d
	mov	rbx, rdx
	mov	r14, rcx
	movzx	r15d, BYTE PTR [r8+2513]
	movzx	edi, BYTE PTR [r8+2514]
	cmp	al, BYTE PTR [r8+2462]
	jge	$LN2@kvz_get_co
	cmp	al, 50					; 00000032H
	jge	$LN2@kvz_get_co

; 323  :       state->qp < MAX_FAST_COEFF_COST_QP) {
; 324  :     // TODO: do we need to assert(0) out of the fast-estimation branch if we
; 325  :     // are to save block costs, or should we just warn about it somewhere
; 326  :     // earlier (configuration validation I guess)?
; 327  :     if (save_cccs) {

	test	r15b, r15b
	je	SHORT $LN4@kvz_get_co

; 328  :       assert(0 && "Fast RD sampling does not work with fast-residual-cost");

	mov	r8d, 328				; 00000148H
	lea	rdx, OFFSET FLAT:$SG4294949242
	lea	rcx, OFFSET FLAT:$SG4294949241
	call	QWORD PTR __imp__wassert

; 329  :       return UINT32_MAX; // Hush little compiler don't you cry, not really gonna return anything after assert(0)

	mov	eax, -1					; ffffffffH
	jmp	$LN3@kvz_get_co
$LN4@kvz_get_co:

; 330  :     } else {
; 331  :       uint64_t weights = kvz_fast_coeff_get_weights(state);
; 332  :       uint32_t fast_cost = kvz_fast_coeff_cost(coeff, width, weights);

	mov	r8, QWORD PTR [r8+rax*8+6544]
	mov	edx, esi
	mov	rcx, rbx
	call	QWORD PTR kvz_fast_coeff_cost
	mov	ebp, eax

; 333  :       if (check_accuracy) {

	test	dil, dil
	je	$LN37@kvz_get_co

; 245  :   for (int i = 0; i < width*width; i++) {

	mov	ecx, esi
	xor	edi, edi
	imul	ecx, esi
	movsxd	rdx, ecx
	test	ecx, ecx
	jle	$LN81@kvz_get_co
	mov	ecx, edi
$LL15@kvz_get_co:

; 246  :     if (coeff[i] != 0) {

	cmp	WORD PTR [rbx+rcx*2], di
	jne	SHORT $LN17@kvz_get_co

; 245  :   for (int i = 0; i < width*width; i++) {

	inc	rcx
	cmp	rcx, rdx
	jl	SHORT $LL15@kvz_get_co

; 246  :     if (coeff[i] != 0) {

	jmp	$LN81@kvz_get_co
$LN17@kvz_get_co:

; 256  :   memcpy(&cabac_copy, &state->cabac, sizeof(cabac_copy));

	lea	rax, QWORD PTR [r14+128]

; 257  : 
; 258  :   // Clear bytes and bits and set mode to "count"
; 259  :   cabac_copy.only_count = 1;
; 260  :   cabac_copy.num_buffered_bytes = 0;
; 261  :   cabac_copy.bits_left = 23;
; 262  : 
; 263  :   // Execute the coding function.
; 264  :   // It is safe to drop the const modifier since state won't be modified
; 265  :   // when cabac.only_count is set.
; 266  :   kvz_encode_coeff_nxn((encoder_state_t*) state,

	mov	BYTE PTR [rsp+48], dil
	movups	xmm0, XMMWORD PTR [rax]
	lea	rcx, QWORD PTR cabac_copy$2[rsp]
	movzx	r9d, sil
	movups	xmm1, XMMWORD PTR [rax+16]
	lea	rax, QWORD PTR [rax+128]
	mov	r8, rbx
	movups	XMMWORD PTR [rcx], xmm0
	lea	rdx, QWORD PTR cabac_copy$2[rsp]
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [rcx+80], xmm1
	movups	xmm1, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx+96], xmm0
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm0, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rcx-16], xmm0
	movups	xmm0, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx], xmm1
	movups	xmm1, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	xmm0, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx+32], xmm1
	movups	xmm1, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	xmm0, XMMWORD PTR [rax+80]
	movzx	eax, BYTE PTR scan_mode$[rsp]
	movups	XMMWORD PTR [rcx+64], xmm1
	mov	BYTE PTR [rsp+40], al
	movups	XMMWORD PTR [rcx+80], xmm0
	mov	rcx, r14
	mov	BYTE PTR cabac_copy$2[rsp+28], 1
	mov	DWORD PTR cabac_copy$2[rsp+20], edi
	mov	DWORD PTR cabac_copy$2[rsp+24], 23
	mov	BYTE PTR [rsp+32], r12b
	call	QWORD PTR kvz_encode_coeff_nxn

; 267  :                        &cabac_copy,
; 268  :                        coeff,
; 269  :                        width,
; 270  :                        type,
; 271  :                        scan_mode,
; 272  :                        0);
; 273  : 
; 274  :   return (23 - cabac_copy.bits_left) + (cabac_copy.num_buffered_bytes << 3);

	mov	eax, DWORD PTR cabac_copy$2[rsp+20]
	lea	edi, DWORD PTR [rax*8]
	sub	edi, DWORD PTR cabac_copy$2[rsp+24]
	add	edi, 23
$LN81@kvz_get_co:

; 334  :         uint32_t ccc = get_coeff_cabac_cost(state, coeff, width, type, scan_mode);
; 335  :         save_accuracy(state->qp, ccc, fast_cost);

	movsx	rcx, BYTE PTR [r14+384]

; 295  :   pthread_mutex_t *mtx = outfile_mutex + qp;

	lea	rsi, OFFSET FLAT:__ImageBase
	lea	rbx, QWORD PTR [rcx*8]

; 296  : 
; 297  :   assert(qp <= RD_SAMPLING_MAX_LAST_QP);

	cmp	cl, 50					; 00000032H
	jle	SHORT $LN21@kvz_get_co
	mov	r8d, 297				; 00000129H
	lea	rdx, OFFSET FLAT:$SG4294949245
	lea	rcx, OFFSET FLAT:$SG4294949244
	call	QWORD PTR __imp__wassert
$LN21@kvz_get_co:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	rcx, QWORD PTR outfile_mutex[rbx+rsi]
	call	QWORD PTR __imp__Mtx_lock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN27@kvz_get_co

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN27@kvz_get_co:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 300  :   fprintf(fastrd_learning_outfile[qp], "%u %u\n", fast_cost, ccc);

	mov	rcx, QWORD PTR fastrd_learning_outfile[rbx+rsi]
	lea	rdx, OFFSET FLAT:$SG4294949243
	mov	r9d, edi
	mov	r8d, ebp
	call	fprintf
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	rcx, QWORD PTR outfile_mutex[rbx+rsi]
	call	QWORD PTR __imp__Mtx_unlock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN37@kvz_get_co

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN37@kvz_get_co:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 337  :       return fast_cost;

	mov	eax, ebp
	jmp	$LN3@kvz_get_co
$LN2@kvz_get_co:

; 245  :   for (int i = 0; i < width*width; i++) {

	mov	ebp, esi
	xor	edi, edi
	imul	ebp, esi
	movsxd	rcx, ebp
	test	ebp, ebp
	jle	$LN82@kvz_get_co
	mov	eax, edi
$LL45@kvz_get_co:

; 246  :     if (coeff[i] != 0) {

	cmp	WORD PTR [rdx+rax*2], di
	jne	SHORT $LN47@kvz_get_co

; 245  :   for (int i = 0; i < width*width; i++) {

	inc	rax
	cmp	rax, rcx
	jl	SHORT $LL45@kvz_get_co

; 246  :     if (coeff[i] != 0) {

	jmp	$LN82@kvz_get_co
$LN47@kvz_get_co:

; 247  :       found = 1;
; 248  :       break;
; 249  :     }
; 250  :   }
; 251  :   if (!found) return 0;
; 252  : 
; 253  :   // Take a copy of the CABAC so that we don't overwrite the contexts when
; 254  :   // counting the bits.
; 255  :   cabac_data_t cabac_copy;
; 256  :   memcpy(&cabac_copy, &state->cabac, sizeof(cabac_copy));

	lea	rax, QWORD PTR [r14+128]

; 257  : 
; 258  :   // Clear bytes and bits and set mode to "count"
; 259  :   cabac_copy.only_count = 1;
; 260  :   cabac_copy.num_buffered_bytes = 0;
; 261  :   cabac_copy.bits_left = 23;
; 262  : 
; 263  :   // Execute the coding function.
; 264  :   // It is safe to drop the const modifier since state won't be modified
; 265  :   // when cabac.only_count is set.
; 266  :   kvz_encode_coeff_nxn((encoder_state_t*) state,

	mov	BYTE PTR [rsp+48], dil
	movups	xmm0, XMMWORD PTR [rax]
	lea	rcx, QWORD PTR cabac_copy$1[rsp]
	movzx	r9d, sil
	movups	xmm1, XMMWORD PTR [rax+16]
	lea	rax, QWORD PTR [rax+128]
	mov	r8, rbx
	movups	XMMWORD PTR [rcx], xmm0
	lea	rdx, QWORD PTR cabac_copy$1[rsp]
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [rcx+48], xmm1
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [rcx+80], xmm1
	movups	xmm1, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx+96], xmm0
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm0, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rcx-16], xmm0
	movups	xmm0, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx], xmm1
	movups	xmm1, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	xmm0, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx+32], xmm1
	movups	xmm1, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	xmm0, XMMWORD PTR [rax+80]
	movzx	eax, BYTE PTR scan_mode$[rsp]
	movups	XMMWORD PTR [rcx+64], xmm1
	mov	BYTE PTR [rsp+40], al
	movups	XMMWORD PTR [rcx+80], xmm0
	mov	rcx, r14
	mov	BYTE PTR cabac_copy$1[rsp+28], 1
	mov	DWORD PTR cabac_copy$1[rsp+20], edi
	mov	DWORD PTR cabac_copy$1[rsp+24], 23
	mov	BYTE PTR [rsp+32], r12b
	call	QWORD PTR kvz_encode_coeff_nxn

; 267  :                        &cabac_copy,
; 268  :                        coeff,
; 269  :                        width,
; 270  :                        type,
; 271  :                        scan_mode,
; 272  :                        0);
; 273  : 
; 274  :   return (23 - cabac_copy.bits_left) + (cabac_copy.num_buffered_bytes << 3);

	mov	eax, DWORD PTR cabac_copy$1[rsp+20]
	lea	edi, DWORD PTR [rax*8]
	sub	edi, DWORD PTR cabac_copy$1[rsp+24]
	add	edi, 23
$LN82@kvz_get_co:

; 338  :     }
; 339  :   } else {
; 340  :     uint32_t ccc = get_coeff_cabac_cost(state, coeff, width, type, scan_mode);
; 341  :     if (save_cccs) {

	test	r15b, r15b
	je	$LN67@kvz_get_co

; 342  :       save_ccc(state->qp, coeff, width * width, ccc);

	movsx	rcx, BYTE PTR [r14+384]

; 279  :   pthread_mutex_t *mtx = outfile_mutex + qp;

	lea	rsi, OFFSET FLAT:__ImageBase

; 342  :       save_ccc(state->qp, coeff, width * width, ccc);

	mov	DWORD PTR ccc$[rsp], edi
	mov	DWORD PTR size$[rsp], ebp

; 279  :   pthread_mutex_t *mtx = outfile_mutex + qp;

	lea	r14, QWORD PTR [rcx*8]

; 280  : 
; 281  :   assert(sizeof(coeff_t) == sizeof(int16_t));
; 282  :   assert(qp <= RD_SAMPLING_MAX_LAST_QP);

	cmp	cl, 50					; 00000032H
	jle	SHORT $LN51@kvz_get_co
	mov	r8d, 282				; 0000011aH
	lea	rdx, OFFSET FLAT:$SG4294949247
	lea	rcx, OFFSET FLAT:$SG4294949246
	call	QWORD PTR __imp__wassert
$LN51@kvz_get_co:
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 51   :         _Check_C_return(_Mtx_lock(_Mymtx()));

	mov	rcx, QWORD PTR outfile_mutex[r14+rsi]
	call	QWORD PTR __imp__Mtx_lock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN57@kvz_get_co

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN57@kvz_get_co:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 286  :   fwrite(&size,  sizeof(size),     1,    fastrd_learning_outfile[qp]);

	mov	r9, QWORD PTR fastrd_learning_outfile[r14+rsi]
	lea	rcx, QWORD PTR size$[rsp]
	mov	edx, 4
	lea	r8d, QWORD PTR [rdx-3]
	call	QWORD PTR __imp_fwrite

; 287  :   fwrite(&ccc,   sizeof(ccc),      1,    fastrd_learning_outfile[qp]);

	mov	r9, QWORD PTR fastrd_learning_outfile[r14+rsi]
	lea	rcx, QWORD PTR ccc$[rsp]
	mov	edx, 4
	lea	r8d, QWORD PTR [rdx-3]
	call	QWORD PTR __imp_fwrite

; 288  :   fwrite( coeff, sizeof(coeff_t),  size, fastrd_learning_outfile[qp]);

	movsxd	r8, DWORD PTR size$[rsp]
	mov	edx, 2
	mov	r9, QWORD PTR fastrd_learning_outfile[r14+rsi]
	mov	rcx, rbx
	call	QWORD PTR __imp_fwrite
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\mutex

; 67   :         _Check_C_return(_Mtx_unlock(_Mymtx()));

	mov	rcx, QWORD PTR outfile_mutex[r14+rsi]
	call	QWORD PTR __imp__Mtx_unlock
; File D:\software_install\VS2019\VC\Tools\MSVC\14.26.28801\include\xthreads.h

; 130  :     if (_Res != _Thrd_success) {

	test	eax, eax
	je	SHORT $LN67@kvz_get_co

; 131  :         _Throw_C_error(_Res);

	mov	ecx, eax
	call	QWORD PTR __imp_?_Throw_C_error@std@@YAXH@Z
	int	3
$LN67@kvz_get_co:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 344  :     return ccc;

	mov	eax, edi
$LN3@kvz_get_co:

; 345  :   }
; 346  : }

	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN83@kvz_get_co:
kvz_get_coeff_cost ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT kvz_get_ic_rate
_TEXT	SEGMENT
state$ = 8
abs_level$ = 16
ctx_num_one$ = 24
ctx_num_abs$ = 32
abs_go_rice$ = 40
c1_idx$ = 48
c2_idx$ = 56
type$ = 64
kvz_get_ic_rate PROC					; COMDAT

; 365  : {

$LN29:
	mov	QWORD PTR [rsp+8], rbp
	mov	QWORD PTR [rsp+16], rsi

; 366  :   cabac_data_t * const cabac = &state->cabac;
; 367  :   int32_t rate = 1 << CTX_FRAC_BITS;
; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	cmp	DWORD PTR c1_idx$[rsp], 8
	movzx	r11d, r8w
	mov	r8, rcx
	movzx	ebp, r9w
	jae	SHORT $LN14@kvz_get_ic
	xor	r10d, r10d
	cmp	DWORD PTR c2_idx$[rsp], 1
	setb	r10b
	add	r10d, 2
	jmp	SHORT $LN15@kvz_get_ic
$LN14@kvz_get_ic:
	mov	r10d, 1
$LN15@kvz_get_ic:

; 369  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);
; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);

	movzx	ecx, BYTE PTR type$[rsp]
	mov	r9d, 322				; 00000142H
	test	cl, cl

; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	mov	esi, 334				; 0000014eH
	mov	eax, 306				; 00000132H
	cmovne	eax, r9d
	lea	r9, QWORD PTR [rax+r8]
	mov	eax, 330				; 0000014aH
	cmovne	eax, esi
	lea	rsi, QWORD PTR [rax+r8]
	cmp	edx, r10d
	jb	$LN4@kvz_get_ic

; 373  :     int32_t symbol     = abs_level - base_level;
; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	movzx	r8d, WORD PTR abs_go_rice$[rsp]
	mov	eax, 3
	mov	ecx, r8d
	sub	edx, r10d
	shl	eax, cl
	cmp	edx, eax
	jge	SHORT $LN6@kvz_get_ic

; 376  :       length = symbol>>abs_go_rice;

	sar	edx, cl

; 377  :       rate += (length+1+abs_go_rice) * (1 << CTX_FRAC_BITS);

	add	edx, 2
	add	edx, r8d

; 378  :     } else {

	jmp	SHORT $LN27@kvz_get_ic
$LN6@kvz_get_ic:

; 379  :       length = abs_go_rice;
; 380  :       symbol  = symbol - ( COEF_REMAIN_BIN_REDUCTION << abs_go_rice);

	sub	edx, eax

; 381  :       while (symbol >= (1<<length)) {

	mov	eax, 1
	shl	eax, cl
	cmp	edx, eax
	jl	SHORT $LN3@kvz_get_ic
	npad	10
$LL2@kvz_get_ic:

; 382  :         symbol -=  (1<<(length++));

	sub	edx, eax
	inc	ecx
	mov	eax, 1
	shl	eax, cl
	cmp	edx, eax
	jge	SHORT $LL2@kvz_get_ic
$LN3@kvz_get_ic:

; 383  :       }
; 384  :       rate += (COEF_REMAIN_BIN_REDUCTION+length+1-abs_go_rice+length) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [rcx+rcx]
	sub	edx, r8d
	add	edx, 5
$LN27@kvz_get_ic:

; 385  :     }
; 386  :     if (c1_idx < C1FLAG_NUMBER) {

	shl	edx, 15
	cmp	DWORD PTR c1_idx$[rsp], 8
	jae	SHORT $LN25@kvz_get_ic

; 387  :       rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	ecx, BYTE PTR [r11+r9]
	lea	r8, OFFSET FLAT:kvz_entropy_bits
	xor	rcx, 1
	add	edx, DWORD PTR [r8+rcx*4]

; 388  : 
; 389  :       if (c2_idx < C2FLAG_NUMBER) {

	cmp	DWORD PTR c2_idx$[rsp], 1
	jae	SHORT $LN25@kvz_get_ic

; 390  :         rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],1);

	movzx	ecx, BYTE PTR [rbp+rsi]
	xor	rcx, 1
	add	edx, DWORD PTR [r8+rcx*4]
$LN25@kvz_get_ic:

; 399  :   }
; 400  : 
; 401  :   return rate;
; 402  : }

	mov	eax, edx
	mov	rbp, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
$LN4@kvz_get_ic:

; 391  :       }
; 392  :     }
; 393  :   }
; 394  :   else if( abs_level == 1 ) {

	cmp	edx, 1
	jne	SHORT $LN10@kvz_get_ic

; 395  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],0);

	movzx	ecx, BYTE PTR [r11+r9]
	lea	r8, OFFSET FLAT:kvz_entropy_bits
	mov	eax, DWORD PTR [r8+rcx*4]
	add	eax, 32768				; 00008000H

; 399  :   }
; 400  : 
; 401  :   return rate;
; 402  : }

	mov	rbp, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
$LN10@kvz_get_ic:

; 396  :   } else if( abs_level == 2 ) {

	cmp	edx, 2
	jne	SHORT $LN24@kvz_get_ic

; 397  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);
; 398  :     rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],0);

	movzx	edx, BYTE PTR [rbp+rsi]
	lea	r8, OFFSET FLAT:kvz_entropy_bits
	movzx	ecx, BYTE PTR [r11+r9]
	xor	rcx, 1
	mov	eax, DWORD PTR [r8+rdx*4]
	add	eax, 32768				; 00008000H
	mov	ecx, DWORD PTR [r8+rcx*4]
	add	eax, ecx

; 399  :   }
; 400  : 
; 401  :   return rate;
; 402  : }

	mov	rbp, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
$LN24@kvz_get_ic:
	mov	rbp, QWORD PTR [rsp+8]
	mov	eax, 32768				; 00008000H
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
kvz_get_ic_rate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
;	COMDAT kvz_get_coded_level
_TEXT	SEGMENT
state$ = 48
coded_cost$ = 56
coded_cost0$ = 64
coded_cost_sig$ = 72
level_double$ = 80
max_abs_level$ = 88
ctx_num_sig$ = 96
ctx_num_one$ = 104
ctx_num_abs$ = 112
abs_go_rice$ = 120
c1_idx$ = 128
c2_idx$ = 136
q_bits$ = 144
temp$ = 152
last$ = 160
type$ = 168
kvz_get_coded_level PROC				; COMDAT

; 427  : {

$LN46:
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	push	r15
	sub	rsp, 8

; 428  :   cabac_data_t * const cabac = &state->cabac;
; 429  :   double cur_cost_sig   = 0;
; 430  :   uint32_t best_abs_level = 0;
; 431  :   int32_t abs_level;
; 432  :   int32_t min_abs_level;
; 433  :   cabac_ctx_t* base_sig_model = type?(cabac->ctx.cu_sig_model_chroma):(cabac->ctx.cu_sig_model_luma);
; 434  : 
; 435  :   if( !last && max_abs_level < 3 ) {

	movzx	r11d, BYTE PTR type$[rsp]
	xor	r15d, r15d
	movzx	eax, BYTE PTR last$[rsp]
	test	r11b, r11b
	mov	rsi, rcx
	mov	r10d, 231				; 000000e7H
	mov	ecx, 204				; 000000ccH
	mov	rbx, r8
	mov	r8d, DWORD PTR max_abs_level$[rsp]
	cmove	r10d, ecx
	add	r10, rsi
	mov	rdi, rdx
	lea	rdx, OFFSET FLAT:kvz_entropy_bits
	xorps	xmm2, xmm2
	test	al, al
	jne	SHORT $LN5@kvz_get_co
	cmp	r8d, 3
	jae	SHORT $LN5@kvz_get_co

; 436  :     *coded_cost_sig = state->lambda * CTX_ENTROPY_BITS(&base_sig_model[ctx_num_sig], 0);

	movzx	ecx, WORD PTR ctx_num_sig$[rsp]
	xorps	xmm0, xmm0
	movzx	eax, BYTE PTR [r10+rcx]
	mov	eax, DWORD PTR [rdx+rax*4]
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR [rsi+368]
	movsd	QWORD PTR [r9], xmm0

; 437  :     *coded_cost     = *coded_cost0 + *coded_cost_sig;

	addsd	xmm0, QWORD PTR [rbx]
	movsd	QWORD PTR [rdi], xmm0

; 438  :     if (max_abs_level == 0) return best_abs_level;

	test	r8d, r8d
	jne	SHORT $LN42@kvz_get_co
	xor	eax, eax

; 463  : }

	add	rsp, 8
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN5@kvz_get_co:

; 439  :   } else {
; 440  :     *coded_cost = MAX_DOUBLE;

	mov	rcx, 9218378953502702454		; 7fee42d130773b76H
	mov	QWORD PTR [rdi], rcx
	movzx	ecx, WORD PTR ctx_num_sig$[rsp]

; 441  :   }
; 442  : 
; 443  :   if( !last ) {

	test	al, al
	jne	SHORT $LN43@kvz_get_co
$LN42@kvz_get_co:

; 444  :     cur_cost_sig = state->lambda * CTX_ENTROPY_BITS(&base_sig_model[ctx_num_sig], 1);

	movzx	eax, BYTE PTR [r10+rcx]
	xorps	xmm2, xmm2
	xor	rax, 1
	mov	eax, DWORD PTR [rdx+rax*4]
	cvtsi2sd xmm2, rax
	mulsd	xmm2, QWORD PTR [rsi+368]
$LN43@kvz_get_co:

; 445  :   }
; 446  : 
; 447  :   min_abs_level    = ( max_abs_level > 1 ? max_abs_level - 1 : 1 );
; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	mov	eax, 1
	lea	r10d, DWORD PTR [r8-1]
	cmp	r8d, eax
	cmovbe	r10d, eax
	cmp	r8d, r10d
	jl	$LN3@kvz_get_co

; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	movzx	r9d, WORD PTR abs_go_rice$[rsp]
	test	r11b, r11b
	movsd	xmm3, QWORD PTR temp$[rsp]
	mov	ecx, 322				; 00000142H
	mov	QWORD PTR [rsp+48], rbp
	mov	ebx, 306				; 00000132H

; 369  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);
; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);
; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	mov	ebp, DWORD PTR c1_idx$[rsp]
	cmovne	ebx, ecx

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	mov	QWORD PTR [rsp+56], r12
	add	rbx, rsi

; 369  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);
; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);
; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	test	r11b, r11b

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	mov	QWORD PTR [rsp+64], r13
	movzx	r13d, WORD PTR ctx_num_abs$[rsp]
	mov	ecx, 334				; 0000014eH

; 369  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);
; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);
; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	movzx	r11d, WORD PTR ctx_num_one$[rsp]
	mov	r12d, 330				; 0000014aH
	cmovne	r12d, ecx

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	mov	QWORD PTR [rsp], r14
	mov	r14d, DWORD PTR c2_idx$[rsp]
	add	r12, rsi
	npad	12
$LL4@kvz_get_co:

; 449  :     double err       = (double)(level_double - ( abs_level * (1 << q_bits) ) );

	mov	ecx, DWORD PTR q_bits$[rsp]
	mov	edx, r8d
	mov	eax, DWORD PTR level_double$[rsp]
	shl	edx, cl
	sub	eax, edx

; 367  :   int32_t rate = 1 << CTX_FRAC_BITS;

	mov	edx, 32768				; 00008000H
	movd	xmm1, eax

; 449  :     double err       = (double)(level_double - ( abs_level * (1 << q_bits) ) );

	cvtdq2pd xmm1, xmm1

; 368  :   uint32_t base_level  =  (c1_idx < C1FLAG_NUMBER)? (2 + (c2_idx < C2FLAG_NUMBER)) : 1;

	cmp	ebp, 8
	jae	SHORT $LN28@kvz_get_co
	xor	ecx, ecx
	cmp	r14d, 1
	setb	cl
	add	ecx, 2
	jmp	SHORT $LN29@kvz_get_co
$LN28@kvz_get_co:
	mov	ecx, 1
$LN29@kvz_get_co:

; 369  :   cabac_ctx_t *base_one_ctx = (type == 0) ? &(cabac->ctx.cu_one_model_luma[0]) : &(cabac->ctx.cu_one_model_chroma[0]);
; 370  :   cabac_ctx_t *base_abs_ctx = (type == 0) ? &(cabac->ctx.cu_abs_model_luma[0]) : &(cabac->ctx.cu_abs_model_chroma[0]);
; 371  : 
; 372  :   if ( abs_level >= base_level ) {

	cmp	r8d, ecx
	jb	$LN18@kvz_get_co

; 373  :     int32_t symbol     = abs_level - base_level;

	mov	eax, r8d

; 374  :     int32_t length;
; 375  :     if (symbol < (COEF_REMAIN_BIN_REDUCTION << abs_go_rice)) {

	mov	edx, 3
	sub	eax, ecx
	mov	ecx, r9d
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LN20@kvz_get_co

; 376  :       length = symbol>>abs_go_rice;

	sar	eax, cl

; 377  :       rate += (length+1+abs_go_rice) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [r9+2]
	add	edx, eax

; 378  :     } else {

	jmp	SHORT $LN44@kvz_get_co
$LN20@kvz_get_co:

; 379  :       length = abs_go_rice;
; 380  :       symbol  = symbol - ( COEF_REMAIN_BIN_REDUCTION << abs_go_rice);

	sub	eax, edx

; 381  :       while (symbol >= (1<<length)) {

	mov	edx, 1
	shl	edx, cl
	cmp	eax, edx
	jl	SHORT $LN17@kvz_get_co
	npad	6
$LL16@kvz_get_co:

; 382  :         symbol -=  (1<<(length++));

	sub	eax, edx
	inc	ecx
	mov	edx, 1
	shl	edx, cl
	cmp	eax, edx
	jge	SHORT $LL16@kvz_get_co
$LN17@kvz_get_co:

; 383  :       }
; 384  :       rate += (COEF_REMAIN_BIN_REDUCTION+length+1-abs_go_rice+length) * (1 << CTX_FRAC_BITS);

	lea	edx, DWORD PTR [rcx+rcx]
	sub	edx, r9d
	add	edx, 5
$LN44@kvz_get_co:

; 385  :     }
; 386  :     if (c1_idx < C1FLAG_NUMBER) {

	shl	edx, 15
	cmp	ebp, 8
	jae	SHORT $LN26@kvz_get_co

; 387  :       rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);

	movzx	ecx, BYTE PTR [r11+rbx]
	lea	rax, OFFSET FLAT:kvz_entropy_bits
	xor	rcx, 1
	add	edx, DWORD PTR [rax+rcx*4]

; 388  : 
; 389  :       if (c2_idx < C2FLAG_NUMBER) {

	cmp	r14d, 1
	jae	SHORT $LN26@kvz_get_co

; 390  :         rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],1);

	movzx	ecx, BYTE PTR [r13+r12]
	lea	rax, OFFSET FLAT:kvz_entropy_bits
	xor	rcx, 1
	add	edx, DWORD PTR [rax+rcx*4]

; 391  :       }
; 392  :     }
; 393  :   }

	jmp	SHORT $LN26@kvz_get_co
$LN18@kvz_get_co:

; 394  :   else if( abs_level == 1 ) {

	cmp	r8d, 1
	jne	SHORT $LN24@kvz_get_co

; 395  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],0);

	movzx	ecx, BYTE PTR [r11+rbx]
	lea	rax, OFFSET FLAT:kvz_entropy_bits
	mov	edx, DWORD PTR [rax+rcx*4]
	add	edx, 32768				; 00008000H
	jmp	SHORT $LN26@kvz_get_co
$LN24@kvz_get_co:

; 396  :   } else if( abs_level == 2 ) {

	cmp	r8d, 2
	jne	SHORT $LN26@kvz_get_co

; 397  :     rate += CTX_ENTROPY_BITS(&base_one_ctx[ctx_num_one],1);
; 398  :     rate += CTX_ENTROPY_BITS(&base_abs_ctx[ctx_num_abs],0);

	movzx	edx, BYTE PTR [r13+r12]
	lea	rax, OFFSET FLAT:kvz_entropy_bits
	movzx	ecx, BYTE PTR [r11+rbx]
	xor	rcx, 1
	mov	edx, DWORD PTR [rax+rdx*4]
	add	edx, 32768				; 00008000H
	mov	ecx, DWORD PTR [rax+rcx*4]
	add	edx, ecx
$LN26@kvz_get_co:

; 450  :     double cur_cost  = err * err * temp + state->lambda *

	mulsd	xmm1, xmm1
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	mulsd	xmm1, xmm3
	mulsd	xmm0, QWORD PTR [rsi+368]
	addsd	xmm1, xmm0

; 451  :                        kvz_get_ic_rate( state, abs_level, ctx_num_one, ctx_num_abs,
; 452  :                                     abs_go_rice, c1_idx, c2_idx, type);
; 453  :     cur_cost        += cur_cost_sig;

	addsd	xmm1, xmm2

; 454  : 
; 455  :     if( cur_cost < *coded_cost ) {

	comisd	xmm1, QWORD PTR [rdi]
	jae	SHORT $LN2@kvz_get_co

; 456  :       best_abs_level  = abs_level;
; 457  :       *coded_cost     = cur_cost;
; 458  :       *coded_cost_sig = cur_cost_sig;

	mov	rax, QWORD PTR coded_cost_sig$[rsp]
	mov	r15d, r8d
	movsd	QWORD PTR [rdi], xmm1
	movsd	QWORD PTR [rax], xmm2
$LN2@kvz_get_co:

; 445  :   }
; 446  : 
; 447  :   min_abs_level    = ( max_abs_level > 1 ? max_abs_level - 1 : 1 );
; 448  :   for (abs_level = max_abs_level; abs_level >= min_abs_level ; abs_level-- ) {

	dec	r8d
	cmp	r8d, r10d
	jge	$LL4@kvz_get_co
	mov	r14, QWORD PTR [rsp]
	mov	r13, QWORD PTR [rsp+64]
	mov	r12, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+48]
$LN3@kvz_get_co:

; 459  :     }
; 460  :   }
; 461  : 
; 462  :   return best_abs_level;

	mov	eax, r15d

; 463  : }

	add	rsp, 8
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
kvz_get_coded_level ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
state$ = 8
pos_x$ = 16
pos_y$ = 24
last_x_bits$ = 32
last_y_bits$ = 40
get_rate_last PROC

; 478  :   uint32_t ctx_x   = g_group_idx[pos_x];

	mov	eax, edx
	lea	rdx, OFFSET FLAT:g_group_idx
	movzx	r11d, BYTE PTR [rax+rdx]

; 479  :   uint32_t ctx_y   = g_group_idx[pos_y];

	mov	eax, r8d

; 480  :   double uiCost = last_x_bits[ ctx_x ] + last_y_bits[ ctx_y ];

	mov	r8d, DWORD PTR [r9+r11*4]
	movzx	r10d, BYTE PTR [rax+rdx]
	mov	rax, QWORD PTR last_y_bits$[rsp]
	add	r8d, DWORD PTR [rax+r10*4]
	movd	xmm2, r8d
	cvtdq2pd xmm2, xmm2

; 481  :   if( ctx_x > 3 ) {

	cmp	r11d, 3
	jbe	SHORT $LN2@get_rate_l

; 482  :     uiCost += CTX_FRAC_ONE_BIT * ((ctx_x - 2) >> 1);

	lea	eax, DWORD PTR [r11-2]
	xorps	xmm0, xmm0
	shr	eax, 1
	shl	eax, 15
	cvtsi2sd xmm0, rax
	addsd	xmm2, xmm0
$LN2@get_rate_l:

; 483  :   }
; 484  :   if( ctx_y > 3 ) {

	cmp	r10d, 3
	jbe	SHORT $LN3@get_rate_l

; 485  :     uiCost += CTX_FRAC_ONE_BIT * ((ctx_y - 2) >> 1);

	lea	eax, DWORD PTR [r10-2]
	xorps	xmm1, xmm1
	shr	eax, 1
	shl	eax, 15
	cvtsi2sd xmm1, rax
	addsd	xmm2, xmm1
$LN3@get_rate_l:

; 486  :   }
; 487  :   return state->lambda * uiCost;

	mulsd	xmm2, QWORD PTR [rcx+368]
	movaps	xmm0, xmm2

; 488  : }

	ret	0
get_rate_last ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
tv787 = 48
state$ = 48
width$ = 56
height$ = 64
type$ = 72
last_x_bits$ = 80
last_y_bits$ = 88
calc_last_bits PROC

; 492  : {

	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14

; 493  :   cabac_data_t * const cabac = &state->cabac;
; 494  :   int32_t bits_x = 0, bits_y = 0;

	xor	r10d, r10d
	mov	QWORD PTR [rsp+56], rbp

; 495  :   int32_t blk_size_offset_x, blk_size_offset_y, shiftX, shiftY;
; 496  :   int32_t ctx;
; 497  : 
; 498  :   cabac_ctx_t *base_ctx_x = (type ? cabac->ctx.cu_ctx_last_x_chroma : cabac->ctx.cu_ctx_last_x_luma);
; 499  :   cabac_ctx_t *base_ctx_y = (type ? cabac->ctx.cu_ctx_last_y_chroma : cabac->ctx.cu_ctx_last_y_luma);

	test	r9b, r9b
	mov	QWORD PTR [rsp+64], r13
	mov	ebx, 276				; 00000114H
	mov	QWORD PTR [rsp+72], r15
	mov	r13d, 291				; 00000123H

; 500  : 
; 501  :   blk_size_offset_x = type ? 0: (kvz_g_convert_to_bit[ width ] *3 + ((kvz_g_convert_to_bit[ width ] +1)>>2));

	mov	r12d, 261				; 00000105H
	cmove	r13d, ebx
	mov	r11d, r10d
	add	r13, rcx
	mov	ebx, 246				; 000000f6H
	test	r9b, r9b
	cmove	r12d, ebx
	add	r12, rcx
	movsxd	rcx, edx
	movsxd	rdx, r8d
	test	r9b, r9b
	lea	r9, OFFSET FLAT:__ImageBase
	mov	QWORD PTR tv787[rsp], rdx
	movsx	r15d, BYTE PTR kvz_g_convert_to_bit[rcx+r9]
	movsx	r14d, BYTE PTR kvz_g_convert_to_bit[rdx+r9]
	je	SHORT $LN13@calc_last_

; 504  :   shiftY = type ? kvz_g_convert_to_bit[ height ] :((kvz_g_convert_to_bit[ height ]+3)>>2);

	mov	esi, r10d
	mov	ebp, r10d
	jmp	SHORT $LN20@calc_last_
$LN13@calc_last_:

; 500  : 
; 501  :   blk_size_offset_x = type ? 0: (kvz_g_convert_to_bit[ width ] *3 + ((kvz_g_convert_to_bit[ width ] +1)>>2));

	movsx	eax, BYTE PTR kvz_g_convert_to_bit[rcx+r9]

; 502  :   blk_size_offset_y = type ? 0: (kvz_g_convert_to_bit[ height ]*3 + ((kvz_g_convert_to_bit[ height ]+1)>>2));
; 503  :   shiftX = type ? kvz_g_convert_to_bit[ width  ] :((kvz_g_convert_to_bit[ width  ]+3)>>2);

	add	r15d, 3
	sar	r15d, 2

; 504  :   shiftY = type ? kvz_g_convert_to_bit[ height ] :((kvz_g_convert_to_bit[ height ]+3)>>2);

	add	r14d, 3
	mov	QWORD PTR tv787[rsp], rdx
	lea	ebp, DWORD PTR [rax+1]
	lea	eax, DWORD PTR [rax+rax*2]
	sar	ebp, 2
	add	ebp, eax
	movsx	eax, BYTE PTR kvz_g_convert_to_bit[rdx+r9]
	lea	esi, DWORD PTR [rax+1]
	sar	esi, 2
	lea	eax, DWORD PTR [rax+rax*2]
	add	esi, eax
	sar	r14d, 2
$LN20@calc_last_:

; 505  : 
; 506  : 
; 507  :   for (ctx = 0; ctx < g_group_idx[ width - 1 ]; ctx++) {

	movzx	edi, BYTE PTR g_group_idx[rcx+r9-1]
	mov	r8d, r10d
	test	edi, edi
	je	SHORT $LN3@calc_last_
	mov	rbx, QWORD PTR last_x_bits$[rsp]
	npad	6
$LL4@calc_last_:

; 508  :     int32_t ctx_offset = blk_size_offset_x + (ctx >>shiftX);

	mov	eax, r8d
	lea	rbx, QWORD PTR [rbx+4]
	mov	ecx, r15d
	inc	r8d
	sar	eax, cl
	add	eax, ebp

; 509  :     last_x_bits[ ctx ] = bits_x + CTX_ENTROPY_BITS(&base_ctx_x[ ctx_offset ],0);

	cdqe
	movzx	edx, BYTE PTR [rax+r13]
	mov	ecx, DWORD PTR kvz_entropy_bits[r9+rdx*4]

; 510  :     bits_x += CTX_ENTROPY_BITS(&base_ctx_x[ ctx_offset ],1);

	xor	rdx, 1
	add	ecx, r11d
	mov	DWORD PTR [rbx-4], ecx
	add	r11d, DWORD PTR kvz_entropy_bits[r9+rdx*4]
	cmp	r8d, edi
	jl	SHORT $LL4@calc_last_
	mov	rdx, QWORD PTR tv787[rsp]
$LN3@calc_last_:

; 511  :   }
; 512  :   last_x_bits[ctx] = bits_x;

	mov	rcx, QWORD PTR last_x_bits$[rsp]

; 513  :   for (ctx = 0; ctx < g_group_idx[ height - 1 ]; ctx++) {

	movzx	ebx, BYTE PTR g_group_idx[rdx+r9-1]
	mov	r15, QWORD PTR [rsp+72]
	mov	r13, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	movsxd	rax, r8d
	mov	DWORD PTR [rcx+rax*4], r11d
	movsxd	rax, r10d
	test	ebx, ebx
	je	SHORT $LN32@calc_last_
	mov	rdi, QWORD PTR last_y_bits$[rsp]
	mov	r11, rdi
	npad	1
$LL7@calc_last_:

; 514  :     int32_t ctx_offset = blk_size_offset_y + (ctx >>shiftY);

	mov	edx, eax
	lea	r11, QWORD PTR [r11+4]
	mov	ecx, r14d
	inc	eax
	sar	edx, cl
	add	edx, esi

; 515  :     last_y_bits[ ctx ] = bits_y + CTX_ENTROPY_BITS(&base_ctx_y[ ctx_offset ],0);

	movsxd	rcx, edx
	movzx	r8d, BYTE PTR [rcx+r12]
	mov	edx, DWORD PTR kvz_entropy_bits[r9+r8*4]

; 516  :     bits_y +=  CTX_ENTROPY_BITS(&base_ctx_y[ ctx_offset ],1);

	xor	r8, 1
	add	edx, r10d
	mov	DWORD PTR [r11-4], edx
	add	r10d, DWORD PTR kvz_entropy_bits[r9+r8*4]
	cmp	eax, ebx
	jl	SHORT $LL7@calc_last_

; 517  :   }
; 518  :   last_y_bits[ctx] = bits_y;

	movsxd	rcx, eax
	mov	DWORD PTR [rdi+rcx*4], r10d

; 519  : }

	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN32@calc_last_:

; 517  :   }
; 518  :   last_y_bits[ctx] = bits_y;

	mov	rcx, rax
	mov	rax, QWORD PTR last_y_bits$[rsp]
	mov	DWORD PTR [rax+rcx*4], r10d

; 519  : }

	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
calc_last_bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
rd_factor$1$ = 0
current$1 = 16
best$2 = 32
signbit$1$ = 112
state$ = 112
last_cg$1$ = 120
qp_scaled$ = 120
scan2raster$ = 128
sh_rates$ = 136
cg_scan$1$ = 144
last_pos$ = 144
coeffs$ = 152
quant_coeffs$ = 160
kvz_rdoq_sign_hiding PROC

; 537  : {

$LN67:
	mov	QWORD PTR [rsp+24], r8
	push	r12
	push	r13
	sub	rsp, 88					; 00000058H
	mov	r11, rcx
	mov	r10d, edx

; 538  :   const encoder_control_t * const ctrl = state->encoder_control;
; 539  : 
; 540  :   int inv_quant = kvz_g_inv_quant_scales[qp_scaled % 6];

	mov	eax, 715827883				; 2aaaaaabH
	lea	rcx, OFFSET FLAT:kvz_g_inv_quant_scales
	imul	edx
	mov	r12, r8
	mov	r13, r9
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	lea	eax, DWORD PTR [rdx+rdx*2]
	add	eax, eax
	sub	r10d, eax
	movsxd	rax, r10d
	movsx	r8d, WORD PTR [rcx+rax*2]

; 541  :   // This somehow scales quant_delta into fractional bits. Instead of the bits
; 542  :   // being multiplied by lambda, the residual is divided by it, or something
; 543  :   // like that.
; 544  :   const int64_t rd_factor = (inv_quant * inv_quant * (1 << (2 * (qp_scaled / 6)))

	lea	ecx, DWORD PTR [rdx+rdx]
	mov	eax, r8d
	shl	eax, cl
	imul	eax, r8d
	movd	xmm1, eax
	mov	rax, QWORD PTR [r11]
	cvtdq2pd xmm1, xmm1
	movsx	ecx, BYTE PTR [rax+2592]
	mov	eax, 1
	divsd	xmm1, QWORD PTR [r11+368]
	lea	ecx, DWORD PTR [rcx*2-16]
	shl	eax, cl

; 545  :                       / state->lambda / 16 / (1 << (2 * (ctrl->bitdepth - 8))) + 0.5);
; 546  :   const int last_cg = (last_pos - 1) >> LOG2_SCAN_SET_SIZE;

	mov	ecx, DWORD PTR last_pos$[rsp]
	dec	ecx
	sar	ecx, 4
	mov	DWORD PTR last_cg$1$[rsp], ecx

; 547  : 
; 548  :   for (int32_t cg_scan = last_cg; cg_scan >= 0; cg_scan--) {

	mov	DWORD PTR cg_scan$1$[rsp], ecx
	movd	xmm0, eax
	mulsd	xmm1, QWORD PTR __real@3fb0000000000000
	cvtdq2pd xmm0, xmm0
	divsd	xmm1, xmm0
	addsd	xmm1, QWORD PTR __real@3fe0000000000000
	cvttsd2si rax, xmm1
	mov	QWORD PTR rd_factor$1$[rsp], rax
	mov	eax, ecx
	test	ecx, ecx
	js	$LN3@kvz_rdoq_s
	mov	QWORD PTR [rsp+136], rbx
	mov	edx, -1
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+64], rdi
	mov	QWORD PTR [rsp+56], r14
	mov	r14, QWORD PTR quant_coeffs$[rsp]
	mov	QWORD PTR [rsp+48], r15
	npad	9
$LL4@kvz_rdoq_s:

; 549  :     const int32_t cg_coeff_scan = cg_scan << LOG2_SCAN_SET_SIZE;

	mov	r11d, eax

; 550  :     
; 551  :     // Find positions of first and last non-zero coefficients in the CG.
; 552  :     int32_t last_nz_scan = -1;
; 553  :     for (int32_t coeff_i = SCAN_SET_SIZE - 1; coeff_i >= 0; --coeff_i) {

	mov	r8d, 15
	shl	r11d, 4
	mov	edi, edx
	movsxd	rsi, r11d
	mov	edx, r8d
	lea	rcx, QWORD PTR [rsi+15]
	lea	rcx, QWORD PTR [r12+rcx*4]
	npad	3
$LL7@kvz_rdoq_s:

; 554  :       if (quant_coeffs[scan2raster[coeff_i + cg_coeff_scan]]) {

	mov	eax, DWORD PTR [rcx]
	cmp	WORD PTR [r14+rax*2], 0
	jne	SHORT $LN41@kvz_rdoq_s

; 550  :     
; 551  :     // Find positions of first and last non-zero coefficients in the CG.
; 552  :     int32_t last_nz_scan = -1;
; 553  :     for (int32_t coeff_i = SCAN_SET_SIZE - 1; coeff_i >= 0; --coeff_i) {

	dec	r8d
	sub	rcx, 4
	sub	rdx, 1
	jns	SHORT $LL7@kvz_rdoq_s

; 561  :       if (quant_coeffs[scan2raster[coeff_i + cg_coeff_scan]]) {

	jmp	SHORT $LN6@kvz_rdoq_s
$LN41@kvz_rdoq_s:

; 555  :         last_nz_scan = coeff_i;

	mov	edi, r8d
$LN6@kvz_rdoq_s:

; 556  :         break;
; 557  :       }
; 558  :     }
; 559  :     int32_t first_nz_scan = SCAN_SET_SIZE;
; 560  :     for (int32_t coeff_i = 0; coeff_i <= last_nz_scan; coeff_i++) {

	xor	r8d, r8d
	mov	ebx, 16
	movsxd	r15, edi
	test	edi, edi
	js	SHORT $LN9@kvz_rdoq_s
	xor	edx, edx
	lea	rcx, QWORD PTR [r12+rsi*4]
$LL10@kvz_rdoq_s:

; 561  :       if (quant_coeffs[scan2raster[coeff_i + cg_coeff_scan]]) {

	mov	eax, DWORD PTR [rcx]
	cmp	WORD PTR [r14+rax*2], 0
	jne	SHORT $LN42@kvz_rdoq_s

; 556  :         break;
; 557  :       }
; 558  :     }
; 559  :     int32_t first_nz_scan = SCAN_SET_SIZE;
; 560  :     for (int32_t coeff_i = 0; coeff_i <= last_nz_scan; coeff_i++) {

	inc	r8d
	inc	rdx
	add	rcx, 4
	cmp	rdx, r15
	jle	SHORT $LL10@kvz_rdoq_s

; 561  :       if (quant_coeffs[scan2raster[coeff_i + cg_coeff_scan]]) {

	jmp	SHORT $LN9@kvz_rdoq_s
$LN42@kvz_rdoq_s:

; 562  :         first_nz_scan = coeff_i;

	mov	ebx, r8d
$LN9@kvz_rdoq_s:

; 563  :         break;
; 564  :       }
; 565  :     }
; 566  : 
; 567  :     if (last_nz_scan - first_nz_scan < SBH_THRESHOLD) {

	mov	eax, edi
	sub	eax, ebx
	cmp	eax, 4
	jl	$LN2@kvz_rdoq_s

; 568  :       continue;
; 569  :     }
; 570  : 
; 571  :     const int32_t signbit = quant_coeffs[scan2raster[cg_coeff_scan + first_nz_scan]] <= 0;

	xor	ebp, ebp
	lea	eax, DWORD PTR [rbx+r11]
	xor	r9d, r9d
	movsxd	rcx, eax
	xor	r10d, r10d
	mov	eax, DWORD PTR [r12+rcx*4]

; 572  :     unsigned abs_coeff_sum = 0;
; 573  :     for (int32_t coeff_scan = first_nz_scan; coeff_scan <= last_nz_scan; coeff_scan++) {

	mov	r12d, ebx
	cmp	WORD PTR [r14+rax*2], bp
	setle	bpl
	xor	r11d, r11d
	mov	DWORD PTR signbit$1$[rsp], ebp
	cmp	r12, r15
	jg	SHORT $LN53@kvz_rdoq_s
	mov	rax, r15
	sub	rax, r12
	inc	rax
	cmp	rax, 2
	jl	SHORT $LN62@kvz_rdoq_s
	mov	rcx, QWORD PTR scan2raster$[rsp]
	lea	rax, QWORD PTR [rbx+rsi]
	mov	rdx, r15
	sub	rdx, r12
	dec	rdx
	shr	rdx, 1
	lea	r8, QWORD PTR [rcx+rax*4]
	inc	rdx
	lea	rbx, QWORD PTR [rbx+rdx*2]
	npad	7
$LL56@kvz_rdoq_s:

; 574  :       abs_coeff_sum += quant_coeffs[scan2raster[coeff_scan + cg_coeff_scan]];

	mov	eax, DWORD PTR [r8]
	lea	r8, QWORD PTR [r8+8]
	movsx	ecx, WORD PTR [r14+rax*2]
	mov	eax, DWORD PTR [r8-4]
	add	r9d, ecx
	movsx	ecx, WORD PTR [r14+rax*2]
	add	r10d, ecx
	sub	rdx, 1
	jne	SHORT $LL56@kvz_rdoq_s

; 572  :     unsigned abs_coeff_sum = 0;
; 573  :     for (int32_t coeff_scan = first_nz_scan; coeff_scan <= last_nz_scan; coeff_scan++) {

	cmp	rbx, r15
	jg	SHORT $LN55@kvz_rdoq_s
$LN62@kvz_rdoq_s:

; 574  :       abs_coeff_sum += quant_coeffs[scan2raster[coeff_scan + cg_coeff_scan]];

	mov	rcx, QWORD PTR scan2raster$[rsp]
	lea	rax, QWORD PTR [rsi+rbx]
	mov	ecx, DWORD PTR [rcx+rax*4]
	movsx	r11d, WORD PTR [r14+rcx*2]
$LN55@kvz_rdoq_s:
	lea	eax, DWORD PTR [r10+r9]
	add	r11d, eax
$LN53@kvz_rdoq_s:

; 575  :     }
; 576  :     if (signbit == (abs_coeff_sum & 0x1)) {

	and	r11d, 1
	cmp	ebp, r11d
	je	$LN64@kvz_rdoq_s

; 588  : 
; 589  :     const int last_coeff_scan = (cg_scan == last_cg ? last_nz_scan : SCAN_SET_SIZE - 1);

	mov	r8d, DWORD PTR last_cg$1$[rsp]
	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR best$2[rsp+8], rcx
	cmp	DWORD PTR cg_scan$1$[rsp], r8d
	mov	eax, 15
	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	cmove	eax, edi
	movsxd	r10, eax

; 590  :     for (int coeff_scan = last_coeff_scan; coeff_scan >= 0; --coeff_scan) {

	test	eax, eax
	js	$LN15@kvz_rdoq_s

; 577  :       // Sign already matches with the parity, no need to modify coefficients.
; 578  :       continue;
; 579  :     }
; 580  : 
; 581  :     // Otherwise, search for the best coeff to change by one and change it.
; 582  : 
; 583  :     struct {
; 584  :       int64_t cost;
; 585  :       int pos;
; 586  :       int change;
; 587  :     } current, best = { MAX_INT64, 0, 0 };

	mov	rcx, QWORD PTR scan2raster$[rsp]
	lea	rax, QWORD PTR [r10+rsi]
	mov	edi, DWORD PTR signbit$1$[rsp]
	mov	rsi, QWORD PTR coeffs$[rsp]
	lea	rbx, QWORD PTR [rcx+rax*4]
	npad	3
$LL16@kvz_rdoq_s:

; 591  :       current.pos = scan2raster[coeff_scan + cg_coeff_scan];

	movsxd	rax, DWORD PTR [rbx]
	mov	DWORD PTR current$1[rsp+8], eax
	mov	r8, rax

; 592  :       // Shift the calculation back into original precision to avoid
; 593  :       // changing the bitstream.
; 594  : #     define PRECISION_INC (15 - CTX_FRAC_BITS)
; 595  :       int64_t quant_cost_in_bits = rd_factor * sh_rates->quant_delta[current.pos];

	movsxd	r11, DWORD PTR [r13+rax*4+12288]

; 596  : 
; 597  :       coeff_t abs_coeff = abs(quant_coeffs[current.pos]);

	movsx	eax, WORD PTR [r14+rax*2]
	imul	r11, QWORD PTR rd_factor$1$[rsp]
	cdq
	mov	r9d, eax
	xor	r9d, edx
	sub	r9d, edx

; 598  : 
; 599  :       if (abs_coeff != 0) {

	test	r9w, r9w
	je	$LN21@kvz_rdoq_s

; 600  :         // Choose between incrementing and decrementing a non-zero coeff.
; 601  : 
; 602  :         int64_t inc_bits = sh_rates->inc[current.pos];

	movsxd	rcx, DWORD PTR [r13+r8*4]

; 603  :         int64_t dec_bits = sh_rates->dec[current.pos];

	movsxd	rdx, DWORD PTR [r13+r8*4+4096]

; 604  :         if (abs_coeff == 1) {

	cmp	r9w, 1
	jne	SHORT $LN23@kvz_rdoq_s

; 605  :           // We save sign bit and sig_coeff goes to zero.
; 606  :           dec_bits -= CTX_FRAC_ONE_BIT + sh_rates->sig_coeff_inc[current.pos];

	mov	eax, DWORD PTR [r13+r8*4+8192]
	add	eax, 32768				; 00008000H
	cdqe
	sub	rdx, rax
$LN23@kvz_rdoq_s:

; 607  :         }
; 608  :         if (cg_scan == last_cg && last_nz_scan == coeff_scan && abs_coeff == 1) {

	mov	eax, DWORD PTR last_cg$1$[rsp]
	cmp	DWORD PTR cg_scan$1$[rsp], eax
	jne	SHORT $LN24@kvz_rdoq_s
	cmp	r15, r10
	jne	SHORT $LN24@kvz_rdoq_s
	cmp	r9w, 1
	jne	SHORT $LN24@kvz_rdoq_s

; 609  :           // Changing the last non-zero bit in the last cg to zero.
; 610  :           // This might save a lot of bits if the next bits are already
; 611  :           // zeros, or just a coupple fractional bits if they are not.
; 612  :           // TODO: Check if calculating the real savings makes sense.
; 613  :           dec_bits -= 4 * CTX_FRAC_ONE_BIT;

	sub	rdx, 131072				; 00020000H
$LN24@kvz_rdoq_s:

; 614  :         }
; 615  : 
; 616  :         inc_bits = -quant_cost_in_bits + inc_bits * (1 << PRECISION_INC);

	sub	rcx, r11

; 617  :         dec_bits = quant_cost_in_bits + dec_bits * (1 << PRECISION_INC);

	add	rdx, r11

; 618  : 
; 619  :         if (inc_bits < dec_bits) {

	cmp	rcx, rdx
	jge	SHORT $LN25@kvz_rdoq_s

; 620  :           current.change = 1;

	mov	DWORD PTR current$1[rsp+12], 1

; 621  :           current.cost = inc_bits;
; 622  :         } else {

	jmp	$LN65@kvz_rdoq_s
$LN25@kvz_rdoq_s:

; 623  :           current.change = -1;

	mov	DWORD PTR current$1[rsp+12], -1

; 624  :           current.cost = dec_bits;

	mov	rcx, rdx
	mov	QWORD PTR current$1[rsp], rdx

; 625  : 
; 626  :           if (coeff_scan == first_nz_scan && abs_coeff == 1) {

	cmp	r10, r12
	jne	SHORT $LN29@kvz_rdoq_s
	cmp	r9w, 1
	jne	SHORT $LN29@kvz_rdoq_s

; 627  :             // Don't turn first non-zero coeff into zero.
; 628  :             // Seems kind of arbitrary. It's probably because it could lead to
; 629  :             // breaking SBH_THRESHOLD.
; 630  :             current.cost = MAX_INT64;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	rcx, rax
	mov	QWORD PTR current$1[rsp], rax

; 631  :           }
; 632  :         }
; 633  :       } else {

	jmp	SHORT $LN29@kvz_rdoq_s
$LN21@kvz_rdoq_s:

; 634  :         // Try incrementing a zero coeff.
; 635  : 
; 636  :         // Add sign bit, other bits and sig_coeff goes to one.
; 637  :         int bits = CTX_FRAC_ONE_BIT + sh_rates->inc[current.pos] + sh_rates->sig_coeff_inc[current.pos];

	mov	ecx, DWORD PTR [r13+r8*4]

; 638  :         current.cost = -llabs(quant_cost_in_bits) + bits * (1 << PRECISION_INC);

	mov	rax, r11
	add	ecx, 32768				; 00008000H

; 639  :         current.change = 1;

	mov	DWORD PTR current$1[rsp+12], 1
	cdq
	xor	rax, rdx
	sub	rax, rdx
	mov	edx, DWORD PTR [r13+r8*4+8192]
	add	edx, ecx
	movsxd	rcx, edx
	sub	rcx, rax
	mov	QWORD PTR current$1[rsp], rcx

; 640  : 
; 641  :         if (coeff_scan < first_nz_scan) {

	cmp	r10, r12
	jae	SHORT $LN29@kvz_rdoq_s

; 642  :           if (((coeffs[current.pos] >= 0) ? 0 : 1) != signbit) {

	movzx	eax, WORD PTR [rsi+r8*2]
	shr	eax, 15
	cmp	eax, edi
	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmovne	rcx, rax
$LN65@kvz_rdoq_s:

; 643  :             current.cost = MAX_INT64;
; 644  :           }
; 645  :         }
; 646  :       }
; 647  : 
; 648  :       if (current.cost < best.cost) {

	mov	QWORD PTR current$1[rsp], rcx
$LN29@kvz_rdoq_s:
	cmp	rcx, rbp
	jge	SHORT $LN14@kvz_rdoq_s

; 649  :         best = current;

	movaps	xmm0, XMMWORD PTR current$1[rsp]
	movdqa	XMMWORD PTR best$2[rsp], xmm0
	mov	rbp, QWORD PTR best$2[rsp]
$LN14@kvz_rdoq_s:

; 590  :     for (int coeff_scan = last_coeff_scan; coeff_scan >= 0; --coeff_scan) {

	sub	rbx, 4
	sub	r10, 1
	jns	$LL16@kvz_rdoq_s
	mov	edx, DWORD PTR best$2[rsp+12]
	mov	ecx, DWORD PTR best$2[rsp+8]
$LN15@kvz_rdoq_s:

; 650  :       }
; 651  :     }
; 652  : 
; 653  :     if (quant_coeffs[best.pos] == 32767 || quant_coeffs[best.pos] == -32768) {
; 654  :       best.change = -1;
; 655  :     }
; 656  : 
; 657  :     if (coeffs[best.pos] >= 0) {

	mov	r12, QWORD PTR scan2raster$[rsp]
	mov	r9d, 32767				; 00007fffH
	movsxd	r8, ecx
	movzx	ecx, WORD PTR [r14+r8*2]
	movzx	eax, cx
	sub	ax, r9w
	mov	r9d, 65534				; 0000fffeH
	test	ax, r9w
	mov	eax, -1
	cmove	edx, eax
	mov	rax, QWORD PTR coeffs$[rsp]
	mov	DWORD PTR best$2[rsp+12], edx
	cmp	WORD PTR [rax+r8*2], 0
	jl	SHORT $LN33@kvz_rdoq_s

; 658  :       quant_coeffs[best.pos] += best.change;

	add	cx, dx
	mov	WORD PTR [r14+r8*2], cx

; 659  :     } else {

	jmp	SHORT $LN2@kvz_rdoq_s
$LN33@kvz_rdoq_s:

; 660  :       quant_coeffs[best.pos] -= best.change;

	sub	cx, WORD PTR best$2[rsp+12]
	mov	WORD PTR [r14+r8*2], cx
	jmp	SHORT $LN2@kvz_rdoq_s
$LN64@kvz_rdoq_s:

; 575  :     }
; 576  :     if (signbit == (abs_coeff_sum & 0x1)) {

	mov	r12, QWORD PTR scan2raster$[rsp]
$LN2@kvz_rdoq_s:

; 547  : 
; 548  :   for (int32_t cg_scan = last_cg; cg_scan >= 0; cg_scan--) {

	mov	eax, DWORD PTR cg_scan$1$[rsp]
	mov	edx, -1
	sub	eax, 1
	mov	DWORD PTR cg_scan$1$[rsp], eax
	jns	$LL4@kvz_rdoq_s
	mov	r15, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+136]
$LN3@kvz_rdoq_s:

; 661  :     }
; 662  :   }
; 663  : }

	add	rsp, 88					; 00000058H
	pop	r13
	pop	r12
	ret	0
kvz_rdoq_sign_hiding ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
cabac_copy$ = 32
state$ = 272
cabac$ = 280
mvd_hor$ = 288
mvd_ver$ = 296
kvz_get_mvd_coding_cost_cabac PROC

; 1014 : {

$LN4:
	push	rbx
	sub	rsp, 256				; 00000100H

; 1015 :   cabac_data_t cabac_copy = *cabac;

	movups	xmm0, XMMWORD PTR [rdx]
	lea	r10, QWORD PTR cabac_copy$[rsp]
	mov	rbx, rdx
	movups	xmm1, XMMWORD PTR [rdx+16]
	lea	rax, QWORD PTR [rdx+128]
	movups	XMMWORD PTR [r10], xmm0
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [r10+16], xmm1
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [r10+32], xmm0
	movups	xmm0, XMMWORD PTR [rdx+64]
	movups	XMMWORD PTR [r10+48], xmm1
	movups	xmm1, XMMWORD PTR [rdx+80]
	movups	XMMWORD PTR [r10+64], xmm0
	movups	xmm0, XMMWORD PTR [rdx+96]
	movups	XMMWORD PTR [r10+80], xmm1
	movups	xmm1, XMMWORD PTR [rax]
	movups	XMMWORD PTR [r10+96], xmm0
	lea	r10, QWORD PTR [r10+128]
	movups	xmm0, XMMWORD PTR [rdx+112]

; 1016 :   cabac_copy.only_count = 1;
; 1017 : 
; 1018 :   // It is safe to drop const here because cabac->only_count is set.
; 1019 :   kvz_encode_mvd((encoder_state_t*) state, &cabac_copy, mvd_hor, mvd_ver);

	lea	rdx, QWORD PTR cabac_copy$[rsp]
	movups	XMMWORD PTR [r10-16], xmm0
	movups	xmm0, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [r10], xmm1
	movups	xmm1, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [r10+16], xmm0
	movups	xmm0, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [r10+32], xmm1
	movups	xmm1, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [r10+48], xmm0
	movups	xmm0, XMMWORD PTR [rax+80]
	movups	XMMWORD PTR [r10+64], xmm1
	movups	XMMWORD PTR [r10+80], xmm0
	mov	BYTE PTR cabac_copy$[rsp+28], 1
	call	kvz_encode_mvd

; 1020 : 
; 1021 :   uint32_t bitcost =

	mov	eax, DWORD PTR cabac_copy$[rsp+20]
	mov	ecx, DWORD PTR [rbx+20]
	shl	ecx, 3
	lea	eax, DWORD PTR [rax*8]
	sub	eax, ecx
	add	eax, DWORD PTR [rbx+24]
	sub	eax, DWORD PTR cabac_copy$[rsp+24]

; 1022 :     ((23 - cabac_copy.bits_left) + (cabac_copy.num_buffered_bytes << 3)) -
; 1023 :     ((23 - cabac->bits_left)     + (cabac->num_buffered_bytes << 3));
; 1024 : 
; 1025 :   return bitcost;
; 1026 : }

	add	rsp, 256				; 00000100H
	pop	rbx
	ret	0
kvz_get_mvd_coding_cost_cabac ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c
_TEXT	SEGMENT
ref_list$3 = 48
state_cabac_copy$ = 64
state$ = 352
x$ = 360
y$ = 368
mv_shift$ = 376
mv_cand$ = 384
merge_cand$ = 392
$T4 = 400
num_cand$ = 400
ref_idx$ = 408
bitcost$ = 416
kvz_calc_mvd_cost_cabac PROC

; 1041 : {

$LN77:
	mov	QWORD PTR [rsp+32], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-32]
	sub	rsp, 288				; 00000120H

; 1042 :   cabac_data_t state_cabac_copy;
; 1043 :   cabac_data_t* cabac;
; 1044 :   uint32_t merge_idx;
; 1045 :   vector2d_t mvd = { 0, 0 };
; 1046 :   int8_t merged = 0;
; 1047 :   int8_t cur_mv_cand = 0;
; 1048 : 
; 1049 :   x *= 1 << mv_shift;
; 1050 :   y *= 1 << mv_shift;
; 1051 : 
; 1052 :   // Check every candidate to find a match
; 1053 :   for (merge_idx = 0; merge_idx < (uint32_t)num_cand; merge_idx++) {

	movsx	ebx, WORD PTR num_cand$[rbp-256]
	mov	r12, rcx
	mov	r13d, DWORD PTR ref_idx$[rbp-256]
	mov	ecx, r9d
	mov	r15d, r8d
	mov	r14d, edx
	shl	r14d, cl
	xor	sil, sil
	shl	r15d, cl
	xor	edi, edi
	mov	DWORD PTR x$[rbp-256], r14d
	test	ebx, ebx
	je	SHORT $LN70@kvz_calc_m

; 1055 :     if (merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][0] == x &&
; 1056 :       merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][1] == y &&

	mov	r8, QWORD PTR merge_cand$[rbp-256]
	npad	11
$LL4@kvz_calc_m:

; 1054 :     if (merge_cand[merge_idx].dir == 3) continue;

	lea	rax, QWORD PTR [rdi+rdi*2]
	mov	ecx, edi
	lea	r9, QWORD PTR [r8+rax*4]
	movzx	eax, BYTE PTR [r8+rax*4]
	cmp	al, 3
	je	SHORT $LN2@kvz_calc_m

; 1055 :     if (merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][0] == x &&
; 1056 :       merge_cand[merge_idx].mv[merge_cand[merge_idx].dir - 1][1] == y &&

	lea	rdx, QWORD PTR [rax-1]
	mov	r11d, eax
	lea	r10, QWORD PTR [rdx+rdi*2]
	add	r10, rcx
	movsx	eax, WORD PTR [r8+r10*4+4]
	cmp	eax, r14d
	jne	SHORT $LN2@kvz_calc_m
	movsx	eax, WORD PTR [r8+r10*4+6]
	cmp	eax, r15d
	jne	SHORT $LN2@kvz_calc_m
	movzx	ecx, BYTE PTR [r11+r9]
	mov	rax, QWORD PTR [r12+40]
	shl	rdx, 4
	add	rcx, rdx
	movzx	ecx, BYTE PTR [rcx+rax+49]
	cmp	ecx, r13d
	je	SHORT $LN52@kvz_calc_m
$LN2@kvz_calc_m:

; 1042 :   cabac_data_t state_cabac_copy;
; 1043 :   cabac_data_t* cabac;
; 1044 :   uint32_t merge_idx;
; 1045 :   vector2d_t mvd = { 0, 0 };
; 1046 :   int8_t merged = 0;
; 1047 :   int8_t cur_mv_cand = 0;
; 1048 : 
; 1049 :   x *= 1 << mv_shift;
; 1050 :   y *= 1 << mv_shift;
; 1051 : 
; 1052 :   // Check every candidate to find a match
; 1053 :   for (merge_idx = 0; merge_idx < (uint32_t)num_cand; merge_idx++) {

	inc	edi
	cmp	edi, ebx
	jb	SHORT $LL4@kvz_calc_m
	jmp	SHORT $LN70@kvz_calc_m
$LN52@kvz_calc_m:

; 1057 :       state->frame->ref_LX[merge_cand[merge_idx].dir - 1][
; 1058 :         merge_cand[merge_idx].ref[merge_cand[merge_idx].dir - 1]
; 1059 :       ] == ref_idx)
; 1060 :     {
; 1061 :       merged = 1;

	mov	sil, 1
$LN70@kvz_calc_m:

; 1062 :       break;
; 1063 :     }
; 1064 :   }
; 1065 : 
; 1066 :   // Store cabac state and contexts
; 1067 :   memcpy(&state_cabac_copy, &state->cabac, sizeof(cabac_data_t));

	lea	rax, QWORD PTR [r12+128]
	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	lea	rcx, QWORD PTR [rcx+128]
	movups	xmm0, XMMWORD PTR [rax]
	movups	xmm1, XMMWORD PTR [rax+16]
	lea	rax, QWORD PTR [rax+128]
	movups	XMMWORD PTR [rcx-128], xmm0
	movups	xmm0, XMMWORD PTR [rax-96]
	movups	XMMWORD PTR [rcx-112], xmm1
	movups	xmm1, XMMWORD PTR [rax-80]
	movups	XMMWORD PTR [rcx-96], xmm0
	movups	xmm0, XMMWORD PTR [rax-64]
	movups	XMMWORD PTR [rcx-80], xmm1
	movups	xmm1, XMMWORD PTR [rax-48]
	movups	XMMWORD PTR [rcx-64], xmm0
	movups	xmm0, XMMWORD PTR [rax-32]
	movups	XMMWORD PTR [rcx-48], xmm1
	movups	xmm1, XMMWORD PTR [rax]
	movups	XMMWORD PTR [rcx-32], xmm0
	movups	xmm0, XMMWORD PTR [rax-16]
	movups	XMMWORD PTR [rcx-16], xmm0
	movups	xmm0, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR [rcx], xmm1
	movups	xmm1, XMMWORD PTR [rax+32]
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	xmm0, XMMWORD PTR [rax+48]
	movups	XMMWORD PTR [rcx+32], xmm1
	movups	xmm1, XMMWORD PTR [rax+64]
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	xmm0, XMMWORD PTR [rax+80]
	movups	XMMWORD PTR [rcx+64], xmm1
	movups	XMMWORD PTR [rcx+80], xmm0

; 1068 : 
; 1069 :   // Clear bytes and bits and set mode to "count"
; 1070 :   state_cabac_copy.only_count = 1;

	mov	BYTE PTR state_cabac_copy$[rsp+28], 1

; 1071 :   state_cabac_copy.num_buffered_bytes = 0;

	mov	DWORD PTR state_cabac_copy$[rsp+20], 0

; 1072 :   state_cabac_copy.bits_left = 23;

	mov	DWORD PTR state_cabac_copy$[rsp+24], 23

; 1073 : 
; 1074 :   cabac = &state_cabac_copy;
; 1075 : 
; 1076 :   if (!merged) {

	test	sil, sil
	jne	$LN21@kvz_calc_m

; 1077 :     vector2d_t mvd1 = {

	mov	rcx, QWORD PTR mv_cand$[rbp-256]

; 1078 :       x - mv_cand[0][0],
; 1079 :       y - mv_cand[0][1],
; 1080 :     };
; 1081 :     vector2d_t mvd2 = {
; 1082 :       x - mv_cand[1][0],
; 1083 :       y - mv_cand[1][1],
; 1084 :     };
; 1085 :     uint32_t cand1_cost = kvz_get_mvd_coding_cost_cabac(state, cabac, mvd1.x, mvd1.y);

	lea	rdx, QWORD PTR state_cabac_copy$[rsp]
	mov	edi, r14d
	mov	r14d, r15d
	movsx	eax, WORD PTR [rcx]
	sub	edi, eax
	movsx	eax, WORD PTR [rcx+2]
	sub	r14d, eax
	mov	r8d, edi
	movsx	eax, WORD PTR [rcx+4]
	mov	r9d, r14d
	sub	DWORD PTR x$[rbp-256], eax
	movsx	eax, WORD PTR [rcx+6]
	mov	rcx, r12
	sub	r15d, eax
	mov	DWORD PTR y$[rbp-256], r15d
	call	kvz_get_mvd_coding_cost_cabac

; 1086 :     uint32_t cand2_cost = kvz_get_mvd_coding_cost_cabac(state, cabac, mvd2.x, mvd2.y);

	mov	r8d, DWORD PTR x$[rbp-256]
	lea	rdx, QWORD PTR state_cabac_copy$[rsp]
	mov	r9d, r15d
	mov	rcx, r12
	mov	ebx, eax
	call	kvz_get_mvd_coding_cost_cabac

; 1087 : 
; 1088 :     // Select candidate 1 if it has lower cost
; 1089 :     if (cand2_cost < cand1_cost) {

	cmp	eax, ebx
	movzx	edx, sil
	lea	rax, QWORD PTR state_cabac_copy$[rbp-43]
	mov	QWORD PTR state_cabac_copy$[rsp], rax
	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	jae	SHORT $LN20@kvz_calc_m

; 1090 :       cur_mv_cand = 1;
; 1091 :       mvd = mvd2;

	mov	ebx, 1

; 1092 :     } else {

	jmp	SHORT $LN75@kvz_calc_m
$LN20@kvz_calc_m:

; 1093 :       mvd = mvd1;

	mov	DWORD PTR x$[rbp-256], edi
	xor	ebx, ebx
	mov	DWORD PTR y$[rbp-256], r14d
$LN75@kvz_calc_m:

; 1113 :       }
; 1114 :     }
; 1115 :   } else {
; 1116 :     uint32_t ref_list_idx;
; 1117 :     uint32_t j;
; 1118 :     int ref_list[2] = { 0, 0 };

	mov	DWORD PTR $T4[rbp-256], ebx
	call	kvz_cabac_encode_bin

; 1119 :     for (j = 0; j < state->frame->ref->used_size; j++) {

	mov	rdx, QWORD PTR [r12+40]
	xor	eax, eax
	xor	ecx, ecx
	mov	QWORD PTR ref_list$3[rsp], rax
	mov	r8, QWORD PTR [rdx+40]
	mov	r10d, DWORD PTR [r8+36]
	test	r10d, r10d
	je	SHORT $LN9@kvz_calc_m

; 1120 :       if (state->frame->ref->pocs[j] < state->frame->poc) {

	mov	r9d, DWORD PTR [rdx+12]
	mov	rdx, QWORD PTR [r8+16]
	mov	r8d, r10d
	npad	2
$LL10@kvz_calc_m:
	cmp	DWORD PTR [rdx], r9d
	jge	SHORT $LN28@kvz_calc_m

; 1121 :         ref_list[0]++;

	inc	eax

; 1122 :       } else {

	jmp	SHORT $LN8@kvz_calc_m
$LN28@kvz_calc_m:

; 1123 :         ref_list[1]++;

	inc	ecx
$LN8@kvz_calc_m:

; 1119 :     for (j = 0; j < state->frame->ref->used_size; j++) {

	add	rdx, 4
	sub	r8, 1
	jne	SHORT $LL10@kvz_calc_m

; 1121 :         ref_list[0]++;

	mov	DWORD PTR ref_list$3[rsp], eax

; 1123 :         ref_list[1]++;

	mov	DWORD PTR ref_list$3[rsp+4], ecx
$LN9@kvz_calc_m:

; 1124 :       }
; 1125 :     }
; 1126 : 
; 1127 :     //ToDo: bidir mv support
; 1128 :     for (ref_list_idx = 0; ref_list_idx < 2; ref_list_idx++) {

	mov	r14d, 1
	lea	r15, QWORD PTR ref_list$3[rsp]
	lea	r12d, QWORD PTR [r14+1]
	npad	4
$LL13@kvz_calc_m:

; 1129 :       if (/*cur_cu->inter.mv_dir*/ 1 & (1 << ref_list_idx)) {

	test	r14b, 1
	je	$LN11@kvz_calc_m

; 1130 :         if (ref_list[ref_list_idx] > 1) {

	mov	esi, DWORD PTR [r15]
	cmp	esi, 1
	jle	$LN54@kvz_calc_m

; 1131 :           // parseRefFrmIdx
; 1132 :           int32_t ref_frame = ref_idx;
; 1133 : 
; 1134 :           cabac->cur_ctx = &(cabac->ctx.cu_ref_pic_model[0]);
; 1135 :           CABAC_BIN(cabac, (ref_frame != 0), "ref_idx_lX");

	xor	edx, edx
	lea	rax, QWORD PTR state_cabac_copy$[rbp-39]
	test	r13d, r13d
	mov	QWORD PTR state_cabac_copy$[rsp], rax
	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	setne	dl
	call	kvz_cabac_encode_bin

; 1136 : 
; 1137 :           if (ref_frame > 0) {

	test	r13d, r13d
	jle	SHORT $LN54@kvz_calc_m

; 1138 :             int32_t i;
; 1139 :             int32_t ref_num = ref_list[ref_list_idx] - 2;

	add	esi, -2

; 1140 : 
; 1141 :             cabac->cur_ctx = &(cabac->ctx.cu_ref_pic_model[1]);

	lea	rax, QWORD PTR state_cabac_copy$[rbp-38]

; 1142 :             ref_frame--;
; 1143 : 
; 1144 :             for (i = 0; i < ref_num; ++i) {

	xor	ebx, ebx
	mov	QWORD PTR state_cabac_copy$[rsp], rax
	lea	edi, DWORD PTR [r13-1]
	test	esi, esi
	jle	SHORT $LN74@kvz_calc_m
	npad	4
$LL16@kvz_calc_m:

; 1145 :               const uint32_t symbol = (i == ref_frame) ? 0 : 1;
; 1146 : 
; 1147 :               if (i == 0) {

	test	ebx, ebx
	jne	SHORT $LN33@kvz_calc_m

; 1148 :                 CABAC_BIN(cabac, symbol, "ref_idx_lX");

	xor	edx, edx
	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	test	edi, edi
	setne	dl
	call	kvz_cabac_encode_bin

; 1149 :               } else {

	jmp	SHORT $LN45@kvz_calc_m
$LN33@kvz_calc_m:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR state_cabac_copy$[rsp+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR state_cabac_copy$[rsp+8], ecx

; 231  :   if (bin_value) {

	cmp	ebx, edi
	je	SHORT $LN44@kvz_calc_m

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR state_cabac_copy$[rsp+12]
	mov	DWORD PTR state_cabac_copy$[rsp+8], ecx
$LN44@kvz_calc_m:

; 233  :   }
; 234  :   data->bits_left--;

	mov	eax, DWORD PTR state_cabac_copy$[rsp+24]
	dec	eax
	mov	DWORD PTR state_cabac_copy$[rsp+24], eax
	cmp	eax, 12

; 235  : 
; 236  :   if (data->bits_left < 12) {

	jge	SHORT $LN45@kvz_calc_m

; 237  :     kvz_cabac_write(data);

	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	call	kvz_cabac_write
$LN45@kvz_calc_m:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 1152 :               if (symbol == 0) break;

	cmp	ebx, edi
	je	SHORT $LN74@kvz_calc_m

; 1142 :             ref_frame--;
; 1143 : 
; 1144 :             for (i = 0; i < ref_num; ++i) {

	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL16@kvz_calc_m
$LN74@kvz_calc_m:

; 1153 :             }
; 1154 :           }
; 1155 :         }
; 1156 : 
; 1157 :         // ToDo: Bidir vector support
; 1158 :         if (!(state->frame->ref_list == REF_PIC_LIST_1 && /*cur_cu->inter.mv_dir == 3*/ 0)) {
; 1159 :           // It is safe to drop const here because cabac->only_count is set.
; 1160 :           kvz_encode_mvd((encoder_state_t*) state, cabac, mvd.x, mvd.y);

	mov	ebx, DWORD PTR $T4[rbp-256]
$LN54@kvz_calc_m:
	mov	r9d, DWORD PTR y$[rbp-256]
	lea	rdx, QWORD PTR state_cabac_copy$[rsp]
	mov	r8d, DWORD PTR x$[rbp-256]
	mov	rcx, QWORD PTR state$[rbp-256]
	call	kvz_encode_mvd

; 1161 :         }
; 1162 : 
; 1163 :         // Signal which candidate MV to use
; 1164 :         kvz_cabac_write_unary_max_symbol(

	mov	r8d, ebx
	mov	DWORD PTR [rsp+32], 1
	lea	rdx, QWORD PTR state_cabac_copy$[rbp-37]
	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	call	kvz_cabac_write_unary_max_symbol
$LN11@kvz_calc_m:

; 1124 :       }
; 1125 :     }
; 1126 : 
; 1127 :     //ToDo: bidir mv support
; 1128 :     for (ref_list_idx = 0; ref_list_idx < 2; ref_list_idx++) {

	rol	r14d, 1
	add	r15, 4
	sub	r12, 1
	jne	$LL13@kvz_calc_m
	mov	r12, QWORD PTR state$[rbp-256]
	jmp	$LN73@kvz_calc_m
$LN21@kvz_calc_m:

; 1094 :     }
; 1095 :   }
; 1096 : 
; 1097 :   cabac->cur_ctx = &(cabac->ctx.cu_merge_flag_ext_model);

	lea	rax, QWORD PTR state_cabac_copy$[rbp-43]

; 1098 : 
; 1099 :   CABAC_BIN(cabac, merged, "MergeFlag");

	movzx	edx, sil
	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	mov	QWORD PTR state_cabac_copy$[rsp], rax
	call	kvz_cabac_encode_bin

; 1100 :   num_cand = state->encoder_control->cfg.max_merge;

	mov	rax, QWORD PTR [r12]
	movzx	ecx, BYTE PTR [rax+2473]

; 1101 :   if (merged) {
; 1102 :     if (num_cand > 1) {

	cmp	cl, 1
	jbe	SHORT $LN73@kvz_calc_m

; 1103 :       int32_t ui;
; 1104 :       for (ui = 0; ui < num_cand - 1; ui++) {

	xor	ebx, ebx
	lea	esi, DWORD PTR [rcx-1]
	test	esi, esi
	jle	SHORT $LN73@kvz_calc_m
$LL7@kvz_calc_m:

; 1105 :         int32_t symbol = (ui != merge_idx);
; 1106 :         if (ui == 0) {

	test	ebx, ebx
	jne	SHORT $LN25@kvz_calc_m

; 1107 :           cabac->cur_ctx = &(cabac->ctx.cu_merge_idx_ext_model);

	xor	edx, edx
	lea	rax, QWORD PTR state_cabac_copy$[rbp-44]
	test	edi, edi
	mov	QWORD PTR state_cabac_copy$[rsp], rax

; 1108 :           CABAC_BIN(cabac, symbol, "MergeIndex");

	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	setne	dl
	call	kvz_cabac_encode_bin

; 1109 :         } else {

	jmp	SHORT $LN41@kvz_calc_m
$LN25@kvz_calc_m:
; File F:\open_codec_learn_2021\kvazaar-master\src\cabac.c

; 230  :   data->low <<= 1;

	mov	eax, DWORD PTR state_cabac_copy$[rsp+8]
	lea	ecx, DWORD PTR [rax+rax]
	mov	DWORD PTR state_cabac_copy$[rsp+8], ecx

; 231  :   if (bin_value) {

	cmp	ebx, edi
	je	SHORT $LN40@kvz_calc_m

; 232  :     data->low += data->range;

	add	ecx, DWORD PTR state_cabac_copy$[rsp+12]
	mov	DWORD PTR state_cabac_copy$[rsp+8], ecx
$LN40@kvz_calc_m:

; 233  :   }
; 234  :   data->bits_left--;

	mov	eax, DWORD PTR state_cabac_copy$[rsp+24]
	dec	eax
	mov	DWORD PTR state_cabac_copy$[rsp+24], eax
	cmp	eax, 12

; 235  : 
; 236  :   if (data->bits_left < 12) {

	jge	SHORT $LN41@kvz_calc_m

; 237  :     kvz_cabac_write(data);

	lea	rcx, QWORD PTR state_cabac_copy$[rsp]
	call	kvz_cabac_write
$LN41@kvz_calc_m:
; File F:\open_codec_learn_2021\kvazaar-master\src\rdo.c

; 1112 :         if (symbol == 0) break;

	cmp	ebx, edi
	je	SHORT $LN73@kvz_calc_m

; 1103 :       int32_t ui;
; 1104 :       for (ui = 0; ui < num_cand - 1; ui++) {

	inc	ebx
	cmp	ebx, esi
	jl	SHORT $LL7@kvz_calc_m
$LN73@kvz_calc_m:

; 1165 :             cabac,
; 1166 :             cabac->ctx.mvp_idx_model,
; 1167 :             cur_mv_cand,
; 1168 :             1,
; 1169 :             AMVP_MAX_NUM_CANDS - 1);
; 1170 :       }
; 1171 :     }
; 1172 :   }
; 1173 : 
; 1174 :   *bitcost = (23 - state_cabac_copy.bits_left) + (state_cabac_copy.num_buffered_bytes << 3);

	mov	eax, DWORD PTR state_cabac_copy$[rsp+20]

; 1175 : 
; 1176 :   // Store bitcost before restoring cabac
; 1177 :   return *bitcost * (uint32_t)(state->lambda_sqrt + 0.5);
; 1178 : }

	mov	rbx, QWORD PTR [rsp+376]
	lea	ecx, DWORD PTR [rax*8]
	mov	rax, QWORD PTR bitcost$[rbp-256]
	sub	ecx, DWORD PTR state_cabac_copy$[rsp+24]
	add	ecx, 23
	mov	DWORD PTR [rax], ecx
	movsd	xmm0, QWORD PTR [r12+376]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvttsd2si rax, xmm0
	imul	eax, ecx
	add	rsp, 288				; 00000120H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
kvz_calc_mvd_cost_cabac ENDP
_TEXT	ENDS
END
